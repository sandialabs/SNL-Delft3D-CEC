<?xml version="1.0"?>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>libsigwatch: basic signal handling for Fortran</title>
<link type="text/css" rel="stylesheet" href="style.css" />
<meta name="keywords" content="Fortran,signal handling" />
</head>

<body>

<h1>libsigwatch: basic signal handling for Fortran</h1>

<div class='abstract'>
<p>libsigwatch.a is a library of routines to provide simple signal
watching for Fortran programs.  This allows a minimal level of control
of a running program from outside it, for example to tell it to
checkpoint itself on receipt of a signal.</p>

<p>Version 1.0, 2011 February 2.</p>
</div>

<p>The project home page is
<a href='http://purl.org/nxg/dist/libsigwatch' ><code>http://purl.org/nxg/dist/libsigwatch</code></a>,
and it's hosted
<a href='https://bitbucket.org/nxg/libsigwatch' >at Bitbucket</a>,
where you can find downloads.
If you find any bugs, please report them at the Bitbucket issue tracker.</p>

<p>It is often useful to have some simple signal handling in larger
Fortran programs, for example to handle the <code>INT</code> interrupt
signal generated by <code>^C</code>, and have a program shut itself
down cleanly; or to handle one of the user signals <code>USR1</code>
or <code>USR2</code>, for example to have a program checkpoint itself,
in case it crashes at some later stage.  However, signal handling is
tricky in Fortran (because the function that is registered as a signal
handler is later called by value rather than by reference), so this
library provides functions to make it easier.</p>

<h2>Background</h2>

<p>On Unix, there is a smallish set of signals which may be sent to a
running process, which the process can either <em>catch</em> or
<em>ignore</em>.  For example, the <code>INT</code> signal is sent to
a process by pressing the interrupt character (usually
<code>^C</code>), <code>HUP</code> is sent when a controlling terminal
logs out, and <code>KILL</code> can be sent either by hand or by the
system when it is forcing processes to die.  The default action of the
<code>INT</code> signal is to terminate a process, and by default the
<code>HUP</code> signal is ignored.  The <code>KILL</code> signal is
one of those which cannot be caught or ignored, but always has its
effect.  There are also two signals, called <code>USR1</code> and
<code>USR2</code> which are ignored by default, have no default
meaning, and are provided for user convenience.</p>

<p>Each signal has a numeric value -- for example <code>HUP</code> is
1 and <code>KILL</code> is 9 -- and after finding a process's PID with
the <code>ps(1)</code> command, you can send signals to it with the
<code>kill(1)</code> command:</p>
<pre>
% kill -HUP <em>&lt;pid&gt;</em>
</pre>
<p>or</p>
<pre>
% kill -1 <em>&lt;pid&gt;</em>
</pre>

<p>Signals thus provide a limited mechanism for communicating with a
running program.  A useful way to use this is to have the program
watch for signal <code>USR1</code>, say, and examine this by calling
function <strong>getlastsignal</strong> at the end of a loop.  If this
returns a non-zero response, you might make your program checkpoint
itself -- save its state for later restart -- in case the program
crashes or has to be stopped for some reason.</p>

<p>For more details about signals, see the man pages for
<code>signal(3)</code> or <code>signal(7)</code>, depending on your
platform.</p>

<h2>Usage</h2>

<p>A program prepares to receive signals by calling one of the
<strong>watchsignalname</strong> or <strong>watchsignal</strong>
functions, and calls <strong>getlastsignal</strong> at any point to
retrieve the last signal which was sent to the process.</p>

<p>The arguments to <strong>watchsignalname</strong> are
<em>signame</em>, a character string containing the name of the signal
to watch for, and <em>response</em>, an integer which will be returned
by <strong>getlastsignal</strong> after the specified signal has been
caught.  The signal names which the function recognises are those most
likely to be useful, namely <code>HUP</code>, <code>INT</code>,
<code>USR1</code> and <code>USR2</code>.</p>

<p>The integer <em>response</em> is the number which will subsequently
be returned by <strong>getlastsignal</strong>, after this signal is
caught.  If this response is passed as -1, the signal number
associated with this name is what will be returned.  Note that,
although both <code>HUP</code> and <code>INT</code> have generally
fixed numbers, the numbers associated with signals <code>USR1</code>
and <code>USR2</code> are different on different unix variants.</p>

<p>If you need to catch another signal for some reason (make sure you
understand the default behavour of the given signal first, however)
you can give that signal as a number to the
<strong>watchsignal</strong> function, and when that signal is later
caught, the corresponding number is what will be returned by
<strong>getlastsignal</strong>.</p>

<p>The <strong>getlastsignal</strong> function returns the response
associated with the last signal which was caught, or zero if no signal
has been caught so far, or since the last call to
<strong>getlastsignal</strong>.  That is, any caught signal is
returned only once.</p>

<p>The installed signal handler does <em>not</em> re-throw the signal
after it has caught it; this would defeat the purpose of this library
for those signals, such as <code>HUP</code> and <code>INT</code>, for
which the default action is to kill the process.  Also, there is no
way to tell if the signal was received by being re-thrown by another
handler, installed after this one.  If all of this matters to you,
then this library cannot reasonably help you, and you have no hope but
to learn to love the <code>sigaction(2)</code> manpage.</p>

<p>When installing the handler, these functions <em>replace</em>
any previous signal handler.  If that was a non-default one (for
example, one put there by an MPI environment) this could potentially
change the behaviour of your program in an unhelpful fashion.  To warn
you of this, these functions return +1 in this case; this is a success
return value, but also a warning that you should understand what that
previous signal handler was doing there.</p>

<p>The <strong>sigwatchversion</strong> function returns the version
number of the library, as an integer formed from the version number by
<em>major_version * 1000 + minor_version</em>, So that the version
number 1.2, for example, would be returned as integer 1002.</p>

<h3>Return values</h3>

<p>Both <strong>watchsignalname</strong> and
<strong>watchsignal</strong> return 0 if the signal watching was
installed successfully, and -1 if there was an error.  If there was a
non-default signal handler already installed, it is replaced, but the
routine returns 1 to warn you of this.</p>

<p>The function <strong>getlastsignal</strong> returns the response
associated with the last signal caught, or zero if there has been no
signal caught since the last time this function was invoked.</p>

<!--  Linking is potentially complicated: see libtool docs for the
      places where libtool installs things (is this the message you
      get when you do libtool - -finish ? -->

<h2>Example</h2>

<p>The following Fortran program shows the library in use.</p>
<pre>
      program sigs
      
      implicit none

      integer i
      integer status

      integer watchsignal
      integer watchsignalname
      integer getlastsignal

* watch for signal 10 (which is USR1 on this platform)
      status = watchsignal(10)
      write(*,'("watchsignal 10:",i2)') status
* watch for HUP, too
      status = watchsignalname("HUP", 99)
      write(*,'("watchsignal HUP:",i2)') status

      do i=1,10
         call sleep(1)
         write (*,'("lastsig=", i2)') getlastsignal()
      enddo

      end
</pre>
<p>Then you can use the library like this:</p>
<pre>
% g77 -o libsigwatch-demo -lsigwatch libsigwatch-demo.f
% ./libsigwatch-demo &amp; # start in the background ($! now has the PID)
[1] 15131
watchsignal 10: 0
watchsignal HUP: 0
% lastsig= 0
lastsig= 0
lastsig= 0
kill -HUP $!    # send the HUP signal to the process
lastsig=99      # saw it!
% lastsig= 0
...
</pre>

<p>You can also link against just <code>sigwatch.o</code> if necessary.</p>

<h2>Downloading and installation</h2>

<p>Download the distribution
<a href='https://bitbucket.org/nxg/libsigwatch/downloads' >from Bitbucket</a>.</p>

<p>To configure, build and install, just use:</p>
<pre>
% ./configure
% make
% make install
</pre>
<p>That will install the software into <code>/usr/local</code>.  If
you want it to go somewhere else, then (as usual with
<code>./configure</code>), specify the alternative location as the
argument to configure's <code>--prefix</code> option.  See
<kbd>./configure --help</kbd> for more details.</p>

<p>This software is copyright 2003, 2005, 2011, Norman Gray.
It is free software, released under the terms of the
<a href='http://www.gnu.org/licenses/gpl.html' >GNU General Public Licence</a>.</p>

<h2>Release notes</h2>

<dl>
<dt>Version 1.0, 2011 February 2</dt>
<dd>Changed hosting; documentation preening.
No functional differences from 0.2,
but it's high time to make this release 1.0.</dd>

<dt>Version 0.2</dt>
<dd>Improved documentation</dd>

<dt>Version 0.1</dt>
<dd>Initial version.</dd>
</dl>


<div class='signature'>
<a href="http://purl.org/nxg" >Norman</a><br/>
2011 February 2
</div>

</body>
</html>

