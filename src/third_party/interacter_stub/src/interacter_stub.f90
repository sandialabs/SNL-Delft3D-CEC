!> @file interacter_stub.f90
!! A stub library with all Interacter subroutine and function interfaces.
!! All routines ares empty, no code is executed, this is just for linking
!! with programs that call Interacter, but may not need it in batch mode.
!!
!! Originally from InteracterEmulatorClass.f90

!! $Id: interacter_stub.f90 47756 2016-09-23 11:04:21Z kernkam $

    subroutine IOutCentre(IY,STRING)
        integer IY ! Row
        character(len=*) STRING ! String to write out
        ! Short-name : OUTCEN
        ! Outputs a string centred on the specified screen line. If IY is invalid, the string is not
        ! written. If the string exceeds the width of the screen, it is truncated.
        !e.g. CALL IScreenMode('T',80,25,2)
        !CALL IOutCentre(13,'This will be in the middle of the screen')
        !Errors :
        !ErrStrTooWide (15) : String extends beyond width of screen . String truncated.
    end subroutine

    subroutine IOutCRLF(NCRLF)
        integer NCRLF ! Number of carriage return/line feeds to output
        ! Short-name : OUTCRL
        ! Performs carriage return/line feed operations by placing the cursor on the start of the
        ! line which is NCRLF lines down from the current line. At least one carriage return/line
        ! feed is simulated. If the cursor would go beyond the last screen line, the cursor is
        ! placed at the bottom left corner of the screen. No scrolling is performed.
        ! This routine is useful following a call to one of the other OU routines, such as
        ! IOutString, to simulate the action of a Fortran WRITE. An NCRLF value of one
        ! puts the cursor at the start of the next screen line, a value of 2 gives a blank line and so
        ! on. Specify a large value to quickly put the cursor at the bottom of the screen without
        ! having to call InfoScreen to check the screen size. See also IOutCRLFScroll.
        !e.g. CALL IOutString('Here is a string')
        !CALL IOutCRLF(1)
        !CALL IOutString('And this is on the next line')
        !Text Output INTERACTER Subroutine Reference
        !1-2
    end subroutine

    subroutine IOutCRLFScroll(NCRLF)
        integer NCRLF ! Number of carriage return/line feeds to output
        ! Short-name : OUTCRS
        ! Performs carriage return/line feed operations by placing the cursor on the start of the
        ! line which is NCRLF lines down from the current line and scrolls the screen if
        ! necessary. At least one carriage return/line feed is simulated. If NCRLF would place the
        ! cursor beyond the last row, the screen is scrolled by an appropriate number of lines.
        ! This routine is useful following a call to one of the other OU routines, such as
        ! IOutString, to simulate the action of a Fortran WRITE. See also IOutCRLF.
        !e.g. DO 100 LINE = 1,100
        !CALL IOutString('This is line number ')
        !CALL IOutInteger(LINE,3)
        !CALL IOutCRLFScroll(1)
        !100 CONTINUE
    end subroutine

    subroutine IOutDouble(DBLVAL,FRMAT)
        double precision DBLVAL ! Double precision value to output
        character(len=*) FRMAT ! Fortran format to be used (D, E, F or G format)
        ! Short-name : OUTDBL
        ! Outputs the supplied double precision value using the specified Fortran format, at the
        ! current cursor position, in the current text style. The format specification must be a
        !valid Fortran format enclosed in brackets, e.g. (F10.4), (D15.8), etc. The maximum
        !width of field in which DBLVAL can be written is 100 characters.
        !The value will be right justified by default, but this is controllable via
        !IOutJustifyNum. The cursor is left at the end of the numeric output field (this will
        !include trailing blanks if left or centre justification was used).
        !e.g. DOUBLE PRECISION DBL
        !:
        !DBL = 1.00000001
        !CALL ICursorXY(10,10)
        !CALL IOutDouble(DBL,'(F11.8)')
        !C the following has the same effect ...
        !CALL IOutStringXY(10,10,' 1.00000001')
    end subroutine

    subroutine IOutDoubleXY(IX,IY,DBLVAL,FRMAT)
        integer IX ! Column
        integer IY ! Row
        double precision DBLVAL ! Double precision value to output
        character(len=*) FRMAT ! Fortran format to be used (D, E, F or G format)
        ! Short-name : OUTDXY
        ! Outputs the supplied double precision value, at a specific cursor position, in the same
        ! way as IOutDouble.
        !e.g. DOUBLE PRECISION DBL
        !CALL ICursorXY(10,10)
        !CALL IOutDouble(DBL,'(F11.8)')
        !C this is simpler ...
        !CALL IOutDoubleXY(10,10,DBL,'(F11.8)')
        !INTERACTER Subroutine Reference Text Output
        !1-3
    end subroutine

    subroutine IOutError(STRING)
        character(len=*) STRING ! String to output at bottom of screen
        ! (blank to clear bottom line)
        ! Short-name : OUTERR
        ! Outputs a string (normally an error message) centred on the bottom line of the screen
        ! and rings the bell. The previous contents of the bottom screen line are cleared before
        ! the message is output, so the message line will be set to the currently selected
        ! background colour on suitable displays. If the supplied string is blank, no string is
        ! output and the bottom line is simply cleared.
        !e.g. IF (InfoError(1).GT.0)
        !1 CALL IOutError('Error on file open - file may not exist')
        !Errors :
        !ErrStrTooWide (15) : String extends beyond width of screen. String truncated.
    end subroutine

    subroutine IOutInteger(INTVAL,IWIDTH)
        integer INTVAL ! Integer value to output
        integer IWIDTH ! Width of field in which INTVAL is to be output (<=100)
        ! Short-name : OUTINT
        ! Outputs the supplied integer value, at the current cursor position, in the current text
        ! style. The value is right-justified by default (but see IOutJustifyNum) in a field
        ! IWIDTH characters wide. The maximum width of field in which INTVAL can be
        ! written is 100 characters. The cursor is left at the end of the numeric output field (this
        ! will include trailing blanks if left or centre justification was used).
        !e.g. CALL ICursorXY(10,10)
        !CALL IOutInteger(150,5)
        !C the following has the same effect ...
        !CALL IOutStringXY(10,10,' 150')
    end subroutine

    subroutine IOutIntegerXY(IX,IY,INTVAL,IWIDTH)
        integer IX ! Column
        integer IY ! Row
        integer INTVAL ! Integer value to output
        integer IWIDTH ! Width of field in which INTVAL is to be output (<=100)
        ! Short-name : OUTIXY
        ! Outputs the supplied integer value, at a specific cursor position, in the same way as
        ! IOutInteger.
        !e.g. CALL ICursorXY(10,10)
        !CALL IOutInteger(150,5)
        !C this is simpler ...
        !CALL IOutIntegerXY(10,10,150,5)
        !Text Output INTERACTER Subroutine Reference
        !1-4
    end subroutine

    subroutine IOutJustifyNum(LCR)
        character(len=*) LCR ! Numeric field Justification required :
        ! = 'L' : Left justify ) either
        ! = 'C' : Centre justify ) upper or
        ! = 'R' : Right justify (default) ) lower case
        ! Short-name : OUTJUS
        ! Defines how numeric fields should be justified on output. By default, numeric values
        ! are output right justified, in the same manner as standard Fortran FORMAT conventions.
        ! However, left-justification may prove more useful, especially in data entry forms. The
        ! justification selected via IOutJustifyNum affects all routines which output numeric
        ! values, namely : IOutInteger, IOutIntegerXY, IOutReal, IOutRealXY,IOutDouble, IOutDoubleXY, IWinOutDouble, IWinOutDoubleXY,
        ! IWinOutInteger, IWinOutIntegerXY, IWinOutReal, IWinOutRealXY,IFormShow, IFormShowUnp, IFormShowField and IFormEdit.
        ! The 'C' option is provided, for the sake of completeness, since the argument to
        ! IOutJustifyNum will be passed to the IJustifyString routine within the
        ! various numeric value output routines.
        ! See also InJustifyNum which determines how numeric values are displayed on
        ! entry to data input fields.
        !e.g. INTVAL = 100
        !IWIDTH = 6
        !C first use right justification (the default)
        !CALL IOutIntegerXY(5,5,INTVAL,IWIDTH)
        !C now use left justification to see the difference
        !CALL IOutJustifyNum('L')
        !CALL IOutIntegerXY(5,7,INTVAL,IWIDTH)
    end subroutine

    subroutine IOutMessage(STRING)
        character(len=*) STRING ! String to output at bottom of screen
        ! (blank to clear bottom line)
        ! Short-name : OUTMES
        ! Outputs a message string centred on the bottom line of the screen. This is useful for
        ! providing prompts and other brief help information at a standard position on the screen.
        ! The previous contents of the bottom screen line are cleared before the message is
        ! output, so the message line will be set to the currently selected background colour on
        ! suitable displays. If the supplied string is blank, no string is output and the message line
        ! is simply cleared.
        !e.g. CALL IOutMessage(' Press any key to continue ')
        !CALL InKeyEvent(KEY)
        !Errors :
        !ErrStrTooWide (15) : String extends beyond width of screen . String truncated.
        !INTERACTER Subroutine Reference Text Output
        !1-5
    end subroutine

    subroutine IOutReal(REAVAL,FRMAT)
        real REAVAL ! Real value to output
        character(len=*) FRMAT ! Fortran format to be used (E, F or G format)
        ! Short-name : OUTREA
        ! Outputs the supplied real value using the specified Fortran format, at the current cursor
        ! position, in the current text style. The format specification must be a valid Fortran
        !format enclosed in brackets, e.g. (F10.4), (E8.2), etc. The maximum width of field in
        !which REAVAL can be written is 100 characters.
        !The value will be right justified by default, but this is controllable via
        !IOutJustifyNum. The cursor is left at the end of the numeric output field (this will
        !include trailing blanks if left or centre justification was used).
        !e.g. CALL ICursorXY(10,10)
        !CALL IOutReal(99.345,'(F6.2)')
        !C the following has the same effect ...
        !CALL IOutStringXY(10,10,' 99.34')
    end subroutine

    subroutine IOutRealXY(IX,IY,REAVAL,FRMAT)
        integer IX ! Column
        integer IY ! Row
        real REAVAL ! Real value to output
        character(len=*) FRMAT ! Fortran format to be used (E, F or G format)
        ! Short-name : OUTRXY
        ! Outputs the supplied real value, at a specific cursor position, in the same way as
        ! IOutReal.
        !e.g. CALL ICursorXY(10,10)
        !CALL IOutReal(99.345,'(F6.2)')
        !C this is simpler ...
        !CALL IOutRealXY(10,10,99.345,'(F6.2)')
    end subroutine

    subroutine IOutString(STRING)
        character(len=*) STRING ! String to output
        ! Short-name : OUTSTR
        ! Outputs STRING, at the current cursor position, in the current text style. The cursor is
        ! left at the end of the string.
        ! Text which would extend beyond the end of the current screen line is truncated. Text
        ! can safely be written to the bottom right hand corner of the screen, since scrolling is
        ! suppressed.
        !e.g. CHARACTER*10 STR1
        !:
        !CALL IOutString(STR1)
        !CALL ICursorXY(1,5)
        !CALL IOutString(.Leave the cursor on this line > ')
        !Text Output INTERACTER Subroutine Reference
        !1-6
    end subroutine

    subroutine IOutStringXY(IX,IY,STRING)
        integer IX ! Column
        integer IY ! Row
        character(len=*) STRING ! String to write out
        ! Short-name : OUTSXY
        ! Outputs a string at the specified screen position, in the same way as IOutString.
        !e.g. CALL ICursorXY(IX,IY)
        !CALL IOutString('Enter name : ')
        !C this is simpler ...
        !CALL IOutStringXY(IX,IY,'Enter name : ')
!        type(Fields), pointer :: this
!        this => this_
!
!        
!        if (IY /= 0) return
!        
!        select case(IX)
!            case(1)
!                this%statusBarText1 = STRING
!            case(2)
!                this%statusBarText2 = STRING
!            case(3)
!                this%statusBarText3 = STRING
!        end select
!        call setStatusbarText(this%canvasWindow, &
!               this%statusBarText1 // this%statusBarText2 // this%statusBarText3)
    end subroutine

    subroutine IOutVertical(STRING)
        character(len=*) STRING ! String to output
        ! Short-name : OUTVER
        ! Outputs STRING, vertically (downwards) from the current cursor position. Text which
        ! would extend beyond the bottom line of the screen is truncated in a similar manner to
        ! text which is output horizontally using IOutString. (If a string is to be written in the
        ! extreme right column of the screen, use IOutVerticalXY to output your string,instead of IOutVertical.)
        !e.g. CALL ICursorXY(2,1)
        !CALL IOutVertical('1 2 3 4 5 6 7 8 9 A B')
    end subroutine

    subroutine IOutVerticalXY(IX,IY,STRING)
        integer IX ! Column
        integer IY ! Row
        character(len=*) STRING ! String to write out
        ! Short-name : OUTVXY
        ! Outputs a string vertically from the specified screen position, in the same way as
        ! IOutVertical.
        !e.g. CALL ICursorXY(IX,1)
        !CALL IOutVertical('Vertical !')
        !C this is simpler ...
        !CALL IOutVerticalXY(IX,1,'Vertical !')
        !INTERACTER Subroutine Reference Cursor Control
        !1-7
        !1.2 Group CU : Cursor Control
        !The cursor control routines use text screen co-ordinates which assume that (1,1) is the
        !top left corner of the screen. The size of screen depends on the mode selected using
        !IScreenMode or IScreenModeN, which are available in group SC.
        !CU routines allow the cursor position to be set absolutely (ICursorXY,ICursorHome) or relatively (ICursorUp/Down/Left/Right). Two routines
        !also scroll the screen if the cursor would move off-screen (ICursorUpScroll,ICursorDownScroll). The on-screen cursor can be enabled/disabled (ICursor)
        !or its size can be controlled (ICursorSize).
    end subroutine

    subroutine ICursor(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch the cursor on (upper or lower case)
        ! = any other value to switch cursor off
        ! Short-name : CURSOR
        ! Enables or disables the hardware text cursor. Certain INTERACTER routines
        ! automatically set the state of the hardware cursor. The menu handling routines disable
        ! it and fixed field input routines enable it. In all cases these routines will restore the state
        ! set by ICursor on exit. The default state of the cursor on mode selection (as
        ! performed by IScreenOpen, IGrInit, IScreenMode or IScreenModeN) is
        ! enabled in text mode and disabled in graphics mode.
        ! Not all displays support hardware cursor disablement. Chapter 18 in the User Guide
        ! lists this capability by display type.
        !e.g. CALL ICursor('OFF')
        !CALL IOutStringXY(10,2,'The cursor should now be off ...')
        !CALL InKeyEvent(IKEY)
        !CALL ICursor('ON')
        !CALL IOutStringXY(10,4,'And now it should be back on ...')
        !Portability notes :
        !DOS :
        !There is no hardware cursor in graphics screen modes.
        !Xlib and MS Windows :
        !A cursor is only maintained in the fixed field input routines (and hence also in forms).
        !It is not visible at other times, so ICursor therefore has no effect.
        !Terminals :
        !ICursor works in text modes on all VT200 compatible displays and in ReGIS
        !graphics mode. Refer to chapter 18 in the User Guide for other display types.
    end subroutine

    subroutine ICursorDown(NROWS)
        integer NROWS ! Number of rows by which to move down
        ! Short-name : CURDN
        ! Moves the cursor down by NROWS rows in the current column. If the cursor would go
        ! beyond the bottom of the screen it is wrapped back on at the top of the screen.
        !e.g. CALL ICursorDown(10)
        !Cursor Control INTERACTER Subroutine Reference
        !1-8
    end subroutine

    subroutine ICursorDownScroll(NROWS)
        integer NROWS ! Number of rows by which to move down and/or scroll
        ! Short-name : CURDNS
        ! Moves the cursor down by NROWS in the current column and scrolls the screen up if the
        ! bottom of the screen is reached (see also ICursorUpScroll). So, if the cursor is 3
        ! rows from the bottom of the screen and NROWS is 5, the cursor will move down 3 rows
        ! to the bottom of the screen and scroll the screen up by 2 rows. If the cursor is already at
        ! the bottom of the screen such a call would scroll the screen up by the full 5 rows.
        !e.g. CALL ICursorDownScroll(5)
        !Portability notes :
        !Tektronix :
        !Scrolling is not available on Tektronix displays which do not support independent
        !text/graphics output.
        !xterm :
        !Scrolling affects the text window when operating via xterm.
    end subroutine

    subroutine ICursorHome
        ! Short-name : CURHOM
        ! Moves cursor to the 'home' position on the screen. i.e. The top left corner of the screen.
        !e.g. CALL ICursorHome
        !CALL IOutString('Top left !')
    end subroutine

    subroutine ICursorLeft(NCOLS)
        integer NCOLS ! Number of columns by which to move left
        ! Short-name : CURLFT
        ! Moves the cursor left by NCOLS columns. If the cursor would move beyond the edge of
        ! the screen it is wrapped onto the previous line, at the other side of the screen.
        !e.g. CALL ICursorLeft(10)
    end subroutine

    subroutine ICursorRestore
        ! Short-name : CURRES
        ! Restores the cursor to the position saved by ICursorSave. The cursor can be
        ! restored as many times as required to the same saved position. If the cursor has not
        ! been saved by a previous call to ICursorSave, ICursorRestore has no effect.
        !e.g. CALL ICursorSave
        !C now do some other screen processing
        !:
        !C and put the cursor back
        !CALL ICursorRestore
        !INTERACTER Subroutine Reference Cursor Control
        !1-9
    end subroutine

    subroutine ICursorRight(NCOLS)
        integer NCOLS ! Number of columns by which to move right
        ! Short-name : CURRHT
        ! Moves the cursor right by NCOLS columns. If the cursor would move beyond the edge
        ! of the screen it is wrapped onto the next line, at the other side of the screen.
        !e.g. CALL ICursorRight(5)
    end subroutine

    subroutine ICursorSave
        ! Short-name : CURSAV
        ! Saves the cursor position so it can be restored later by ICursorRestore. Only one
        ! cursor position can be saved at a time. Calling ICursorSave twice without an
        ! intervening call to ICursorRestore will cause INTERACTER to forget the
        ! previously saved position.
        !e.g. CALL ICursorSave
        !:
        !C now do some other screen processing
        !:
        !C and put the cursor back
        !CALL ICursorRestore
    end subroutine

    subroutine ICursorSize(SIZE)
        character(len=*) SIZE ! 'UN' : underline (default)
        ! = 'BL' : Block
        ! Short-name : CURSIZ
        ! Selects the size of the hardware text cursor. Any value for SIZE other than a string
        ! starting with BL will give an underline cursor. If the cursor is currently disabled, this
        ! call will have no effect until an ICursor('ON') call is executed.
        ! All the fixed field input routines, (see chapter 2) override the cursor size selection.
        ! Their cursor size selection is determined by InCursorType. ICursorSize
        ! controls the appearance of the cursor outside these routines.
        ! At start up INTERACTER defaults to an underline cursor and restores this state on exit.
        ! Not all displays support hardware cursor size control. Chapter 18 in the User Guide
        ! lists this capability by display type.
        !e.g. CALL ICursor('ON')
        !CALL ICursorSize('BL')
        !CALL IOutStringXY(10,2,'Block cursor ...')
        !CALL InKeyEvent(IKEY)
        !CALL ICursor('UN')
        !CALL IOutStringXY(10,4,'underline cursor ... ')
        !Portability notes :
        !DOS :
        !There is no hardware cursor in graphics screen modes, so ICursorSize only affects
        !text screen modes.
        !Cursor Control INTERACTER Subroutine Reference
        !1-10
        !Terminals :
        !ICursorSize does not work on true VT100/VT200 terminals or on most of their
        !variants. Certain terminals do support this feature however (see chapter 18 in the User
        !Guide).
        !Xlib and MS Windows :
        !There is no hardware cursor on these displays. A vertical bar cursor is provided by
        !INTERACTER in data entry fields. ICursorSize has no effect.
    end subroutine

    subroutine ICursorUp(NROWS)
        integer NROWS ! Number of rows by which to move up
        ! Short-name : CURUP
        ! Moves the cursor up by NROWS rows in the current column. If the cursor would go
        ! beyond the top of the screen it is wrapped back on at the bottom of the screen.
        !e.g. CALL ICursorUp(2)
    end subroutine

    subroutine ICursorUpScroll(NROWS)
        integer NROWS ! Number of rows by which to move up and/or scroll
        ! Short-name : CURUPS
        ! Moves the cursor up by NROWS rows in the current column and scrolls the screen down
        ! if the top of the screen is reached (see also ICursorDownScroll). Hence if the
        ! cursor were 3 rows from the top of the screen and NROWS were 5, the cursor would
        ! move up 3 rows to the top of the screen and scroll the screen down by two rows. If the
        ! cursor were already at the top of the screen such a call would have scrolled the screen
        ! down by the full 5 rows.
        !e.g. CALL ICursorUpScroll(6)
        !Portability notes :
        !See ICursorDownScroll
    end subroutine

    subroutine ICursorXY(IX,IY)
        integer IX ! Column
        integer IY ! Row
        ! Short-name : CURXY
        ! Moves the cursor to a specific position, assuming that the top left 'home' position is
        ! (1,1). Attempts to position the cursor 'off-screen' are handled as follows :
        ! (a) If both IX and IY lie off-screen, the request is ingnored.
        ! (b) If only one of IX and IY is invalid, the current cursor column/row position is
        ! substituted for the invalid argument.
        !e.g. CALL ICursorXY(10,5)
        !CALL IOutString('This is 10 columns across & 5 lines down')
        !INTERACTER Subroutine Reference Text Screen Clearing
        !1-11
        !1.3 Group CL : Clearing
        !These routines allow all or part of the screen to be cleared. The important aspect of
        !these routines regards the effect on the area which is cleared. Routines IClearArea
        !and IClearField always clear according to the current background text attribute as
        !set by the ITextColour/ITextColourN and ITextReverse routines in the AT
        !group. IClearLine and IClearScreen also clear according to this attribute on
        !most displays except many serial terminals which usually clear to the default
        !background. Support for the clear-to-background attribute feature can be tested by
        !calling InfoAttribute(15).
        !When used in graphics mode on a display which supports independent text and
        !graphics output (e.g. xterm, Tek 4100) these routines affect the text screen only. Where
        !text and graphics are mixed (e.g. DOS, Windows) both graphics and text are cleared.
    end subroutine

    subroutine IClearArea(IXTOPL,IYTOPL,IXBOTR,IYBOTR)
        integer IXTOPL ! Top left column of area
        integer IYTOPL ! Top left row of area
        integer IXBOTR ! Bottom right column of area
        integer IYBOTR ! Bottom right row of area
        ! Short-name : CLAREA
        ! Clears an area, defined by the top left and bottom right co-ordinates
        ! (IXTOPL,IYTOPL) & (IXBOTR,IYBOTR), leaving the cursor at (IXTOPL,IYTOPL).
        ! The routine does nothing if the left X value is greater than the right X value, or if the
        ! top Y value is greater than the bottom Y value. The cleared area will be in colour or
        ! reverse video if previously selected by ITextColour/ITextColourN or
        ! ITextReverse.
        ! If the specified area extends beyond the current screen limits, the area co-ordinates are
        ! adjusted accordingly.
        !e.g. DO 50 IY=1,20
        !CALL IOutStringXY(1,IY,'***********************************')
        !50 CONTINUE
        !CALL IClearArea(5,5,20,15)
        !Errors :
        !ErrBadClear (14) : Invalid text co-ordinates. i.e. IXTOPL is greater than IXBOTR
        !or IYTOPL is greater than IYBOTR.
        !Portability notes :
        !Tektronix :
        !On displays which use Tek 4010/4014 Alpha mode for text output in graphics mode,support for solid rectangle fills is required (not usually available). On displays which
        !support independent text/graphics, (xterm, Tek 4100/Tek4200, Tera Term Pro) only the
        !text window or plane is affected.
        !Text Screen Clearing INTERACTER Subroutine Reference
        !1-12
    end subroutine

    subroutine IClearField(IX,IY,ILEN)
        integer IX ! Column
        integer IY ! Row
        integer ILEN ! Length of field to clear from (IX,IY)
        ! Short-name : CLFIEL
        ! Clears a field at screen position (IX,IY), leaving the cursor at (IX,IY). The cleared
        ! field will be in colour or reverse video if previously selected by
        ! ITextColour/ITextColourN or ITextReverse.
        ! If the specified field length would extend beyond the edge of the screen,IClearField simply clears to the end of the line from position (IX,IY).
        !e.g. CALL ICursorXY(10,5)
        !CALL IOutString('Press SPACE to wipe this message')
        !10 CALL InKeyEvent(IKEY)
        !IF (IKEY.NE.ICHAR(' ')) GOTO 10
        !CALL IClearField(10,5,33)
        !Portability notes :
        !Tektronix :
        !See IClearArea
    end subroutine

    subroutine IClearLine(IY)
        integer IY ! Row to clear
        ! Short-name : CLLINE
        ! Clears the whole of line IY, leaving the cursor at the beginning of that line.
        !e.g. CALL ICursorXY(10,10)
        !CALL IOutString('Press SPACE to clear this line')
        !10 CALL InKeyEvent(IKEY)
        !IF (CHAR(IKEY).NE.' ') GOTO 10
        !CALL IClearLine(10)
        !Portability notes :
        !DOS, Xlib and Windows:
        !The line is cleared to the current background, as set by
        !ITextColour/ITextColourN or ITextReverse.
        !Terminals :
        !Normally, on a serial terminal a text screen line is cleared to the default background for
        !the current terminal (usually black). When used on certain ANSI compatible
        !terminals/emulators, the line is cleared to the current background colour, in a manner
        !consistent with other versions. See chapter 18 in the User Guide under the CL heading
        !for a list of terminals which support this feature or call InfoAttribute(15).
        !Tektronix :
        !See IClearArea
    end subroutine

    subroutine IClearScreen
        ! Short-name : CLSCRN
        ! Clears the screen, leaving the cursor at position (1,1).
        ! INTERACTER Subroutine Reference Text Screen Clearing
        ! 1-13
        !e.g. CALL IOutStringXY(1,20,'Press a key to continue')
        !CALL InKeyEvent(KEY)
        !CALL IClearScreen
        !Portability notes :
        !DOS, Xlib andWindows :
        !The screen is cleared to the current background, as set by
        !ITextColour/ITextColourN or ITextReverse.
        !Terminals :
        !Normally, on a serial terminal the text screen is cleared to the default background for
        !the current terminal (usually black). When used on certain ANSI compatible
        !terminals/emulators, the screen is cleared to the current background colour, in a manner
        !consistent with other versions. See chapter 18 in the User Guide under the CL heading
        !for a list of terminals which support this feature or call InfoAttribute(15).
        !Tektronix :
        !Full screen clearing is supported on all Tektronix displays. On displays which support
        !independent text/graphics, (xterm, Tek 4100/4200, Tera Term Pro) only the text
        !window/plane is cleared.
        !
        !INTERACTER Subroutine Reference Text Attributes
        !1-15
        !1.4 Group AT : Text Attributes
        !Displayed text can be greatly enhanced using the various text attribute control routines.
        !These allow colours to be selected (where available) as well as supporting highlights
        !such as underlining, bold text and so on. All the routines simply select the attribute to
        !be used by any further text output. They have no immediate on-screen effect until other
        !routines are called which display text.
        !Attributes can be selected individually (e.g. by calling ITextBold to enable or
        !disable bold text) or in combination (by calling ITextAttribute which sets several
        !attributes at once). Wherever the display hardware supports it, changing the state of a
        !single highlight does not affect the state of the others.
        !IScreenOpen initialises all attributes to 'off' and text colours to bold/white-on-black
        !(or black-on-bold/white if black/white reversal is enabled).
        !Since the availability of text attributes varies from one type of display or screen mode
        !to another, the InfoAttribute function is provided to identify which are supported.
        !See the documentation under Group IF. None of the routines in this group have any
        !effect in Tektronix graphics mode on displays which use Tek 4010/4014 text handling
        !protocols.
    end subroutine

    subroutine ITextAttribute(BFIRU)
        character(len=*) BFIRU ! A string containing any or none of the following
        ! characters in upper or lower case :
        ! B : Select bold text
        ! F : Select flashing text
        ! I : Select italics
        ! R : Select reverse video
        ! U : Select underlining
        ! Short-name : ATTRIB
        ! Selects a combination of text attributes. Only those attributes indicated in the argument
        ! string will be enabled and the others will be disabled. All attributes are off at start-up.
        ! To disable all text attributes, call ITextAttribute with a blank argument. To
        ! enable or disable specific attributes without affecting the other current selections, use
        ! the routines ITextBold, ITextFlash, ITextItalic, ITextReverse or
        ! ITextUnderline.
        ! Text attribute support is highly display dependent. InfoAttribute reports the
        ! availability of each attribute. Chapter 18 in the User Guide also summarises attribute
        ! availability. Selecting an unavailable attribute will have no effect.
        !e.g. CALL ITextAttribute('B.F.I')
        !CALL IOutCentre(3,'Flashing - Bold - Inverse')
        !CALL ITextAttribute(' ')
        !CALL IOutCentre(5,'This is normal text')
        !Text Attributes INTERACTER Subroutine Reference
        !1-16
        !Portability notes :
        !DOS :
        !Bold is supported under DOS in all modes except mono graphics modes. Enabling bold
        !causes text to be displayed in a higher intensity. Thus if foreground and background
        !text colours are the same and bold is enabled, text is still readable. On a colour screen,the same effect can be achieved by specifying a bold colour number/name to
        !ITextColourN or ITextColour.
        !Flashing text is only supported in text screen modes. Flashing text availability must be
        !explicitly enabled by calling IScreenModeOptions(8,1) (in which case only 8
        !background colours will be available).
        !Italic text is not supported in any mode.
        !Reverse video is supported in all modes.
        !Underlining is supported in all graphics modes. It is not available in text mode.
        !MS Windows :
        !Reverse video and underlining are supported on all displays. Bold text is supported
        !using a different colour shade on most displays. Italics are supported in graphics mode.
        !Flashing text is not supported.
        !Xlib :
        !Reverse video, underlining and bold text are supported on all displays. Bold text is
        !displayed using a thicker character set (where available) and a different colour shade
        !(on colour displays). Flashing text and italics are not supported.
        !Terminals :
        !True VT100/VT200 compatible terminals support all of bold, flashing, reverse video
        !and underlining. These are also supported whilst in ReGIS graphics mode. Attribute
        !support on other terminals and emulators varies considerably. As indicated above, refer
        !to InfoAttribute or chapter 18 in the User Guide for device dependencies.
    end subroutine

    subroutine ITextBold(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch bold text on (upper or lower case)
        ! = any other value to switch bold off
        ! Short-name : ATBOLD
        ! Switches bold text on or off. Only the foreground text attribute is affected.
        !e.g. CALL ITextBold('ON')
        !CALL IOutCentre(3,'This is bold text')
        !CALL ITextBold('OFF')
        !CALL IOutCentre(5,'This is normal text.')
        !Portability notes :
        !See ITextAttribute
        !INTERACTER Subroutine Reference Text Attributes
        !1-17
    end subroutine

    subroutine ITextColour(FORCOL,BACCOL)
        character(len=*) FORCOL ! Foreground colour name (see below)
        character(len=*) BACCOL ! Background colour name (see below)
        ! Short-name : ATCOL
        ! Selects foreground and background text colours, by name. The colours can be specified
        ! in full or can be abbreviated. Valid colour names are (upper or lower case) : Black,Cyan, Red, Blue, Yellow, Magenta, Green or White. For bright/bold shades prefix the
        !colour name with a B (e.g. BWhite). Unambiguous abbreviations are allowed too, i.e.
        !BLA, BBLA, C, BC, R, BR, BLU, BBLU, Y, BY, M, BM, G, BG, W or BW. The
        !default at start-up is bold-white on black (or black on bold-white if black/white reversal
        !is enabled). See IScreenOpen and the REVERSE keyword.
        !The first eight colours are 'normal intensity'. The latter 8 select a bold/bright shade
        !which may not be available on some screens. Where a screen only supports eight
        !foreground or background colours, the appropriate colour is still selected, but the
        !bold/normal intensity selection is ignored. If only one colour needs to be specified,leave the other colour string blank.
        !Unrecognised colour names are ignored, as are calls made in monochrome screen
        !modes. See also ITextColourN.
        !e.g. CALL ITextColour('blue','w')
        !CALL IOutCentre(3,' Blue text on a white background ')
        !CALL ITextColour('Red' ,' ')
        !CALL IOutCentre(5,' Now red text, still on a white background')
        !CALL ITextColour('Black','yel')
        !CALL IFrameTitleBox(8,8,73,20,'C','Black frame/Yellow b/grond')
        !Portability notes :
        !See ITextColourN
    end subroutine

    subroutine ITextColourN(NFCOLR,NBCOLR)
        integer NFCOLR ! Foreground text colour number (see below)
        integer NBCOLR ! Background text colour number (see below)
        ! Short-name : ATCOLN
        ! Include : interat.inc
        ! Text colour numbers are :
        ! TextBlack (0) : Black TextBlackBold (8) : Dark Grey
        ! TextRed (1) : Red TextRedBold (9) : Bold Red
        ! TextYellow (2) : Yellow TextYellowBold (10) : Bold Yellow
        ! TextGreen (3) : Green TextGreenBold (11) : Bold Green
        ! TextCyan (4) : Cyan TextCyanBold (12) : Bold Cyan
        ! TextBlue (5) : Blue TextBlueBold (13) : Bold Blue
        ! TextMagenta (6) : Magenta TextMagentaBold (14) : Bold Magenta
        ! TextWhite (7) : Off-white TextWhiteBold (15) : Bold White
        ! Selects foreground and background text colours, by number. This routine is directly
        ! equivalent to ITextColour except that the colour is specified by number rather than
        ! by name.
        ! Text Attributes INTERACTER Subroutine Reference
        ! 1-18
        ! Colours 0-7 are 'normal intensity'. Colours 8-15 select equivalent bold/bright shades
        ! which may not be available on some screens. Where a screen only supports eight
        ! foreground or background colours, a colour number of MOD(colour,8) is used. If
        ! only one colour needs to be specified, the other colour number should be set to -1.
        ! Invalid colour numbers are ignored, as are calls made in monochrome screen modes.
        ! In a graphics mode, the text palette is the same as the 16-colour palette described under
        ! IGrColourN. Redefining the following graphics colour numbers will therefore
        ! typically also redefine the corresponding text colours :
        ! Colour Text Graphics Graphics colour #
        ! Name colour # colour # Black/white Reversed
        ! Black 0 0 223
        ! Red 1 47 47
        ! Yellow 2 79 79
        ! Green 3 111 111
        ! Cyan 4 143 143
        ! Blue 5 175 175
        ! Magenta 6 207 207
        ! Off-white 7 239 240
        ! Dark grey 8 240 239
        ! Bold red 9 31 31
        ! Bold yellow 10 63 63
        ! Bold green 11 95 95
        ! Bold cyan 12 127 127
        ! Bold blue 13 159 159
        ! Bold magenta 14 191 191
        ! Bold white 15 223 0
        ! The third column in the table shows the graphics colour numbers which are selected
        ! when black/white reversal is selected via IScreenOpen or the REVERSE keyword.
        !e.g. CALL ITextColourN(5,7)
        !CALL IOutCentre(3,' Blue text on a white background ')
        !CALL ITextColourN(1,-1)
        !CALL IOutCentre(5,' Now red text, still on a white background')
        !CALL ITextColourN(0,2)
        !CALL IFrameTitleBox(8,8,73,20,'C','Black frame/Yellow b/ground')
        !Portability notes :
        !DOS :
        !Both foreground and background colours are selectable in all colour screen modes. All
        !16 colours are available by default. If IScreenModeOptions(8,1) has been
        !called (to enable flashing text), only 8 background colours are available in 16-colour
        !text modes.
        !Specifying a normal intensity colour in combination with the 'bold' attribute (as set by
        !ITextBold/ITextAttribute) has the same effect as specifying a bold colour
        !directly.
        !INTERACTER Subroutine Reference Text Attributes
        !1-19
        !MS Windows :
        !A video driver with 256 colours or more is required to be able to display all 16 text
        !colours. Some colours are not necessarily distinguishable on screens using 16 colour
        !video drivers.
        !Xlib :
        !All 16 text colours are supported on colour workstations for both foreground and
        !background colours. If bold is enabled at the same time as a normal intensity colour,the equivalent bold/bright colour is selected for so long as bold is enabled. An X server
        !with at least 256 colours available is required. 16-colour X servers will give poor
        !results.
        !Terminals :
        !Colour is selectable in text mode on a variety of ANSI compatible colour terminals and
        !terminal emulators. On most such terminals, only 8 colours are selectable. 16
        !foreground colours are selectable on PC-based terminal emulators which support both
        !colour and the bold attribute. See chapter 18 in the User Guide. On other terminals,ITextColour has no effect.
!        type(Fields), pointer :: this
!        this => this_
!        call setFontColor(this%canvas, this%colors(NFCOLR))
    end subroutine

    subroutine ITextFlash(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch flash text on (upper or lower case)
        ! = any other value to switch flashing text off
        ! Short-name : ATFLSH
        ! Switches flashing text on or off. Only the foreground text attribute is affected.
        !e.g. CALL ITextFlash('ON')
        !CALL IOutCentre(3,'This is flashing text')
        !CALL ITextFlash('OFF')
        !CALL IOutCentre(5,'This is steady.')
        !Portability notes :
        !See ITextAttribute
    end subroutine

    subroutine ITextItalic(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch italics on (upper or lower case)
        ! = any other value to switch italics off
        ! Short-name : ATITAL
        ! Switches italic text on or off.
        !e.g. CALL ITextItalic('ON')
        !CALL IOutCentre(3,'This is in italics')
        !CALL ITextItalic('OFF')
        !CALL IOutCentre(5,'And back to normal.')
        !Portability notes :
        !See ITextAttribute
        !Text Attributes INTERACTER Subroutine Reference
        !1-20
    end subroutine

    subroutine ITextReverse(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch reverse video on (upper or lower case)
        ! = any other value to switch reverse video off
        ! Short-name : ATRVID
        ! Switches reverse video on or off. In the default palette, this selects black-on-white. If
        ! palette reversal has been enabled via IScreenOpen or the REVERSE keyword, it
        ! selects white-on-black.
        ! On a colour display, when ITextReverse is called with an 'off' parameter, the
        ! foreground and background colours are restored to whatever they were when
        ! ITextReverse was previously called with an 'ON' parameter. If ITextReverse
        ! has not previously been called with an 'ON' parameter, switching reverse video off
        ! selects the default text colours.
        !e.g. CALL ITextColour('BLUE','CYAN')
        !CALL ITextReverse('ON')
        !CALL IOutCentre(3,'This is black on white')
        !CALL ITextReverse('OFF')
        !CALL IOutCentre(5,'And back to blue on cyan')
        !Portability notes :
        !See ITextAttribute
    end subroutine

    subroutine ITextUnderline(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch underlining on (upper or lower case)
        ! = any other value to switch underlining off
        ! Short-name : ATUNDR
        ! Switches underlining on or off.
        !e.g. CALL ITextUnderline('ON')
        !CALL IOutCentre(3,'This is underlined')
        !CALL ITextUnderline('OFF')
        !CALL IOutCentre(5,'And back to normal.')
        !Portability notes :
        !See ITextAttribute
        !INTERACTER Subroutine Reference Character Graphics
        !1-21
        !1.5 Group CG : Character Graphics
        !The routines in this group are used by the fixed-field-input (IN), menu (OM/MN),forms manager (FM) and text window (WN) routines, to draw frames around text areas.
        !Unlike the high-resolution graphics facilities described in Volume 2, these routines
        !are available in both text and graphics modes. Character graphics frames are drawn in
        !one of two ways, depending on display type :
        !(1) Box-character frames :
        !Simple line drawing characters are used in text mode on all displays and in graphics
        !mode on certain types of display.
        !(2) Graphical frames :
        !In graphics mode on displays which do not fall into category (1), frames are drawn
        !using graphics primitives, providing a more pleasing effect and a wider choice of
        !frame types.
        !Logically, these modes of operation are the same. In both cases, the height or width of a
        !frame is considered to be equivalent to that of one text character. This is obviously true
        !for box-drawing characters, but graphical frames are designed to always lie within the
        !same single character cell width/height. This ensures a consistent calling interface,regardless of the current frame drawing method.
        !Graphical frames are used on the following display types :
        !DOS graphics
        !Microsoft Windows
        !X-Windows
        !Tek terminals which use 401x alpha mode graphics-mode text screen handling
        !For the sake of portability, it is always best to precede and follow any use of character
        !graphics by a call to the ICharGraphics routine. This is required for compatibility
        !with most serial terminals which must switch character sets to use box-drawing
        !characters. See the ICharGraphics Portability notes for more information.
        !Associated with the line graphics character set are a number of special characters such
        !as mathematical symbols, arrows, etc. These symbols, along with the line graphics
        !characters are accessible via the ISpecialChar function.
    end subroutine

    subroutine ICharCross(IX,IY)
        integer IX ! Column
        integer IY ! Row
        ! Short-name : CROSS
        ! Prints a vertical/horizontal 'cross' (i.e. a +) at the specified row and column position.
        ! This routine is designed to be used with the character graphics line and frame drawing
        ! routines, (such as ISplitFrameH, ISplitFrameV, IFrame, etc.) to enable lines
        ! to cross one another neatly, when box-character frames are being drawn. It is not
        ! necessary to use this routine for this purpose on screens which draw graphical frames,but it is still implemented on such displays.
        ! Character Graphics INTERACTER Subroutine Reference
        ! 1-22
        ! The example below would divide a framed area into four equally sized quadrants.
        !e.g. CALL IFrame(IX1,IY1,IX2,IY2,' ')
        !MIDDLX = IY1+(IY2-IY1)/2
        !MIDDLY = IX1+(IX2-IX1)/2
        !CALL ISplitFrameH(IX1,MIDDLY,IX2)
        !CALL ISplitFrameV(MIDDLX,IY1,IY2)
        !CALL ICharCross(MIDDLX,MIDDLY)
    end subroutine

    subroutine ICharGraphics(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch character graphics on (upper/lower case)
        ! = any other value to switch character graphics off
        ! Short-name : CHARGR
        ! Switches character graphics mode on or off. When switched on this mode enables line
        ! graphics characters, such as those used by the frame and line routines, to be displayed.
        ! A number of special symbols also become available. All these characters can be
        ! accessed via the function ISpecialChar.
        ! Routines which use the line graphics characters, such as IFrame, ISplitFrameH,etc., all enable the use of character graphics automatically. On exit they restore the
        ! character graphics state to that set previously by ICharGraphics. Initially, character
        ! graphics are disabled by IScreenOpen.
        ! See ISpecialChar for a table of the available characters.
        !e.g. CHARACTER*1 LESSEQ,ISpecialChar
        !LESSEQ = ISpecialChar(13)
        !CALL IOutStringXY(10,5,'X > Y')
        !IF (X.LE.Y) THEN
        !CALL ICharGraphics('ON')
        !CALL IOutStringXY(12,5,LESSEQ)
        !CALL ICharGraphics('OFF')
        !ENDIF
        !Portability notes :
        !DOS :
        !ICharGraphics does nothing. Graphics characters and other special symbols are
        !available all the time, in both text and graphics screen modes.
        !MS Windows :
        !Character graphics are available at all times in text mode (using a PC compatible 8-bit
        !character set), but are not available in graphics mode. ICharGraphics has no effect.
        !Xlib :
        !Character graphics are available at all times, except in the rare situation where a DEC
        !Terminal font has had to be selected. The latter only normally occurs on older
        !DECwindows systems where the fonts which provide box-drawing characters at all
        !times are not available. Otherwise, ICharGraphics has no effect.
        !Terminals :
        !Do not leave character graphics enabled after displaying frames, lines, etc. since certain
        !ASCII characters will not be printable until they are disabled. Follow the sequence :
        !(a) enable character graphics
        !(b) print lines, symbols, etc.
        !(c) disable character graphics
        !(d) continue processing
        !INTERACTER Subroutine Reference Character Graphics
        !1-23
        !Tektronix displays which use 401x alpha mode for graphics mode text screen handling
        !do not support character graphics. Hi-res graphics facilities are used instead.
        !On Falco terminals (in Falco text mode) and on Prime PT250's, all printable characters
        !become redefined whilst character graphics are enabled, including the space character.
        !Hence, it is particularly important to only display characters returned by
        !ISpecialChar whilst character graphics are enabled.
    end subroutine

    subroutine IFrame(IXLEFT,IYTOP,IXRGHT,IYBOT,ACTION)
        integer IXLEFT ! Left column of box
        integer IYTOP ! Top row of box
        integer IXRGHT ! Right column of box
        integer IYBOT ! Bottom row of box
        character(len=*) ACTION ! String describing required action :
        ! = ' ' : leave frame contents unchanged
        ! = 'C' : clear frame contents (upper or lower case)
        ! Short-name : FRAME0
        ! Draws a frame around an area of the screen defined by (IXLEFT,IYTOP) and
        ! (IXRGHT,IYBOT). The frame itself lies within the text columns/rows specified by the
        ! subroutine arguments. If ACTION contains the letter C, the area inside the frame will
        ! be cleared, otherwise it will remain unchanged.
        ! IFrame always draws a complete frame. If any of the arguments lie off-screen, the
        ! invalid corner co-ordinates of the frame are adjusted to fit within the screen area.
        !e.g. CALL IFrame(10,10,40,12,'C')
        !CALL ICursorXY(12,11)
        !CALL IOutString('This is inside the frame')
        !Character Graphics INTERACTER Subroutine Reference
        !1-24
    end subroutine

    subroutine IFrameOptions(NOPTN,IVALUE)
        integer NOPTN ! Option number (see below)
        integer IVALUE ! Option value (see below)
        ! Include : intercg.inc, interat.inc, intergen.inc
        ! NOPTN IVALUE Default
        ! BorderControls (1) Allow for border controls in graphical frames No
        ! IntNo (0) = no
        ! BorderCRight (1) = at right only
        ! BorderCRightBelow (2) = at right and below
        ! BoxChars (2) Force box-character frames No
        ! IntNo (0) = no
        ! IntYes (1) = yes
        ! TitlePos (3) Frame title position Varies
        ! IntNone (0) = no title, as IFrame
        ! TitleInFrame (1) = as IFrameTitle
        ! TitleInBox (2) = as IFrameTitleBox
        ! TitleForeCol (4) Title foreground colour ) Bold white
        ! TitleBackCol (5) Title background colour ) see below Blue
        ! BorderCol (6) Primary border colour ) -1
        ! BorderCol2 (7) Secondary border colour ) -1
        ! Defines options to be applied when drawing text frames.
        ! Option 1 causes an area to be drawn in graphical type 1/3 frames (as selected by
        ! IFrameType) which allows for border controls. Scrolling menus set option 1 to 1
        ! automatically so they require no special action. This option is therefore mainly useful
        ! when opening windows for use with the window browsers, IWinBrowseText and
        ! IWinBrowseFile. It should normally be set to zero for other frames.
        ! Option 2 is provided as a backwards compatibility switch for those who need to
        ! continue using box-characters in graphics mode under DOS and X Windows. This
        ! switch will not work under Windows, where line-drawing characters are not available
        ! in graphics mode. Its long-term use is discouraged.
        ! Option 3 is updated automatically by IFrame, IFrameTitle and
        ! IFrameTitleBox to indicate the title position within the most recently drawn frame.
        ! This information is used by ISplitFrameV to determine the top of its vertical line
        ! when graphical frames are in use. If ISplitFrameV must be called for a frame
        ! which was called earlier with a different title position, option 3 allows this to be
        ! identified.
        ! Options 4/5 allow frame title colours to be controlled independently of the currently
        ! selected colours as set by ITextColour/ITextColourN. Colour numbers are as
        ! for ITextColourN, i.e. 0.15 or -1 to use the current colour. Titles are bold white on
        ! blue (15/5) by default.
        ! INTERACTER Subroutine Reference Character Graphics
        ! 1-25
        ! Options 6/7 control both box-character and graphical frames, on all colour displays.
        ! They set the border colours independently of the currently selected colours as set by
        ! ITextColour/ITextColourN. Colour numbers are as for ITextColourN, i.e.
        ! 0.15 or -1 to use the current colour. The latter is the default, so frames use the colours
        ! most recently selected by ITextColour or ITextColourN. The 'primary' and
        ! 'secondary' border colours represent the foreground and background text colours when
        ! using box-character frames. In 3D graphical frames they control the colour pairs used
        ! to create the 3D effect.
        ! The selected options are available via InfoFrame(101+).
        ! The following example selects a bold yellow title on a red background with a bold
        ! white and black border. The inner area of the window is blue.
        !e.g. CALL IFrameOptions(4,10)
        !CALL IFrameOptions(5,1)
        !CALL IFrameOptions(6,15)
        !CALL IFrameOptions(7,0)
        !CALL ITextColour(' ','BLUE')
        !CALL IWinAction('FC')
        !CALL IWinOpenTitle(0,0,50,10,'Bold Yellow Title on Red b/g')
    end subroutine

    subroutine IFrameTitle(IXLEFT,IYTOP,IXRGHT,IYBOT,ACTION,TITLE)
        integer IXLEFT ! Left column of box
        integer IYTOP ! Top row of box
        integer IXRGHT ! Right column of box
        integer IYBOT ! Bottom row of box
        character(len=*) ACTION ! String describing required action :
        ! = 'C' : Clear frame contents ) any
        ! = 'W' : Wide title bar ) combination
        ! = 'L' : Left justify title ) in upper or
        ! = 'R' : Right justify title ) lower case
        character(len=*) TITLE ! Heading for top of frame
        ! Short-name : FRAME1
        ! Prints a frame around an area of the screen, with a title string printed within the top of
        ! the frame. The title string can be printed at the left or right if required. By default it is
        ! centred. Strings which are too wide are truncated. Otherwise, as for IFrame.
        ! On displays which draw box-character frames, the frame is drawn to either end of the
        ! title string and terminated with left/right 'tee' characters, by default. Optionally, a 'W'
        ! can be specified in the ACTION argument for a wide title bar. This causes the title bar
        ! to extend across the full width of the frame in a manner which is more consistent with
        ! graphical frames (which always use a full frame-width title bar)
        !e.g. CALL IFrameTitle(10,10,40,12,'CLW','Title in the Frame')
        !Character Graphics INTERACTER Subroutine Reference
        !1-26
    end subroutine

    subroutine IFrameTitleBox(IXLEFT,IYTOP,IXRGHT,IYBOT,ACTION,TITLE)
        integer IXLEFT ! Left column of box
        integer IYTOP ! Top row of box
        integer IXRGHT ! Right column of box
        integer IYBOT ! Bottom row of box
        character(len=*) ACTION ! String describing required action :
        ! = 'C' : Clear frame contents ) any combination
        ! = 'L' : Left justify title ) in upper or
        ! = 'R' : Right justify title ) lower case
        character(len=*) TITLE ! Heading for top of frame
        ! Short-name : FRAME2
        ! Prints a frame around an area of the screen, with a title string printed at the top of the
        ! frame in a box of its own. The title string can be printed at the left, right or centre (the
        ! default). Strings which are too wide are truncated. Otherwise, as for IFrame.
        ! Unlike IFrameTitle, the top frame edge, the title and the frame line under the title
        ! each occupy a separate text row. When 2D graphical frame styles are in use, the
        ! appearance of a frame drawn using IFrameTitleBox is similar to that drawn by
        ! IFrameTitle, except that there is more space around the title string. When 3D
        ! graphical frames are enabled, frames drawn via IFrameTitleBox look better than
        ! the IFrameTitle equivalents.
        !e.g. CALL IFrameTitleBox(10,10,40,12,'CL','Title in a Box')
    end subroutine

    subroutine IFrameType(ITYPE)
        integer ITYPE ! Frame type :
        ! SingleLine1 (1) : Single line (#1)
        ! DoubleLine1 (2) : Double lines
        ! SingleLine2 (3) : Single line (#2)
        ! DropShadow (4) : Drop Shadow
        ! Field3D1 (5) : 3D style best suited to field frames
        ! Field3D2 (6) : Same as (5) but thicker
        ! Button3D1 (7) : 3D style best suited to buttons
        ! Button3D2 (8) : Same as (7) but exchanged colours
        ! Window3D1 (9) : 3D style best suited to windows
        ! Window3D2 (10): Same as (9) but thicker
        ! Short-name : FRTYPE
        ! Include : intercg.inc, interat.inc
        ! Selects the frame type drawn by IFrame and other routines in this group.
        ! IFrameType also updates the box-drawing characters returned by ISpecialChar.
        !All INTERACTER routines which use frame drawing routines (e.g. IWinOpen,IMenuVertic, InRealXY, etc.) will automatically use the selected frame type.
        !The precise effect of calling this routine depends on the current frame drawing method:
        !INTERACTER Subroutine Reference Character Graphics
        !1-27
        !(1) Box-character frames :
        !Single line frame characters are used by default (type 1). All odd numbered
        !frame types use single line frame characters. Even numbered frame types select
        !double line frame characters, where available (see Portability notes). Screens
        !which only support single line frame characters ignore the frame type selection.
        !(2) Graphical frames :
        !All frame types are selectable on displays which draw graphical frames. The
        !effect of selecting each type is as follows :
        !1 : Frame is drawn at the outer edge of the single character-cell border area. If
        !the area within the frame is cleared, the border character area is also cleared.
        !2 : The same as frame type 1, but a second line is drawn part way into the
        !border character area, giving a slightly more pleasing effect.
        !3 : The frame is drawn at the inner edge of the single character-width border
        !area. Only the area within this frame line is cleared. This leaves all but one
        !pixel of the frame border area visible. When used with a menu, the menu bar
        !will thus extend to meet the frame border.
        !4 : As for frame type 3 except that a drop shadow appears within the frame
        !border area to the right and below the frame, in the same colour as the frame.
        !5 : A 3D-effect frame is drawn at the inner edge of the single character-cell
        !border area, using different colours for the top/left and bottom/right edges. This
        !frame is well suited to individual field frames in data entry forms.
        !6 : As for type 5 but slightly thicker.
        !7 : A 3D-effect frame is drawn at the inner edge of the single character-cell
        !border area, as for type 5, plus a single-colour/single-pixel border around the
        !edge of the 3D effect. This frame is well suited to button field frames in forms.
        !The form editor implements special 'button-down' highlighting when the mouse
        !is clicked on a push-button with this frame type.
        !8 : As for type 7 but the colours used for the 3D part of the frame are exchanged
        !(the single pixel border colour remains the same).
        !9 : A 3D-effect frame is drawn at the outer edge of the single character-cell
        !border area, using different colours for the top/left and bottom/right edges. This
        !frame is well suited to window and menu frames, leaving a slight space between
        !the 3D effect border at characters printed at the edge of the window/menu.
        !10 : As for type 9 but slightly thicker.
        !The colours used to print/draw the selected frame type are determined by the current
        !text colours set by ITextColour/ITextColourN. Optionally, separate frame
        !colours can be set via IFrameOptions(6/7,n).
        !The currently selected frame type and box-char/graphical frame availability can be
        !interrogated via InfoFrame in the IF group.
        !e.g. CALL IFrameType(10)
        !CALL IFrameOptions(6,15)
        !CALL IFrameOptions(7,0)
        !CALL IWinOpen(0,0,40,10)
        !Character Graphics INTERACTER Subroutine Reference
        !1-28
        !Portability notes :
        !DOS :
        !Double line frame characters are fully supported.
        !MS Windows :
        !Double line frame characters are supported in text screen mode.
        !Xlib :
        !Double line frame characters are only supported if a PC compatible font has been
        !explicitly requested in the initialisation file.
        !Terminals :
        !Double line frame characters are supported only on displays which use a PC compatible
        !character set. Relatively few terminals do so in practice. See chapter 18 of the User
        !Guide.
    end subroutine

    subroutine IHorizLine(IXLEFT,IY,IXRGHT)
        integer IXLEFT ! Left hand end of line
        integer IY ! Row
        integer IXRGHT ! Right hand end of line
        ! Short-name : HOLINE
        ! Prints a horizontal line from text co-ordinate (IXLEFT,IY) to (IXRGHT,IY). Unlike
        ! ISplitFrameH, no 'tees' are printed.
        !e.g. CALL IOutStringXY(30,6,'This is in the top half of the screen')
        !CALL IHorizLine(1,12,80)
        !CALL IOutStringXY(30,18,'and this is in the bottom half')
    end subroutine

    CHARACTER*1 function ISpecialChar(NUMBER) result(res)
        integer NUMBER ! Number of special character to be returned (1-23)
        ! CornerTopRight (1) ChrPlusMinus (12)
        ! CornerTopLeft (2) ChrLessEqual (13)
        ! CornerBottomRight (3) ChrGreaterEqual (14)
        ! CornerBottomLeft (4) ChrNotEqual (15)
        ! IntersectionRight (5) ChrPi (16)
        ! IntersectionLeft (6) ChrDegree (17)
        ! IntersectionTop (7) ChrFilledBlock (18)
        ! IntersectionBottom (8) ChrUpArrow (19)
        ! IntersectionMiddle (9) ChrDownArrow (20)
        ! LineHorizontal (10) ChrRightArrow (21)
        ! LineVertical (11) ChrLeftArrow (22)
        ! ChrBullet (23)
        ! Short-name : SPCHAR
        ! Include : intercg.inc
        ! INTERACTER Subroutine Reference Character Graphics
        ! 1-29
        ! Returns a special character, in a similar manner to the standard Fortran CHAR function.
        ! To use the returned character, ICharGraphics should be called to enable character
        ! graphics and the current screen mode will need to support character graphics.
        ! Symbols 1 to 11 are useful for any frame or diagram drawing applications not otherwise
        ! covered by the existing routines in the CG group. Symbols 12 upwards provide various
        ! useful non-alphanumeric symbols.
        ! On screens which draw graphical frames, the availability of special characters is display
        ! dependent. Graphical frames were introduced to free INTERACTER from its reliance on
        ! character sets which provide such characters. In practice they are available in graphics
        ! mode on the majority of currently supported displays, the major exception being
        ! Windows.
        ! Note that ISpecialChar must be declared as CHARACTER*1 in your calling
        ! program.
        !e.g. CHARACTER*1 LESSEQ,ISpecialChar
        !:
        !LESSEQ = ISpecialChar(13)
        !CALL IOutStringXY(10,5,'X > Y')
        !IF (X.LE.Y) THEN
        !CALL ICharGraphics('ON')
        !CALL IOutStringXY(12,5,LESSEQ)
        !CALL ICharGraphics('OFF')
        !ENDIF
        !Portability notes :
        !MS Windows :
        !Box-drawing characters are only available in text mode. Special characters are only
        !fully available in text mode. In graphics mode, characters 12, 17 and 23 are available
        !and the arrow symbols are represented by ^ v < > characters.
        !Xlib :
        !The arrow symbols are normally represented using the ^ v < > characters under X,unless a PC compatible font has been explicitly requested in the initialisation file. In
        !the latter case, the same arrow characters are available as under DOS.
        !Terminals :
        !The arrow symbols are represented on most displays using the ^ V < > characters. The
        !non-box drawing symbols are not supported by many non-VT terminals (e.g. Falco
        !terminals in Falco text mode, Prime PT250). Block graphics characters are used on a
        !Prime PT250 as a substitute for true box-drawing characters.
        !Character Graphics INTERACTER Subroutine Reference
        !1-30
    
        res = ""
    end function

    subroutine ISplitFrameH(IXLEFT,IY,IXRGHT)
        integer IXLEFT ! Left hand end of line
        integer IY ! Row
        integer IXRGHT ! Right hand end of line
        ! Short-name : HSPLIT
        ! Prints a horizontal line from text co-ordinate (IXLEFT,IY) to (IXRGHT,IY). Where
        ! box-characters are used, a 'tee' is printed at either end of the line to split a frame drawn
        ! using IFrame, IFrameTitle or IFrameTitleBox.
        !e.g. CALL IFrame(10,10,70,20,' ')
        !CALL ISplitFrameH(10,15,70)
        !CALL IOutStringXY(30,12,'This is in the top half')
        !CALL IOutStringXY(30,17,'This is in the bottom half')
    end subroutine

    subroutine ISplitFrameV(IX,IYTOP,IYBOT)
        integer IX ! Column
        integer IYTOP ! Top row of line
        integer IYBOT ! Bottom row of line
        ! Short-name : VSPLIT
        ! Prints a vertical line from text co-ordinate (IX,IYTOP) to (IX,IYBOT). Where boxcharacters
        ! are used, a 'tee' is printed at either end of the line to split a frame drawn
        ! using IFrame, IFrameTitle or IFrameTitleBox.
        ! Note that IFrameOptions(3,n) may need to be called if the frame to be split is
        ! not the most recent frame to have been drawn and graphical frames are in use.
        !e.g. CALL IFrame(10,10,70,20,' ')
        !CALL ISplitFrameV(40,10,20)
        !CALL IOutStringXY(15,15,'LEFT HALF')
        !CALL IOutStringXY(45,15,'RIGHT HALF')
    end subroutine

    subroutine IVerticLine(IX,IYTOP,IYBOT)
        integer IX ! Column
        integer IYTOP ! Top row of line
        integer IYBOT ! Bottom row of line
        ! Short-name : VELINE
        ! Prints a vertical line from text co-ordinate (IX,IYTOP) to (IX,IYBOT). Unlike
        ! ISplitFrameV, no 'tees' are printed.
        !e.g. CALL IOutStringXY(15,15,'LEFT HALF')
        !CALL IVerticLine(40,1,20)
        !CALL IOutStringXY(45,15,'RIGHT HALF')
        !INTERACTER Subroutine Reference Text Window manager
        !1-31
        !1.6 Group WN : Window Manager
        !This group provides a useful set of routines which allow text output to be restricted to
        !certain areas of the screen. Several windows can be defined at once, though only one is
        !selected at any one time. You 'open' windows using IWinOpen. The precise effect of
        !opening a window is controlled by IWinAction, which determines whether the area
        !defined by the window is to be framed and/or cleared, and whether the pop-up feature
        !is to be used.
        !Every time you open a window, it becomes the 'currently selected window'. All the
        !other windowing routines then operate on that window. Logically, windows are
        !'stacked' Last In First Out, though they need not physically lie on top of one another on
        !screen. The most recently opened window is referred to as the 'top' window. Open,Move and Close operations all apply to this top window only. All other operations
        !apply to the currently selected window, which need not necessarily be the top one
        !(though as explained above, opening a new window makes that the 'current' window by
        !default). IWinSelect, IWinSelectInter or IWinSelectXY can be used to
        !select between the open windows. This is of most use when your windows have been
        !laid out in a tiled (i.e. non-overlapping) manner.
        !Various operations re-select the top or current window :
        !  If IWinClose is called to close the top window, the window management system
        !has no further knowledge of that window. The previously opened window (if any)
        !becomes the top window.
        !  If IWinOpen is called again, the newly defined window becomes the 'current' and
        !'top' window. The position and attributes of the previous window are held in the
        !stack. The previous window can be reselected as the current window by calling
        !IWinSelect/IWinSelectXY or as the top window by calling IWinClose.
        !The maximum number of windows which can be managed is 20.
        !An important feature of the window management system is the 'pop-up' facility. This
        !causes INTERACTER to copy the current screen contents before opening the window,enabling them to be restored later when it is closed. This enables windows to appear on
        !screen rather like pieces of paper, which can be 'lifted' to reveal what was there before.
        !Windows can even overlap in this case, so one window can be laid on top of another,on top of another and so on. As each one is closed, the contents of the one 'underneath'
        !will reappear. This is particularly useful for instant 'help' windows, dialog boxes, etc.
        !When writing to a window, scrolling is normally disabled. However, a window can
        !either be scrolled explicitly (using IWinScroll) or teletype-style scrolling can be
        !simulated using IWinOutCRLFScroll. The browsing and editing routines
        !(IWinBrowseText, IWinBrowseFile and IWinEditFile) use scrolling
        !automatically .
        !The colours and attributes of all text output via the window management routines are
        !normally determined by the most recent calls to the routines in the AT group (i.e.
        !ITextColour, etc.). However, it is possible to override the default text colours and
        !attributes using embedded tags. These can be used to temporarily change the
        !appearance of window text in mid-string. The tag highlighting feature is
        !enabled/disabled by IWinTagChar.
        !Text Window manager INTERACTER Subroutine Reference
        !1-32
        !Most of the facilities of the window management system can be used in graphics mode
        !on Tektronix or ReGIS compatible terminals. However, the availability of features such
        !as scrolling, window-clearing and pop-ups will be display dependent on such terminals.
        !See the routine-specific Portability notes and chapter 18 in the User Guide.
    end subroutine

    subroutine IWinAction(ACTION)
        character(len=*) ACTION ! String describing action when opening a new window.
        ! If it contains any of the following characters (upper
        ! or lower case), the specified actions are taken :
        ! = 'F' : Draw a frame round the window using either
        ! IFrame or IFrameTitle
        ! = 'B' : Draw a frame round the window using
        ! IFrameTitleBox
        ! = 'C' : Clear the window
        ! = 'P' : Select 'pop-up' mode (i.e. Copy existing
        ! screen contents before opening window)
        ! = 'W': Wide titles in character graphics frames
        ! (graphical frame titles are always wide)
        ! = 'L' : Left justify title
        ! = 'R' : Right justify title
        ! Short-name : WNACTN
        ! Controls the action to be taken when IWinOpen, IWinOpenInter or
        ! IWinOpenTitle opens a new window. The values set by a call to IWinAction
        ! remain in effect until another call to IWinAction.
        ! If ACTION contains an 'F', windows will be framed using IFrame or
        ! IFrameTitle. Alternatively, specify a 'B' for a window with the title in a separate
        ! box, as drawn by IFrameTitleBox. The 'F' and 'B' options are mutually exclusive.
        ! If both are specified, 'F' takes priority.
        ! If a 'C' is specified, the window area will be cleared to the current background colour.
        ! If 'pop-up' mode is selected, the screen area 'under' the window will be copied before
        ! opening the window, enabling the old window contents to be restored when it is closed.
        ! Whilst 'pop-up' mode is enabled, the number of windows which can be opened is
        ! limited by the size of the internal buffer into which the old screen contents are copied.
        ! This buffer will hold the equivalent of 15,000 characters of screen text. i.e. The total
        ! size (including frames) of all simultaneously open pop-up windows cannot exceed
        ! 15,000 characters. To check the remaining space in this buffer, call InfoWindow. Not
        ! all displays are able to restore graphics data if a window pop-up is used in a graphics
        ! mode. Use InfoGrScreen to test this feature.
        ! Specify a 'W' if your programs will run on displays which use character graphics to
        !draw window frames (e.g. DOS text mode, character terminals, etc.) and full-window
        !width title bars are required. Graphical frames always use full width titles. If 'W' is
        !omitted from ACTION, titles in character graphics frames are only as wide as their
        !passed length. Using the 'W' option ensures consistency of behaviour between screens
        !which use each type of frame.
        !The action codes 'L' and 'R' can be used to specify the position of titles supplied to
        !IWinOpenTitle. By default titles are centred.
        !INTERACTER Subroutine Reference Text Window manager
        !1-33
        !The window management system derives much of its flexibility from this routine, since
        !it also enables the window control facilities (e.g. IWinScroll which scrolls a
        !window) to be applied to text which is already on screen, by omitting C from the
        !ACTION argument. When the window system is initialised, frames are 'on', pop-up is
        !'off', clearing is 'on' and all titles are wide.
        !e.g. CALL IWinOpen(20,2,30,3)
        !CALL IWinOutStringXY(2,2,'Cleared window with a frame')
        !CALL IWinAction('pc')
        !CALL IWinOpen(40,12,30,3)
        !CALL IWinOutStringXY(2,2,'Pop-up window with no frame')
        !Portability notes :
        !DOS :
        !Windows can pop-up over both text and graphics. To pop-up over graphics, relatively
        !large amounts of screen data must be buffered. Graphics screen data is buffered to
        !memory. Video data is compressed to minimise the memory overhead of this operation.
        !A 400k pop-up buffer is built into the library for this purpose. Under rare conditions,this buffer may fill. Graphics data is then buffered to a temporary disk file. The default
        !name of this disk file is C:\INTTEMPW.$$$. As for other default filenames, this can
        !be overridden using an initialisation file keyword, TEMPWINDOW. If an alternative
        !window buffer file name is specified, it must include a full drive and pathname
        !specification. e.g.
        !TEMPWINDOW = d:\tmp\window.buf
        !Xlib and MS Windows :
        !Graphics mode window areas are saved and restored via bit-images. If an expose/resize
        !event occurs between the opening and closing of a pop-up window, the underlying
        !graphics area will not be restored. It is up to the calling program to process such an
        !event and repaint the whole of the program window.
        !ReGIS :
        !In ReGIS graphics mode on a VT240/VT340 type terminal, pop-up windows restore
        !underlying text screen data but not graphics. Otherwise, window actions are fully
        !supported.
        !Tektronix :
        !Full window actions are only supported on displays which support independent
        !text/graphics output (e.g. xterm, Tek 410x/420x, EM4105, Tera Term Pro). On other
        !Tek type screens, window clearing requires support for solid rectangle fills, whilst popups
        !of any sort are not supported.
        !Text Window manager INTERACTER Subroutine Reference
        !1-34
    end subroutine

    subroutine IWinBrowseFile(FNAME,LRSTEP,IPOS,USRBUT)
        character(len=*) FNAME ! Name of ASCII text file to browse
        integer LRSTEP ! Left/right step size in columns
        ! (zero to suppress left/right scrolling)
        integer IPOS ! Position in file :
        ! Entry : Start browsing from this record
        ! Exit : Final position on exit
        character(len=*) USRBUT ! User-defined buttons (equivalent to exit codes 26-30)
        ! (Max 25 characters, 5 per button. Not used if blank)
        ! Short-name : WNFILE
        ! Displays the contents of the file FNAME in the current window, allowing the user to
        ! browse freely through the file using the control keys listed in the table. When the user
        ! has finished browsing, pressing any of the standard INTERACTER 'exit' keys will
        ! terminate the browser. A message line is also displayed at the top of the window,consisting of a series of 'buttons' which can be selected by mouse users. User-definable
        ! buttons can be added to this message line.
        ! See InControlKey for details of the actual keys assigned to the control keys for
        ! which an 'InControlKey key number' is listed. Note that several extra keys are also
        ! recognised in addition to the normal 'control' keys. Most of these correspond to the
        ! initial letters of the options displayed in the message line at the top of the window.
        ! Mouse users can click on these options for the same effect. The control key used to exit
        ! from the browser is available in the normal way via InfoInput(55).
        ! LRSTEP controls the amount by which the left/right cursor keys scroll across the text
        ! array. Typically this would be 5-10, but can be set to 0 to suppress sideways scrolling.
        ! IPOS defines the starting position within the file from which browsing will begin. This
        ! specifies the record which will appear initially at the top of the window. IPOS is
        ! actually an input/output argument (and must therefore be a variable). It returns the final
        ! position within the file on exit from IWinBrowseFile. As on entry, this specifies
        ! the record number of the line at the top of the window.
        ! Where a frame has been drawn around the current window, border controls are printed
        ! on the frame to indicate the directions in which the window can scroll. These are
        ! updated according to the current position within the file. The colour of these border
        ! controls is determined by IFrameOptions(6,n). This can be independent of the
        ! currently selected text colour, if required. When this routine is used on a display which
        ! draws graphical frames it is also advisable to temporarily set frame option number 1 to
        ! 2, before opening a window for browsing. Certain types of window frame will then be
        ! drawn with an area set aside for border controls to the right and below the frame. In
        ! general, this option should be reset to zero when not required.
        ! Where a mouse is available, the user can click on the border controls to scroll the
        ! window. The action of the browser is then determined by the current mouse 'feel'
        ! setting, determined by InMouseOptions(3,n) :
        ! INTERACTER Subroutine Reference Text Window manager
        ! 1-35
        ! (a) If a Windows-like feel is selected (the default), holding down a mouse button over
        ! a border control simulates the corresponding cursor key. This action will autorepeat
        ! until a button is released. Moving the mouse cursor off the border control
        ! stops scrolling, but moving the cursor back onto the control without releasing the
        ! mouse button resumes scrolling.
        ! (b) If the older 'select on button down' feel is enabled, mouse button clicks simulate the
        ! action of the U/D keys and the cursor left/right keys. Auto-repeat does not occur in
        ! this case.
        ! Additionally, InMouseOptions(101,n) can be called to allow a specific mouse
        ! button to generate extreme movement when clicked on border controls. In the latter
        ! case, mouse button clicks simulate the action of control keys 9-12.
        ! Mouse button presses elsewhere on the frame or within the window are ignored, except
        ! on the message line. The behaviour of the browser when a button is pressed outside the
        ! window is controlled by InMouseOptions(2,n). By default, a click outside the
        ! window rings the bell but does not exit.
        ! If the browser is used in graphics mode in a windowing environment and a
        ! resize/expose occurs, the browser will exit with InfoInput(55) set to 259.
        ! Similarly, a close-window request will cause the browser to exit with
        ! InfoInput(55) set to 260.
        ! The message line at the top of the window is displayed using the attributes selected by
        ! the InHighlight routine. The same attributes are used to highlight a string found by
        ! the Find/Next options. By default, the option selection characters on the message line
        ! are highlighted (see InSelectionChars and InHighlightChar).
        ! The contents of the window (i.e. the file being browsed) are displayed in the current
        ! text colours/attributes as set by the routines in AT group, unless tag processing is
        ! enabled (see IWinTagChar). In this case, the file can contain embedded tag strings
        ! which highlight strings within the file. Note that the end of each line resets the current
        ! colours to the default (i.e. an end of line is treated like tag 0).
        ! The string search option is case insensitive. The search operates forwards through the
        ! file and wraps at the end of the file (in the same manner as 'vi' under Unix). The most
        ! recently entered search string is available on exit via InfoWinString(1).
        ! Up to five user-buttons of 5 characters each can be added to the message line if
        ! required, associated with control keys 26-30. For example, an argument of
        ! 'PrintEdit' would define two user buttons. The USRBUT string must be non-blank
        ! and the appropriate control key values (26, 27, etc.) must have non-zero values for this
        ! option to have an effect. Mouse users can then click on the user-button to exit and
        ! keyboard users can press the key associated with control key 26/27/etc. for the same
        ! effect. Since keystrokes are rolled to upper case in the browser, setting control keys
        ! 26/etc. to the upper case initial letter of the string in USRBUT allows single key
        !selection of the program specified button. e.g. If USRBUT is set to 'PrintEdit',setting control keys 26 and 27 to ICHAR('P') and ICHAR('E') would allow the
        !user to press the P or E keys to exit from the browser. User buttons appear on the
        !message line after 'Goto' and before 'Help'/'Quit'.
        !The control keys used by IWinBrowseFile are as follows :
        !Text Window manager INTERACTER Subroutine Reference
        !1-36
        !InControlKey Key Function
        !key number
        !1 Cursor up Up one line
        !2 Cursor down Down one line
        !3 Cursor right Right by LRSTEP columns
        !4 Cursor left Left by LRSTEP columns
        !5 Page Up Up one window-full
        !6 Page Down Down one window-full
        !9 Extreme up Top of file
        !10 Extreme down Bottom of file
        !11 Extreme right Position to far right
        !12 Extreme left Position to column 1
        !15 Move to start Top of file
        !16 Move to end Bottom of file
        !35 Next (space bar) Down one window-full
        !21-30 Exit keys Exit from IWinBrowseFile
        !36-70 Exit keys Exit from IWinBrowseFile
        !- U or Alt/U Up half a window full
        !- D or Alt/D Down half a window full
        !- T or Alt/T Top of file
        !- B or Alt/B Bottom of file
        !- F, Alt/F or / Find a text string
        !- N or Alt/N Find next occurrence of string
        !- G or Alt/G Goto line number
        !- H or Alt/H Help
        !- Q or Alt/Q Quit
        !A built-in help screen which describes the available control keys can be displayed by
        !pressing the 'help' key (control key 22, usually set to F1) or by pressing 'H'. Mouse
        !users can click on the 'Help' button. The internal help screen can be suppressed by
        !setting control key 22 to zero, in which case the 'Help' button does not appear.
        !The minimum window width is 60 columns with one user-button or 54 without. Using
        !all 5 user buttons requires a window width of 84 characters. If the internal help screen
        !is used, the window must be at least 15 rows deep. File records of up to 255 characters
        !can be displayed, by means of left/right scrolling.
        !Fortran I/O is used to access the file (i.e. OPEN, READ, BACKSPACE, REWIND and
        !CLOSE). No buffering is performed on data read from the file, minimising data space
        !requirements. Where supported by the current compiler, the file is opened in read-only
        !mode.
        !If no window is currently open IWinBrowseFile takes no action and exits. If the
        !file does not exist or cannot be opened, error codes are returned via
        !InfoError(1/2).
        !Internally, IWinBrowseFile makes use of IWinScroll. Refer to the Portability
        !notes for that routine for the implications of using scrolling on certain types of display.
        !See also IWinBrowseText, which performs the equivalent operation on a text array.
        !INTERACTER Subroutine Reference Text Window manager
        !1-37
        !e.g. CALL IWinAction('FPC')
        !CALL IFrameType(3)
        !CALL IFrameOptions(1,2)
        !CALL IWinOpen(0,0,60,20)
        !IPOS = 1
        !CALL InControlKey(26,ICHAR('H'))
        !100 CALL IWinBrowseFile('results.dat',10,IPOS,'Help')
        !IF (InfoInput(55).EQ.26) THEN
        !CALL MYHELP
        !GOTO 100
        !ENDIF
        !CALL IWinClose(1)
        !CALL IFrameOptions(1,0)
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error reading from file
    end subroutine

    subroutine IWinBrowseText(TEXT,NLINES,LRSTEP,IPOS,USRBUT)
        integer NLINES ! Number of elements in TEXT array
        character(len=*) TEXT(NLINES) ! Array of text strings to browse
        integer LRSTEP ! Left/right step size in columns
        ! (zero to suppress left/right scrolling)
        integer IPOS ! Position in text array :
        ! Entry : Start browsing from this position
        ! Exit : Final position on exit
        character(len=*) USRBUT ! User-defined buttons. Not used if blank.
        ! (equivalent to exit codes 26-30)
        ! (Max 25 characters, 5 per button)
        ! Short-name : WNBRWS
        ! Displays the contents of the TEXT array in the current window, allowing the user to
        ! browse through the text in the same manner as described under IWinBrowseFile
        ! later in this chapter. The only differences from IWinBrowseFile are :
        ! a) Text is displayed directly from the TEXT array rather than from a file.
        ! b) IPOS refers to an array subscript rather than a file record number. Unlike
        ! IWinBrowseFile, it can be negative on entry to indicate that the initial text
        ! already exists in the window and that browsing will start from IABS(IPOS). This
        ! feature is similar to the negative ISTOPT option used by the MN group menu
        ! routines and can be used to minimise screen repainting when re-entering the
        ! browser. Like IWinBrowseFile, IPOS must be a variable, since it also returns
        ! the final text position on exit.
        ! c) File input/output errors cannot occur.
        ! d) Text record width is determined by the passed length of TEXT().
        ! Text Window manager INTERACTER Subroutine Reference
        ! 1-38
        !e.g. CHARACTER*60 TEXT(1000)
        !OPEN(20,FILE='results.dat',STATUS='OLD')
        !DO 100 I = 1,1000
        !READ(20,'(A)',END=200) TEXT(I)
        !NLINE = I
        !100 CONTINUE
        !200 CLOSE(20)
        !C Create a pop-up window to browse text in
        !CALL IWinAction('FPC')
        !CALL IWinOpen(0,0,40,20)
        !IPOS = 1
        !CALL IWinBrowseText(TEXT,NLINE,10,IPOS,' ')
        !CALL IWinClose(1)

!        character(len=NLINES*len(text)) joinedText
!
!        integer i
!        integer :: pos = 1
!        type(TextViewerHandle) textViewer;
!        type(Fields), pointer :: this
!        this => this_
!        
!        pos = 1
!        do i = 1, NLINES
!            joinedText(pos:pos+len_trim(text(i))) = text(i)
!            pos = pos + len_trim(text(i))
!            joinedText(pos:pos) = char(10) !Line Feed
!            pos = pos + 1
!        end do
!        
!        textViewer = TextViewer_new(0, str(this%caption))
!        
!        call setText(textViewer, joinedText)
!        call show(textViewer)
!
!        call free(textViewer)
!
    end subroutine

    subroutine IWinClear
        ! Short-name : WNCLR
        ! Clears the whole of the currently selected window. If a frame was requested for the
        ! window, this is left unaffected. The cursor is left at the top left corner of the window.
        ! The cleared window will be in colour or reverse video if previously selected by
        ! ITextColour/ITextColourN or ITextReverse.
        !e.g. CALL IWinOpen(10,2,30,3)
        !CALL IWinOutStringXY(1,1,'Here is some help info ...')
        !CALL IWinOutStringXY(1,3,'Press SPACE to continue >')
        !10 CALL InKeyEvent(KEY)
        !IF (CHAR(KEY).NE.' ') GOTO 10
        !CALL IWinClear
        !CALL IWinOutStringXY(1,1,'And here is some more help')
        !Portability notes :
        !Tektronix :
        !Window clearing in graphics mode requires a display with independent text/graphics
        !output (e.g. xterm, Tek 4107, EM4105, Tera Term) or support for solid rectangle fills.
    end subroutine

    subroutine IWinClearArea(IXTOPL,IYTOPL,IXBOTR,IYBOTR)
        integer IXTOPL ! Top left window column of area to clear
        integer IYTOPL ! Top left window row of area to clear
        integer IXBOTR ! Bottom right window column of area to clear
        integer IYBOTR ! Bottom right window row of area to clear
        ! Short-name : WNCLAR
        ! Clears an area of the currently selected window, defined by the top left and bottom
        ! right window co-ordinates (IXTOPL,IYTOPL) & (IXBOTR,IYBOTR), leaving the
        ! cursor at (IXTOPL,IYTOPL). The cleared area will be in colour or reverse video if
        ! previously selected by ITextColour/ITextColourN or ITextReverse.
        !e.g. CALL ITextColour('W','BLUE')
        !NROW = 10
        !CALL IWinOpen(10,2,30,NROW)
        !C clear bottom half of window to cyan
        !CALL ITextColour(' ','CYAN')
        !CALL IWinClearArea(1,NROW/2+1,30,NROW)
        !Portability notes :
        !See IWinClear
        !INTERACTER Subroutine Reference Text Window manager
        !1-39
    end subroutine

    subroutine IWinClearLine(IY)
        integer IY ! Window row to clear
        ! Short-name : WNCLLI
        ! Clears a line of the currently selected window, leaving the cursor at the start of the
        ! specified window line. The cleared line will be in colour or reverse video if previously
        ! selected by ITextColour/ITextColourN or ITextReverse.
        !e.g. CALL ITextColour('W','G')
        !NROW = 10
        !CALL IWinOpen(10,2,30,NROW)
        !C clear bottom line of window in different colour
        !CALL ITextColour(' ','BLUE')
        !CALL IWinClearLine(NROW)
        !Portability notes :
        !See IWinClear
    end subroutine

    subroutine IWinClose(ICONTE)
        integer ICONTE ! Controls what happens to window contents :
        ! = 0 : Leave contents exactly as they are
        ! <> 0 : Restore previous contents (if pop-up mode was on
        ! when the window was opened) or clear window.
        ! Short-name : WNCLOS
        ! Closes the top window, regardless of which window is currently selected for output. If
        ! pop-up mode was on when the window was first opened, the old screen contents can be
        ! restored as if the window had never been there. The next window down the stack (if
        ! any) now becomes the top window again. If the closed window was the current
        ! window, the top window also becomes the current window, otherwise the current
        ! window remains unchanged.
        ! If the current window is not the top window and it must be closed, all the windows
        ! 'above' it in the stack must also be closed.
        !e.g. CALL IWinAction('PFC')
        !CALL IWinOpen(10,2,30,3)
        !CALL IWinOutStringXY(1,1,'Here is some help info ...')
        !CALL IWinOutStringXY(1,3,'Press SPACE to continue >')
        !10 CALL InKeyEvent(KEY)
        !IF (KEY.NE.ICHAR(' ')) GOTO 10
        !CALL IWinClose(1)
        !Portability notes :
        !DOS :
        !If created, the file containing the graphics screen buffer must still be accessible to the
        !application program. (See IWinAction)
        !Tektronix :
        !Full window actions in graphics mode are supported on displays which support
        !independent text/graphics output (e.g. xterm, Tek 410x/420x, EM4105, Tera Term
        !Pro). On other Tek type screens, window clearing requires support for solid rectangle
        !fills and pop-ups are not supported.
        !ReGIS :
        !Only underlying text screen data is restored in ReGIS graphics mode.
        !Text Window manager INTERACTER Subroutine Reference
        !1-40
    end subroutine

    subroutine IWinCursorHome
        ! Short-name : WNHOME
        ! Moves the cursor to the 'home' position (top left corner) in the current window.
        !e.g. CALL IWinCursorHome
        !C is equivalent to ..
        !CALL IWinCursorXY(1,1)
    end subroutine

    subroutine IWinCursorXY(IX,IY)
        integer IX ! Column in current window
        integer IY ! Row in current window
        ! Short-name : WNCUXY
        ! Moves the cursor to the specified (x,y) position within the current window. Remember
        ! that in this context (1,1) is the top left corner of the window.
        !e.g. CALL ICursorXY(5,5)
        !CALL IOutString('This is at (5,5)')
        !CALL IWinOpen(11,11,20,10)
        !CALL IWinCursorXY(5,5)
        !CALL IOutString('But this is at (15,15)')
    end subroutine

    subroutine IWinEditFile(FNAME,LRSTEP,IPOS,USRBUT,INIT,TBUFF,MAXLINE)
        character(len=*) FNAME ! Name of ASCII text file to edit
        integer LRSTEP ! Left/right step size in columns
        ! (zero to suppress left/right scrolling)
        integer IPOS ! Position in file :
        ! Entry : Start editing from this record
        ! Exit : Current edit line on exit
        character(len=*) USRBUT ! User-defined buttons (equivalent to exit codes 26-30)
        ! (Max 25 characters, 5 per button. Not used if blank)
        integer INIT ! Initialise editor & load the file from disk
        ! 1 : Initialise editor and load file
        ! 0 : Don't initialise editor or load file
        ! -1 : Initialise editor, but don't load file
        character(len=*) TBUFF(:) ! Text buffer to hold edited file
        integer MAXLINE ! Size of text buffer in lines
        ! Edits the file FNAME in the current window. Behaviour is similar to the window-based
        ! file browser, IWinBrowseFile. The contents of the file FNAME is displayed in the
        ! current window and can be edited. Whilst the editor does not emulate a specific editor,it is closer to editors such as EDIT (DOS) or EDT (VMS) than vi (Unix) for example.
        ! The end of the file is marked [End of File] using the highlight colours specified by
        ! InHighLight. If InsertOverMessage has been called then the appropriate
        ! prompt for insert/overtype mode will be displayed. A cursor is displayed at the current
        ! edit position, in the style set by InCursorType. This can be moved using the normal
        ! cursor and extended movement keys. It can also be placed at a specific position via the
        ! mouse.
        ! INTERACTER Subroutine Reference Text Window manager
        ! 1-41
        ! A message line is also displayed at the top of the window, consisting of a series of
        ! 'buttons' which can be selected by mouse users. The message line also serves as a
        ! reminder of available commands for keyboard users. User-definable buttons can be
        ! added to this message line, in the same way as for the browsers. This message line also
        ! displays the current cursor position within the file. Up to 999999 lines and 999
        ! columns are allowed for. The message line is displayed in the attributes selected by
        ! InHighlight.
        ! LRSTEP controls the amount by which the window scrolls and the cursor moves when
        ! the extended cursor left/right keys are used. This also applies to the left/right border
        ! controls. Typical values would be 5 to 10.
        ! IPOS determines the line number at which the cursor is initially displayed and also
        ! returns the current edit line number on exit. IPOS must therefore always be a variable.
        ! Typically, when re-entering the editor to continue editing an already loaded file, IPOS
        ! would be left with its previous return value (though this is not obligatory).
        ! Up to five user-buttons of 5 characters each can be added to the message line if
        ! required, associated with control keys 26-30. For example, an argument of
        ! 'PrintList' would define two user buttons. The USRBUT string must be non-blank
        ! and the appropriate control key values (26, 27, etc.) must have non-zero values for this
        ! option to have an effect. Mouse users can then click on the user-button to exit and
        ! keyboard users can press the key associated with control key 26/27/etc. for the same
        ! effect. Setting control keys 26/etc. to the upper case initial letters of the menu items in
        !USRBUT allows single key selection of the program specified button. e.g. If USRBUT is
        !set to 'PrintList', setting control keys 26 and 27 to ICHAR('P') and
        !ICHAR('L') would allow the user to press Alt/P (or Ctrl/P) and Alt/L (or Ctrl/L) to
        !exit from the browser. User buttons appear on the message line after 'Goto' and before
        !'Help'/'Quit'.
        !INIT indicates whether the editor should be initialised and whether the specified file
        !should be loaded from disk:
        !INIT=1 will be the normal setting, initialising the editor and loading the file.
        !INIT=0 allows processing of resize/expose events in a GUI environment. If such an
        !event occurs during editing, the routine exits with InfoInput(55) set to 259. In this
        !case, regenerate the screen as normal, then call IWinEditFile with INIT set to 0.
        !This reuses the existing editor state and buffer contents.
        !INIT=-1 allows the editor to be initialised but without loading the specified file. This
        !allows the caller to initialise or modify the contents of TBUFF directly. To take
        !advantage of this feature, note that CHAR(0) (null) is used to indicate the end of the
        !significant part of each line. The same mechanism is used on exit from the routine. This
        !allows significant (i.e. entered) trailing blanks to be identified. Note that these nulls are
        !not saved when the file is written to disk. IWinEditText provides an alternative
        !calling interface which provides the same functionality, but also suppresses the 'Save.
        !facility.
        !If a close-window request is received while editing (see InEventSelect(7,n)),the editor will terminate and InfoInput(55) will return 260.
        !Text Window manager INTERACTER Subroutine Reference
        !1-42
        !TBUFF is a character array of MAXLINE elements. It is used as a memory buffer in
        !which to edit the file. This avoids INTERACTER having to impose a fixed size limit on
        !file size and allows the calling program to use dynamic allocation under a Fortran 90
        !compiler. The maximum enterable line length is determined by the length of each
        !element of the array. The maximum number of lines that can be entered is determined
        !by MAXLINE. Error code 56 will be set if an attempt is made to edit or create a file with
        !more lines.
        !The maximum line length which can be edited is determined by the definition of the
        !TBUFF array, subject to an internal limit of 999 characters.
        !Where a frame has been drawn around the window, border controls are printed on the
        !frame to indicate the directions in which the window can scroll. These behave in a
        !similar way to IWinBrowseFile and IWinEditFile, except that the left/right
        !controls simulate extended left/right (scrolling by the amount set by LRSTEP).
        !Selecting the Save option invokes IdFilename allowing the user to select a new file
        !name and/or directory for the saved file. This has two consequences :
        !  Because IdFilename uses the Forms Manager any current form definition will
        !be lost. Be sure to save and reload your form definition across editor calls (using
        !IFormSave/IFormLoad), if you wish to maintain a form in this situation.
        !  The IdFilename form is invoked in pop-up mode. The editor therefore requires a
        !screen which supports pop-ups. In practice this just affects certain serial terminal
        !types running in graphics mode. Mostly these are not suitable for running an editor
        !anyway, so this does not represent a major limitation in practice.
        !A block copy/cut/paste/delete facility is provided, via control keys 71-74. Press the
        !Mark key (usually Ctrl/K) to mark the start of a block. Subsequent cursor movement
        !will cause the area between the marked position and the current cursor position to be
        !highlighted using the attributes specified by InHighlight. Available operations are:
        !  Press either Copy (usually Ctrl/C or Ctrl/D) or Cut (usually Ctrl/X) to copy the
        !marked text block to a block-text buffer (max size approx 32k). The Cut key also
        !removes the marked text from the main editor buffer.
        !  Press Backspace or Delete to remove the marked block, without copying it to the
        !block-text buffer.
        !  Press Paste (usually Ctrl/V) at any time to paste the contents of the block-text
        !buffer into the main editor buffer at the current position.
        !  Block marking mode can be cancelled by pressing any non-movement key.
        !INTERACTER Subroutine Reference Text Window manager
        !1-43
        !The control keys used by IWinEditFile are as follows :
        !InControlKey Key Function
        !key number
        !1 Cursor up Move the cursor up one line.
        !2 Cursor down Move the cursor down one line
        !3 Cursor right Move the cursor right one character
        !Wraps at end of line.
        !4 Cursor left Move the cursor left one character
        !Wraps at start of line.
        !5 Page Up Up one window-full
        !6 Page Down Down one window-full
        !7 Extended right Right by LRSTEP columns
        !8 Extended left Left by LRSTEP columns
        !9 Extreme up Top of file
        !10 Extreme down Bottom of file
        !15 Move to start Start of line
        !16 Move to end End of line
        !17 Toggle insert Switches between insert and overtype
        !18 Backspace cursor Deletes character to left of cursor
        !or currently highlighted block
        !20 Delete under cursor Deletes the character under the cursor
        !or currently highlighted block
        !21 Confirm Insert line break
        !22 Help Display help screen
        !23 Quit Terminate editor
        !24 Tab Insert spaces to next 8-column tab stop
        !34 Menu toggle Indicate that the next character is a
        !selection from the displayed buttons,not a character to be entered into the file.
        !71 Mark Mark start of a block of text
        !72 Copy Copy a block of text
        !73 Cut Cut a block of text
        !74 Paste Paste a block of text
        !- Alt/T or Ctrl/T Top of file ) Press "menu toggle"
        !- Alt/B or Ctrl/B Bottom of file ) key (usually F2)
        !- Alt/F or Ctrl/F Find a text string ) followed by menu
        !- Alt/N or Ctrl/N Find a string ) item initial letter
        !- Alt/G or Ctrl/G Goto line number ) for same effect on
        !- Alt/S or Ctrl/S Save file ) serial terminals
        !- Alt/H or Ctrl/H Help ) if Alt or Ctrl
        !- Alt/Q or Ctrl/Q Quit ) not available.
        !Selecting Help brings up a brief summary of the main editor control keys, in a similar
        !manner to the browser routines.
        !The string search option is case insensitive. The search operates forwards through the
        !file and wraps at the end of the file (in the same manner as 'vi' under Unix). The most
        !recently entered search string is available on exit via InfoWinString(1).
        !Text Window manager INTERACTER Subroutine Reference
        !1-44
        !If Quit is selected, or the 'quit' key (usually Escape) is pressed, the file is not
        !automatically saved. Instead, InfoWindow(18) can be interrogated to determine
        !whether the file has been saved since the last change.
        !e.g. PARAMETER (NLINES = 1000)
        !CHARACTER*80 FILENAME
        !CHARACTER*80 TBUFFER(NLINES)
        !:
        !C Open window for editor
        !5 CALL IWinOpenTitle(0,0,78,20,'Editing File '//FILENAME')
        !C Call Editor - Start edit on 1st line of file
        !C Load from file
        !C No user buttons
        !10 IPOS = 1
        !LOAD = 1
        !CALL IWinEditFile(FILENAME,5,IPOS,' ',LOAD,TBUFFER,NLINES)
        !C Resize/Expose? - Re-enter editor
        !IF (InfoInput(55).EQ.259) THEN
        !CALL IWinClose(1)
        !CALL IClearScreen
        !LOAD = 0
        !GOTO 5
        !ENDIF
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error reading from file
        !ErrEditBuffSize (56) : Text buffer too small
    end subroutine

    subroutine IWinEditText(LRSTEP,IPOS,USRBUT,INIT,TBUFF,MAXLINE)
        integer LRSTEP ! Left/right step size in columns
        ! (zero to suppress left/right scrolling)
        integer IPOS ! Position in file :
        ! Entry : Start editing from this record
        ! Exit : Current edit line on exit
        character(len=*) USRBUT ! User-defined buttons (equivalent to exit codes 26-30)
        ! (Max 25 characters, 5 per button. Not used if blank)
        integer INIT ! Initialise editor (0=no, -1/1=yes)
        character(len=*) TBUFF(:) ! Text buffer holding the editor text
        integer MAXLINE ! Size of text buffer in lines
        ! Edits the character array held in TBUFF, using the same editor as IWinEditFile.
        ! The only difference from that routine is that the text is always passed in/out via TBUFF
        ! and no Save option is available.
        ! See IWinEditFile for more details of the behaviour of the editor.
        ! INTERACTER Subroutine Reference Text Window manager
        ! 1-45
    end subroutine

    subroutine IWinMove(IXTOPL,IYTOPL)
        integer IXTOPL ! Top left column of new window position
        integer IYTOPL ! Top left row of new window position
        ! Short-name : WNMOVE
        ! Moves the top window, including its contents and frame area, to a new position, such
        ! that (IXTOPL,IYTOPL) becomes the new top left co-ordinate of the window. As for
        ! IWinOpen, (IXTOPL,IYTOPL) specifies the top corner of the text area of the
        ! window itself. Remember that if the window has a frame this will lie just outside the
        ! window area.
        ! The effect on the screen area which the window currently occupies is determined by the
        ! pop-up mode (as set by IWinAction) which was in operation when the window was
        ! opened by IWinOpen. If pop-up was on (i.e. the screen was copied) the old screen
        ! contents will be restored at the current position and the screen contents at the new
        ! position will be copied. Hence in this case the window continues to 'overlay' the screen
        ! and IWinMove is analagous to moving a piece of paper on a desk. If pop-up was off
        ! (i.e. the screen was not copied) the screen area at the old window position will simply
        ! be cleared before redisplaying the window at the new position.
        ! On most systems, only text which lies within the window will be moved. However, see
        ! the Portability notes.
        ! If the new window position would lie partly off-screen, it is adjusted so as to ensure
        ! that the whole of the window fits on screen.
        ! The colour or other highlights used in the window will be maintained when it appears
        ! at its new position.
        !e.g. CALL IWinOpen(10,2,30,2)
        !CALL IWinOutCentre(1,'Get ready to move ...')
        !CALL InKeyEvent(KEY)
        !CALL IWinMove(30,6)
        !CALL IWinOutCentre(2,'And here we are ..')
        !Errors :
        !ErrWinOffScreen (17) : Window destination partly or wholly off-screen.
        !(Destination co-ordinates adjusted accordingly.)
        !Portability notes :
        !DOS :
        !When used in a graphics mode, both text and graphics which lie within the window will
        !be moved.
        !Xlib and MS Windows :
        !When used in a graphics mode, both text and graphics which lie within the program
        !window will be moved.
        !Tektronix :
        !Window moving in graphics mode requires a display with independent text/graphics
        !output (e.g. xterm, Tek 410x/420x, EM4105, Tera Term Pro). Only text within the
        !window is moved.
        !ReGIS :
        !Only text within the window will be moved.
        !Text Window manager INTERACTER Subroutine Reference
        !1-46
    end subroutine

    subroutine IWinMoveInter
        ! Short-name : WNMOVI
        ! Moves the top window, interactively, to a new position.
        ! TIN (Text INput) mode is used to drag a frame from the top window position to a new
        ! location. IWinMove is then called to move the window and to update the old window
        ! position as appropriate. The new window position is available via InfoWindow. See
        ! ITextInputBox (which is used with action mode 2) and IWinMove for more
        ! information. The 'current' window selection is unaffected by this operation.
        ! If the user presses the 'quit' key/button, no action is taken. The exit key/event can be
        ! interrogated using InfoInput(55) in the usual way.
        !e.g. CALL IWinOpen(10,2,40,2)
        !CALL IWinOutCentre(1,'Drag window to a new position..')
        !CALL IWinMoveInter
        !IF (InfoWindow(4).EQ.10.AND.INFOWN(5).EQ.2)
        !1 CALL IWinOutCentre(2,'Window not moved !')
    end subroutine

    subroutine IWinOpen(IXTOPL,IYTOPL,IWIDTH,IHEIGH)
        integer IXTOPL ! Top left column of window (= 0 : centre horizontally)
        integer IYTOPL ! Top left row of window (= 0 : centre vertically)
        integer IWIDTH ! Width of window
        integer IHEIGH ! Height of window
        ! Short-name : WNOPEN
        ! Opens a new window. This becomes both the top and the current window. The position
        ! of the previously opened window (if any) is not lost, so that window can be returned to
        ! when the current window is closed or reselected as the current window by calling
        ! IWinSelect.
        ! The precise action when opening the window is determined by a previous call to
        ! IWinAction :
        !   If a frame is required, it is drawn just outside the area specified, using IFrame.
        ! Hence, the actual screen area occupied by the window plus a frame will be one
        ! character larger on all sides. The frame style is determined by IFrameType and
        ! IFrameOptions.
        !   If pop-up mode has been selected, the contents of the area defined by this window
        ! (including any frame) will be copied into an internal buffer, so that they can be
        ! restored later by IWinClose. Windows can thus be overlaid on the screen rather
        ! like pieces of paper on a desk.
        !   If the window is to be cleared, this is done after a copy operation, to ensure that the
        ! original screen contents are correctly restored.
        ! Selecting reverse video or a background colour before calling IWinOpen (using
        ! ITextReverse or ITextColour) sets the initial colour in which the window is
        ! printed/cleared. This is a useful technique for highlighting a newly opened window.
        ! INTERACTER Subroutine Reference Text Window manager
        ! 1-47
        ! The window can be centred horizontally and/or vertically by specifying zero IXTOPL
        ! and/or IYTOPL values. Similarly the window can be forced to appear at the far right or
        !bottom of the screen by specifying a large IXTOPL or IYTOPL value (e.g. 999), since
        !the position of the window is automatically adjusted if it would lie wholly or partly offscreen.
        !This is particularly useful when a program must be able to run on screens with
        !differing dimensions. These positioning conventions are shared with the menu and
        !input box routines in the OM/MN/IN groups.
        !If the specified window size (including frame) is too large to fit on the screen, the
        !window width and/or height is reduced accordingly.
        !As an alternative, windows can also be opened under keyboard/mouse control using
        !IWinOpenInter or with a title using IWinOpenTitle.
        !e.g. CALL IScreenBackground(' ',' ')
        !CALL ITextColour('W','BLUE')
        !CALL IWinAction('FCP')
        !CALL IWinOpen(0,0,30,3)
        !CALL IWinOutStringXY(1,1,'Here is some help info ...')
        !CALL IWinOutStringXY(1,3,'Press SPACE to continue >')
        !10 CALL InKeyEvent(IKEY)
        !IF (IKEY.NE.ICHAR(' ')) GOTO 10
        !CALL IWinClose(1)
        !Errors :
        !ErrMaxWindow (7) : Maximum number of windows exceeded
        !ErrWinBuffer (8) : Window buffer space exceeded
        !ErrWinCoOrds (9) : Invalid window co-ordinates (e.g. negative
        !width/height)
    end subroutine

    subroutine IWinOpenInter(IXTOPL,IYTOPL,IWIDTH,IHEIGH)
        integer IXTOPL ! Top left column of window ) 0 to set top left
        integer IYTOPL ! Top left row of window ) corner interactively
        integer IWIDTH ! Initial width of window
        integer IHEIGH ! Initial height of window
        ! Short-name : WNOPNI
        ! Opens a new window interactively. This is identical to IWinOpen except that the user
        ! is able to select the size of the window under keyboard/mouse control.
        ! TIN (Text INput) mode is used to define the area of the screen to be opened as a
        ! window. If (IXTOPL,IYTOPL) specifies a non-zero screen co-ordinate, a frame is
        ! drawn around the initially defined window area, in just the same way as opening a
        ! normal window with frame mode on and clear mode off. The user can then 'rubberband'
        ! the window to the size required. The top left corner of the frame remains fixed
        ! while the current Text Input device (see ITextInputDevice) is used to move the
        ! bottom right corner to the desired position. The 'confirm' key/button is pressed to fix
        ! the window. IWinOpen is then called to open the window in the normal way.
        ! Alternatively, if IXTOPL is zero, the user can first place the top left corner of the
        ! window, using ITextInputXY, before continuing to mark the window area in the
        ! manner described above.
        ! Text Window manager INTERACTER Subroutine Reference
        ! 1-48
        ! If the height or width is less than 1, a default initial value of 1 is used. Similarly, if the
        ! initial window would extend beyond the window edge, the width or height is adjusted
        ! accordingly. In either case, no error is generated.
        ! If the quit key/button is pressed, no window is opened. The exit key can be interrogated
        ! using InfoInput in the usual way.
        ! See the TI group documentation for more information on TIN mode. Refer to
        ! IWinOpen for the precise effect of opening a new window. To check the final size of
        ! the window, call the InfoWindow information function.
        !e.g. IYLAST = InfoScreen(3)
        !CALL IOutStringXY(1,IYLAST,'Use cursor keys to fix window')
        !CALL IWinOpenInter(10,2,30,2)
        !LASTLN = InfoWindow(7)
        !CALL IWinOutCentre(LASTLN,'Last line of window !')
        !Errors :
        !ErrMaxWindow (7) : Maximum number of windows exceeded
        !ErrWinBuffer (8) : Window buffer space exceeded
        !ErrWinCoOrds (9) : Invalid window co-ordinates (e.g. negative
        !width/height)
    end subroutine

    subroutine IWinOpenTitle(IXTOPL,IYTOPL,IWIDTH,IHEIGH,TITLE)
        integer IXTOPL ! Top left column of window (= 0 : centre horizontally)
        integer IYTOPL ! Top left row of window (= 0 : centre vertically )
        integer IWIDTH ! Width of window
        integer IHEIGH ! Height of window
        character(len=*) TITLE ! Window heading
        ! Short-name : WNOPNT
        ! Opens a new window, with a title. The title will be printed within the top of the window
        ! frame, using IFrameTitle or IFrameTitleBox, if frames are currently selected.
        ! If frames have been disabled no title is printed. In all other respects this is exactly the
        ! same as IWinOpen (in fact, IWinOpenTitle is simply an alternative entry point to
        ! the IWinOpen routine). The position of the title (centred or left/right justified) can be
        ! specified using IWinAction. By default, titles are centred.
        !e.g. CALL IWinOpenTitle(10,2,30,3,'Help')
        !CALL IWinOutStringXY(1,1,'Here is some help info ...')
        !Errors :
        !ErrMaxWindow (7) : Maximum number of windows exceeded
        !ErrWinBuffer (8) : Window buffer space exceeded
        !ErrWinCoOrds (9) : Invalid window co-ordinates (e.g. negative width/height)
        !INTERACTER Subroutine Reference Text Window manager
        !1-49
    end subroutine

    subroutine IWinOutCentre(IY,STRING)
        integer IY ! Row in current window
        character(len=*) STRING ! String to write out
        ! Short-name : WNOUCE
        ! Outputs STRING to the current window, centred on the specified window line. This is
        ! the window management equivalent of IOutCentre. If IY is outside the window, the
        ! string is not written. If the string exceeds the width of the window, it is truncated.
        !e.g. CALL IWinOpen(20,10,40,11)
        !CALL IWinOutCentre(5,'Centre of window !')
        !Errors :
        !ErrStrTooWide (15) : String extends beyond width of window. String truncated.
        !Title for textviewer

!        type(Fields), pointer :: this
!        this => this_
!        call free(this%caption)
!        this%caption = STRING
    end subroutine

    subroutine IWinOutCRLF(NCRLF)
        integer NCRLF ! Number of carriage return/line feeds to output
        ! Short-name : WNOUCR
        ! Performs the specified number of carriage return/line feed operations in the current
        ! window, by placing the cursor on the start of the row which is NCRLF lines down from
        ! the current row. At least one carriage return/line feed is simulated. If the cursor would
        ! go beyond the last window row, the cursor is placed at the bottom left corner of the
        ! window. No scrolling is performed.
        ! This routine is useful following a call to one of the other IWinOutxxx routines, such
        ! as IWinOutString, to simulate the action of a Fortran WRITE. An NCRLF value of
        ! one puts the cursor at the start of the next window row, a value of 2 gives a blank line
        ! and so on. Specify a large value to quickly put the cursor at the bottom of the window
        ! without having to call InfoWindow to check the window size.
        !e.g. CALL IWinOutString('Here is a string')
        !CALL IWinOutCRLF(1)
        !CALL IWinOutString('And this is on the next row')
    end subroutine

    subroutine IWinOutCRLFScroll(NCRLF)
        integer NCRLF ! Number of carriage return/line feeds to output
        ! Short-name : WNOUCS
        ! Performs the specified number of carriage return/line feed operations in the current
        ! window, by placing the cursor on the start of the row which is NCRLF lines down from
        ! the current row, scrolling the window if necessary. At least one carriage return/line feed
        ! is simulated. If NCRLF would place the cursor beyond the last row, the window is
        ! scrolled by an approriate number of lines.
        ! This routine is useful following a call to one of the other IWinOutxxx routines, such
        ! as IWinOutString, to simulate the action of a Fortran WRITE. An NCRLF value of
        ! one puts the cursor at the start of the next window row, a value of 2 gives a blank line
        ! and so on. See also IWinOutCRLF.
        ! Text Window manager INTERACTER Subroutine Reference
        ! 1-50
        !e.g. CALL IWinOpen(5,5,40,10)
        !DO 100 IROW = 1,20
        !CALL IWinOutString('This is row number ')
        !CALL IWinOutInteger(IROW,3)
        !CALL IWinOutCRLFScroll(1)
        !100 CONTINUE
    end subroutine

    subroutine IWinOutDouble(DVALUE,FRMAT)
        double precision DVALUE ! Double precision value to output
        character(len=*) FRMAT ! Fortran format to be used (D, E, F or G format)
        ! Short-name : WNOUDB
        ! Outputs the supplied double precision value, using the specified Fortran format, to the
        ! current window at the current window cursor position. This is the window management
        ! equivalent of IOutDouble. If the value would extend beyond the right-hand column
        ! of the window it is written at the start of the next window line, unless the cursor is
        ! already at the beginning of the current window line. Output which would appear
        ! beyond the bottom of the window is not displayed. The format specification must be a
        !valid Fortran format enclosed in brackets, e.g. (F10.4), (D15.8), etc. The maximum
        !width of field in which DVALUE can be written is 100 characters.
        !The value will be right justified by default, but this is controllable via
        !IOutJustifyNum.
        !e.g. DOUBLE PRECISION DBL
        !DBL = 1.00000001
        !CALL IWinCursorXY(10,10)
        !CALL IWinOutDouble(DBL,'(F11.8)')
        !C the following has the same effect ...
        !CALL IWinOutStringXY(10,10,' 1.00000001')
    end subroutine

    subroutine IWinOutDoubleXY(IX,IY,DVALUE,FRMAT)
        integer IX ! Column in current window
        integer IY ! Row in current window
        double precision DVALUE ! Double precision value to output
        character(len=*) FRMAT ! Fortran format to be used (D, E, F or G format)
        ! Short-name : WNOUDX
        ! Outputs the supplied double precision value to the current window, starting at the
        ! specified window co-ordinate. This is the window management equivalent of
        ! IOutDoubleXY. It is also equivalent to calling IWinCursorXY and
        ! IWinOutDouble in succession.
        !e.g. DOUBLE PRECISION DVALUE
        !:
        !CALL IWinOpen(20,3,40,11)
        !CALL IWinOutStringXY(1,2,'Current value')
        !CALL IWinOutRealXY(20,2,DVALUE,'(D15.8)')
        !INTERACTER Subroutine Reference Text Window manager
        !1-51
    end subroutine

    subroutine IWinOutError(STRING)
        character(len=*) STRING ! String to output at bottom of window
        ! (blank to clear bottom line)
        ! Short-name : WNOUER
        ! Outputs a string (normally an error message) centred on the bottom line of the current
        ! window and rings the bell. The previous contents of the bottom window line are cleared
        ! before the message is output, so the message line will be set to the currently selected
        ! background colour. If the supplied string is blank, no string is output and the bottom
        ! window line is simply cleared. IWinOutError is the window management
        ! equivalent of IOutError.
        !e.g. IF (InfoError(1).GT.0)
        !1 CALL IWinOutError('Error on file open - file may not exist')
    end subroutine

    subroutine IWinOutInteger(IVALUE,IWIDTH)
        integer IVALUE ! Integer value to output
        integer IWIDTH ! Width of field in which IVALUE is to be output (<=100)
        ! Short-name : WNOUIN
        ! Outputs IVALUE to the current window at the current window cursor position. This is
        ! the window management equivalent of IOutInteger. If the value would extend
        ! beyond the right-hand column of the window it is written at the start of the next
        ! window line, unless the cursor is already at the beginning of the current window line.
        ! Output which would appear beyond the bottom of the window is not displayed. The
        ! value is right-justified in a field IWIDTH characters wide. The maximum width of field
        ! in which IVALUE can be written is 100 characters.
        ! The value will be right justified by default, but this is controllable via
        ! IOutJustifyNum.
        !e.g. CALL IWinCursorXY(10,10)
        !CALL IWinOutInteger(150,5)
        !C the following has the same effect ...
        !CALL IWinOutStringXY(10,10,' 150')
    end subroutine

    subroutine IWinOutIntegerXY(IX,IY,IVALUE,IWIDTH)
        integer IX ! Column in current window
        integer IY ! Row in current window
        integer IVALUE ! Integer value to output
        integer IWIDTH ! Width of field in which IVALUE is to be output (<=100)
        ! Short-name : WNOUIX
        ! Outputs IVALUE to the current window, starting at the specified window co-ordinate.
        ! This is the window management equivalent of IOutIntegerXY. It is also equivalent
        ! to calling IWinCursorXY and IWinOutInteger in succession.
        !e.g. CALL IWinOpen(20,3,40,11)
        !CALL IWinOutStringXY(1,2,'Current value')
        !CALL IWinOutIntegerXY(20,2,IVALUE,10)
        !Text Window manager INTERACTER Subroutine Reference
        !1-52
    end subroutine

    subroutine IWinOutMessage(STRING)
        character(len=*) STRING ! String to output at bottom of window
        ! (blank to clear bottom line)
        ! Short-name : WNOUME
        ! Outputs a message string centred on the bottom line of the current window. This is
        ! useful for providing prompts and other brief help information at a standard position in a
        ! window. The previous contents of the bottom window line are cleared before the
        ! message is output, so the message line will be set to the currently selected background
        ! colour. If the supplied string is blank, no string is output and the message line is simply
        ! cleared. IWinOutMessage is the window management equivalent of
        ! IOutMessage.
        !e.g. CALL IWinOutMessage(' Press any key to continue ')
        !CALL InKeyEvent(KEY)
    end subroutine

    subroutine IWinOutReal(RVALUE,FRMAT)
        real RVALUE ! Real value to output
        character(len=*) FRMAT ! Fortran format to be used (E, F or G format)
        ! Short-name : WNOURE
        ! Outputs the supplied real value, using the specified Fortran format, to the current
        ! window at the current window cursor position. This is the window management
        ! equivalent of IOutReal. If the value would extend beyond the right-hand column of
        ! the window it is written at the start of the next window line, unless the cursor is already
        ! at the beginning of the current window line. Output which would appear beyond the
        ! bottom of the window is not displayed. The format specification must be a valid Fortran
        !format enclosed in brackets, e.g. (F10.4), (E8.2), etc. The maximum width of field in
        !which RVALUE can be written is 100 characters.
        !The value will be right justified by default, but this is controllable via
        !IOutJustifyNum.
        !e.g. CALL IWinCursorXY(10,10)
        !CALL IWinOutReal(99.345,'(F6.2)')
        !C the following has the same effect ...
        !CALL IWinOutStringXY(10,10,' 99.34')
    end subroutine

    subroutine IWinOutRealXY(IX,IY,RVALUE,FRMAT)
        integer IX ! Column in current window
        integer IY ! Row in current window
        real RVALUE ! Real value to output
        character(len=*) FRMAT ! Fortran format to be used (E, F or G format)
        ! Short-name : WNOURX
        ! Outputs RVALUE to the current window, starting at the specified window co-ordinate.
        ! This is the window management equivalent of IOutRealXY. It is also equivalent to
        ! calling IWinCursorXY and IWinOutReal in succession.
        !e.g. CALL IWinOpen(20,3,40,11)
        !CALL IWinOutStringXY(1,2,'Current value')
        !CALL IWinOutRealXY(20,2,RVALUE,'(F10.2)')
        !INTERACTER Subroutine Reference Text Window manager
        !1-53
    end subroutine

    subroutine IWinOutString(STRING)
        character(len=*) STRING ! String to write out
        ! Short-name : WNOUST
        ! Outputs STRING at the current window cursor position. This is the window manager
        ! equivalent of IOutString. If the text would extend beyond the right-hand column of
        ! the window the text is wrapped according to the mode set by IWinWordWrap. Text
        ! which would appear beyond the bottom of the window is not displayed.
        ! By default, text is written in the current colours/attributes as set by the routines in the
        ! AT group. Optionally, substrings can be highlighted. See IWinTagChar for details.
        !e.g. CALL IWinOpen(20,10,40,10)
        !CALL IWinOutStringXY(2,3,'Here is some text ...')
        !CALL IWinOutString(' and this follows it.')
    end subroutine

    subroutine IWinOutStringXY(IX,IY,STRING)
        integer IX ! Column in current window
        integer IY ! Row in current window
        character(len=*) STRING ! String to write out
        ! Short-name : WNOUSX
        ! Outputs STRING to the current window, starting at the specified window co-ordinate.
        ! This is the window management equivalent of IOutStringXY. If the text would
        ! extend beyond the right-hand column of the window the text is written according to the
        ! mode set by IWinWordWrap. Text which would appear beyond the bottom of the
        ! window is not displayed.
        ! By default, text is written in the current colours/attributes as set by the routines in the
        ! AT group. Optionally, substrings can be highlighted. See IWinTagChar for details.
        !e.g. CALL IWinOpen(20,10,40,11)
        !CALL IWinOutStringXY(1,6,1 'This should appear halfway down the window')
    end subroutine

    subroutine IWinScroll(DIRECN,NUMBER)
        character(len=*) DIRECN ! String describing direction in which to scroll window
        ! = 'U' scroll up
        ! = 'D' scroll down
        ! = 'L' scroll left
        ! = 'R' scroll right
        integer NUMBER ! Number of rows or columns to scroll the window
        ! = 0 : Clear window
        ! Short-name : WNSCRL
        ! Scrolls the current window up, down, left or right by NUMBER rows or columns. The
        ! new rows or columns will be blank and in the current highlight/background colour.
        ! Text Window manager INTERACTER Subroutine Reference
        ! 1-54
        !e.g. CALL IWinOpen(20,10,40,10)
        !CALL IWinOutStringXY(1,5,'Cursor keys scroll the window')
        !CALL InKeyEvent(KEY)
        !IF (KEY.EQ.128) THEN
        !CALL IWinScroll('d',1)
        !ELSE IF (KEY.EQ.129) THEN
        !CALL IWinScroll('u',1)
        !ELSE IF (KEY.EQ.130) THEN
        !CALL IWinScroll('L',5)
        !ELSE IF (KEY.EQ.131) THEN
        !CALL IWinScroll('R',5)
        !ENDIF
        !Portability notes :
        !Xlib and MS Windows :
        !Scrolling is performed by means of a bit-block move. This will typically be much faster
        !on hardware which includes acceleration facilities.
        !Terminals :
        !Hardware scrolling is usually only available across the full width of the screen, so
        !IWinScroll normally uses a software scroll, i.e. all lines in the window are rewritten
        !at their new position. If the window occupies the full screen width, faster
        !hardware scrolling is used for vertical scrolling.
        !Tektronix :
        !Scrolling in graphics mode requires a display with independent text/graphics output
        !(e.g. xterm, Tek 410x/420x, EM4105, Tera Term Pro).
    end subroutine

    subroutine IWinSelect(NUMBER)
        integer NUMBER ! Number of window to be selected
        ! ( 1 =< NUMBER =< number of currently open windows)
        ! Short-name : WNSEL
        ! Selects the 'current' window by number. All window operations, with the exception of
        ! Open/Move/Close, will apply to the specified window.
        ! Whenever a window is opened, it is assigned a number corresponding to its position in
        ! the window 'stack'. The first window to be opened is thus number 1. If a second
        ! window is opened without closing the first that becomes number 2 and so on. Any
        ! window can be selected for output. By default, IWinOpen resets the 'current' window
        ! to the 'top' window.
        ! If an invalid window number is specified, the current window selection remains
        ! unchanged. InfoWindow can be called to check how many windows have been
        ! opened (i.e. the number of the 'top' window) and also the number of the 'current'
        ! window.
        !e.g. CALL IScreenOpen(' ','T',80,25,16)
        !CALL IWinOpen(2,2,78,8)
        !CALL IWinOpen(2,12,78,8)
        !CALL IWinSelect(1)
        !CALL IWinOutCentre(4,'This is in window 1')
        !CALL IWinSelect(2)
        !CALL IWinOutCentre(4,'This is in window 2')
        !INTERACTER Subroutine Reference Text Window manager
        !1-55
    end subroutine

    subroutine IWinSelectInter
        ! Selects the 'current' window interactively via the keyboard/mouse. The user just points
        ! to the required window and either clicks the mouse or presses return. That window is
        ! then selected for output, as though IWinSelect had been called. Pressing the help or
        ! quit key/button cancels the selection operation and exits. Internally,IWinSelectInter uses ITextInputXY, so the exit key used to terminate the
        ! routine is available via InfoInput(55) in the normal way.
        !e.g. CALL IWinSelectInter
        !IF (InfoInput(55).EQ.21) THEN
        !IWIN = InfoWindow(1)
    end subroutine

    subroutine IWinSelectXY(IX,IY)
        integer IX ! Screen column number
        integer IY ! Screen row number
        ! Short-name : WNSELX
        ! Selects the 'current' window by text screen co-ordinate. This routine performs exactly
        ! the same task as IWinSelect except that the window is identified by means of an
        ! (x,y) text position rather than a screen number. IWinSelectXY will select the most
        ! recently opened window in which (IX,IY) lies. If (IX,IY) does not lie in any open
        ! window, the current window selection remains unchanged.
        !e.g. CALL IWinOpen(2,2,78,8)
        !CALL IWinOpen(2,12,78,8)
        !CALL IOutMessage('Use mouse or cursor keys to select window')
        !IX = 5
        !IY = 5
        !CALL ITextInputXY(IX,IY)
        !CALL IWinSelectXY(IX,IY)
    end subroutine

    subroutine IWinTagChar(TAG)
        character(len=*) TAG ! Tag character (typically ~ or %. Blank to disable tag handling)
        ! Defines the character to be used to mark colour/attribute tags embedded in text window
        ! output strings. A 'tag' consists of this character followed by one of the following
        ! characters which specifies a particular colour or text attribute :
        ! A to P : Background colours 0-15 ) See ITextColourN
        ! a to p : Foreground colours 0-15 )
        ! 1 : Bold
        ! 2 : Flashing
        ! 3 : Italics
        ! 4 : Reverse video
        ! 5 : Underlining
        ! 0 : Restore current default colours/attributes
        ! Hence, if the tag character is set to %, the string %b would temporarily enable red as
        ! the foreground colour. These two-character tags can be embedded in text to be output
        ! via any of the routines in the WN group (including the browsers but excepting the
        !editor). Tags can be combined (e.g. %B%f) to set more than one colour or attribute.
        !To restore all the default colours/attributes use tag 0 (e.g. %0). This occurs
        !automatically at the end of an output operation, ensuring that currently selected colours
        !are not affected by embedded tags.
        !Text Window manager INTERACTER Subroutine Reference
        !1-56
        !If a tag character is selected which must also be output literally, just specify the tag
        !character twice in the output string. So if the tag character is %, then %% outputs a
        !single %.
        !To disable tag processing, set the tag character to a blank. This is the default state at
        !initialisation. The current tag character is available via InfoWindow(16).
        !e.g. CALL IWinTagChar('%')
        !CALL IWinOutString('This is %bred%0 and this is not.')
        !CALL IWinOutStringXY(5,5,'%1%5Bold and underlined')
        !CALL IWinTagChar(' ')
        !CALL IWinOutStringXY(5,8,'No tag processing so % appears OK')
    end subroutine

    subroutine IWinWordWrap(ONOFF)
        character(len=*) ONOFF ! 'ON' : Enable end-of-line word wrapping ) upper
        ! and split lines at word endings ) or
        ! = 'JU' : Same as 'ON' but justify text to right ) lower
        ! edge of window ) case
        ! = 'TR' : Disable end-of-line wrapping entirely )
        ! truncating strings at window edge )
        ! any other value : Enable line wrapping, but split at end of line,not at word ending, with no justification
        ! Short-name : WNWRAP
        ! Selects the manner in which text should be treated by IWinOutString and
        ! IWinOutStringXY when they must write beyond the right-hand column of a
        ! window.
        ! If word wrapping is switched on, text is 'formatted' so that it is split at the last nonblank
        ! before the window edge. Text is left justified, giving a 'ragged' right margin.
        ! If justified text is selected, lines are still split at word endings, but spaces within the
        ! output string are padded to align all word endings at the right edge of the window. This
        !gives a neater effect in informational windows (e.g. help windows). Justified text output
        !operates most effectively when a whole paragraph of text is output in a single call to
        !IWinOutString or IWinOutStringXY. This is the initial default state selected by
        !IScreenOpen.
        !If truncation is selected, text stops at the end of the first line on which it is printed and
        !text beyond the edge of the window is lost.
        !If none of the above options are selected, text wraps onto the next line when it reaches
        !the window edge in the same way as a conventional operating system command line.
        !e.g. CALL IWinOpen(25,10,25,10)
        !CALL IWinWordWrap('ON')
        !CALL IWinOutStringXY(1,1,'This should appear in the window with '
        !1 //'the text properly split at word endings '
        !2 //'so it is fully readable.')
        !CALL IWinWordWrap('OFF')
        !CALL IWinOutString(' However, this will very likely look untidy'
        !1 //' as word wrapping has been disabled.')
        !INTERACTER Subroutine Reference Output-only Menus
        !1-57
        !1.7 Group OM : Output-only Menus
        !The routines in this group display menus, without obtaining a selection from the user.
        !They directly complement the menu handling routines in the MN group. Each routine
        !in the OM group is an output-only equivalent of a menu function in the MN group.
        !These output-only routines will prove useful where it is necessary to generate a screen
        !display which is identical to that created by using the MN routines, but without
        !obtaining input.
        !Like the routines in the MN group, all menus are displayed using the text attributes
        !most recently selected by the routines in the AT group. Similarly the attributes used to
        !highlight the current option and any help strings are determined by InHighlight
        !and InHighlightHelp. Positioning logic is also the same as for the MN group.
        !Frame/border styles are determined by the IFrameType and IFrameOptions
        !routines in the CG group.
    end subroutine

    subroutine IOutMenuCycle(OPTION,MAXOPT,IXPOS,IYPOS,PROMPT,IFRAME,IHIOPT)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IXPOS ! Column at which menu item is to be displayed
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Row on which menu item is to be displayed
        ! (zero to centre the menu vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round menu, prompt to left (if specified)
        ! = 2 : Frame round menu, prompt above (if specified)
        integer IHIOPT ! Option to be displayed/highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! Displays a cycling menu, in exactly the same way as IMenuCycle.
        ! IHIOPT determines which option is displayed and highlighted in the menu.
        !e.g. CHARACTER*6 OPTION(3)
        !DATA OPTION/'Large ','Medium','Small '/
        !IXPOS = 20
        !IYPOS = 2
        !IFRAME = 1
        !CALL InHighlight(' ',' ')
        !CALL IOutMenuCycle(OPTION,3,IXPOS,IYPOS,'Size: ',IFRAME,1)
        !Output-only Menus INTERACTER Subroutine Reference
        !1-58
    end subroutine

    subroutine IOutMenuHoriz(OPTION,MAXOPT,IXPOS,IYPOS,IWIDTH,IBORDR,IHIOPT)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IXPOS ! Left hand column of menu
        integer IYPOS ! Top row of menu
        integer IWIDTH ! Width of menu
        integer IBORDR ! 1 : Print a line above menu only
        ! = 2 : Print a line below menu only
        ! = 3 : Print lines above and below menu
        ! = 4 : Print a frame around the menu
        ! = any other value for no border
        integer IHIOPT ! Number of option to highlight
        ! (none if <1 or >MAXOPT)
        ! Short-name : HOMENU
        ! Displays a horizontal menu, in exactly the same way as IMenuHoriz.
        ! Optionally, one of the options can be highlighted using the style defined by
        ! InHighlight. This can be useful where a 'currently selected option' needs to be
        ! displayed, in the same way as it would be in IMenuHoriz, but no input is required. If
        ! IHIOPT is zero, no option is highlighted. This argument is equivalent to ISTOPT
        ! when calling IMenuHoriz.
        !e.g. CHARACTER*8 OPTION(4)
        !DATA OPTION/'1 : Load','2 : Save','3 : Edit','4 : Quit'/
        !IX = 11
        !IY = 5
        !IWID = 60
        !IBRDR = 4
        !CALL IOutMenuHoriz(OPTION,4,IX,IY,IWID,IBRDR,0)
    end subroutine

    subroutine IOutMenuHorizHelp(OPTION,MAXOPT,IYPOS,HELP,IBORDR,IHIOPT)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IYPOS ! Row on which menu is to start being displayed
        ! (zero to centre the menu vertically)
        character(len=*) HELP(MAXOPT)
        ! = Array of help strings for each OPTION element
        integer IBORDR ! 1 : Print a line above menu only
        ! = 2 : Print a line below menu only
        ! = 3 : Print lines above and below menu
        ! = any other value for no border
        integer IHIOPT ! First option to be highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! Displays a horizontal help menu, in exactly the same way as IMenuHorizHelp.
        ! INTERACTER Subroutine Reference Output-only Menus
        ! 1-59
        !e.g. CHARACTER*4 OPTION(4)
        !CHARACTER*20 HELP(4)
        !DATA OPTION/'Help','Run ','Edit','Quit'/
        !HELP(1) = 'Display help text'
        !HELP(2) = 'Run data analysis'
        !HELP(3) = 'Modify data'
        !HELP(4) = 'Exit from program'
        !IOLDOP = 1
        !CALL InHighlight('BOLD','RED')
        !CALL IOutMenuHorizHelp(OPTION,4,1,HELP,2,IOLDOP)
    end subroutine

    subroutine IOutMenuScroll(OPTION,MAXOPT,IXPOS,IYPOS,TITLE,NVISIB,IFRAME,IHIOPT)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IXPOS ! Left column of menu
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Top row of menu
        ! (zero to centre the menu vertically)
        character(len=*) TITLE ! Menu heading (Blank for no heading)
        integer NVISIB ! Number of options which are to be visible in the
        ! scrolling menu area
        integer IFRAME ! 0 : for no frame to be drawn
        ! = 1 : draw a frame, placing title within top of frame
        ! if title is non-blank
        ! > 1 : draw a frame, placing title in a box at top of
        ! frame if title is non-blank
        integer IHIOPT ! First option to be highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! Displays a vertical scrolling menu, in exactly the same way as IMenuScroll.
        !e.g. CHARACTER*14 FILES(20)
        !C get a list of up to 20 filenames
        !NFILE = 20
        !CALL IOsDirList(' ',' ',FILES,NFILE)
        !IXPOS = 30
        !IYPOS = 5
        !IFRAME = 1
        !IHIOPT = 2
        !C only display 6 files in scrolling menu
        !NVISIB = 6
        !CALL InHighlight('CYA','BLA')
        !CALL IOutMenuScroll(FILES,NFILE,IXPOS,IYPOS,'File ?',NVISIB,1 IFRAME,IHIOPT)
        !Output-only Menus INTERACTER Subroutine Reference
        !1-60
    end subroutine

    subroutine IOutMenuTwo(OPT1,OPT2,IXPOS,IYPOS,PROMPT,IFRAME,IHIOPT)
        character(len=*) OPT1 ! First option
        character(len=*) OPT2 ! Second option
        integer IXPOS ! Menu column
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Menu row
        ! (zero to centre the menu vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round menu, prompt to left (if specified)
        ! = 2 : Frame round menu, prompt above (if specified)
        integer IHIOPT ! First option to be highlighted :
        ! = 1 : First option (default)
        ! = 2 : Second option
        ! Displays a two-option menu, in exactly the same way as IMenuTwo.
        !e.g. IXPOS = 20
        !IYPOS = 5
        !IFRAME = 1
        !CALL InHighlight('CYA','BLA')
        !CALL IOutMenuTwo('Cancel','Confirm',IXPOS,IYPOS,1 'Save :',IFRAME,1)
    end subroutine

    subroutine IOutMenuVertic(OPTION,MAXOPT,IXPOS,IYPOS,TITLE,ISPACE,IFRAME,IHIOPT)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IXPOS ! Left column of menu
        integer IYPOS ! Top row of menu
        character(len=*) TITLE ! Menu heading (Blank for no heading)
        integer ISPACE ! Menu line spacing (0=no spacing, 1=one line, etc.)
        integer IFRAME ! 0 : for no frame to be drawn
        ! = 1 : draw a frame, placing title within top of frame
        ! if title is non-blank
        ! > 1 : draw a frame, placing title in a box at top of
        ! frame if title is non-blank
        integer IHIOPT ! Number of option to highlight
        ! (none if <1 or >MAXOPT)
        ! Short-name : VEMENU
        ! Displays a vertical menu, in exactly the same way as IMenuVertic.
        ! Optionally, one of the options can be highlighted using the style defined by
        ! InHighlight. This can be useful where a 'currently selected option' needs to be
        ! displayed, in the same way as IMenuVertic. If IHIOPT is zero, no option is
        ! highlighted. This argument is equivalent to ISTOPT when calling IMenuVertic.
        ! INTERACTER Subroutine Reference Output-only Menus
        ! 1-61
        !e.g. CHARACTER*8 OPTION(4)
        !DATA OPTION/'1 : Load','2 : Save','3 : Edit','4 : Quit'/
        !IX = 11
        !IY = 1
        !ISPACE = 1
        !IFRAME = 2
        !CALL IOutMenuVertic(OPTION,4,IX,IY,'Menu',ISPACE,IFRAME,3)
    end subroutine

    subroutine IOutMenuVerticHelp(OPTION,MAXOPT,IXPOS,IYPOS,HELP,TITLE,ISPACE,IFRAME,IHIOPT)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IXPOS ! Left column of menu
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Top row of menu
        ! (zero to centre the menu vertically)
        character(len=*) HELP(MAXOPT)
        ! = Array of help strings for each OPTION element
        character(len=*) TITLE ! Menu heading (Blank for no heading)
        integer ISPACE ! Menu line spacing (0=no spacing, 1=one line, etc.)
        integer IFRAME ! 0 : for no frame to be drawn
        ! = 1 : draw a frame, placing title within top of frame
        ! if title is non-blank
        ! > 1 : draw a frame, placing title in a box at top of
        ! frame if title is non-blank
        integer IHIOPT ! First option to be highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! Displays a vertical help menu, in exactly the same way as IMenuVerticHelp.
        !e.g. CHARACTER*4 OPTION(3)
        !CHARACTER*21 HELP
        !OPTION(1) = 'Save'
        !OPTION(2) = 'Load'
        !OPTION(3) = 'Edit'
        !HELP(1) = 'Write data to disk'
        !HELP(2) = 'Read data from disk'
        !HELP(3) = 'Change current values'
        !IXPOS = 20
        !IYPOS = 5
        !ISPACE = 0
        !IFRAME = 1
        !CALL InHighlight('CYA','BLA')
        !CALL InHighlightHelp('WHI','RED')
        !CAKL IOutMenuVerticHelp(OPTION,3,IXPOS,IYPOS,HELP,1 'Menu',ISPACE,IFRAME,5)
        !Output-only Menus INTERACTER Subroutine Reference
        !1-62
    end subroutine

    subroutine IOutMenuYesNo(IXPOS,IYPOS,PROMPT,IFRAME,IHIOPT)
        integer IXPOS ! Column for Yes/No prompt
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Row for Yes/No prompt
        ! (zero to centre the menu vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame required
        ! <> 0 : Draw frame round Yes/No and prompt (if specified)
        integer IHIOPT ! First option to be highlighted :
        ! = 1 : Yes (default)
        ! = 2 : No
        ! Displays a yes/no menu, in exactly the same way as IMenuYesNo.
        !e.g. CALL InHighlight('RED','white')
        !CALL IOutMenuYesNo(10,10,'Having Fun ? ',1,1)
        !INTERACTER Subroutine Reference Keyboard/Mouse Event Handling
        !2-1
        !2. Input Handling : Subroutine Descriptions
        !2.1 Group KM : Keyboard/Mouse Event Handling
        !The routines in this group provide the most basic keyboard and mouse input event
        !handling functions. In particular, InKeyEvent performs single key input and can also
        !be used to report other input events such as those generated by a mouse, where
        !available. InKeyEvent is able to read a keystroke without waiting for Return/Enter to
        !be pressed and is able to identify non-printing (e.g. function) keys in a keyboard
        !independent manner. The alternative routine InKeyEventImm performs exactly the
        !same task, but in a non-blocking manner, i.e. it returns immediately if no keyboard or
        !mouse events are waiting. InKeyEventCursor also performs the same task as
        !InKeyEvent and simulates a cursor on displays with no hardware text cursor support.
        !Whilst InKeyEvent always reports keyboard events, the reporting of other events can
        !be selectively enabled or disabled using InEventSelect. Keyboard input can be
        !flushed from the input queue using InFlush.
        !For keyboard debugging purposes, direct access to system dependent keyboard codes is
        !also provided by means of the lower level InCharacter/InCharacterImm.
        !A single key yes/no confirmation function is also provided, called InYesNo.
    end subroutine

    subroutine InCharacter(ICHR)
        integer ICHR ! ASCII code returned from keyboard
        ! Short-name : INCHR
        ! Gets a single character from the keyboard queue. This routine will not return until a key
        ! has been pressed. When a normal printable ASCII character key (i.e. Space through
        ! tilde) is pressed, InCharacter returns a 7-bit integer ASCII code (i.e. 32-126). If a
        ! non-printing key is pressed, such keys often generate multi-byte sequences consisting
        ! of system/keyboard dependent codes. In this case these codes will be returned
        ! sequentially in consecutive calls to InCharacter.
        ! InCharacter should be viewed as providing 'raw' keyboard input. As such, it fails to
        ! identify function/keypad/cursor keys in a meaningful way. InCharacter should not
        ! normally be used, except for debugging/diagnostic purposes, when it may prove useful
        ! to identify the precise low-level codes being generated by the keyboard. Otherwise,InKeyEvent should be used instead.
        ! To return immediately if no key has been pressed, use InCharacterImm.
        ! Portability notes :
        ! DOS :
        ! Keyboard detection is via BIOS or DOS interrupts, as selected by InKeyVia. Where a
        ! standard ASCII key is detected, InCharacter only returns the ASCII code. If an
        ! extended key code is detected, two codes are returned in consecutive calls to
        ! InCharacter. 8-bit keycodes entered using Alt/keypad will be returned unmodified.
        ! Keyboard/Mouse Event Handling INTERACTER Subroutine Reference
        ! 2-2
        ! Xlib and MS Windows :
        ! Keyboard input requires that the program window must have the current focus. Codes
        ! returned by InCharacter are usually standard ASCII codes for printable characters.
        ! Other keys generate values which are only meaningful to INTERACTER.
        ! Terminals :
        ! On a serial terminal, function/keypad/cursor keys commonly return several characters
        ! with a single key press. Typically these sequences start with a value of 27 (ESC) or 155
        ! (CSI). The characters which make up these sequences are returned in consecutive calls
        ! to InCharacter. Eight bit keycodes, such as those generated using the VT200
        ! 'compose character' key, are returned without modification.
    end subroutine

    subroutine InCharacterImm(ICHR)
        integer ICHR ! ASCII code returned from keyboard
        ! (-999 if no key currently available)
        ! Short-name : INCHRI
        ! Like InCharacter, this routine gets a single character from the keyboard queue,except it returns immediately with a code of -999 if no key has been pressed.
        ! Otherwise, refer to InCharacter for more information. InCharacterImm should
        ! only be used for diagnostic purposes. InKeyEventImm is preferred.
    end subroutine

    subroutine InEventSelect(NEVENT,IEMASK)
        integer NEVENT ! Event types to enable/disable :
        ! AllEvents (0) : All events at once
        ! ButtonDown (1) : Mouse button-down events
        ! ButtonUp (2) : Mouse button-up events
        ! MouseMoveText (3) : Mouse movement events (text)
        ! MouseMoveGraph (4) : Mouse movement events (graphics)
        ! ResizeExpose (6) : Graphics mode
        ! expose/resize events
        ! CloseWindow (7) : Close-window requests
        integer IEMASK ! Event mask for all events or one event :
        ! If NEVENT > 0 then IEMASK = :
        ! IntNo (0) : Disable event specified by NEVENT
        ! IntYes (1) : Enable event specified by NEVENT
        ! If NEVENT = 0 then IEMASK = sum of :
        ! 1 : enable mouse button down events
        ! +2 : enable mouse button up events
        ! +4 : enable mouse movement events (text)
        ! +8 : enable mouse movement events (graphics)
        ! +32 : enable graphics mode expose/resize events
        ! +64 : enable close-window requests
        ! Short-name : INEVEN
        ! Include : interkm.inc, intergen.inc
        ! Specifies the non-keyboard events which will be reported by InKeyEvent.
        ! INTERACTER Subroutine Reference Keyboard/Mouse Event Handling
        ! 2-3
        ! Multiple events can be enabled and disabled in combination, in a single call by
        ! specifying NEVENT=0 and summing the relevant event mask values in IEMASK.
        ! Alternatively, single events can be switched on or off by specifying the appropriate
        ! event number in NEVENT and passing a binary flag in IEMASK.
        ! When reporting of any of the listed events is activated, InKeyEvent returns special
        ! codes when the requested events occur. For mouse events, the position of the mouse
        ! cursor is then available via InfoInput and/or InfoGraphics. Two demonstration
        ! programs on the distribution media (doodlet and doodleg) show how event
        ! selection can be used to perform low level mouse handling.
        ! Mouse button-down and expose/resize events are reported by default. Button-up and
        ! movement events should only be activated whilst they are required and disabled as soon
        ! as they are no longer needed. Reporting mouse movement events when not required can
        ! be highly inefficient in networked or multi-user environments (as under X Windows).
        ! The fixed field input, menu and form editor routines all disable button-up and
        ! movement events internally then restore the current event selection on exit.
        ! Mouse movement events can either be selected as 'text' or 'graphics' movement :
        ! (a) Text mouse movement events are available in both text and graphics screen modes
        ! and occur when the mouse crosses a text cell boundary.
        ! (b) Graphics mouse movement events are available in graphics screen mode only and
        ! occur when the mouse moves to a new pixel position.
        ! Both movement event types can be selected if required, though it will be more usual to
        ! only select one. Both types of movement event generate an InKeyEvent code of 257.
        ! To be able to detect mouse events, a mouse must be available (i.e.
        ! InfoHardware(13)>1). To be able to report mouse movement events,InfoHardware(8) and InfoHardware(9) must return values of 2.
        ! Event type 6 (graphics mode expose/resize) is used in a windowing environment to
        ! identify when the graphics window needs to be redrawn as a result of interaction with
        ! the window manager. When such an event occurs, INTERACTER's internal graphics
        ! dimensions are updated to match the window size automatically, so the calling program
        ! only need clear the window and regenerate the current graphic image as appropriate.
        ! The text dimensions of the window will also change when such an event occurs. If
        ! reporting of graphics window expose/resize events is disabled, INTERACTER's internal
        ! graphics dimensions will not be updated until the next mode change (i.e. at the next call
        ! to IGrInit/IScreenMode/IScreenModeN).
        ! Event type 7 is reportable under Microsoft Windows and X Windows. When the user
        ! attempts to close the program window using the border controls or Alt/F4, the
        ! application will terminate immediately by default. Enabling event type 7 allows the
        ! application to trap a close-window request, to allow confirmation to be sought or to
        ! allow program-specific close-down processing to be performed.
        ! When expose/resize events or close-window requests are enabled, input routines such
        ! as menus, window browsers, the form editor, etc. will automatically terminate when
        ! such an event occurs, returning an exit code of 259 or 260 respectively via
        ! InfoInput(55). These are the same codes as will be returned by InKeyEvent
        ! when the input queue is read directly.
        ! Keyboard/Mouse Event Handling INTERACTER Subroutine Reference
        ! 2-4
        ! The current event mask (equivalent to the value which would be passed in IEMASK
        ! when NEVENT=0) is available via InfoInput(66).
        !e.g. See doodlet and doodleg demos on distribution media
        !Portability notes :
        !DOS :
        !All four mouse event types are supported, provided a mouse is available.
        !Xlib and MS Windows :
        !All event types are supported.
        !Terminals :
        !Mouse button-down events are available under xterm and DECterm. Other events are
        !not supported.
    end subroutine

    subroutine InFlush
        ! Flushes any pending keys from the keyboard buffer. This can be useful to prevent the
        ! user from typing ahead before a 'press a key to continue' type of prompt.
        !e.g. CALL IOutMessage('Press any key to continue')
        !CALL InFlush
        !CALL InKeyEvent(KEY)
        !Portability notes :
        !Xlib and MS Windows :
        !Since all events are delivered in a single queue, InFlush will also clear pending
        !mouse events from the input queue. However, InFlush will stop flushing the input
        !buffer if a graphics window expose/resize event or a close-window request is
        !encountered, allowing these events to be processed by a subsequent call to
        !InKeyEvent or one of INTERACTER's other input handling routines.
    end subroutine

    subroutine InKeyEvent(ICODE)
        integer ICODE ! Keyboard or mouse event code :
        ! 32-126: 7-bit ASCII chars
        ! 384-511: 8-bit keyboard code (i.e. 256 + key code)
        ! 560-569: Alt/0 to Alt/9
        ! 577-602: Alt/A to Alt/Z
        ! or one of the specially assigned
        ! codes in the table that follows
        ! Short-name : INKEY
        ! Include : interkm.inc
        ! Gets the next event from the input queue. Under Fortran 90 compilers, ICODE has an
        ! OPTIONAL attribute when the INTERACTER module is USE'd.
        ! Keystroke events are always reported, providing portability to all display types. Mouse
        ! button-down events are also reported by default, where a mouse is known to be
        ! available. Other mouse events can optionally be reported, under the control of the
        ! InEventSelect routine. Expose/resize events are reported by default, in windowing
        ! environments.
        ! INTERACTER Subroutine Reference Keyboard/Mouse Event Handling
        ! 2-5
        ! ICODE Key/Event ICODE Key/Event
        ! KeyBackSpace 8 Backspace KeyDeleteUnder 143 Delete under cursor
        ! KeyTab 9 Tab KeyShiftTab 144 Shift/Tab
        ! KeyReturn 13 Return Keypad0 150 Keypad 0
        ! KeyEscape 27 Escape Keypad1 151 Keypad 1
        ! KeyDelete 127 Delete left Keypad2 152 Keypad 2
        ! KeyCursorUp 128 Cursor Up Keypad3 153 Keypad 3
        ! KeyCursorDown 129 Cursor Down Keypad4 154 Keypad 4
        ! KeyCursorRight 130 Cursor Right Keypad5 155 Keypad 5
        ! KeyCursorLeft 131 Cursor Left Keypad6 156 Keypad 6
        ! KeyPageUp 132 Page Up Keypad7 157 Keypad 7
        ! KeyPageDown 133 Page Down Keypad8 158 Keypad 8
        ! KeyPageRight 134 Page Right Keypad9 159 Keypad 9
        ! KeyPageLeft 135 Page Left KeypadMinus 160 Keypad -
        ! KeyUpExtreme 136 Extreme Up KeypadPoint 161 Keypad .
        ! KeyDownExtreme 137 Extreme Down KeypadPlus 162 Keypad +
        ! KeyRightExtreme 138 Extreme Right KeypadDivide 163 Keypad /
        ! KeyLeftExtreme 139 Extreme Left KeypadMultiply 164 Keypad *
        ! KeyHome 140 Home KeypadHash 165 Keypad #
        ! KeyEnd 141 End KeypadEnter 166 Keypad Enter
        ! KeyInsert 142 Insert KeyPrint 170 Print
        ! KeyF1 - KeyF20 171-190 F1 - F20
        ! KeyShiftF1 - KeyShiftF20 191-210 Shift/F1 - Shift/F20
        ! KeyCtrlF1 - KeyCtrlF20 211-230 Ctrl/F1 - Ctrl/F20
        ! KeyAltF1 - KeyAltF20 231-250 Alt/F1 - Alt/F20
        ! LeftButtonDown 251 Left mouse button down
        ! MiddleButtonDown 252 Middle mouse button down
        ! RightButtonDown 253 Right mouse button down
        ! LeftButtonUp 254 Left mouse button up
        ! MiddleButtonUp 255 Middle mouse button up
        ! RightButtonUp 256 Right mouse button up
        ! MouseMove 257 Mouse moved
        ! ResizeEvent 259 Graphics window exposed/resized
        ! CloseRequest 260 Close program window request
        ! KeyAltBackspace 520 Alt/Backspace
        ! KeyAltTab 521 Alt/Tab
        ! KeyAltReturn 525 Alt/Return
        ! KeyAltEscape 539 Alt/Escape
        ! At its simplest level, InKeyEvent is a single key input routine, performing the same
        ! function as InCharacter except also uniquely identifying cursor, keypad, function
        ! and editing keys. Its additional ability to report mouse button/movement events makes
        ! it suitable for low level input handling on a wide variety of displays from dumb
        ! terminals to mouse driven windowing environments. InKeyEvent is recommended as
        ! the lowest level of keyboard and mouse handling which should be used.
        ! Keyboard/Mouse Event Handling INTERACTER Subroutine Reference
        ! 2-6
        ! Ordinary printable keyboard characters are returned as 7-bit ASCII codes, i.e. as values
        ! in the range 32-126. Many keyboards are also able to generate system dependent 8-bit
        !characters (e.g. to generate international characters). Since these key codes are in the
        !range 128-255, they conflict with INTERACTER's system independent codes allocated
        !for function/cursor/keypad keys. InKeyEvent thus adds 256 to 8-bit keyboard codes
        !to differentiate them from the non-ASCII control keys. For example, under DOS the
        !UK pound sign generates the code 156 which is returned by InKeyEvent as an
        !ICODE value of 412 (i.e. 156 + 256 = 412).
        !Given the variability in keyboard layout and the codes generated by non-ASCII keys,InKeyEvent attempts to standardise the key codes reported for non-printable keys.
        !This task is easier said than done given the varying nature of keyboard designs. The
        !table describes the key code assignments by function for an 'ideal' keyboard. Only some
        !of these keys will be available on any one keyboard and the keytop legends will vary.
        !Chapter 19 in the User Guide lists the actual keys which are recognised on various
        !types of keyboard and describes some of the peculiarities of individual keyboards.
        !Some keyboards support keypad identification, but lack other dedicated special keys.
        !For example, the original 83-key IBM PC keyboard did not have separate cursor keys
        !and a VT100 keyboard has no Page Up/Page Down keys. On these types of keyboard
        !INTERACTER supports two different modes of keypad interpretation numbered 2 and
        !3. Mode 2 is designated as 'special key substitution' mode which causes the keypad to
        !return the same codes as the cursor keys, Page Up/Down, etc. i.e. codes 128-135 etc. In
        !keypad mode 3, the keypad keys return the codes listed in the table i.e. 150-166. Refer
        !to the InKeypad routine in the IP group for more information on keypad
        !interpretation selection. Chapter 19 in the User Guide also gives more details.
        !To detect the Escape key on most serial terminals, it must be pressed twice, enabling
        !INTERACTER to differentiate this key from the other special keys which mostly
        !generate code sequences beginning with a single escape character. When Escape is
        !pressed twice, INTERACTER returns a single code of 27. The exception to this is on
        !VT200/VT300/VT400 compatible terminals configured for 8-bit control codes. In the
        !latter case the DATABITS=8 keyword should be included in the INTERACTER
        !initialisation file to enable InKeyEvent to detect Escape using a single keystroke.
        !Where mouse input is available, InKeyEvent also reports mouse events. The
        !combination of events to be reported is controlled by InEventSelect. By default,mouse-button down events are reported but button-up and movement events are not. If
        !a mouse event is reported, the position of the mouse at the time of the event is available
        !via InfoInput(62)/(63). In graphics modes, the position may alternatively be
        !available in graphics co-ordinates via InfoGraphics(5)/(6). A time stamp is also
        !normally available for such mouse events, via InfoInput(70). See also
        !InfoOpSystem(15) which returns the system time in the same units.
        !In addition to keyboard and mouse events, InKeyEvent also reports two event types
        !which are specific to windowing environments :
        !  When the graphics window needs to be redrawn, as a result of interaction with the
        !user or other windows, ICODE returns 259. By default, expose/resize event
        !reporting is enabled, but see InEventSelect.
        !INTERACTER Subroutine Reference Keyboard/Mouse Event Handling
        !2-7
        !  If the user attempts to close the program window via a border control or Alt/F4
        !ICODE returns 260. Reporting of close-window requests must currently be enabled
        !via InEventSelect. Reporting of this event is disabled by default, causing
        !programs to terminate immediately on a close-window request.
        !e.g. CALL IOutStringXY(5,20,'Use cursor keys/RETURN to select option')
        !10 CALL IOutStringXY(5,10+IOPT,'-->')
        !CALL InKeyEvent(ICODE)
        !CALL IClearField(5,10+IOPT,3)
        !IF (ICODE.EQ.128.AND.IOPT.GT.1) IOPT = IOPT - 1
        !IF (ICODE.EQ.129.AND.IOPT.LT.5) IOPT = IOPT + 1
        !IF (ICODE.NE.13) GOTO 10
        !Portability notes :
        !See chapter 19 in the User Guide for details of supported keycodes on various
        !display/keyboard types.
        !MS Windows :
        !A few key combinations are not supported under Windows (see chapter 19 in the User
        !Guide), but all the non-keyboard event codes can be generated.
        !Xlib :
        !Virtually all of the key combinations assigned by InKeyEvent can be recognised by
        !the Xlib driver, but the availability of particular keys depends on the type of keyboard
        !attached to the workstation or X terminal being used. All of the non-keyboard event
        !codes can potentially be generated under X.
        !Tektronix :
        !In Tektronix 4010/4014 graphics mode, cursor/keypad/function keys cannot normally
        !be detected, so only the standard ASCII codes (1-127) are detectable. Notable
        !exceptions are Kermit, xterm and Tera Term Pro which return the same cursor key
        !codes as in VT100 mode. Note that on a Tektronix 4105/4107, the keys marked F1-F4
        !actually act as cursor keys and function keys F5-F8 act as function keys 1 to 4.
        !Terminals :
        !Mouse input is not normally available via InKeyEvent on serial terminals or under
        !serial terminal emulations. The main exceptions to this are xterm and DECterm which
        !can report button-down events, but not button-up or movement events.
!        type(Fields), pointer :: this
!        integer :: i = 0
!        this => this_
!
!        do while (this%icode == -999 .and. this%nextICode == -999)
!            if (i == 100) then
!                call stopDrawing(this)
!            else
!                i = i + 1
!            end if
!            call processEvents(this%canvasWindow)
!        end do
!        if (this%icode == -999) then 
!            this%icode = this%nextICode
!            this%nextICode = -999
!        end if
!        ICODE = this%icode
!        this%icode = this%nextICode
!        this%nextICode = -999
    end subroutine

    subroutine InKeyEventCursor(ICODE)
        integer ICODE ! Keyboard or mouse event code (See InKeyEvent)
        ! Short-name : INKEYC
        ! InKeyEventCursor performs the same function as InKeyEvent except that it
        ! will also display and remove a simulated text cursor on certain displays (see Portability
        ! notes). Under Fortran 90 compilers, ICODE has an OPTIONAL attribute.
        ! This is useful as a functional replacement for InKeyEvent in routines which perform
        ! low level text entry on screens where no cursor is visible. This routine is used internally
        ! by the fixed field input routines in the IN group and hence by the form editor
        ! (IFormEdit). The size of the cursor (i.e. a block or an underline) is determined by
        ! the most recent call to ICursorSize. The default cursor size is an underline.
        ! On displays which support a hardware text cursor or where a cursor cannot be
        ! simulated, InKeyEventCursor is exactly equivalent to InKeyEvent.
        ! Keyboard/Mouse Event Handling INTERACTER Subroutine Reference
        ! 2-8
        !e.g. CHARACTER*10 NAME
        !CALL IOutStringXY(2,2,'Enter name : ')
        !IPOS = 1
        !10 CALL InKeyEventCursor(ICODE)
        !IF (ICODE.GE.32.AND.ICODE.LE.126) THEN
        !NAME(IPOS:IPOS) = CHAR(ICODE)
        !CALL IOutString(CHAR(ICODE))
        !GOTO 10
        !Portability notes :
        !DOS :
        !A vertical bar cursor is simulated in all DOS graphics modes.
        !Xlib and MS Windows :
        !A vertical bar cursor is simulated in all modes.
!        type(Fields), pointer :: this
!        this => this_
!        if (this%icode == -999) call processEvents(this%canvasWindow)
!        ICODE = this%icode
!        this%icode = -999
!
    end subroutine

    subroutine InKeyEventImm(ICODE)
        integer ICODE ! Keyboard or mouse event code (See InKeyEvent)
        ! (-999 if no key currently available)
        ! Short-name : INKEYI
        ! This performs the same function as InKeyEvent except that it will return
        ! immediately with a special code of -999 if no key or mouse event is waiting. Otherwise,the function and operation of this routine is exactly as for InKeyEvent, so refer to
        ! that routine for more information.
        ! Under Fortran 90 compilers, ICODE has an OPTIONAL attribute.
        !e.g. CALL IOutCentre(2,'Press a function key to halt execution')
        !10 CALL UPDATE
        !CALL InKeyEventImm(ICODE)
        !IF (ICODE.LT.170.OR.ICODE.GT.250) GOTO 10
    end subroutine

    LOGICAL function InYesNo(IECHO) result(res)
        integer IECHO ! 0 : Nothing is echoed to the screen (default)
        ! = 1 : Echo Y or N
        ! = 2 : Echo Yes or No
        ! Short-name : INYNO
        ! A simple confirmation function. Gets a single key yes/no response from the user,echoing the response at the current cursor position if required. Returns .TRUE. for yes
        ! or .FALSE. for no. Be sure to declare InYesNo as LOGICAL.
        !e.g. LOGICAL InYesNo
        !CALL IOutStringXY(10,10,'Having Fun ? ')
        !IF (InYesNo(2)) CALL IOutString(' Me too !')
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-9
        !2.2 Group IN : Fixed Field Input Handling
        !These routines are built on the lower level single key input facilities in the KM group.
        !They provide a controlled substitute for the Fortran READ statement, preventing the
        !user from typing outside a specified on-screen field. Routines are provided to read
        !string, long-string, integer, real and double precision data at the current cursor position,namely InString, InLongString, InInteger, InReal and InDouble.
        !There are also more powerful variants of each of these routines which enable a default
        !value to be presented to the user which can either be changed or accepted without
        !modification. The latter routines are InStringDef, InLongStringDef,InIntegerDef, InRealDef and InDoubleDef. Note that when using the
        !numeric input routines, the maximum field width is 100 characters.
        !The ten fixed field input routines described above all take input from the current cursor
        !position. Ten complementary routines offer the facility to specify the cursor position
        !and whether a prompt and/or frame are required. These are : InStringXY,InStringXYDef, InLongStringXY, InLongStringXYDef, InIntegerXY,
        !InIntegerXYDef, InRealXY, InDoubleXY, InRealXYDef
        !InDoubleXYDef. A pop-up feature is also supported by the latter 10 routines (see
        !InPopup in the IP group). Frame styles are determined by IFrameType and
        !IFrameOptions in the CG group.
        !The ten input-at-(x,y) routines (InStringXY, etc.) automatically adjust the on-screen
        !position of the input field/box if it would otherwise lie partly or wholly off screen.
        !Similarly, these routines offer the ability to centre the input field either horizontally or
        !vertically in the same manner as the menu (MN) and window opening routines. Note
        !that these features are not offered by the equivalent input-at-cursor routines.
        !All of the routines in this group activate the text cursor and restore it to its previous
        !state on exit. Where a hardware text cursor is used and block/underline cursor selection
        !is available, the cursor automatically toggles between an underline whilst in overtype
        !mode and a block whilst in insert mode. This behaviour can be modified by calling
        !InCursorType in the IP group. On most graphical displays, a vertical bar text cursor
        !is used.
        !Similarly, all routines in this group activate the mouse cursor (where available) on entry
        !and restore it to its previous state on exit. The mouse can be used to move the text input
        !cursor within the field by clicking on the required position. The mouse can also be used
        !to exit from a fixed field input routine by clicking outside of the field (with any button)
        !or inside the field (with the right button). The latter two features are controlled by
        !InMouseOptions in the IP group.
        !The behaviour of all of the fixed field input routines can be modified in various ways
        !using the input parameter control routines in the IP group. Features such as 'pop-up'
        !mode, case conversion, initial in-field cursor position and editing control keys are
        !selectable using routines such as InPopup, InCase, InCursorPos and
        !InControlKey, which are described in the IP section later in this chapter.
        !The fixed field input routines are also used by the Forms Manager, which is described
        !in chapter 3. The Forms Manager provides higher level facilities and can greatly
        !simplify multiple input field handling.
        !Fixed Field Input INTERACTER Subroutine Reference
        !2-10
    
        res = .true.
    end function

    subroutine InDouble(DBLVAL,IWIDTH)
        double precision DBLVAL ! Double precision value entered by the user
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed
        ! to enter a value
        ! Short-name : INDBL
        ! Fixed-field double precision value input routine, providing a controlled replacement for
        ! the Fortran READ statement. The user is not allowed to enter a response longer than the
        ! specified field width IWIDTH. Attempts to type anything other than a numeric, +/-
        ! signs, a D (for exponentiation) or a decimal point are trapped. Similarly entering an
        !invalid reply (e.g. two decimal points) is also trapped and causes the cursor to be
        !repositioned at the start of the input field.
        !A number of control keys are available, which can be redefined using the
        !InControlKey routine or the initialisation file. See the documentation for
        !InControlKey for a complete list of the supported input control keys. Any control
        !keys entered which are not amongst those currently selected, are trapped and ignored.
        !The text cursor can be repositioned within the field using a mouse, where available.
        !In addition to the standard 'confirm' key (which will usually be Return/Enter) all the
        !other 'exit' keys can be used to tab to another field, ask for help or quit entering the
        !value. The precise exit key which was used can be checked by calling
        !InfoInput(55) (see group IF). InDouble will also exit when a mouse button is
        !pressed outside of the input field. In this case, InfoInput(55) will return a control
        !key of .2. The mouse button number and position will then be available via
        !InfoInput(61-63) and/or InfoGraphics(5)/(6).
        !To offer a default value, see the equivalent InDoubleDef routine.
        !See also InMouseOptions.
        !e.g. DOUBLE PRECISION THICK
        !:
        !CALL IOutStringXY(1,5,'Enter thickness (1.0-1.0000001) : ')
        !CALL InDouble(THICK,12)
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-11
    end subroutine

    subroutine InDoubleDef(DBLVAL,IWIDTH,FRMAT)
        double precision DBLVAL ! On entry, contains default double prec. value
        ! = On exit, contains final entered value.
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed
        ! to enter value
        character(len=*) FRMAT ! Fortran format to use to display default value
        ! (D, F, E or G format specification, in brackets)
        ! Short-name : INDBLD
        ! Fixed-field double precision value input routine, with a default reply supplied to save
        !the user typing a full response (e.g. a standard value). In all other respects, this routine
        !is equivalent to InDouble.
        !The default response is displayed, using the supplied format, in a field of size IWIDTH
        !at the current cursor position. The cursor is placed at the beginning of the response,unless InCursorPos has been called. If the default value is too large for the supplied
        !format, the field is filled with asterisks. If the value does fit within the supplied format,but the resulting value is wider than IWIDTH columns, the maximum field width into
        !which the user can type is that of the default value. Once displayed, the user can modify
        !the response by typing over it and/or clearing parts of it. Any of the 'exit' keys can be
        !pressed to terminate input.
        !e.g. DOUBLE PRECISION THICK
        !:
        !100 CALL IOutStringXY(1,5,'Enter thickness (1.0-1.0000001) : ')
        !THICK = 1.00000005
        !CALL InRealDef(THICK,12,'(F12.9)')
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !CALL CALC(THICK)
        !ELSE IF (KEXIT.EQ.22) THEN
        !CALL HELP
        !GOTO 100
        !ELSE IF (KEXIT.EQ.24) THEN
        !C .. move to next field ..
        !ELSE IF (KEXIT.EQ.25) THEN
        !C .. move to previous field
        !ELSE
        !CALL IScreenClose
        !ENDIF
        !Errors :
        !ErrNumToStr (18) : Numeric-to-string conversion error
        !(default value is converted to string before output)
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
        !Fixed Field Input INTERACTER Subroutine Reference
        !2-12
    end subroutine

    subroutine InDoubleXY(IXPOS,IYPOS,PROMPT,IFRAME,DBLVAL,IWIDTH)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left
        ! = 2 : Frame round field, prompt above
        double precision DBLVAL ! Double precision value entered by the user
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed
        ! to enter value
        ! Short-name : INDXY
        ! Fixed-field double precision value input routine. This is directly equivalent to calling
        ! InDouble except that position, prompt and frame can all be specified, and the input
        ! field can be made to pop up.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! two arguments are as for InDouble.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. DOUBLE PRECISION THICK
        !:
        !CALL InHighlight('W','BLUE')
        !CALL InDoubleXY(2,5,1 'Enter thickness (1.0-1.0000001) : ',1,THICK,12)
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-13
    end subroutine

    subroutine InDoubleXYDef(IXPOS,IYPOS,PROMPT,IFRAME,DBLVAL,IWIDTH,FRMAT)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left
        ! = 2 : Frame round field, prompt above
        double precision DBLVAL ! On entry, contains default real value.
        ! = On exit, contains final entered value.
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed
        ! to enter value
        character(len=*) FRMAT ! Fortran format to use to display default value
        ! (D, F, E or G format specification, in brackets)
        ! Short-name : INDXYD
        ! Fixed-field double precision value input routine, with a default reply supplied. This is
        ! directly equivalent to calling InDoubleDef except that position, prompt and frame
        ! can all be specified, and the input field can be made to pop up.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! three arguments are as for InDoubleDef.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. DOUBLE PRECISION THICK
        !:
        !CALL InPopup('ON')
        !THICK = 1.00000005
        !CALL InDoubleXYDef(IX,IY,1 'Enter thickness (1.0-1.0000001) : ',1,THICK,12,'(F12.9)'))
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
        !Fixed Field Input INTERACTER Subroutine Reference
        !2-14
    end subroutine

    subroutine InInteger(INTVAL,IWIDTH)
        integer INTVAL ! Integer value entered by the user
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed to enter a value
        ! Short-name : ININT
        ! Fixed-field integer value input routine, providing a controlled replacement for the
        ! Fortran READ statement. The user is not allowed to enter a response longer than the
        ! specified field width IWIDTH. Attempts to type anything other than a numeric or +/-
        !signs are trapped. Similarly entering an invalid reply (e.g. two minus signs) is also
        !trapped and causes the cursor to be repositioned at the start of the input field.
        !A number of control keys are available, which can be redefined using the
        !InControlKey routine or the initialisation file. See the documentation for
        !InControlKey for a complete list of the supported input control keys. Any control
        !keys entered which are not amongst those currently selected, are trapped and ignored.
        !The text cursor can be repositioned within the field using a mouse, where available.
        !In addition to the standard 'confirm' key (which will usually be Return/Enter) all the
        !other 'exit' keys can be used to tab to another field, ask for help or quit entering the
        !value. The precise exit key which was used can be checked by calling
        !InfoInput(55) (see group IF). InInteger will also exit when a mouse button is
        !pressed outside of the input field. In this case, InfoInput(55) will return a control
        !key of .2. The mouse button number and position will then be available via
        !InfoInput(61-63) and/or InfoGraphics(5)/(6).
        !To offer a default value, see the equivalent InIntegerDef routine.
        !See also InMouseOptions.
        !e.g. CALL IOutStringXY(1,5,'How many data points ? (max = 999) : ')
        !CALL InInteger(NUMPTS,3)
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
    end subroutine

    subroutine InIntegerDef(INTVAL,IWIDTH)
        integer INTVAL ! On entry, contains default integer value.
        ! = On exit, contains final entered value.
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed to enter a value
        ! Short-name : ININTD
        ! Fixed-field integer value input routine, with a default reply supplied to save the user
        !typing a full response (e.g. a standard value). In all other respects, this routine is
        !equivalent to InInteger.
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-15
        !The default response is displayed in a field of size IWIDTH at the current cursor
        !position. The cursor is placed at the beginning of the response, unless InCursorPos
        !has been called. If the default integer value is longer than the specified field width, the
        !width of the default response takes priority over the specified IWIDTH value. For
        !example, if IWIDTH is specified as 2 but the default response is 100, the field width
        !into which the user can type will be 3. The user can then modify the response by typing
        !over it and/or clearing parts of it. Any 'exit' keys can be pressed to terminate input.
        !e.g.
        !100 CALL IOutStringXY(1,5,'How many data points ? (max = 999) : ')
        !NUMPTS = 50
        !CALL InIntegerDef(NUMPTS,3)
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !CALL GETVAL(NUMPTS)
        !ELSE IF (KEXIT.EQ.24) THEN
        !C .. move to next field ..
        !ELSE IF (KEXIT.EQ.25) THEN
        !C .. move to previous field
        !ELSE IF (KEXIT.EQ.22) THEN
        !CALL HELP
        !GOTO 100
        !ELSE
        !CALL IScreenClose
        !ENDIF
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
    end subroutine

    subroutine InIntegerXY(IXPOS,IYPOS,PROMPT,IFRAME,INTVAL,IWIDTH)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left (if specified)
        ! = 2 : Frame round field, prompt above (if specified)
        integer INTVAL ! Integer value entered by the user
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed to enter value
        ! Short-name : INIXY
        ! Fixed-field integer value input routine. This is directly equivalent to calling
        ! InInteger except that position, prompt and frame can all be specified, and the input
        ! field can be made to pop up.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! two arguments are as for InInteger.
        ! Fixed Field Input INTERACTER Subroutine Reference
        ! 2-16
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. CALL InPopup('ON')
        !CALL InHighlight('W','BLUE')
        !CALL InIntegerXY(2,5,'How many data points ? ',1,NUMPTS,3)
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
    end subroutine

    subroutine InIntegerXYDef(IXPOS,IYPOS,PROMPT,IFRAME,INTVAL,IWIDTH)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left (if specified)
        ! = 2 : Frame round field, prompt above (if specified)
        integer INTVAL ! On entry, contains default integer value.
        ! = On exit, contains final entered value.
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed to enter value
        ! Short-name : INIXYD
        ! Fixed-field integer value input routine, with a default reply supplied. This is directly
        ! equivalent to calling InIntegerDef except that position, prompt and frame can all
        ! be specified, and the input field can be made to pop up.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! two arguments are as for InIntegerDef.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. CALL InPopup('ON')
        !NUMPTS = 100
        !CALL InIntegerXYDef(IX,IY,'How many data points ? ',1,NUMPTS,3)
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-17
    end subroutine

    subroutine InLongString(STRING,LENGTH,IWIDTH)
        character(len=*) STRING ! String entered by the user
        integer LENGTH ! Returns the actual length of string entered by user,including trailing blanks
        integer IWIDTH ! Visible field width (normally < LEN(STRING))
        ! Long-string input routine, equivalent to InString, except that the enterable string
        ! length should be greater than the visible field width. As the user types data into the
        ! field and edits the entered value, the field scrolls left/right allowing long strings such as
        ! file names to be entered in a relatively small screen area. The left/right cursor keys
        ! cause the field to scroll when the cursor is at either end of the field. The move-to-start
        ! and move-to-end keys (usually Home/End) scroll the field to the extreme start or end as
        ! appropriate.
        ! Unlike other types of field described in this group, long string fields only support left
        ! handed gravity. Otherwise all the input control parameters in the IP group apply to long
        ! string fields.
        ! The LENGTH argument has the OPTIONAL attribute under Fortran 90 compilers, when
        ! the INTERACTER module is USE'd.
        ! To offer a default value, see the equivalent InLongStringDef routine.
        !e.g. CHARACTER*70 FILNAM
        !CALL IOutStringXY(1,5,'Enter filename (max 70 characters) :')
        !CALL InLongString(FILNAM,LENGTH,20)
        !IF (LENGTH.GT.0) OPEN(20,FILE=FILNAM(:LENGTH),STATUS='OLD')
        !Portability notes :
        !See InString
    end subroutine

    subroutine InLongStringDef(STRING,LENGTH,IWIDTH)
        character(len=*) STRING ! On entry, contains default response string.
        ! = On exit, contains final response string.
        integer LENGTH ! On exit, contains the length of the string entered by user,including any typed trailing blanks
        integer IWIDTH ! Visible field width (normally < LEN(STRING))
        ! Long-string input routine, with a default reply supplied to save the user typing a full
        !response (e.g. a standard filename). In all other respects, this routine is equivalent to
        !InLongString. It is the long-string equivalent of InStringDef.
        !e.g. CHARACTER*70 FILNAM
        !100 CALL IOutStringXY(1,5,'Enter filename (max 70 characters) :')
        !FILNAM = 'c:\project\defaults\work01.dat'
        !CALL InCursorPos(999)
        !CALL InLongStringDef(FILNAM,LENGTH,20)
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !IF (LENGTH.GT.0) THEN
        !OPEN(LFN,FILE=FILNAM(:LENGTH),STATUS='OLD')
        !ELSE
        !GOTO 100
        !ENDIF
        !ELSE . . .
        !Fixed Field Input INTERACTER Subroutine Reference
        !2-18
        !Portability notes :
        !See InString
    end subroutine

    subroutine InLongStringXY(IXPOS,IYPOS,PROMPT,IFRAME,STRING,LENGTH,IWIDTH)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left (if specified)
        ! = 2 : Frame round field, prompt above (if specified)
        character(len=*) STRING ! String entered by the user
        integer LENGTH ! Actual length of string entered by user,including trailing blanks
        integer IWIDTH ! Visible field width (normally < LEN(STRING))
        ! Long-string input routine. This is directly equivalent to calling InLongString
        ! except that position, prompt and frame can all be specified, and the input field can be
        ! made to pop up. As such it is also equivalent to InStringXY, but with the added
        ! benefit of left/right scrolling within the field.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! three arguments are as for InLongString.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. CHARACTER*70 FILEN
        !:
        !CALL InHighlight('W','BLUE')
        !IWIDTH = 20
        !CALL InLongStringXY(5,5,'File:',0,FILEN,LENGTH,IWIDTH)
        !Portability notes :
        !See InString
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-19
    end subroutine

    subroutine InLongStringXYDef(IXPOS,IYPOS,PROMPT,IFRAME,STRING,LENGTH,IWIDTH)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left (if specified)
        ! = 2 : Frame round field, prompt above (if specified)
        character(len=*) STRING ! On entry, contains default response string.
        ! = On exit, contains final response string.
        integer LENGTH ! On exit, contains the length of the string entered by user,including any typed trailing blanks
        integer IWIDTH ! Visible field width (normally < LEN(STRING))
        ! Long-string input routine, with a default reply supplied. This is directly equivalent to
        ! calling InLongStringDef except that position, prompt and frame can all be
        ! specified. The input field can also be made to pop up. As such it is also equivalent to
        ! InStringXYDef, but with the added benefit of left/right scrolling within the field.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! three arguments are as for InLongStringDef.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. CHARACTER*70 FILNAM
        !:
        !FILNAM = '/usr/project/datafiles/work001.dat'
        !CALL InLongStringXYDef(5,5,'File: ',1,FILNAM,LENGTH,20)
        !Portability notes :
        !See InString
    end subroutine

    subroutine InReal(REAVAL,IWIDTH)
        real REAVAL ! Real value entered by the user
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed to enter a value
        ! Short-name : INREA
        ! Fixed-field real value input routine, providing a controlled replacement for the Fortran
        ! READ statement. The user is not allowed to enter a response longer than the specified
        ! field width IWIDTH. Attempts to type anything other than a numeric, +/- signs, an E
        ! (for exponentiation) or a decimal point are trapped. Similarly entering an invalid reply
        !(e.g. two decimal points) is also trapped and causes the cursor to be repositioned at the
        !start of the input field.
        !Fixed Field Input INTERACTER Subroutine Reference
        !2-20
        !A number of control keys are available, which can be redefined using the
        !InControlKey routine or the initialisation file. See the documentation for
        !InControlKey for a complete list of the supported input control keys. Any control
        !keys entered which are not amongst those currently selected, are trapped and ignored.
        !The text cursor can be repositioned within the field using a mouse, where available.
        !In addition to the standard 'confirm' key (which will usually be Return/Enter) all the
        !other 'exit' keys can be used to tab to another field, ask for help or quit entering the
        !value. The precise exit key which was used can be checked by calling
        !InfoInput(55) (see group IF). InReal will also exit when a mouse button is
        !pressed outside of the input field. In this case, InfoInput(55) will return a control
        !key of .2. The mouse button number and position will then be available via
        !InfoInput(61-63) and/or InfoGraphics(5)/(6).
        !To offer a default value, see the equivalent InRealDef routine.
        !See also InMouseOptions.
        !e.g. CALL IOutStringXY(1,5,'Enter threshold value (0.5 - 1.0) : ')
        !CALL InReal(THRESH,5)
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
    end subroutine

    subroutine InRealDef(REAVAL,IWIDTH,FRMAT)
        real REAVAL ! On entry, contains default real value.
        ! = On exit, contains final entered value.
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed to enter value
        character(len=*) FRMAT ! Fortran format to use to display default value
        ! (F, E or G format specification, in brackets)
        ! Short-name : INREAD
        ! Fixed-field real value input routine, with a default reply supplied to save the user typing
        !a full response (e.g. a standard value). Otherwise, this routine is equivalent to InReal.
        !The default response is displayed, using the supplied format, in a field of size IWIDTH
        !at the current cursor position. The cursor is placed at the beginning of the response,unless InCursorPos has been called. If the default value is too large for the supplied
        !format, the field is filled with asterisks. If the value does fit within the supplied format,but the resulting value is wider than IWIDTH columns, the maximum field width into
        !which the user can type is that of the default value. Once displayed, the user can modify
        !the response by typing over it and/or clearing parts of it. Any of the 'exit' keys can be
        !pressed to terminate input.
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-21
        !e.g.
        !100 CALL IOutStringXY(1,5,'Enter threshold value (0.5 - 1.0) : ')
        !THRESH = 0.75
        !CALL InRealDef(THRESH,6,'(F6.2)')
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !CALL CALC(THRESH)
        !ELSE IF (KEXIT.EQ.22) THEN
        !CALL HELP
        !GOTO 100
        !ELSE IF (KEXIT.EQ.24) THEN
        !C .. move to next field ..
        !ELSE IF (KEXIT.EQ.25) THEN
        !C .. move to previous field
        !ELSE
        !CALL IScreenClose
        !ENDIF
        !Errors :
        !ErrNumToStr (18) : Numeric-to-string conversion error
        !(default value is converted to string before output)
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
    end subroutine

    subroutine InRealXY(IXPOS,IYPOS,PROMPT,IFRAME,REAVAL,IWIDTH)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left (if specified)
        ! = 2 : Frame round field, prompt above (if specified)
        real REAVAL ! Real value entered by the user
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed to enter value
        ! Short-name : INRXY
        ! Fixed-field real value input routine. This is directly equivalent to calling InReal
        ! except that position, prompt and frame can all be specified, and the input field can be
        ! made to pop up.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! two arguments are as for InReal.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. CALL InHighlight('W','BLUE')
        !CALL InRealXY(2,5,'Enter threshold (0.5-1.0) : ',1,THRESH,6)
        !Fixed Field Input INTERACTER Subroutine Reference
        !2-22
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
    end subroutine

    subroutine InRealXYDef(IXPOS,IYPOS,PROMPT,IFRAME,REAVAL,IWIDTH,FRMAT)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left (if specified)
        ! = 2 : Frame round field, prompt above (if specified)
        real REAVAL ! On entry, contains default real value.
        ! = On exit, contains final entered value.
        ! (returned as zero if blank reply entered)
        integer IWIDTH ! Width of field in which user is allowed to enter value
        character(len=*) FRMAT ! Fortran format to use to display default value
        ! (F, E or G format specification, in brackets)
        ! Short-name : INRXYD
        ! Fixed-field real value input routine, with a default reply supplied. This is directly
        ! equivalent to calling InRealDef except that position, prompt and frame can all be
        ! specified, and the input field can be made to pop up.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! three arguments are as for InRealDef.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. CALL InPopup('ON')
        !THRESH = 0.75
        !CALL InRealXYDef(IX,IY,'Enter threshold : ',1,THRESH,6,'(F6.2)')
        !Errors :
        !ErrBlankInput (29) : Blank field entered
        !Portability notes :
        !See InString
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-23
    end subroutine

    subroutine InString(STRING,LENGTH)
        character(len=*) STRING ! String entered by the user
        integer LENGTH ! Actual length of string entered by user,including trailing blanks
        ! Short-name : INSTR
        ! Fixed-field string input routine, providing a controlled replacement for the Fortran
        ! READ statement. The user is not allowed to enter a response longer than the receiving
        ! variable STRING. The actual length of the entered string (including trailing spaces) is
        ! returned in LENGTH which must therefore be a variable.
        ! A number of control keys are available, which can be redefined using the
        ! InControlKey routine or the initialisation file. See the documentation for
        ! InControlKey for a complete list of the supported input control keys. Any control
        ! keys entered which are not amongst those currently selected, are trapped and ignored.
        ! The text cursor can be repositioned within the field using a mouse, where available.
        ! In addition to the standard 'confirm' key (which will usually be Return/Enter) all the
        ! other 'exit' keys can be used to tab to another field, ask for help or quit entering the
        ! value. The precise exit key which was used can be checked by calling
        ! InfoInput(55) (see group IF). InString will also exit when a mouse button is
        ! pressed outside of the input field. In this case, InfoInput(55) will return a control
        ! key of .2. The mouse button number and position will then be available via
        ! InfoInput(61-63) and/or InfoGraphics(5)/(6).
        ! To enter a numeric value, the alternative routines InDouble, InInteger and
        ! InReal are also available. Note that InString differs slightly from these routines
        ! in that the second parameter LENGTH is an output argument.
        ! The LENGTH argument has the OPTIONAL attribute under Fortran 90 compilers, when
        ! the INTERACTER module is USE'd.
        ! To offer a default value, see InStringDef. See also InMouseOptions.
        !e.g. CHARACTER*12 FILNAM
        !:
        !CALL IOutStringXY(1,5,'Enter filename (max 8 characters) :')
        !CALL InString(FILNAM(:8),LENGTH)
        !IF (LENGTH.GT.0) OPEN(20,FILE=FILNAM(:LENGTH),STATUS='OLD')
        !Portability notes :
        !DOS :
        !In graphics screen modes there is no hardware text cursor, so a block/underline cursor
        !is simulated via InKeyEventCursor. This is removed automatically on exit.
        !Xlib and MS Windows :
        !There is no hardware text cursor, so a vertical bar cursor is simulated, via
        !InKeyEventCursor. This is removed automatically on exit.
        !Tektronix :
        !On a screen which uses Tektronix 4010/4014 Alpha mode for text screen handling in
        !graphics mode, alphanumeric text overstrikes existing text rather than replacing it.
        !Whilst overtyping or backspacing moves the cursor and enters text correctly, the onscreen
        !field contents become unreadable. This is a limitation of the 4010/14 standard.
        !Fixed Field Input INTERACTER Subroutine Reference
        !2-24
    end subroutine

    subroutine InStringDef(STRING,LENGTH)
        character(len=*) STRING ! On entry, contains default response string.
        ! = On exit, contains final response string.
        integer LENGTH ! On exit, contains the length of the string entered by user,including any typed trailing blanks
        ! Short-name : INSTRD
        ! Fixed field string input routine, with a default reply supplied to save the user typing a
        !full response (e.g. a standard filename). In all other respects, this routine is equivalent
        !to InString.
        !The default response STRING is displayed at the current cursor position. The cursor is
        !placed at the beginning of the response, unless InCursorPos has been called. The
        !user can then modify the response by typing over it and/or clearing parts of it. Any of
        !the 'exit' keys can be pressed to terminate input. By default (i.e. if the user types nothing
        !at all) LENGTH is returned as the length of STRING excluding any trailing spaces.
        !However, if the user types beyond the last non-blank character of the supplied string,LENGTH is returned accordingly including any trailing spaces which the user may
        !explicitly type at the end of the string.
        !To enter a numeric value, the alternative routines InDoubleDef, InIntegerDef
        !and InRealDef are available for double precision, integer and real data respectively.
        !e.g. CHARACTER*8 FILNAM
        !:
        !100 CALL IOutStringXY(1,5,'Enter filename (max 8 characters) :')
        !FILNAM = 'MYDATA'
        !CALL InStringDef(FILNAM,LENGTH)
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !IF (LENGTH.GT.0) THEN
        !OPEN(LFN,FILE=FILNAM(:LENGTH),STATUS='OLD')
        !ELSE
        !GOTO 100
        !ENDIF
        !ELSE IF (KEXIT.EQ.23) THEN
        !CALL HELP
        !GOTO 100
        !ELSE IF (KEXIT.EQ.24) THEN
        !C .. move to next field ..
        !ELSE IF (KEXIT.EQ.25) THEN
        !C .. move to previous field
        !ELSE
        !CALL IScreenClose
        !ENDIF
        !Portability notes :
        !See InString
        !INTERACTER Subroutine Reference Fixed Field Input
        !2-25
    end subroutine

    subroutine InStringXY(IXPOS,IYPOS,PROMPT,IFRAME,STRING,LENGTH)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left (if specified)
        ! = 2 : Frame round field, prompt above (if specified)
        character(len=*) STRING ! String entered by the user
        integer LENGTH ! Actual length of string entered by user,including trailing blanks
        ! Short-name : INSXY
        ! Fixed-field string input routine. This is directly equivalent to calling InString except
        ! that position, prompt and frame can all be specified, and the input field can be made to
        ! pop up.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! two arguments are as for InString.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. CHARACTER*8 USERID
        !:
        !CALL InHighlight('W','BLUE')
        !CALL InStringXY(5,5,'Enter i.d. ',0,USERID,LENGTH)
        !Portability notes :
        !See InString
        !Fixed Field Input INTERACTER Subroutine Reference
        !2-26
    end subroutine

    subroutine InStringXYDef(IXPOS,IYPOS,PROMPT,IFRAME,STRING,LENGTH)
        integer IXPOS ! Column at which field is to be displayed
        ! (zero to centre field horizontally)
        integer IYPOS ! Row on which field is to be displayed
        ! (zero to centre field vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round field, prompt to left (if specified)
        ! = 2 : Frame round field, prompt above (if specified)
        character(len=*) STRING ! On entry, contains default response string.
        ! = On exit, contains final response string.
        integer LENGTH ! On exit, contains the length of the string entered by user,including any typed trailing blanks
        ! Short-name : INSXYD
        ! Fixed-field string input routine, with a default reply supplied. This is directly
        ! equivalent to calling InStringDef except that position, prompt and frame can all be
        ! specified, and the input field can be made to pop up.
        ! The first 4 arguments are as for IMenuCycle which is functionally similar to this
        ! routine. Refer to IMenuCycle for details of frame and prompt positioning. The last
        ! two arguments are as for InStringDef.
        ! The pop-up mode is selectable by calling InPopup and the appearance of the input
        ! field is controlled by InHighlight. The text and mouse cursors are automatically
        ! enabled for the duration of the call and restored to their previous state on exit.
        !e.g. CHARACTER*20 FILNAM
        !:
        !FILNAM = 'datafile.dat'
        !CALL InStringXYDef(5,5,'Filename : ',1,FILNAM,LENGTH)
        !Portability notes :
        !See InString
        !INTERACTER Subroutine Reference Menus
        !2-27
        !2.3 Group MN : Menu Handling
        !The menu handling routines provide some of the most useful user interface building
        !blocks in the entire INTERACTER library. Options can be presented to the user in a
        !wide variety of layouts. All the routines in this group display a menu and then get a
        !choice from the user. A set of equivalent output-only menu display routines are also
        !provided in the OM group.
        !Choices are made by means of a simple to use pointer/highlight method. A highlight
        !bar is moved using the mouse or keyboard. The cursor keys and/or space bar move the
        !highlight and Return selects. For the more familiar user a single-key selection facility is
        !also available to speed option selection (controlled by InSingle and
        !InSelectionChars in the IP group). Control keys can also be redefined if
        !preferred, using InControlKey in the IP group or by an initialisation file keyword.
        !All menu input functions in this group activate the mouse cursor (where available) on
        !entry and restore it to its previous state on exit. The mouse can be used to select, cycle
        !or toggle menu options, depending on context. The mouse can also be used to exit from
        !a menu function by selecting a position outside of the menu, though this feature can be
        !disabled via InMouseOptions in the IP group. Similarly, the 'feel' of mouse input
        !via the menu routines is also controllable via InMouseOptions(3,n). By default, a
        !Windows-like mechanism is used.
        !All the menus in the MN group can be made to 'pop up', even on a serial terminal. This
        !means that the menu can be displayed, a selection made and the previous screen
        !contents restored with no special action by the calling program other than enabling 'pop
        !up' mode (see the InPopup routine in the IP group). This feature can be extended
        !using the 'linked pop-up' mode to create menu chains which are only closed when the
        !last sub-menu item is selected. Linked mode is also selectable via InPopup.
        !All menus are displayed using the text attributes most recently selected by the routines
        !in the AT group. Also, the means by which a currently selectable item is highlighted
        !can be determined using InHighlight. This defines the preferred highlighting
        !method, but INTERACTER will adapt the actual highlight used depending on the
        !display hardware in use. This is a very useful portability aid. Whatever highlight is used
        !to display a selectable menu option, the current text attributes selected by the AT
        !routines are undisturbed on exit from an MN routine.
        !Frame/border styles are determined by the IFrameType and IFrameOptions
        !routines in the CG group.
        !Where a menu displayed by one of the MN functions would lie partly or wholly off
        !screen, its position is adjusted to fit on screen. (Where a menu is too large to fit on
        !screen, no such adjustment is made). Similarly, all menu functions offer the ability to
        !centre the menu either horizontally or vertically in the same manner as the input box
        !and window opening routines.
        !Menus are available in all modes, except in graphics mode on terminals which use Tek
        !4010/4014 Alpha mode for graphics mode text screen handling. Only the menu output
        !routines in the OM group can usefully be called on such displays.
        !Menus INTERACTER Subroutine Reference
        !2-28
    end subroutine

    integer function IMenuCycle(OPTION,MAXOPT,IXPOS,IYPOS,PROMPT,IFRAME,ISTOPT) result(res)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IXPOS ! Column at which menu item is to be displayed
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Row on which menu item is to be displayed
        ! (zero to centre the menu vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round menu, prompt to left (if specified)
        ! = 2 : Frame round menu, prompt above (if specified)
        integer ISTOPT ! First option to be displayed
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! (If negative do not redraw menu - see below)
        ! Short-name : MNCYCL
        ! Presents a cycling menu of MAXOPT options, described in the character array OPTION,where only one option is displayed at a time at position (IXPOS,IYPOS). Optionally,
        ! a prompt and frame can be printed.
        ! The user selects an item from the menu in one of the following ways :
        !   Using the cursor or 'next-item' keys to cycle through the options, which are printed
        ! in turn at the specified x,y position. Cursor up/left keys cycle backwards, cursor
        ! down/right keys cycle forwards. The 'next-item' key cycles forwards. The 'confirm'
        ! key is then pressed to confirm the selection. 'Next-item' and 'confirm' are as defined
        ! by InControlKey or the initialisation file (usually Space and Return).
        !   If single key option selection is enabled (see InSingle), the user may also select
        ! an option by pressing the initial letter of that option. Alt and an initial letter can
        ! also be used, provided that this key combination is not defined as an exit key.
        !   When mouse input is enabled, a mouse cursor is displayed which can be positioned
        ! over the current menu option. Mouse button presses on the option string will cycle
        ! through the available options. IMenuCycle will exit with an InfoInput(55)
        ! value of -2 if a mouse button is pressed outside the area occupied by the menu,including the prompt and/or frame. The right mouse button can be used to confirm
        ! the menu rather than cycling to the next option. (See also InEventSelect and
        ! InMouseOptions).
        ! In addition to the 'confirm' key, tab/back-tab/help/quit keys can also be used to exit
        ! from the menu. Again these keys are as defined by InControlKey or the
        ! initialisation file. The actual exit key is available via InfoInput(55). It is the
        ! responsibility of the calling program to decide whether to allow the use of these exit
        ! keys and to take appropriate action if they are used instead of the usual confirm key.
        ! In a graphics mode in a windowing environment, if a resize/expose event occurs the
        ! menu will terminate and InfoInput(55) will return 259. Similarly, a close-window
        ! request will also terminate the menu returning an InfoInput(55) value of 260.
        ! INTERACTER Subroutine Reference Menus
        ! 2-29
        ! If a frame is requested, it is placed around the area specified by the subroutine
        ! parameters. Hence the position of the menu itself is the same regardless of whether a
        ! frame is requested or not. An IFRAME value of 1 places the prompt string (if specified)
        ! to the left of the menu option field, with the frame drawn around both. An IFRAME
        ! value of 2 places the prompt string (if specified) within the frame above the menu. The
        ! width of the frame is then determined by the two option strings, so the prompt string
        ! may be truncated if it is wider than the frame.
        ! The first option to be highlighted is specified by ISTOPT. Alternatively, ISTOPT can
        ! be specified as a negative value, in which case the following is assumed :
        !   IABS(ISTOPT) specifies the option to be highlighted.
        !   The menu is assumed to already be on the screen and will not be redrawn. This is
        ! useful to avoid unnecessary menu 'repainting', especially on serial terminals.
        ! The menu is displayed according to the current text styles set by ITextBold,ITextColour, etc. The way in which the current option is highlighted is controlled
        ! using InHighlight. A pop-up feature is also available, controlled by InPopup.
        ! The cursor is disabled for the duration of the menu, if the display supports this feature.
        !e.g. CHARACTER*6 OPTION(3)
        !DATA OPTION/'Large ','Medium','Small '/
        !IXPOS = 20
        !IYPOS = 2
        !CALL InHighlight(' ',' ')
        !IOPT = IMenuCycle(OPTION,3,IXPOS,IYPOS,'Size: ',1,1)
        
        res = 0
    end function

    integer function IMenuHoriz(OPTION,MAXOPT,IXPOS,IYPOS,IWIDTH,IBORDR,ISTOPT) result(res)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT) ! Array of option names
        integer IXPOS ! Left hand column of menu (zero to centre menu horizontally)
        integer IYPOS ! Top row of menu (zero to centre menu vertically)
        integer IWIDTH ! Width of menu
        integer IBORDR ! 1 : Print a line above menu only
        ! = 2 : Print a line below menu only
        ! = 3 : Print lines above and below menu
        ! = 4 : Print a frame around the menu
        ! = any other value for no border
        integer ISTOPT ! First option to be highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! (If negative do not redraw menu - see below)
        ! Short-name : MNHORI
        ! Presents a horizontal (possibly multi-line) pointer/highlight menu described in the array
        ! OPTION and gets a selection from the user. It returns the option number which has
        ! been chosen by simply pointing to the required menu item.
        ! IMenuHoriz is similar to IMenuHorizHelp in its mode of interaction with the
        ! user, but differs in the following ways :
        !   No help text is displayed, so the user must know what each option means.
        ! Menus INTERACTER Subroutine Reference
        ! 2-30
        !   All available options can be displayed at one time, unlike IMenuHorizHelp
        ! which spills extra options onto additional screens if they will not fit on one screen.
        !   Only part of the screen width need be used, by selecting appropriate combinations
        ! of IXPOS and IWIDTH. If IWIDTH is too wide to fit on the screen, the menu
        ! width is reduced accordingly.
        ! The user selects an item from the menu in one of the following ways :
        !   Using the cursor keys or 'next-item' key to move a highlight to the required option,then pressing the 'confirm' key. The 'next-item' and 'confirm' keys are as defined by
        ! InControlKey or the initialisation file (usually Space and Return).
        !   When single key option selection is enabled (see InSingle and
        ! InSelectionChars), the user may also select an option directly by pressing the
        ! initial letter of that option. Alt and an initial letter can also be used, provided that
        ! this key combination has not been defined as an exit key.
        !   When mouse input is enabled, a mouse cursor is enabled which can be used to
        ! select a menu option. This returns an InfoInput(55) exit key code of 21 as
        ! though the 'confirm' key had been pressed. The calling program can thus check for
        ! an exit key code of 21 regardless of whether a mouse is available or not.
        ! IMenuHoriz will exit with an InfoInput(55) value of -2 if a mouse button is
        ! clicked outside the menu. A button release outside the menu normally has the same
        ! effect (see also InEventSelect and InMouseOptions).
        ! In addition to the 'confirm' key, tab/back-tab/help/quit keys can also be used to exit
        ! from the menu. Again these keys are as defined by InControlKey or the
        ! initialisation file. The actual exit key is available via InfoInput(55). It is the
        ! responsibility of the calling program to decide whether to allow the use of these exit
        ! keys and to take appropriate action if they are used instead of the usual confirm key.
        ! In a graphics mode in a windowing environment, if a resize/expose event occurs the
        ! menu will terminate and InfoInput(55) will return 259. Similarly, a close-window
        ! request will also terminate the menu returning an InfoInput(55) value of 260.
        ! Another exit code which may prove useful is InfoInput(61). This identifies
        ! whether a mouse button was used to exit from the menu and if so which one. This is
        ! always set to zero if a keyboard key is used to exit from the menu, but returns the
        ! mouse button number otherwise. When used in combination with InfoInput(55)
        ! and InfoInput(62)/(63) (the mouse position) this mechanism allows button
        ! dependent exit processing to be performed.
        ! The first option to be highlighted is specified by ISTOPT. Alternatively, ISTOPT can
        ! be specified as a negative value, in which case the following is assumed :
        !   IABS(ISTOPT) specifies the option to be highlighted.
        !   The menu is assumed to already be on the screen and will not be redrawn. This is
        ! useful to avoid unnecessary menu 'repainting', especially on serial terminals. In this
        ! case IABS(ISTOPT) must specify the same option as was returned by the call to
        ! IMenuHoriz which printed the menu previously.
        ! INTERACTER Subroutine Reference Menus
        ! 2-31
        ! The menu is displayed according to the current text styles set by ITextBold,ITextColour, etc. The way in which the current option is highlighted is controlled
        ! using InHighlight. A pop-up feature is also available, controlled by InPopup.
        ! The cursor is disabled for the duration of the menu, if the display supports this feature.
        ! If a border is requested, this is located outside the area specifed by the subroutine
        ! parameters. For example, if you ask for a frame, the top left corner of the frame will be
        ! at (IXPOS-1,IYPOS-1), since the frame occupies 1 row and column. If only a line
        ! above the menu were requested, it would start at (IXPOS,IYPOS-1) and so on.
        ! A special feature (also supported by IMenuVertic/IMenuVerticHelp) allows
        ! options which start with a hyphen ('-') to be displayed, but non-selectable. This enables
        ! options to be temporarily disabled without changing the order or relative position of
        !other menu options. In other words, any option which starts with a dash (e.g. '----') will
        !appear in the menu but the user will not be able to place the highlight bar on that line or
        !select the option using its initial letter or the mouse.
        !Optionally, IMenuHoriz can be used for multiple option selection. In this case
        !control key 34 or left-button mouse clicks toggle menu options on/off. Right-button
        !mouse clicks confirm multiple choice menus. See InMultiple and
        !InMouseOptions in the IP group.
        !e.g. CHARACTER*4 OPTION(4)
        !LOGICAL LOADED
        !DATA OPTION/'Help','Run ','Edit','Quit'/
        !:
        !IXPOS = 21
        !IYPOS = 2
        !IWIDTH = 40
        !IBORDR = 4
        !CALL InHighlight(' ',' ')
        !IF (.NOT.LOADED) OPTION(2) = '---'
        !IOPT = IMenuHoriz(OPTION,4,IXPOS,IYPOS,IWIDTH,IBORDR,1)
        !Errors :
        !ErrMenuOpt (19) : All options start with '-'. At least one menu item must start with
        !a character other than '-'. IMenuHoriz is returned as 0 in this
        !situation.
        !Menus INTERACTER Subroutine Reference
        !2-32

!        character(len = 500) :: text = ""
!        type(Fields), pointer :: this
!
!        integer i
!
!        integer pos
!        integer L
!        this => this_
!
!        pos = 1
!        do i = 1, MAXOPT
!            L = len_trim(OPTION(i))
!            text(pos:l) = OPTION(i)
!            pos = pos + l + 3
!        end do
!        
!
!        call setStatusBarText(this%canvasWindow, text)
!    
        res = 0
    end function

    integer function IMenuHorizHelp(OPTION,MAXOPT,IYPOS,HELP,IBORDR,ISTOPT) result(res)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IYPOS ! Row on which menu is to start being displayed
        ! (zero to centre the menu vertically)
        character(len=*) HELP(MAXOPT)
        ! = Array of help strings for each OPTION element
        ! (or a blank for no help text)
        integer IBORDR ! 1 : Print a line above menu only
        ! = 2 : Print a line below menu only
        ! = 3 : Print lines above and below menu
        ! = Any other value for no border
        integer ISTOPT ! First option to be highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range )
        ! (If negative do not redraw menu - see below)
        ! Short-name : MNHELP
        ! Presents a horizontal pointer/highlight menu described in the array OPTION, across
        ! one full line of the screen. By default, an optional help-text for the currently selected
        ! option is displayed on the line below. An option can be selected by any combination of
        ! the cursor keys, space bar and initial letters of the menu options.
        ! If the options will not all fit onto one line, three dots (...) appear at the end of the menu
        ! to indicate that there are more options. On subsequent 'pages' of the menu these dots
        ! appear at the right of the menu to indicate that the user can move forward in the menu.
        ! The user selects an item from the menu in one of these ways :
        !   Using the cursor keys or 'next-item' key to move a highlight to the required option,then pressing the 'confirm' key. The 'next-item' and 'confirm' keys are as defined by
        ! InControlKey or the initialisation file (usually Space and Return).
        !   When single key option selection is enabled (see InSingle and
        ! InSelectionChars) the user may also select an option by pressing an initial
        ! letter. Alt and an initial letter can also be used, provided that this key combination
        ! has not been defined as an exit key.
        !   When mouse input is enabled, a mouse cursor is displayed which can be used to
        ! select a menu option. This returns an InfoInput(55) exit code of 21 as though
        ! the 'confirm' key had been pressed. The calling program can thus check for an exit
        ! code of 21 regardless of whether a mouse is available or not. Clicking on the three
        ! dots at the right of the menu moves to the next 'page' of menu options.
        ! IMenuHorizHelp will exit with an InfoInput(55) value of -2 if a mouse
        ! button is pressed outside the menu (i.e. beyond the help strings and any border). A
        ! button release outside the menu normally has the same effect. (See also
        ! InEventSelect and InMouseOptions).
        ! INTERACTER Subroutine Reference Menus
        ! 2-33
        ! In addition to the 'confirm' key, tab/back-tab/help/quit keys can also be used to exit
        ! from the menu. Again these keys are as defined by InControlKey or the
        ! initialisation file. The actual exit key which was pressed can be checked by a call to
        ! InfoInput(55). It is the responsibility of the calling program to decide whether to
        ! allow the use of these exit keys and to take appropriate action if they are used instead of
        ! the usual confirm key.
        ! In a graphics mode in a windowing environment, if a resize/expose event occurs the
        ! menu will terminate and InfoInput(55) will return 259. Similarly, a close-window
        ! request will also terminate the menu returning an InfoInput(55) value of 260.
        ! Another exit code which may prove useful is InfoInput(61). This identifies
        ! whether a mouse button was used to exit from the menu and if so which one. This is
        ! always set to zero if a keyboard key is used to exit from the menu, but returns the
        ! mouse button number otherwise. When used in combination with InfoInput(55)
        ! and InfoInput(62)/(63) (the mouse position) this mechanism allows button
        ! dependent exit processing to be performed.
        ! The first option to be highlighted is specified by ISTOPT. As an extension to this
        ! feature, ISTOPT can be specified as a negative value, in which case the following is
        ! assumed :
        !   IABS(ISTOPT) specifies the option to be highlighted.
        !   The menu is assumed to already be on the screen and will not be redrawn. This is
        ! useful to avoid unnecessary menu 'repainting', especially on serial terminals. In this
        ! case IABS(ISTOPT) must specify the same option as was returned by the call to
        ! IMenuHorizHelp which printed the menu previously.
        ! By default, menu options are trimmed to their actual length (with two spaces between
        ! each option). Alternatively, they can be displayed equally spaced, regardless of their
        ! actual length. Each item is then placed at intervals of LEN(OPTION)+2 across the
        ! screen. This is controlled by InCondenseHelpMenu. To calculate the horizontal
        !position at which an option will be displayed (e.g. to determine the position of a dropdown
        !sub-menu) use InHelpMenuOptionPos in the IP group.
        !If the HELP argument is specified as a blank (or an array with a blank first element), no
        !help strings are displayed. If a border below the menu is requested, this is relocated
        !accordingly. This feature allows the other benefits of this routine (such as multi-screen
        !options and condensed option strings) to be utilised without having to provide help
        !text. The position of the help text is redefinable via InHelpStringPos. The help
        !string can optionally be highlighted using InHighlightHelp.
        !The menu is displayed according to the current text styles set by ITextBold,ITextColour, etc. The way in which the current option is highlighted is controlled
        !using InHighlight. A pop-up feature is also available, controlled by InPopup.
        !The cursor is disabled for the duration of the menu, if the display supports this feature.
        !Menus INTERACTER Subroutine Reference
        !2-34
        !e.g. CHARACTER*4 OPTION(4)
        !CHARACTER*20 HELP(4)
        !DATA OPTION/'Help','Run ','Edit','Quit'/
        !:
        !HELP(1) = 'Display help text'
        !HELP(2) = 'Run data analysis'
        !HELP(3) = 'Modify data'
        !HELP(4) = 'Exit from program'
        !IOLDOP = 1
        !CALL InHighlight('BOLD','RED')
        !10 IOPT = IMenuHorizHelp(OPTION,4,1,HELP,2,IOLDOP)
        !IF (IOPT.EQ.1) THEN
        !CALL HELP
        !ELSE IF (IOPT.EQ.2) THEN
        !CALL RUN
        !ELSE IF (IOPT.EQ.3) THEN
        !CALL EDIT
        !ELSE
        !GOTO 20
        !ENDIF
        !IOLDOP = -IOPT
        !GOTO 10
        !20 ....
    
        res = 0
    end function

    integer function IMenuScroll(OPTION,MAXOPT,IXPOS,IYPOS,TITLE,NVISIB,IFRAME,ISTOPT) result(res)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IXPOS ! Left column of menu
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Top row of menu
        ! (zero to centre the menu vertically)
        character(len=*) TITLE ! Menu heading (Blank for no heading)
        integer NVISIB ! Number of options which are to be visible in the
        ! scrolling menu area
        integer IFRAME ! 0 : For no frame to be drawn
        ! = 1 : Draw a frame, placing title within top of frame
        ! if title is non-blank
        ! > 1 : Draw a frame, placing title in a box at top of
        ! frame if title is non-blank
        integer ISTOPT ! First option to be highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! (If negative do not redraw menu - see below)
        ! Short-name : MNSCRL
        ! Presents a scrolling vertical menu described in the array OPTION, and gets a selection
        ! from the user. It returns the option number which has been chosen by simply pointing
        ! to the required menu item. This routine is particularly suitable for selecting items from
        ! relatively long lists, without occupying a large screen area. The height of the menu is
        ! automatically reduced, if NVISIB is too large for the current screen height.
        ! INTERACTER Subroutine Reference Menus
        ! 2-35
        ! The user selects an item from the menu using the cursor keys or 'next-item' key to move
        ! a highlight to the required option, then pressing the 'confirm' key. 'Next-item' and
        ! 'confirm' keys are as defined by InControlKey or the initialisation file (usually
        ! Space and Return). The number of menu options which are visible at any one time can
        ! be specified to be less than the total number of options available. In this case, if the user
        ! moves the highlight off the top or bottom of the menu, the items in the list scroll to
        ! reveal the next option. The extended cursor up/down keys can be used to page quickly
        ! through the menu and the move-to-start/move-to-end keys can be used to move the
        ! highlight to the top or bottom of the menu.
        ! If single key selection is enabled (see InSingle), the user may also select an option
        ! directly by pressing the initial letter of that option. However, the InSingle 'moveonly'
        ! mode may be more useful in this context. This allows the user to press an initial
        ! letter to move to the first option beginning with that letter but does not confirm the
        ! selection. This provides a quick way to move around an alphabetically organised menu.
        ! When mouse input is enabled, a mouse cursor is enabled which can be used to select a
        ! menu option. This returns an InfoInput(55) exit key code of 21 as though the
        ! 'confirm' key had been pressed. The calling program can thus check for an exit key code
        ! of 21 regardless of whether a mouse is available or not. IMenuScroll will exit with
        ! an InfoInput(55) value of -2 if a mouse button is pressed outside the menu. A
        ! button release outside the menu normally has the same effect. (See also
        ! InEventSelect and InMouseOptions).
        ! When a frame is selected, arrows appear at the top and/or bottom right edges of the
        ! frame to indicate when more options are available in the menu above or below the
        ! current selection. The effect of clicking the mouse on these border controls depends on
        ! the current mouse-feel option, as set by InMouseOptions(3,n). By default,holding a button down over a border control simulates the cursor up/down keys and
        ! auto-repeats until a button is released. Scrolling stops if the cursor moves off the border
        ! control but resumes if the cursor moves back over it, provided no button release occurs
        ! in the meantime. Alternatively, button clicks on a border control can simulate Page
        ! up/Page down, but without the auto-repeat feature. InMouseOptions(101,n) can
        ! also be called to allow a specific mouse button to generate extreme movement when
        ! clicked on the border controls, i.e. to go to the top/bottom of the menu.
        ! In addition to the 'confirm' key, tab/back-tab/help/quit keys can also be used to exit
        ! from the menu. Again these keys are as defined by InControlKey or the
        ! initialisation file. The actual exit key is available via InfoInput(55). It is the
        ! responsibility of the calling program to decide whether to allow the use of these exit
        ! keys and to take appropriate action if they are used instead of the usual confirm key.
        ! In a graphics mode in a windowing environment, if a resize/expose event occurs the
        ! menu will terminate and InfoInput(55) will return 259. Similarly, a close-window
        ! request will also terminate the menu returning an InfoInput(55) value of 260.
        ! Another useful exit code is InfoInput(61). This identifies whether a mouse button
        ! was used to exit from the menu and if so which one. It returns zero if a keystroke is
        ! used to exit from the menu or the mouse button number otherwise. In combination with
        ! InfoInput(62)/(63) (the mouse position) and InfoInput(55) this
        ! mechanism allows button dependent exit processing to be performed.
        ! Menus INTERACTER Subroutine Reference
        ! 2-36
        ! The first option to be highlighted is specified by ISTOPT. Alternatively, ISTOPT can
        ! be specified as a negative value, in which case the following is assumed :
        !   IABS(ISTOPT) specifies the option to be highlighted.
        !   The menu is assumed to already be on the screen and will not be redrawn. This is
        ! useful to avoid unnecessary menu 'repainting', especially on terminals. In this case
        ! IABS(ISTOPT) must specify the same option as was returned by the call to
        ! IMenuScroll which printed the menu previously. There must have been no
        ! intervening calls to IMenuScroll since the menu was previously displayed,otherwise the re-entered menu will not behave correctly.
        ! On exit, IMenuScroll sets the cursor position to the start of the highlighted item.
        ! This allows InfoCursor(2) to be used to identify the screen position of the selected
        ! item. Without this feature, it would not be possible to determine the exact final position
        ! of the highlight, since the menu may have scrolled.
        ! The menu is displayed according to the current text styles set by ITextBold,ITextColour, etc. The way in which the current option is highlighted is controlled
        ! using InHighlight. A pop-up feature is also available, controlled by InPopup.
        ! The cursor is disabled for the duration of the menu, if the display supports this feature.
        ! Optionally, IMenuScroll can be used for multiple option selection. In this case
        ! control key 34 or left-button mouse clicks toggle menu options on/off. Right-button
        ! mouse clicks confirm multiple choice menus. See InMultiple and
        ! InMouseOptions in the IP group.
        !e.g. CHARACTER*14 FILES(20)
        !C get a list of up to 20 filenames
        !NFILE = 20
        !CALL IOsDirList(' ',' ',FILES,NFILE)
        !IXPOS = 30
        !IYPOS = 5
        !ISTOPT = 2
        !C only display 6 files in scrolling menu
        !NVISIB = 6
        !CALL InHighlight('CYA','BLA')
        !IOPT = IMenuScroll(FILES,NFILE,IXPOS,IYPOS,'File ?',NVISIB,1 1,ISTOPT)
        !Portability notes :
        !See IWinScroll in chapter 1.
        !INTERACTER Subroutine Reference Menus
        !2-37
    
        res = 0
    end function

    integer function IMenuTwo(OPT1,OPT2,IXPOS,IYPOS,PROMPT,IFRAME,ISTOPT) result(res)
        character(len=*) OPT1 ! First option
        character(len=*) OPT2 ! Second option
        integer IXPOS ! Menu column (zero to centre the menu horizontally)
        integer IYPOS ! Menu row (zero to centre the menu vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame drawn
        ! = 1 : Frame round menu, prompt to left (if specified)
        ! = 2 : Frame round menu, prompt above (if specified)
        integer ISTOPT ! First option to be highlighted :
        ! = 1 : first option (default)
        ! = 2 : second option
        ! (If negative do not redraw menu - see below)
        ! Short-name : MNTWO
        ! Presents a two-option menu, with OPT1 & OPT2 separated horizontally by a slash and
        ! optionally preceded by a prompt. The entire length of the prompt and options should
        ! not exceed the current screen width. The selected option number is returned.
        ! The user selects an item from the menu in one of the following ways :
        !   Using the cursor keys or 'next-item' key to move a highlight to the required option,then pressing the 'confirm' key. The 'next-item' and 'confirm' keys are as defined by
        ! InControlKey or the initialisation file (usually Space and Return).
        !   If the single key option selection mode is enabled (see InSingle), the user may
        ! also select an option directly by pressing the initial letter of that option. Alt and an
        ! initial letter can also be used, provided that this key combination has not been
        ! defined as an exit key.
        !   When mouse input is enabled, a mouse cursor is displayed which can be used to
        ! select either menu option. This returns an InfoInput(55) exit key code of 21 as
        ! though the 'confirm' key had been pressed. The calling program can thus check for
        ! an exit key code of 21 regardless of whether a mouse is available or not.
        ! IMenuTwo will exit with an InfoInput(55) value of -2 if a mouse button is
        ! pressed outside the menu. A button release outside the menu normally has the same
        ! effect. (See also InEventSelect and InMouseOptions)
        ! In addition to the 'confirm' key, tab/back-tab/help/quit keys can also be used to exit
        ! from the menu. Again these keys are as defined by InControlKey or the
        ! initialisation file. The actual exit key which was pressed can be checked by a call to
        ! InfoInput(55). It is the responsibility of the calling program to decide whether to
        ! allow the use of these exit keys and to take appropriate action if they are used instead of
        ! the usual confirm key.
        ! In a graphics mode in a windowing environment, if a resize/expose event occurs the
        ! menu will terminate and InfoInput(55) will return 259. Similarly, a close-window
        ! request will also terminate the menu returning an InfoInput(55) value of 260.
        ! Menus INTERACTER Subroutine Reference
        ! 2-38
        ! Another exit code which may prove useful is InfoInput(61). This identifies
        ! whether a mouse button was used to exit from the menu and if so which one. This is
        ! always set to zero if a keyboard key is used to exit from the menu, but returns the
        ! mouse button number otherwise. When used in combination with InfoInput(55)
        ! and InfoInput(62)/(63) (the mouse position) this mechanism allows button
        ! dependent exit processing to be performed.
        ! If a frame is requested, it is placed around the area specified by the subroutine
        ! parameters. Hence the position of the menu itself is the same regardless of whether a
        ! frame is requested or not. An IFRAME value of 2 places the prompt string (if specified)
        ! within the frame above the menu. The width of the frame is determined by the two
        ! option strings, so the prompt string may be truncated if it is wider than the frame.
        ! The first option to be highlighted is specified by ISTOPT. Alternatively, ISTOPT can
        ! be specified as a negative value, in which case the following is assumed :
        !   IABS(ISTOPT) specifies the option to be highlighted.
        !   The menu is assumed to already be on the screen and will not be redrawn. This is
        ! useful to avoid unnecessary menu 'repainting', especially on serial terminals. In this
        ! case IABS(ISTOPT) must specify the same option as was returned by the call to
        ! IMenuTwo which printed the menu previously.
        ! The menu is displayed according to the current text styles set by ITextBold,ITextColour, etc. The way in which the current option is highlighted is controlled
        ! using InHighlight. A pop-up feature is also available, controlled by InPopup.
        ! The cursor is disabled for the duration of the menu, if the display supports this feature.
        !e.g. IXPOS = 20
        !IYPOS = 5
        !IFRAME = 1
        !CALL InHighlight('CYA','BLA')
        !IOPT = IMenuTwo('Cancel','Confirm',IXPOS,IYPOS,'Save :',IFRAME,1)
        !INTERACTER Subroutine Reference Menus
        !2-39
    
        res = 0
    end function

    integer function IMenuVertic(OPTION,MAXOPT,IXPOS,IYPOS,TITLE,ISPACE,IFRAME,ISTOPT) result(res)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT)
        ! = Array of option names
        integer IXPOS ! Left column of menu
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Top row of menu
        ! (zero to centre the menu vertically)
        character(len=*) TITLE ! Menu heading (Blank for no heading)
        integer ISPACE ! Menu line spacing (0=no spacing, 1=one line, etc.)
        integer IFRAME ! 0 : For no frame to be drawn
        ! = 1 : Draw a frame, placing title within top of frame if title is
        ! non-blank
        ! > 1 : Draw a frame, placing title in a box at top of frame if
        ! title is non-blank
        integer ISTOPT ! First option to be highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! (If negative do not redraw menu - see below)
        ! Short-name : MNVERT
        ! Presents a vertical pointer/highlight menu described in the array OPTION and gets a
        ! selection from the user. It returns the option number which has been chosen by simply
        ! pointing to the required menu item.
        ! The user selects an item from the menu in one of the following ways :
        !   Using the cursor keys or 'next-item' key to move a highlight to the required option,then pressing the 'confirm' key. The 'next-item' and 'confirm' keys are as defined by
        ! InControlKey or the initialisation file (usually Space and Return).
        !   When single key option selection is enabled (see InSingle and
        ! InSelectionChars), the user may also select an option directly by pressing the
        ! initial letter of that option. Alt and an initial letter can also be used, provided that
        ! this key combination has not been defined as an exit key.
        !   When mouse input is enabled, a mouse cursor is displayed which can be used to
        ! select a menu option. This returns an InfoInput(55) exit key code of 21 as
        ! though the 'confirm' key had been pressed. The calling program can thus check for
        ! an exit key code of 21 regardless of whether a mouse is available or not.
        ! IMenuVertic will exit with an InfoInput(55) value of -2 if a mouse button
        ! is pressed outside the menu. A button release outside the menu normally has the
        ! same effect. (See also InEventSelect and InMouseOptions).
        ! In addition to the 'confirm' key, tab/back-tab/help/quit keys can also be used to exit
        ! from the menu. Again these keys are as defined by InControlKey or the
        ! initialisation file. The actual exit key is available via InfoInput(55). It is the
        ! responsibility of the calling program to decide whether to allow the use of these exit
        ! keys and to take appropriate action if they are used instead of the usual confirm key.
        ! Menus INTERACTER Subroutine Reference
        ! 2-40
        ! In a graphics mode in a windowing environment, if a resize/expose event occurs the
        ! menu will terminate and InfoInput(55) will return 259. Similarly, a close-window
        ! request will also terminate the menu returning an InfoInput(55) value of 260.
        ! Another useful exit code is InfoInput(61). This identifies whether a mouse button
        ! was used to exit from the menu and if so which one. This is always set to zero if a
        ! keyboard key is used to exit from the menu, but returns the mouse button number
        ! otherwise. When used in combination with InfoInput(55) and
        ! InfoInput(62)/(63) (the mouse position) this mechanism allows button
        ! dependent exit processing to be performed.
        ! If a frame is requested, it is placed around the area specified by the subroutine
        ! parameters. Hence the position of the menu itself is the same regardless of whether a
        ! frame is requested or not.
        ! ISTOPT specifies the first option to be highlighted. Alternatively, ISTOPT can be
        ! specified as a negative value, in which case the following is assumed :
        !   IABS(ISTOPT) specifies the option to be highlighted.
        !   The menu is assumed to already be on the screen and will not be redrawn. This is
        ! useful to avoid unnecessary menu 'repainting', especially on serial terminals. In this
        ! case IABS(ISTOPT) must specify the same option as was returned by the call to
        ! IMenuVertic which printed the menu previously.
        ! The menu is displayed according to the current text styles set by ITextBold,ITextColour, etc. The way in which the current option is highlighted is controlled
        ! using InHighlight. A pop-up feature is also available, controlled by InPopup.
        ! The cursor is disabled for the duration of the menu, if the display supports this feature.
        ! If a frame is requested, then a menu title may also be supplied. If TITLE is non-blank,it will be printed at the top of the frame. If both a frame and a title are requested, the
        ! value of IFRAME determines whether the title is printed within the frame (using
        ! IFrameTitle) or in a box at the top of the frame (using IFrameTitleBox). The
        ! frame is always printed outside the menu area specified by the subroutine parameters.
        ! A special feature (which IMenuVertic shares with IMenuVerticHelp) allows
        ! options which start with a hyphen ('-') to be displayed, but non-selectable. The highlight
        ! bar skips over such options and mouse clicks on them are ignored. If such an option
        ! begins with '-+', a solid separator is drawn at that point in the menu otherwise the string
        ! is displayed as supplied.
        ! Optionally, IMenuVertic can be used for multiple option selection. In this case
        ! control key 34 or left-button mouse clicks toggle menu options on/off. Right-button
        ! mouse clicks confirm multiple choice menus. See InMultiple and
        ! InMouseOptions in the IP group.
        !e.g. CHARACTER*4 OPTION(6)
        !DATA OPTION/'Save','Load','Edit',1 '----','Help','Quit'/
        !IXPOS = 20
        !IYPOS = 5
        !ISPACE = 1
        !IFRAME = 1
        !CALL InHighlight('CYA','BLA')
        !IOPT = IMenuVertic(OPTION,6,IXPOS,IYPOS,'Menu',ISPACE,IFRAME,5)
        !INTERACTER Subroutine Reference Menus
        !2-41
        !Errors :
        !ErrMenuOpt (19) : All options start with '-'. At least one menu item must start with
        !a character other than '-'. IMenuVertic will return 0.
    
        res = 0
    end function

    integer function IMenuVerticHelp(OPTION,MAXOPT,IXPOS,IYPOS,HELP,TITLE,ISPACE,IFRAME,ISTOPT) result(res)
        integer MAXOPT ! Number of options in OPTION array
        character(len=*) OPTION(MAXOPT) ! Array of option names
        integer IXPOS ! Left column of menu (zero to centre menu horizontally)
        integer IYPOS ! Top row of menu (zero to centre menu vertically)
        character(len=*) HELP(MAXOPT) ! Array of help strings for each OPTION element
        character(len=*) TITLE ! Menu heading (Blank for no heading)
        integer ISPACE ! Menu line spacing (0=no spacing, 1=one line, etc.)
        integer IFRAME ! 0 : For no frame to be drawn
        ! = 1 : Fraw a frame, placing title within top of frame
        ! > 1 : Fraw a frame, placing title in a box at top of frame
        integer ISTOPT ! First option to be highlighted
        ! (1 to MAXOPT - defaults to 1 if outside this range)
        ! (If negative do not redraw menu - see below)
        ! Short-name : MNVELP
        ! Presents a vertical pointer/highlight menu described in the array OPTION, with a helptext
        ! for the currently selected option. By default, the help text is displayed at the bottom
        ! of the menu. This function returns the option number which has been chosen by simply
        ! pointing to the required menu item.
        ! IMenuVerticHelp is equivalent to IMenuVertic, except that a help text
        ! associated with each menu option is displayed and updated in a similar manner to
        ! IMenuHorizHelp. By default, the help text is displayed immediately below the
        ! menu option strings, but within the menu frame (if selected). The position of the help
        ! text is redefinable via InHelpStringPos. The help text is displayed in the currently
        ! selected attributes unless the InHighlightHelp routine has been called.
        !e.g. CHARACTER*4 OPTION(3)
        !CHARACTER*21 HELP(3)
        !DATA OPTION/'Save','Load','Edit'/
        !HELP(1) = 'Write data to disk'
        !HELP(2) = 'Read data from disk'
        !HELP(3) = 'Change current values'
        !ISPACE = 0
        !IFRAME = 1
        !CALL InHighlight('CYA','BLA')
        !CALL InHighlightHelp('WHI','RED')
        !IOPT = IMenuVerticHelp(OPTION,3,20,5,HELP,1 'Menu',ISPACE,IFRAME,5)
        !Menus INTERACTER Subroutine Reference
        !2-42
    
        res = 0
    end function

    LOGICAL function IMenuYesNo(IXPOS,IYPOS,PROMPT,IFRAME,ISTOPT) result(res)
        integer IXPOS ! Column for Yes/No prompt
        ! (zero to centre the menu horizontally)
        integer IYPOS ! Row for Yes/No prompt
        ! (zero to centre the menu vertically)
        character(len=*) PROMPT ! Optional prompt string (None used if blank)
        integer IFRAME ! 0 : No frame required
        ! <> 0 : Draw frame round Yes/No and prompt (if specified)
        integer ISTOPT ! First option to be highlighted :
        ! = 1 : Yes (default)
        ! = 2 : No
        ! (If negative do not redraw menu - see below)
        ! Short-name : MNYESN
        ! Obtains a yes/no response from the user by means of a pointer/highlight menu. Prints
        ! Yes/No at (IXPOS,IYPOS), with one or other response highlighted. The user moves
        ! the highlight with the left/right cursor keys or the 'next-item' key and selects using the
        ! 'confirm' key or by pressing the Y or N keys. 'Next-item' and 'confirm' keys are as
        ! defined by InControlKey or the initialisation file (usually Space and Return).
        ! Optionally, a prompt can be printed and a frame drawn round the prompt and Yes/No
        ! options. TRUE is returned for yes and FALSE for no. Be sure to declare IMenuYesNo
        ! as type LOGICAL in your calling routine.
        ! IMenuYesNo is functionally equivalent to calling IMenuTwo with 'Yes' and 'No'
        ! parameters. However, since entering a yes/no response is such a common operation in
        ! interactive software, IMenuYesNo is supplied as a separate routine, with a simplified
        ! argument list. Also, IMenuYesNo returns a logical rather than numerical value since
        ! this is more natural when handling a confirmation.
        ! Unlike the other menu routines, the use of exit keys other than 'confirm' is suppressed,since the aim of this function is to provide an uncomplicated confirmation from the
        ! user. If tab/help/quit are required, you can still use the IMenuTwo function directly.
        ! The prompt and frame are displayed according to the current text styles set by
        ! ITextReverse, ITextBold, ITextColour, etc. The way in which the current
        ! option is highlighted can be controlled using the InHighlight routine. A pop-up
        ! feature is also available, controlled by InPopup.
        !e.g. LOGICAL IMenuYesNo
        !:
        !CALL InHighlight('RED','white')
        !CALL InPopup('ON')
        !IF (IMenuYesNo(10,10,'Having Fun ? ',1,1)) THEN
        !CALL IOutStringXY(10,10,'Good !')
        !ELSE
        !CALL IOutStringXY(10,10,'Sorry !')
        !ENDIF
        !CALL InPopup('OFF')
        !INTERACTER Subroutine Reference Input Control Parameters
        !2-43
        !2.4 Group IP : Input Control Parameter Selection
        !The behaviour of the input, menu and form handling routines in the IN, MN, FM and
        !WN groups can be modified in a number of different ways using the parameter
        !selection routines in this group.
        !The text attributes for menu highlight bars, data entry fields and file browser prompt
        !lines can be determined using InHighlight. This defines the preferred highlighting
        !method, but INTERACTER will adapt the actual highlight used depending on the
        !display hardware in use. An equivalent routine called InHighlightHelp is also
        !available to define the preferred highlight for help strings displayed by
        !IMenuHorizHelp and IMenuVerticHelp.
        !The control keys used by the various fixed field input routines and the menu routines
        !can all be redefined using InControlKey. This routine also selects the control keys
        !used by the TIN and GIN mode routines, along with the interactive window control
        !keys.
        !Mouse processing in single key and fixed-field-input routines, menus, browsers and the
        !form editor can be controlled via InMouseOptions.
        !Several routines are specifically relevant to the fixed field input routines, namely
        !InCase, InCursorPos, InCursorType, InGravity, InJustifyNum,InsertOverMessage, InsertOver, Invisible and InTypeWipe. InCase
        !allows automatic case conversion to be selected. InCursorPos controls the initial
        !cursor position within the field, whilst InsertOverMessage/InsertOver relate
        !to the insert/overtype state. InCursorType controls the insert/overtype mode text
        !cursor types. InGravity selects either left-handed or right-handed field 'gravity'.
        !InJustifyNum controls the justification of default numeric values offered by
        !routines in the IN group and Invisible allows for 'invisible' input of passwords.
        !InTypeWipe selects the 'type and wipe' feature.
        !InKeypad provides general purpose keypad interpretation control and affects all
        !routines which take input from the keyboard.
        !Single key selection in menus is controlled by two routines. InSingle
        !enables/disables this feature and provides a 'move to but don't select' capability.
        !InSelectionChars determines which characters will be used for single key
        !selection (initials are used by default) and enables/disables highlighting of these
        !characters (see also InHighlightChar).
        !Multiple choice menus can be enabled using InMultiple. The pop-up feature, as
        !used by the input-at-(x,y) and menu routines, is controlled by InPopup.
        !Three routines are specifically designed to complement the help-menu routines,IMenuHorizHelp and IMenuVerticHelp. InCondenseHelpMenu
        !determines whether options are equally spaced or trimmed to their actual lengths in a
        !horizontal menu. InHelpMenuOptionPos caclulates the position of an item in such
        !a menu (useful for locating drop-down sub-menus). InHelpStringPos allows the
        !position of the help text to be specified in both vertical and horizontal menus.
        !Input Control Parameters INTERACTER Subroutine Reference
        !2-44
    
        res = .true.
    end function

    subroutine InCase(CASE)
        character(len=*) CASE ! Case conversion required :
        ! = 'U' : Upper case
        ! = 'L' : Lower case
        ! Other : No case conversion (default)
        ! Short-name : INCASE
        ! Enables or disables automatic case conversion in the fixed field input routines. Once
        ! enabled, keyboard input via the routines in the IN group will be automatically forced to
        ! the specified case. Obviously this is mainly useful with the string input routines, such
        ! as InString, InLongString, etc. Since these routines are also used by the form
        ! editing routine IFormEdit, InCase also controls the default case conversion
        ! method used in that routine.
        ! By default, no case conversion is performed on input. This state can be returned to by
        ! passing a CASE argument other than 'U' or 'L'.
        !e.g. CHARACTER*4 USERID
        !:
        !C force upper case conversion
        !CALL InCase('U')
        !CALL InStringXY(2,2,'User name :',0,USERID,LENGTH)
        !IF (USERID.NE.'FRED'.AND.
        !1 USERID.NE.'JOHN')
        !2 CALL IOsExitProgram('Unauthorised user!',21)
        !C disable case conversion
        !CALL InCase(' ')
    end subroutine

    subroutine InCondenseHelpMenu(ONOFF)
        character(len=*) ONOFF ! 'ON' : Enable condensed options in horizontal help menus
        ! = Any other string : Disable condensed options
        ! Enables/disables condensed options in horizontal help menus generated by
        ! IMenuHorizHelp and IOutMenuHorizHelp. By default, condensed options are
        ! enabled, so option strings are trimmed to their actual length allowing more options to
        ! be displayed at one time. Alternatively, options can be displayed uncondensed (i.e.
        ! equally spaced).
        !e.g. CHARACTER*4 OPTION(4)
        !CHARACTER*20 HELP(4)
        !DATA OPTION/'Analyse ','Modify','Help','Quit'/
        !:
        !HELP(1) = 'Run data analysis'
        !HELP(2) = 'Modify data'
        !HELP(3) = 'Display help text'
        !HELP(4) = 'Exit from program'
        !IOLDOP = 1
        !CALL InCondenseHelpMenu('ON')
        !10 IOPT = IMenuHorizHelp(OPTION,4,1,HELP,2,IOLDOP)
        !INTERACTER Subroutine Reference Input Control Parameters
        !2-45
    end subroutine

    subroutine InControlKey(KEYCNT,KEYCOD)
        integer KEYCNT ! Control key number :
        ! ControlUp (1) : cursor up
        ! ControlDown (2) : cursor down
        ! ControlRight (3) : cursor right
        ! ControlLeft (4) : cursor left
        ! ControlPageUp (5) : extended cursor up ('page up')
        ! ControlPageDown (6) : extended cursor down ('page down')
        ! ControlPageRight (7) : extended cursor right
        ! ControlPageLeft (8) : extended cursor left
        ! ControlExtremeUp (9) : extreme cursor up
        ! ControlExtremeDown (10) : extreme cursor down
        ! ControlExtremeRight (11) : extreme cursor right
        ! ControlExtremeLeft (12) : extreme cursor left
        ! ControlClearStart (13) : clear to start of field
        ! ControlClearEnd (14) : clear to end of field
        ! ControlMoveStart (15) : move to start
        ! ControlMoveEnd (16) : move to end
        ! ControlInsert (17) : toggle insert mode
        ! ControlBackspace1 (18) : backspace and delete (key 1)
        ! ControlBackspace2 (19) : backspace and delete (key 2)
        ! ControlDelete (20) : delete character under the cursor
        ! ControlConfirm (21) : confirm input
        ! ControlHelp (22) : help
        ! ControlQuit (23) : quit
        ! ControlTab (24) : tab
        ! ControlBackTab (25) : back-tab
        ! 26-30 : spare 'exit' codes (group #1)
        ! ControlConfirm2 (31) : confirm (key 2 : GIN mode only)
        ! ControlHelp2 (32) : help (key 2 : GIN mode only)
        ! ControlQuit2 (33) : quit (key 2 : GIN mode only)
        ! ControlMenu (34) : menu toggle
        ! (multiple choice menus and forms)
        ! ControlNext (35) : Next item/Next page
        ! 36-60 : spare 'exit' codes (group #2)
        ! 61-70 : spare 'exit' codes (group #3)
        ! ControlMark (71) : mark start of block in editor
        ! ControlCopy (72) : copy block in editor
        ! ControlCut (73) : cut block in editor
        ! ControlPaste (74) : paste block in editor
        integer KEYCOD ! Actual INTERACTER InKeyEvent code of key or event to
        ! be treated as the specified control key or zero to suppress key
        ! Short-name : INCTRL
        ! Include : interip.inc
        ! Input Control Parameters INTERACTER Subroutine Reference
        ! 2-46
        ! Allows any one of the listed input control keys to be redefined. These are the keys
        ! which the user is able to press when using any INTERACTER routines which involve
        ! data input (i.e. all of the routines in the IN group plus the form editor IFormEdit) or
        ! pointing/dragging (IWinOpenInter, IWinMoveInter, IWinBrowseText,IWinBrowseFile, ITextInputXY, ITextInputBox, IGrInputXY,
        ! IGrInputBox, IGrInputLine and the menu routines in the MN group). The
        ! current value of keys 1-50 are available via InfoInput(1-50). The value of keys
        ! 51-74 are returned via InfoInput(151-174).
        ! For example to redefine the 'help' key to be function key number 2, KEYCNT would be
        ! specified as 22 and KEYCOD as 172, since this is the INTERACTER InKeyEvent
        ! code for F2. The default values for all of the above are initialised according to display
        ! type, since the natural keys to use vary from one system to another. These default
        ! assignments are listed in chapter 19 in the User Guide.
        ! Any key which has a zero value assigned to it becomes unavailable to the user. This is a
        ! useful way of temporarily deactivating keys such as Tab, back-Tab or quit. In this case,it is advisable to first read the current value using InfoInput, save this value, then
        ! call InControlKey with a zero KEYCOD value to suppress the use of a particular
        ! key.
        ! When using the various fixed field input routines the cursor can be moved to the start
        ! or end of field using the specially assigned control keys 15 and 16. Alternatively, the
        ! extended left/right cursor control keys 8 and 7 can be used for the same purpose.
        ! Control keys 15 and 16 also allow movement to the top or bottom of a scrolling menu
        ! displayed by IMenuScroll.
        ! Keys 18 and 19 define two different 'backspace and delete' keys. This is because some
        ! keyboards generate backspace (ASCII 8) and some generate delete (ASCII 127), and
        ! many generate both depending on which key is pressed. This can be a regular source of
        ! confusion with some pieces of software or operating systems, which only recognise one
        ! or the other. INTERACTER overcomes this problem by allowing both keys to do the
        ! same job. Of course, if only one 'backspace and delete' code is required, simply set the
        ! second one to zero.
        ! Keys 21-25 all act as 'exit' keys when used with the fixed field input, menu, form and
        ! GIN/TIN routines. In other words, keyboard input ceases when any of these keys are
        ! pressed and the currently entered value is passed back to the calling program. Keys 26-
        ! 30 and 36-70 are also available for this purpose but are initially undefined. They can be
        ! activated by calling InControlKey with a suitable INTERACTER key code value.
        ! Keys in group #1 (26-30) have special meaning in the form editor IFormEdit, when
        ! activated. Keys in group #2 (36-60) always act simply as spare exit keys. The keys in
        ! group #3 (61-70) are also just spare exit keys in all except IdMessage and
        ! IGridEdit (where they are reserved for internal use).
        ! Another feature of exit keys is that, in most cases, they all perform the same task of
        ! terminating input and nothing else. They are defined separately to enable the calling
        ! program to take different action depending on the context in which a particular input
        ! routine is being used. Since any InKeyEvent code can be assigned as a control 'key'
        !this means that non-keyboard event codes (e.g. mouse events) can also be assigned as
        !exit 'keys'. The most recently used exit key is available via InfoInput(55), which
        !returns the control key number rather than the InKeyEvent code assigned to it.
        !INTERACTER Subroutine Reference Input Control Parameters
        !2-47
        !Keys 31-33 define a second set of confirm/help/quit codes solely for use by the
        !Graphics Input (GIN) routines, as alternatives to control keys 21, 22 and 23. By default
        !the alternative GIN exit keys are undefined, ensuring a common set of
        !confirm/help/quit keys for both text and graphics input operations. However, on
        !displays which require different key selections in text and graphics modes (notably
        !VT/Tek terminals), the alternative GIN mode keys (31-33) can be selected without
        !disturbing the text mode equivalents (21-23).
        !Key 34 is used in three situations :
        !(a) The menu routines IMenuHoriz, IMenuScroll, IMenuVerticHelp and
        !IMenuVertic use key 34 to toggle individual menu options on/off when multiple
        !choice mode has been enabled using InMultiple.
        !(b) The form editor IFormEdit/IFormEditUser uses key 34 to toggle menu
        !fields between a simple cycling format and a pop-up vertical format, if enabled via
        !IFormPopUpMenu.
        !(c) In the editor (IWinEditFile) key 34 followed by a menu item initial letter is
        !treated like Alt and the corresponding letter. This is useful on serial terminals where
        !the Alt key is not available.
        !Key 35 (normally the space bar) is used by the menu routines to move the highlight
        !onto the next menu item (or to cycle the menu forwards in the case of IMenuCycle).
        !It is also used by the window browser routines as a 'next page' key.
        !Keys 71-74 are used exclusively by the editor routines IWinEditFile and
        !IWinEditText. They are used to mark/copy/cut/paste blocks of text.
        !Given the variation in keyboard layouts, key functions and user preferences, it is
        !impossible to define a set of control keys which suit every user. As an alternative to
        !calling InControlKey, control keys can be defined at run time in the initialisation
        !file. See chapter 14 in the User Guide. To help identify precisely which codes a
        !particular keyboard generates, try compiling the keybtest demo program.
        !e.g.
        !C define 'help' to be F2 and disable use of Space as 'next item' key
        !CALL InControlKey(22,172)
        !CALL InControlKey(35,0)
        !Portability notes :
        !DOS, Xlib and Windows :
        !A separate set of control keys is assigned for each of these display types. See the tables
        !in chapter 19 of the User Guide.
        !Terminals :
        !The great majority of INTERACTER serial terminal display types use the
        !VT100/VT200 control key assignments described in chapter 19 of the User Guide.
        !However, different default keys are assigned on a handful of non-VT terminals where
        !no keypad is available or where better editing keys are available, e.g. Prime PT250,Falco. Note also that the alternative exit keys 31-33 will need to be utilised on many
        !VT/Tek terminals due to differences in keyboard conventions in VT and Tek screen
        !modes.
        !Input Control Parameters INTERACTER Subroutine Reference
        !2-48
    end subroutine

    subroutine InCursorPos(IPOS)
        integer IPOS ! Cursor position relative to start of field
        ! (1 = start of input field)
        ! (large value = after last non-blank character(len=100)
        ! Short-name : INCURP
        ! Defines the initial relative cursor position to be used by the fixed field input routines
        ! which offer default responses, i.e. InStringDef, InIntegerDef, InRealDef,etc. By default these routines always start with the cursor at the beginning of the
        ! response, but InCursorPos can be used to place the cursor at an alternative position.
        ! Where IPOS would put the cursor beyond the end of the field, the cursor is placed after
        ! the last non-blank character. So, to move the input cursor to the end of the response
        ! string call InCursorPos with a large positive value.
        ! An IPOS value <=0 resets the default position to one, i.e. the start of the input field.
        ! When right-handed field gravity is selected, using InGravity('R'), the 'start' of
        ! field is interpreted as the right-hand end of the field. The cursor position counts to the
        ! left in this case. i.e. IPOS=1 is the right most field character, IPOS=2 is the next
        ! character in to the left and so on.
        !e.g. IYEAR = 19
        !CALL InCursorPos(3)
        !CALL InIntegerXYDef(1,5,'Year : ',1,IYEAR,4)
    end subroutine

    subroutine InCursorType(OVER,INS)
        character(len=*) OVER ! Overtype mode cursor ) 'UN' : underline
        character(len=*) INS ! Insert mode cursor ) 'BL' : block
        ! ) .VB' : vertical bar
        ! Selects the type of text cursor to be displayed when a fixed field input routine is in
        ! overtype or insert mode. The default cursor type is display/mode dependent. This
        ! routine can be used to set different or identical cursors for each input mode. Both
        ! arguments should be a two character string (upper or lower case).
        ! The vertical bar cursor is only available on displays where a text input cursor is
        ! simulated by INTERACTER itself (i.e. Windows, Xlib and DOS/graphics).
        !e.g.
        !C force cursor to remain as an underline at all times
        !CALL InCursorType('UN',UN')
        !CALL InStringXY(2,2,'User name :',0,USERID,LENGTH)
        !Portability notes :
        !DOS :
        !In text mode block and underline hardware cursors are available. In graphics mode all
        !three cursor types are available. Default settings are an underline in overtype mode and
        !a block in insert mode.
        !Windows and Xlib :
        !All three cursor types are available. A vertical bar cursor is used by default in both
        !overtype and insert modes.
        !INTERACTER Subroutine Reference Input Control Parameters
        !2-49
        !Terminals :
        !Some terminals support block/underline cursor size selection (see ICursorSize) but
        !most do not. Vertical bar cursors are not supported. Where size selection is available,default settings are as for DOS.
    end subroutine

    subroutine InGravity(GRAVIT)
        character(len=*) GRAVIT ! Field gravity required :
        ! = 'L' : Left-handed gravity (default)
        ! = 'R' : Right-handed gravity
        ! Selects the required field 'gravity'. Conventionally, data entry fields have a left-handed
        ! 'gravity' and this is the default. However, when entering numeric data it may be useful
        ! to select right handed field gravity. In the latter case the direction in which text is
        ! pulled/pushed by backspace/delete keys is reversed. Similarly, insert mode operates in
        ! the opposite direction. When right-handed gravity is selected, the initial cursor position
        ! (as controlled by InCursorPos) is measured relative to the right-hand end of the
        ! field, rather than the left. Hence the default initial cursor position is the far right of the
        ! field in this case.
        ! Right-handed gravity is usually most useful when used with the right-justification on
        ! input option, selectable by InJustifyNum('R').
        ! The current field gravity setting can be interrogated via InfoInput(69).
        !e.g. CALL InJustifyNum('R')
        !CALL InGravity('R')
        !CALL InCursorPos(1)
        !TEMP = 2.05
        !CALL InRealXYDef(2,2,'Default temperature :',1,TEMP,8,'(F8.3)')
    end subroutine

    INTEGER function InHelpMenuOptionPos(OPT,ITEM) result(res)
        character(len=*) OPT(*) ! Array of menu option strings
        integer ITEM ! Menu option number
        ! Calculates the position (i.e the column) at which menu option OPT(ITEM) would be
        ! displayed in a horizontal help menu, taking account of the current 'condensed options'
        ! mode as set by InCondenseHelpMenu. This function is useful when calculating the
        ! required position for a drop-down menu which option number ITEM will lead to.
        !e.g. CHARACTER*7 OPTION(4)
        !CHARACTER*20 HELP(4)
        !DATA OPTION/'Analyse ','Modify','Help','Quit'/
        !HELP(1) = 'Run data analysis'
        !HELP(2) = 'Modify data'
        !HELP(3) = 'Display help text'
        !HELP(4) = 'Exit from program'
        !IOLDOP = 1
        !CALL InCondenseHelpmenu('ON')
        !10 IOPT = IMenuHorizHelp(OPTION,4,1,HELP,2,IOLDOP)
        !IF (IOPT.EQ.2) THEN
        !IX = InHelpMenuOptionPos(OPTION,IOPT)
        !IOPT2 = IMenuVertic(OPT2,NOPT2,IX,2,' ',0,1,1)
        !ELSE ...
        !Input Control Parameters INTERACTER Subroutine Reference
        !2-50
    
        res = 0
    end function

    subroutine InHelpStringPos(IX,IY,LENGTH)
        integer IX ! Column at which to display help strings
        ! (zero for default position)
        integer IY ! Row on which to display help strings
        integer LENGTH ! Length of help string field
        ! Defines the position and size of the help string field associated with horizontal and
        ! vertical help menus generated by IMenuHorizHelp and IMenuVerticHelp.
        ! By default, horizontal help menus display the help string on the line below the menu
        ! options. Vertical menus display the help text at the bottom of the menu, within the
        ! menu frame by default. This routine allows the help string to be placed anywhere on the
        ! screen. When this feature is activated, the help string does not form part of the 'pop-up'
        ! area of a help menu. Instead, the field is cleared on exit from a menu (if pop-up mode is
        ! enabled) or simply left on-screen (if pop-up mode is disabled).
        ! The default help text positioning logic can be restored at any time by calling this
        ! routine with a zero IX value.
        !e.g. NCOLUMN = InfoScreen(2)
        !LASTROW = InfoScreen(3)
        !CALL InHelpStringPos(1,LASTROW,NCOLUMN)
        !C Vertical help menu with help text on bottom screen line
        !IOPT = IMenuVerticHelp(OPTION,NOPT,IXPOS,IYPOS,HELP,1 'Menu',ISPACE,IFRAME,5)
    end subroutine

    subroutine InHighlight(HIGH1,HIGH2)
        character(len=*) HIGH1 ! ) A pair of strings containing blanks, the
        character(len=*) HIGH2 ! ) word 'BOLD' or colour names as follows :
        ! Short-name : INHIGH
        ! HIGH1 HIGH2
        ! blank blank = Reverse video
        ! 'BOLD' blank = Bold text in current foreground colour
        ! 'BOLD' colourF = Bold text in foreground colourF
        ! colourF colourB = Foreground colourF / background colourB
        ! blank colourB = Current foreground colour / background colourB
        ! colourF blank = Foreground colourF / Current background colour
        ! (where colourF or colourB is a colour name as definable to ITextColour)
        ! Defines the preferred highlighting method to be used in subsequent calls to the menu
        ! routines (in the OM and MN groups), the fixed-field input routines (in the IN group)
        ! the text browsers (IWinBrowseText, IWinBrowseFile), the text editors
        ! (IWinEditText, IWinEditFile), and the form editor (IFormEdit,IFormEditUser). The currently selected menu option or input field will be
        ! highlighted using one of reverse video, bold text or a foreground / background colour
        ! combination. The default preferred highlight is bold white on blue.
        ! HIGH1 can be one of three highlight definitions : blank (for reverse video or
        ! background colour only), 'bold' in lower or upper case, (for bold text with an optional
        ! foreground colour) or the name of a foreground colour. HIGH2 can either be blank (in
        ! which case HIGH1 completely defines the highlight) or it can be a colour name (either
        ! foreground or background depending on what was specified for HIGH1).
        ! INTERACTER Subroutine Reference Input Control Parameters
        ! 2-51
        ! If the current hardware/screen mode does not support the requested highlight,INTERACTER will automatically select an alternative. For example, requesting colours
        ! in a monochrome screen mode, will cause reverse video to be used instead. Thus colour
        ! can be used, without sacrificing portability since the pointer/highlight facilities will still
        ! operate when colour is not available.
        !e.g. LOGICAL HAPPY
        !:
        !CALL InHighlight(' ',' ')
        !HAPPY = IMenuYesNo(10,20,'Happy ?',1,1)
        !CALL InHighlight('BOLD','RED')
        !IOPT = IMenuVertic(OPT,MAXOPT,IX,IY,'Menu',ISPC,IFRM,ISTOPT)
        !CALL InHighlight('BLUE','WHITE')
        !IOPT = IMenuVertic(OPT,MAXOPT,IX,IY,'Menu',ISPC,IFRM,ISTOPT)
        !CALL InHighlight(' ','BLUE')
        !IOPT = IMenuVertic(OPT,MAXOPT,IX,IY,'Menu',ISPC,IFRM,ISTOPT)
    end subroutine

    subroutine InHighlightChar(HIGH1,HIGH2)
        character(len=*) HIGH1 ! ) Preferred highlight description
        character(len=*) HIGH2  != ) as for InHighlight
        ! Defines the preferred method to be used to highlight single-key selection characters in
        ! menus when InSelectionChars has been called with a non-blank argument (true
        ! at initialisation) and underlining is not available.
        ! Option selection characters identified by InSelectionChars are always
        ! highlighted using an underline, if supported by the current screen type/mode.
        ! InHighlightChar therefore provides a means of specifying a substitute highlight to
        ! be used when underlining is not available. In this case, the arguments have the same
        ! meaning as InHighlight. The default at initialisation is bold/white.
        !e.g. CALL InSelectionChars('FRHQ')
        !C highlight option selection chars in bold/yellow if no underlining
        !CALL InHighlightChar('BOLD','Y')
        !IOPT = IMenuHorizHelp(OPTION,MAXOPT,IY,HELP,2,IOLDOP)
        !C highlight option selection chars in reverse video if no underlining
        !CALL InHighlightChar(' ',' ')
        !IOPT = IMenuVerticHelp(OPTION,MAXOPT,IX,IY,HELP,' ',0,0,IOLDOP)
    end subroutine

    subroutine InHighlightHelp(HIGH1,HIGH2)
        character(len=*) HIGH1 ! ) Preferred highlight description,
        character(len=*) HIGH2 ! ) as for InHighlight
        ! Short-name : INHELP
        ! Defines the preferred highlighting method to be used to display help strings in
        ! subsequent calls to the 'help' menu routines IMenuHorizHelp and
        ! IMenuVerticHelp. The default help string highlight as set by IScreenOpen is
        ! 'none', i.e. help strings are displayed using the current text style if
        ! InHighlightHelp has not been called.
        ! HIGH1 can be one of three highlight definitions : blank (for reverse video or
        ! background colour only), 'bold' in lower or upper case, (for bold text with an optional
        ! foreground colour) or the name of a foreground colour. HIGH2 can either be blank (in
        ! which case HIGH1 completely defines the highlight) or it can be a colour name (either
        ! foreground or background depending on what was specified for HIGH1).
        ! Input Control Parameters INTERACTER Subroutine Reference
        ! 2-52
        ! If the current hardware/screen mode does not support the requested highlight,INTERACTER will automatically select an alternative. For example, requesting colours
        ! in a monochrome screen mode, will cause help strings to be displayed in reverse video
        ! instead. Thus colour can be used, without sacrificing portability.
        ! InHighlightHelp is very similar to InHighlight, which sets the preferred
        ! highlight combination for menu highlight bars, input fields, forms, etc.
        !e.g. CALL InHighlightHelp(' ',' ')
        !IOPT = IMenuHorizHelp(OPTION,MAXOPT,IY,HELP,2,IOLDOP)
        !CALL InHighlightHelp('BOLD','RED')
        !IOPT = IMenuVerticHelp(OPTION,MAXOPT,IX,IY,HELP,' ',0,0,IOLDOP)
    end subroutine

    subroutine InJustifyNum(LCR)
        character(len=*) LCR ! Numeric field Justification required :
        ! = 'L' : Left justify (default) ) either
        ! = 'C' : Centre justify ) upper or
        ! = 'R' : Right justify ) lower case
        ! Short-name : INJUST
        ! Defines how numeric fields should be justified on entry to the fixed field input routines
        ! which offer a default value, namely InIntegerDef, InIntegerXYDef,InRealDef, InRealXYDef, InDoubleDef and InDoubleXYDef. Since these
        ! routines are also used by the form editing routine IFormEdit, InJustifyNum also
        ! controls the default justification of numeric fields in that routine.
        ! By default, on entry to a numeric input field numeric, the current value is left justified.
        ! This places the value under the cursor ready for editing. However, since routines such
        ! as IOutInteger and IOutReal display numeric values right-justified by default,this gives the effect of 'pulling' the value in from the right. To prevent this effect, either
        ! call InJustifyNum('R') (to ensure that all fields are right-justified) or
        ! IOutJustifyNum('L') (to left-justify all fields). If right justification is used, the
        ! right-handed field gravity option may also prove useful (see InGravity).
        ! The 'C' option is provided, for the sake of completeness, since the argument to
        ! InJustifyNum will be passed to the IJustifyString routine within
        ! InIntegerDef/InIntegerXYDef/etc. It will not normally be useful.
        !e.g. INTVAL = 100
        !C first use left justification (the default)
        !CALL InIntegerXYDef(5,5,' ',0,INTVAL,IWIDTH)
        !C now use right justification
        !CALL InJustifyNum('R')
        !CALL InIntegerXYDef(5,7,' ',0,INTVAL,IWIDTH)
        !INTERACTER Subroutine Reference Input Control Parameters
        !2-53
    end subroutine

    subroutine InKeypad(MODE)
        integer MODE ! NumericMode (1) : Numeric mode
        ! (selected on program exit)
        ! SubstMode (2) : Special key substitution mode
        ! FullMode (3) : Full keypad mode
        ! Short-name : INKPAD
        ! Include : interip.inc
        ! Selects the manner in which keys on the numeric keypad will be interpreted by
        ! InKeyEvent/InKeyEventImm. This in turn determines how keypad keys are
        ! treated by the fixed field input and form editor routines. This table summarises the
        ! codes returned by the keypad in each of the three modes :
        ! Keypad key Mode 1 Mode 2 Mode 3
        ! 0 48 142 (Insert) 150
        ! 1 49 141 (End/Copy/Select) 151
        ! 2 50 129 (Cursor down) 152
        ! 3 51 133 (Page Down) 153
        ! 4 52 131 (Cursor left) 154
        ! 5 53 155 155
        ! 6 54 130 (Cursor right) 156
        ! 7 55 140 (Home/Find) 157
        ! 8 56 128 (Cursor up) 158
        ! 9 57 132 (Page Up) 159
        ! - 45 160 160
        ! . 46 143 (Delete) 161
        ! + or , 43 or 44 162 162
        ! / 47 163 163
        ! * 42 164 164
        ! # 35 165 165
        ! Enter 13 166 166
        !In numeric mode (MODE=1) the keys return the codes shown on the key tops e.g.
        !keypad 9 generates character '9' and so on. In this mode keys on the keypad are
        !indistinguishable from equivalent keys on the main keyboard.
        !In full keypad mode (MODE=3) keypad keys generate unique codes 150 to 166.
        !Unfortunately, whilst most keyboards have a keypad the availability of other important
        !keys is more variable. For example, on the original ('standard') 83 key IBM PC
        !keyboard, there are no separate cursor keys. Similarly, a VT100 keyboard does not have
        !Insert or Page up/down keys. Given these limitations, keypad mode 2 is provided. In
        !this mode some keypad keys return the same codes as the cursor and other special keys.
        !To check whether keypad keys are identifiable and whether cursor/keypad keys are
        !separate, call InfoInput(56).
        !See the Portability notes for the initial keypad mode. It is implementation dependent.
        !Input Control Parameters INTERACTER Subroutine Reference
        !2-54
        !e.g. CALL InKeypad(3)
        !CALL InKeyEvent(KEY)
        !IF (KEY.GE.128.AND.KEY.LE.131) THEN
        !CALL IOutStringXY(10,10,'Cursor key detected ')
        !ELSE IF (KEY.GE.150.AND.KEY.LE.159) THEN
        !CALL IOutStringXY(10,10,'Keypad key detected ')
        !ELSE IF (KEY.LE.127) THEN
        !CALL IOutStringXY(10,10,'Normal keyboard character detected')
        !ENDIF
        !Portability notes :
        !DOS :
        !The initial keypad mode is 2, since some PC's do not have separate cursor keys and
        !keypad. When DOS keyboard input is selected (the default), InKeypad has the
        !documented effect when Num Lock is off. Enabling Num Lock effectively forces the
        !keypad into mode 1. If keyboard input via the BIOS is selected, keypad interpretation is
        !solely under program control, i.e. the Num Lock key has no effect on keypad
        !interpretation. See InKeyVia for further details of BIOS and DOS keyboard input.
        !MS Windows :
        !InKeypad only has an effect under Windows when Num Lock is enabled, in which
        !case all three modes are supported. The initial mode is 1. When Num Lock is off, the
        !keypad remains in mode 2 regardless of the InKeypad setting.
        !Xlib :
        !The initial keypad mode is 3, as most workstations have separately identifiable keypads.
        !However, interpretation of keypad keys by individual X servers can vary considerably.
        !Behaviour can also be modified by the state of the Num-lock key on most (but not all)
        !X servers. This ambiguity is caused by the fact that a keypad key may potentially
        !generate any one of 4 different Xlib key codes internally and the choice of which
        !keycode to generate relies on the design of the current X server.
        !Terminals :
        !The initial keypad mode is 3, since VT keyboards have separate cursor keys and
        !keypad. The default input control keys rely on the use of this mode. Cursor keys are
        !independently identifiable in both modes 1 and 3. Note that 'application' mode is
        !selected for modes 2 or 3. IScreenClose returns the keypad to numeric mode.
        !Some non-VT terminals (e.g. Falco terminals in Falco mode) remain permanently in
        !keypad mode number 1 and cannot be changed.
        !On a Prime PT250 terminal, mode 1 switches the keypad to numeric mode. Modes 2
        !and 3 enable the keypad keys to act as cursor and editing keys, though the returned
        !InKeyEvent codes reflect the keytop legends not the organisation shown in the table
        !above. This is due to the non-standard layout of the PT250 keypad. Mode 3 is the
        !default, allowing cursor and editing keys to be detected.
    end subroutine

    subroutine InKeyVia(BIODOS)
        character(len=*) BIODOS ! 'B' : PC keyboard input is via BIOS
        ! = 'D. : PC keyboard input is via DOS (default)
        ! Short-name : INKVIA
        ! Selects the manner in which keyboard input will be read under DOS. This routine has
        ! no effect in non-DOS implementations.
        ! INTERACTER Subroutine Reference Input Control Parameters
        ! 2-55
        ! By default, DOS keyboard input is performed via DOS interrupts. This offers two main
        ! advantages over input via the ROM BIOS :
        ! 1) Program input can be redirected using the standard DOS '<' syntax. Keystrokes can
        ! thus be 'stacked' in an input file to allow programs to operate in 'batch' mode
        ! without user interaction.
        ! 2) The Num Lock key has its more normal effect of switching the keypad between
        ! numeric mode and cursor/editing mode. When Num Lock is on, keypad keys are
        ! indistinguishable from the equivalent keys on the main keyboard. When Num Lock
        ! is off, keypad keys return the same codes as when BIOS input is selected.
        ! However, there are certain limitations to the use of DOS input, associated with the use
        ! of Enhanced 101/102 key keyboards, which might justify using BIOS input :
        ! 1) The F11/F12 keys on Enhanced keyboards may not be detected by some old
        ! versions of DOS.
        ! 2) The separate cursor editing keys are not distinguishable from the equivalent keypad
        ! keys. They behave exactly like the same keys on the keypad, except that they are
        ! not affected by Num Lock. The following table shows the codes returned by the
        ! separate cursor/editing keys in each of the three keypad interpretation modes
        ! selectable by InKeypad (Mode 2 is the default) :
        ! Keypad key Mode 1 Mode 2 Mode 3
        ! Insert 48 142 150
        ! End 49 141 151
        ! Cur Down 50 129 152
        ! Page Dn 51 133 153
        ! Cur Left 52 131 154
        ! Cur Right 54 130 156
        ! Home 55 140 157
        ! Curs Up 56 128 158
        ! Page Up 57 132 159
        ! Delete 46 143 161
        ! When BIOS input is selected, the separate cursor/editing keys always return the
        ! codes shown in the middle column regardless of the keypad mode set by
        ! InKeypad. This means that DOS and BIOS input are fully compatible, so long as
        ! the keypad interpretation mode is not changed from its default of 2.
        ! 3) Ctrl and the separate cursor keys return the same codes as Ctrl and the keypad
        ! equivalents, i.e. both return InKeyEvent codes of 132-135. When BIOS input is
        ! selected Ctrl and the separate cursor keys return unique InKeyEvent codes of
        ! 136-139.
        ! 4) Keypad / * - + and Enter cannot be identified as keypad keys unless they are
        ! pressed in combination with Alt (or in some cases with Ctrl). When input via DOS
        ! is selected they simply return the same codes as their main keyboard equivalents.
        !e.g. Keypad * returns ASCII 42, but Alt/Keypad * returns 164.
        !Input Control Parameters INTERACTER Subroutine Reference
        !2-56
        !e.g. CHARACTER*2 ARG1
        !CALL IScreenOpen(' ','G',640,480,16)
        !CALL IOsArgument(1,ARG1)
        !CALL IUpperCase(ARG1)
        !C If /B or -B command line arg found use BIOS input
        !IF (ARG1.EQ.'/B'.OR.ARG1.EQ.'-B') CALL InKeyVia('B')
        !Portability notes :
        !All non-DOS versions :
        !InKeyVia has no effect.
    end subroutine

    subroutine InMouseOptions(NOPTN,IVALUE)
        integer NOPTN ! Option number (see table)
        integer IVALUE ! Option value (see table)
        ! Short-name : INMOPT
        ! Include : interip.inc, intergen.inc
        ! Defines mouse options for the single key, fixed field, menu, form editor and window
        ! browser routines. NOPTN values outside the specified range are ignored.
        ! NOPTN IVALUE
        ! MouseInput 1 Enable/disable mouse input in InKeyEvent and
        ! fields/menus/forms/etc.
        ! IntNo (0) = Disable
        ! IntYes (1) = Enable (default if mouse available)
        ! MouseExit 2 Set behaviour on a mouse button press outside 'input area'
        ! NoMouseExit (0) = Do nothing
        ! ExitOutside (1) = Exit
        ! NoMouseExitBell (2) = Ring bell
        ! ExitOutsideWin (3) = Exit
        ! ExitOutsideMenuBell (4) = Menu/fields : as (1)
        ! Forms/browsers : as (2)
        ! ExitOutsideMenu (5) = Menu/fields : as (1)
        ! Forms/browsers : as (0)
        ! (For 2-5 in a form, 'input area'=form-window)
        ! MouseFeel 3 Select mouse feel
        ! SelectOnButDown (0) = Select on button-down
        ! DragRelease (1) = Windows 3.x-like feel
        ! FollowCursor (2) = Windows 4.x-like feel
        ! ExtremeButton 101 Button for extreme movement in browsers and
        ! scrolling menus
        ! PopupButton 102 Button to display a pop-up menu within a form
        ! ConfirmMultiButton 103 Button to confirm a multiple choice menu
        ! ToggleMultiButton 104 Button to toggle choice & confirm a multiple choice menu
        ! ConfirmCycleButton 105 Button to confirm a cycling menu
        ! ConfirmFixedButton 106 Button to confirm a fixed-width input field
        ! Button codes for NOPTN 101-106 are :
        ! IntNone (0) : none
        ! LeftButton (1) : left
        ! MiddleButton (2) : middle
        ! RightButton (3) : right
        ! INTERACTER Subroutine Reference Input Control Parameters
        ! 2-57
        ! Option 1 has been superceded by InEventSelect in the KM group. Calling
        ! InMouseOptions(1,0) is equivalent to disabling all four mouse events which are
        ! selectable by InEventSelect. This forces keyboard-only input effectively reverting
        ! to v1.xx behaviour. Alternatively, calling InMouseOptions(1,1) enables mousebutton-
        ! down events and leaves all other event selections unchanged. Calling IMouse
        ! or IdMouse resets this option to its default setting. Use of InEventSelect is
        ! recommended in preference to InMouseOptions(1,n) in new software.
        ! Option 2 allows fixed-field input, menu, form-editor and window browser routines to
        ! exit when a mouse button selection occurs outside the area defined by the relevant
        ! routine. A mouse button selection means a button-down event. If option 3 is enabled
        ! (the default on most displays) this also means a button-up event outside a menu
        ! following a button-down inside the menu. By default option 2 is set to 4. The specific
        ! behaviour, by input-function type, is as follows :
        ! Menus and single input fields : IVALUE=1, 3, 4 and 5 are identical. A click outside
        ! the input area exits. The input area is the area inside the menu/field frame plus the
        ! frame itself. Outside therefore means the area beyond the frame (or beyond the area
        ! which the frame would surround, if no frame is selected). IVALUE= 0 and 2 are
        ! identical except that the latter rings the bell.
        ! Window browsers : IVALUE=1 and 3 are identical. A click outside the window exits.
        ! IVALUE= 0/2/4/5 are identical except that 2 & 4 ring the bell.
        ! Forms : In a windowed form, the input area is dependent on the specified IVALUE. For
        ! IVALUE=1, the input area means unprotected form fields only. All other areas of the
        ! screen are considered to be outside the form. For IVALUE=3 the window containing
        ! the form is considered to be the input area. Outside then means beyond the form
        ! window frame. IVALUE=0 or 5 are identical (i.e. no action). For IVALUE=2 or 4 the
        ! definition of outside is the same as for IVALUE=3, but these settings only ring the bell
        ! if the mouse is clicked outside the form window.
        ! When a 'click outside' exit occurs as a result of an option 2 setting, InfoInput(55)
        ! returns an exit code of -2. The mouse button number and position when the selection
        ! occurred will be available via InfoInput(61-63) and/or
        ! InfoGraphics(5)/(6). The current setting of this option is available via
        ! InfoInput(68).
        ! Option 3 determines the mouse 'feel' in menus, browsers and forms. Three possible
        ! 'feel' selections are available :
        ! IVALUE=0 : Selects the behaviour of INTERACTER 3.0 and earlier, where selection
        ! occurs as soon as a button is clicked. This is used by default on certain workstation/PC
        !terminal emulators were only mouse button-down events are supported (e.g. xterm,DECterm).
        !IVALUE=1 : Selects a Windows 3.x style feel. This is the default under Windows 3.1,DOS and Xlib. It has the following effects :
        !(a) Selection in menus occurs when a mouse button is released, with the highlight bar
        !following mouse movement whilst a button is held down. Releasing a button
        !outside of a menu after a button press inside a window is ignored by default but
        !generates exit code -2 if option 2 is enabled (see above).
        !Input Control Parameters INTERACTER Subroutine Reference
        !2-58
        !(b) In window browsers and scrolling menus, option 3 gives continuous scrolling when
        !a mouse button is held down over a border control.
        !(c) In the form editor, clicking on a push-button field causes the button field's
        !attributes to be temporarily modified. The push button is only activated by a button
        !release on that field otherwise control returns to the most recently highlighted data
        !entry field.
        !IVALUE=2 : Selects a Windows 4.x style feel. This is the default when running a
        !Windows program under Windows 9x/Me/NT/2K. The effect is the same as
        !IVALUE=1, except that the menu highlight automatically tracks mouse cursor
        !movement, regardless of whether a button is held down. Because of the potentially
        !serious implications for network traffic, we do not recommend the use of this option
        !under X Windows, if the client and server are on different machines.
        !Options 101-106 allow button specific processing to be performed, where all mouse
        !buttons would otherwise be treated identically. If IVALUE is zero, the specified button
        !action is disabled. Setting IVALUE to 1, 2 or 3 selects the left, middle or right button
        !for the specified action. These actions are activated on a button click, regardless of the
        !'feel' option setting. The current settings for these buttons can be interrogated via
        !InfoInput(101-106). The specific effects of setting each of these button values
        !are as follows :
        !101 Clicking the specified button on a window browser or scrolling menu border
        !control (in IWinBrowseText, IWinBrowseFile or IMenuScroll)
        !causes the routine to move to the extreme of the text or menu. Default=0.
        !102 Clicking the specified button on a menu field in a form which has been given a
        !pop-up capability (either via IFormPopUpMenu or an IFD file parameter)
        !causes the menu to pop up in the same way as if the toggle menu key (control
        !key 34) had been pressed. Default=3.
        !103 Clicking with the specified button on an option in a multiple choice menu (in
        !IMenuHoriz, IMenuScroll, IMenuVertic or IMenuVerticHelp)
        !confirms the menu, without toggling that option. Default=3.
        !104 Same as 103 except that the menu option is also toggled on/off. Default=0.
        !105 Clicking the specified button on a cycling menu (IMenuCycle) confirms the
        !menu choice, rather than cycling to the next option. Default=3.
        !106 Clicking the specified button in a fixed input field (any routine from the IN
        !group) confirms the field, rather than moving the cursor. Default =3.
        !e.g. CALL InMouseOptions(2,1)
        !IOPT = IMenuVertic(OPT,MAXOPT,IX,IY,'Menu',ISPC,IFRM,ISTOPT)
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.-2) THEN
        !MOUSEX = InfoInput(62)
        !MOUSEY = InfoInput(63)
        !ELSE IF (KEXIT.EQ.23) THEN
        !...
        !INTERACTER Subroutine Reference Input Control Parameters
        !2-59
    end subroutine

    subroutine InMultiple(TAGCHR)
        character(len=*) TAGCHR ! Tag character to be used to mark selected
        ! menu items in multiple choice menus
        ! (blank to disable multiple choice menu mode)
        ! Short-name : INMULT
        ! Enables or disables multiple choice mode when using the IMenuHoriz,IMenuScroll, IMenuVerticHelp and IMenuVertic functions. When this
        ! mode is enabled, several options can be selected by the user by pressing the 'toggle
        ! menu option' key (usually F2 though this is redefinable). The specified tag character
        ! will then appear beside each selected option. By default, multiple choice mode is
        ! disabled and menus select a single option in the usual way. To return to single option
        ! mode after using the multiple choice feature, call InMultiple with a blank
        ! argument. The current tag character can be interrogated via InfoInput(65).
        ! When multiple choice mode has been enabled, the array of option strings passed to
        ! IMenuHoriz/IMenuScroll/IMenuVerticHelp/IMenuVertic must have
        !the first character of each option set to either a blank or the tag character (e.g. an '*').
        !Hence, it is possible to offer a default set of pre-selected options by tagging certain
        !options before entering the menu routine. The menu function will then toggle the first
        !character of a menu option between a blank and the tag character when control key 34
        !is pressed. On exit from a menu function, simply scan through the option string array
        !checking the first character of each string to see whether it contains the tag character.
        !When multiple choice input is enabled, the effect of clicking a mouse button on a menu
        !item is changed. Instead of confirming the menu item, it is toggled on/off. The mouse
        !can still be used to exit from a menu in multiple choice mode by clicking outside of the
        !menu (see InMouseOptions(2,n)). Alternatively, specific mouse buttons can be
        !assigned to signify 'toggle+confirm' or 'confirm-only', when clicked on a multiple
        !choice menu option. See InMouseOptions(103/104,n).
        !e.g. CHARACTER*8 NAME(5)
        !DATA NAME/' John',' Terry',' Michael',' Graham',' Eric'/
        !C enable multiple choice mode by setting tag character to *
        !CALL InMultiple('*')
        !IOPT = IMenuVertic(NAME,5,IX,IY,' ',0,1,IOPT)
        !C extract selected options from the list
        !DO 100 I = 1,5
        !IF (NAME(I)(:1).EQ.'*') WRITE(LFN,*) NAME(I)(2:)
        !100 CONTINUE
        !C return to single-option mode
        !CALL InMultiple(' ')
    end subroutine

    subroutine InPopup(MODE)
        character(len=*) MODE ! 'ON' : switch single pop-up mode on ) upper or
        ! = 'LI' : select linked pop-up mode ) lower case
        ! = Any other value to disable pop-up mode
        ! Short-name : INPOP
        ! Selects the 'pop-up' mode for the pointer/highlight menu routines in the MN group and
        ! the fixed field input-box routines (InDoubleXY, InStringXY, InStringXYDef,etc.). Three pop-up modes are available, namely single, disabled or linked. The default
        ! mode as selected at start-up by IScreenOpen is 'disabled'.
        ! Input Control Parameters INTERACTER Subroutine Reference
        ! 2-60
        ! Single pop-up mode
        ! When enabled, this feature causes menus and input boxes to be overlaid on top of
        ! whatever is already on the screen. The original screen contents are then restored as soon
        ! as a selection has been made or a value has been entered. This is simpler to use than
        ! linked mode (see below), since each pop-up uses its own workspace and operates
        ! entirely independently of other parts of the library.
        ! Disabled pop-up mode
        ! When the pop-up feature is switched off, menu or field contents remain on the screen.
        ! The underlying screen area cannot be restored.
        ! Linked pop-up mode
        ! Pop-up menus and input boxes can alternatively be linked. This is the most complex
        ! mode of operation, but one which offers greatest flexibility. It is referred to as 'linked'
        ! mode for two reasons :
        ! 1) Menus and/or input boxes can be linked together, with the original screen contents
        ! only being restored at the end of the chain.
        ! 2) For the duration of the chain, the menu/input-box routines are linked to the window
        ! management system. Each menu or input box opens its own pop-up window, using
        ! the window manager's workspace. This also means that windows can also be
        ! opened as part of the chain using the usual IWinOpen/IWinOpenTitle
        ! routines.
        ! When InPopup('LI') is called, a new menu chain is opened (and any existing
        ! chain is closed, but see below). Thereafter, each call to a menu/input-box routine opens
        ! a pop-up window of exactly the size occupied by the menu or box. Each menu/box
        ! becomes another window in the stack which can be closed using a IWinClose(1)
        ! call. Alternatively, the entire chain can be closed with another call to InPopup with
        ! any argument. Each time InPopup is called it will check whether there is an
        ! outstanding menu chain and close all windows which have been opened since that
        ! chain was created with a InPopup('LI') call. It is thus important to 'bracket'
        ! sections of code which manipulate linked menus with InPopup('LI') and
        ! InPopup('ON')/InPopup(' ') calls. This way, INTERACTER knows that it
        ! should go back to treating menus and windows as separate entities.
        ! Linked pop-up mode should be used with care, since it is possible to unwittingly open
        ! more windows than intended, particularly where 'walking' menus are constructed which
        ! allow a user to move both down and up a menu chain. When 'unwinding' back up a
        ! menu chain and re-entering a previous menu, the ISTOPT (initially highlighted option)
        ! argument must be negative to signify that the menu is not to be redrawn and that no
        ! pop-up is required. This will prevent an additional window being opened over the top
        ! of the existing menu. See the LINKMENU demonstration program for an example of
        ! how to use linked menu mode. The example is a little too long to reproduce here.
        ! In linked pop-up mode, the size of menu which can be displayed is limited by the
        ! available space in the window buffer. This limit is documented under IWinAction.
        ! In single pop-up mode, any size of menu can be displayed, within the limits of the
        ! physical screen size.
        ! INTERACTER Subroutine Reference Input Control Parameters
        ! 2-61
        ! Not all displays are able to restore graphics data if a pop-up is used in a graphics mode.
        ! Use InfoGrScreen to test this feature.
        !e.g. CHARACTER*12 OPTION(4)
        !DATA OPTION/'Help Screen','Run Analysis',1 'Edit Data' ,'Quit Program'/
        !CALL InHighlight('BLU','WHI')
        !C use single pop-up mode to make the menu
        !C close as soon as a selection has been made
        !CALL InPopup('ON')
        !IOPT = IMenuVertic(OPTION,4,20,5,'Pop Up Menu',1,1,1)
        !CALL InPopup('OFF')
        !Portability notes :
        !DOS :
        !Menus and input-boxes can pop-up over both text and graphics. To pop-up over
        !graphics, larger amounts of screen data must be buffered than in a text mode. Graphics
        !screen data is buffered to a memory buffer of approx 400k, which is shared with the
        !text window manager. Data is compressed in this buffer. The available buffer space for
        !a menu or input-box in 'single pop-up' mode therefore depends on whether any pop-up
        !windows are currently open. In the rare situation where a pop-up requires more buffer
        !space than is available in the memory buffer, excess screen data is buffered to disk. The
        !location of the disk-buffer follows the same rules as described in the IWinAction
        !Portability notes. In practice, a disk buffer is only likely to be used in 256 colour
        !SVGA modes, for pop-up menus which occupy very large screen areas.
        !Xlib and MS Windows :
        !Graphics mode menu/pop-up areas are saved and restored via bit-images. If a resize
        !event occurs between the opening and closing of a pop-up menu, the underlying
        !graphics area will not be restored. It is up to the calling program to process the
        !expose/resize event and repaint the program window.
        !ReGIS :
        !In ReGIS graphics mode, only underlying text screen data is restored.
        !Tektronix :
        !Pop-up mode is only supported in graphics mode on displays which support
        !independent text/graphics output (e.g. xterm, Tek 410x/420x, EM4105, Tera Term).
    end subroutine

    subroutine InSelectionChars(SELCHARS)
        character(len=*) SELCHARS ! List of single-key selection characters to highlight
        ! in subsequent horizontal/vertical menus
        ! or = 'I' to highlight initial characters of menu options
        ! or = ' ' to disable highlighting of option selection chars
        ! Specifies the characters to be used in subsequent horizontal and vertical menus for
        ! single key selection. The specified characters will also be underlined. Where
        ! underlining is not available, a substitute character highlight can be specified via
        ! InHighlightChar (the default substitute is bold/white).
        ! Input Control Parameters INTERACTER Subroutine Reference
        ! 2-62
        ! Each character in SELCHARS should specify a character in the corresponding menu
        ! item in a subsequently displayed menu. That character will be highlighted and the user
        ! can press that key to make a menu selection, according to the method determined by
        ! InSingle. If SELCHARS is specified as 'I', the initial letter of each menu option is
        ! highlighted and used for option selection. This is the initial default. A blank in
        ! SELCHARS disables single key highlighting, though single key selection will still be
        ! available if enabled by InSingle.
        ! Characters in SELCHARS can be in upper or lower case and do not need to match the
        ! case of the corresponding characters in the menu. The menu routines will highlight the
        ! option selection character in the case specified in the menu option string, not the case
        ! specified to SELCHARS.
        ! The routines affected by InSelectionChars are as follows :
        ! IMenuHoriz IOutMenuHoriz
        ! IMenuHorizHelp IOutMenuHorizHelp
        ! IMenuVertic IOutMenuVertic
        ! IMenuVerticHelp IOutMenuVerticHelp
        ! The setting of SELCHARS is ignored in scrolling, two-way and cycling menus, though
        ! single key-selection will still be available in those routines if enabled by InSingle.
        !e.g. CHARACTER*4 MENU(3)
        !DATA MENU/'Open','Edit','Exit'/
        !CALL InSelectionChars('OEX')
        !IOPT = IMenuVertic(MENU,4,IX,IY,' ',0,IFRAME,ISTOPT)
        !CALL InSelectionChars(' ')
    end subroutine

    subroutine InsertOver(MODE)
        character(len=*) MODE ! Any string starting with 'I' to select insert mode
        ! = Any string starting with 'O' to select overtype mode
        ! = Any other string will leave current mode unchanged
        ! Short-name : INSOVR
        ! Selects the insert/overtype mode to be used by the fixed field input routines. The
        ! default state as set by IScreenOpen is 'insert' mode. Remember that the user can
        ! reset the mode whilst typing by pressing the 'toggle insert mode' key as defined by
        ! InControlKey or the initialisation file. InsertOver provides a means of ensuring
        ! the initial insert/overtype state on entry to one of the fixed field input routines.
        ! An on-screen insert/overtype status message display is available using
        ! InsertOverMessage. If hardware cursor size control is supported, the current
        ! insert/overtype state is shown automatically by means of a block or underline cursor.
        !e.g. CALL InsertOver('Over')
        !CALL InString(STRING,LENGTH)
        !INTERACTER Subroutine Reference Input Control Parameters
        !2-63
    end subroutine

    subroutine InsertOverMessage(IX,IY,MESSOV,MESSIN)
        integer IX ! Column at which to display insert/overtype message
        ! (zero for no message)
        integer IY ! Row on which to display insert/overtype message
        character(len=*) MESSOV ! Overtype message (up to 10 characters)
        character(len=*) MESSIN ! Insert message (up to 10 characters)
        ! Short-name : INSMES
        ! Defines the position and wording of an optional field indicating the current
        ! insert/overtype status. Calling this routine has no immediate effect, but controls the
        ! action taken by the fixed field input routines (InString, InInteger, etc.) and the
        ! file editor (IWinEditFile). On entry to such a routine, the appropriate overtype or
        ! insert message will be displayed at the specified position. The field will be updated if
        ! the user presses the 'toggle insert/overtype' key.
        ! This feature is optional and by default is disabled. On displays which use a hardware
        ! text cursor INTERACTER usually shows the current insert/overtype state by means of a
        ! block/underline cursor. However, some important display types such as
        ! VT100/VT200/VT300 do not support such a feature. InsertOverMessage is
        ! mainly useful on such displays.
        ! Once enabled, the insert/overtype message feature can be disabled again by calling
        ! InsertOverMessage with a zero IX value. Whilst enabled, the insert/overtype
        ! message is always left on screen on exit from a fixed field input routine. It is the
        ! responsibility of the calling program to clear the message if this is not required.
        ! The size of field in which the messages are printed is determined by the longer of the
        ! two supplied strings. Hence if they were 'Over' and 'Ins' respectively, the message
        ! would always be printed in a 4 character field, with a trailing blank after the 'Ins' when
        ! insert mode is selected.
        ! Note that it is possible to force the insert/overtype message to always appear at the
        ! bottom of the screen regardless of its size, simply by specifying a very large IY value.
        !e.g. CALL InsertOverMessage(1,999,'Over','Ins')
        !CALL InsertOver('O')
        !CALL InStringXY(5,5,' ',0,STRING,LENGTH)
    end subroutine

    subroutine InSingle(ONOFF)
        character(len=*) ONOFF ! 'ON' : Enable single key 'move-and-select' mode
        ! = 'MV' : Enable single key 'move-only' mode
        ! = Any other value to disable single key selection
        ! Short-name : INSING
        ! Selects the single key option selection mode for the menu input routines. All the
        ! routines in the MN group check for single-key selection, when 'move and select' or
        ! 'move-to' mode is enabled. By default, the initial letters of each menu option identify
        ! the single key selection characters. Non-initial letters can be selected, in
        ! horizontal/vertical menus, by calling InSelectionChars. The latter routine also
        ! enables highlighting of single-key selection characters. By default, single-key selection
        ! characters are not highlighted.
        ! Input Control Parameters INTERACTER Subroutine Reference
        ! 2-64
        ! When 'move-and-select' is enabled, single-key selection characters can be pressed to
        ! save moving the highlight bar to the required option and pressing the confirm key. This
        ! is the default mode selected by IScreenOpen.
        ! Alternatively, 'move-only' mode can be enabled. This causes the highlight bar to move
        ! in the same way as the 'move-and-select' mode, but the option is not automatically
        ! confirmed. This mode may prove more appropriate in scrolling menus containing large
        ! numbers of options, possibly organised in alphabetical order.
        ! Where a menu contains more than one occurence of the same option selection character
        !(e.g. 'Edit' and 'Exit' in initial-letter mode), the search for a matching menu option starts
        !from the current menu position. In 'move-only' mode this makes it possible to search
        !through all the items in a menu which begin with a given letter, by repeatedly pressing
        !the appropriate key.
        !On displays which support Alt/key combinations (e.g. DOS, Windows), an Alt/key
        !press such as Alt/E is treated identically to the equivalent key without the Alt modifier.
        !The only exception is when an Alt/key combination has already been defined as an exit
        !key code. So, for example, if 'Edit' is the second option in a menu, pressing E or Alt/E
        !will return InfoInput(55) as 21 and the menu option value as 2. However, if
        !InControlKey(50,512+ICHAR('E')) has been called, pressing Alt/E would
        !cause the menu to exit with InfoInput(55) set to 50 and the menu would return the
        !number of the currently highlighted option.
        !In some situations, (e.g. cycling menus) neither mode may be appropriate, in which
        !case single key menu selection can be disabled completely.
        !e.g. CALL InSingle('OFF')
        !IOPT = IMenuCycle(OPT,NOPT,IX,IY,PROMPT,IFRAME,ISTOPT)
        !CALL InSingle('ON')
    end subroutine

    subroutine InTypeWipe(ONOFF)
        character(len=*) ONOFF ! 'ON' : enable 'type-and-wipe' feature (upper or lower case)
        ! = Any other value to disable 'type-and-wipe'
        ! Short-name : INWIPE
        ! Enables or disables the fixed field input 'type-and-wipe' feature. Enabling this feature
        ! causes the fixed field input routines to automatically clear from the cursor position to
        ! the end of the field if the first key pressed is a printable character. If the initial cursor
        ! position has been set to a value greater than one using InCursorPos, text to the left
        ! of the cursor will be unaffected.
        ! By default the 'type-and-wipe' feature is disabled by IScreenOpen at start up, so
        ! starting to type in a field does not clear its contents.
        !e.g. CALL IOutMessage(
        !1 'Press Enter to accept or type a different value')
        !CALL InTypeWipe('ON')
        !INTVAL = 100
        !IWIDTH = 6
        !CALL InIntegerXYDef(5,5,' ',0,INTVAL,IWIDTH)
        !INTERACTER Subroutine Reference Input Control Parameters
        !2-65
    end subroutine

    subroutine Invisible(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch invisible input mode on
        ! (upper or lower case)
        ! = Any other value to switch invisible input mode off
        ! Short-name : INVISI
        ! Enables or disables invisible input mode for the fixed field input routines in the IN
        ! group. When switched on, text which is typed does not appear on the screen. The
        ! cursor moves in the normal way but spaces are echoed instead of the keys which are
        ! typed. Passwords or other sensitive data can thus be entered without appearing on
        ! screen. By default invisible input mode is switched off by IScreenOpen at start up,so all input is echoed to the screen.
        !e.g. CALL IOutStringXY(15,5,'Enter password : ')
        !CALL Invisible('ON')
        !CALL InString(PASSWD,LENGTH)
        !IF (PASSWD(:LENGTH).NE.'POOH') CALL IOsExitProgram('Hacker !',99)
        !CALL Invisible('OFF')
        !
        !INTERACTER Subroutine Reference Interactive Option Identification
        !2-67
        !2.5 Group II : Interactive Option Identification
        !The routines in this group provide a number of predefined menus and forms which
        !allow various INTERACTER-related options to be selected interactively by the enduser.
        !Typically, these routines consist of a menu or form followed by a call to the
        !relevant INTERACTER routine which selects the required option, e.g.
        !IdGrHardcopyDriver displays a hardcopy drivers menu then calls
        !IGrHardCopySelect.
        !The IdDigitiser, IdDisplay, IdMouse, IdPlotter, IdPrinter and
        !IdPrinter2 routines allow hardware types to be identified, providing menu-driven
        !interfaces to the IDigitiser, IDisplay, IMouse, IPlotter, IPrinter and
        !IPrinter2 routines respectively.
        !IdScreenMode allows text or graphics screen modes to be selected.
        !IdGrHardcopyDriver displays a menu of graphics hardcopy drivers then calls
        !IGrHardCopySelect to select the required driver. IdGrHardcopyOptions is a
        !complementary routine which allows the options associated with the currently selected
        !hardcopy driver to be edited. IdScreenDumpOptions performs the same function
        !for graphics screen dump options. IdPgStyles provides an interactive interface to
        !the IPgStyle routine.
        !IdFilename allows a filename to be selected or entered and incorporates a directory
        !tree browsing facility. The file selecter window title can be set via
        !IdFilenameTitle.
        !IdGrHardcopyOptions, IdScreenDumpOptions and IdPgStyles all use
        !pre-defined forms which are suplied as IFD files. These must be present in the current
        !directory at run-time or in the directory defined by the INTFMDIR o.s. variable or the
        !FORMDIR initialisation file keyword (see chapters 3 and 14 of the User Guide).
        !A message-window routine, IdMessage, displays a message in a centred window and
        !allows the user to press a button. By default OK/Cancel/Help buttons are offered, but
        !they can be redefined using IdFormButtons which allows program specified 'user'
        !buttons to be added to any of the pre-defined forms.
        !Most of the menu and form handling routines in this group have very short argument
        !lists. Menu/form layout options are controlled by the IdMenuOptions routine.
        !Forms are presented in a window which is opened automatically.
        !In all of the menu/forms presented by the routines in this group, the current selection
        !remains unchanged if the 'quit' key is pressed. The same is also true for 'click-outside'
        !(see InMouseOptions(2,n)).
    end subroutine

    subroutine IdDigitiser(IY)
        integer IY ! Start screen line for menu
        ! Short-name : IIDIGT
        ! Interactively identifies the digitiser type. The user is asked to select from a menu of the
        ! digitiser types supported by the current implementation of INTERACTER.
        ! The IY argument specifies the vertical position of the menu. The style and layout of the
        ! menu can be modified by an earlier call to IdMenuOptions.
        ! Interactive Option Identification INTERACTER Subroutine Reference
        ! 2-68
        ! This routine need only be used if IScreenOpen/IDigitiser have been forced to
        ! select a default digitiser type. This situation can be checked for by calling the
        ! InfoHardware function with a parameter of 24.
        ! Once the user has identified the digitiser, IdDigitiser calls IDigitiser to
        ! ensure that INTERACTER knows precisely what type of digitiser (if any) is to be used.
        ! See chapter 13 of the User Guide for a list of the supported digitiser types.
        !e.g. CALL IScreenOpen(' ','P',640,480,16)
        !C has digitiser been reliably identified ?
        !IF (InfoHardware(24).EQ.0) THEN
        !CALL IClearScreen
        !CALL IOutCentre(2,'Digitiser Identification Required')
        !CALL IdDigitiser(4)
        !ENDIF
    end subroutine

    subroutine IdDisplay(IY)
        integer IY ! Start screen line for prompts and menu
        ! Short-name : IIDISP
        ! Interactively identifies the display type and clears the screen. The user is asked to select
        ! from a menu of the displays supported by the current implementation of INTERACTER.
        ! The IY argument specifies the vertical position of the menu. The style and layout of the
        ! menu can be modified by an earlier call to IdMenuOptions.
        ! This routine need only be used if IScreenOpen/IDisplay have been forced to
        ! select a default display type. This situation can be checked for by calling the
        ! InfoHardware function with a parameter of 20.
        ! Once the user has identified the display, IdDisplay automatically calls IDisplay
        ! to ensure that INTERACTER knows precisely what screen facilities are available.
        ! See chapter 13 of the User Guide for lists of the supported display types.
        !e.g. CALL IScreenOpen(' ','T',80,25,16)
        !C has display been reliably identified ?
        !IF (InfoHardware(20).EQ.0) THEN
        !CALL IClearScreen
        !CALL IOutCentre(2,'Display Type Identification Required')
        !CALL IdDisplay(4)
        !ENDIF
        !Portability notes :
        !MS Windows :
        !Since there is only one display type, this routine has no effect.
        !INTERACTER Subroutine Reference Interactive Option Identification
        !2-69
    end subroutine

    subroutine IdFilename(PATH)
        character(len=*) PATH ! File name
        ! On entry : Initial default file/directory name
        ! On exit : Full pathname of selected file
        ! Short-name : IIFILE
        ! Interactively identifies a filename. A form is presented, consisting of enterable filename
        ! and directory fields, file and directory menus and OK/Cancel buttons. The user can
        ! browse around the directory tree by selecting directories from the directory menu. Files
        ! can be selected from the file menu or typed into the filename field. Selecting a filename
        ! from the files menu updates the contents of the enterable filename field, but does not
        ! exit the form.
        ! The value supplied in PATH is split into a local filename and the directory name, each
        ! of which appears in the appropriate form field. If the filename contains wildcards, these
        ! are used to generate the file menu, otherwise all files in the directory are matched. If no
        ! directory is specified in PATH, the current directory is displayed.
        ! Entering wildcarded file specifications in the filename field causes IdFilename to
        ! update the files menu accordingly. Pressing the confirm key whilst the highlight is on
        ! the filename field or clicking on either the OK or Cancel buttons, exits the form.
        ! Pressing any other valid form exit key anywhere in the form also exits the form.
        ! On exit, PATH contains the selected filename, unless the 'quit' key was pressed or the
        ! Cancel button was used to exit the form. Since IdFilename uses the Form Editor
        ! IFormEditUser, the exit code is available in the normal manner via
        ! InfoInput(55).
        ! Up to 3 program defined 'user buttons' can be added to OK/Cancel, via
        ! IdFormButtons. Clicking on one of these buttons exits immediately, regardless of
        ! whether a filename has been selected (in the same manner as the Cancel button). The
        ! code returned via InfoInput corresponds to the IBCODE value supplied to
        ! IdFormButtons.
        ! Version-dependent limits apply to the number of entries which can be displayed in the
        ! file/directory menus and the length of file/directory names which can be displayed (see
        ! the Portability notes). When a menu is unable to display all the required file or
        ! directory names in a menu, the final menu entry appears as '<more>'. If there are no
        ! matching files in a directory, '<no files>' appears in the files menu. If there are no
        ! selectable sub-directories, '<no dirs>' appears in the directories menu.
        ! In all directories except for the root, a '..' entry appears at the top of the directory menu.
        ! This can be selected on all operating systems to move to the parent directory. This
        ! makes it possible to move up and down the directory tree simply by selecting items on
        ! the directory menu. On operating systems which support disk/drive selection, a drive
        ! specification can be entered in the directory name field to move to the required drive.
        ! Interactive Option Identification INTERACTER Subroutine Reference
        ! 2-70
        ! The form is presented in a window which is opened automatically. The window action
        ! (frame, pop-up, etc.) is controllable by an earlier call to IWinAction. The window
        ! title can be set via IdFilenameTitle. The window width is determined from the
        ! form definition file and will vary between operating systems because of differences in
        ! maximum filename lengths. The position of the window is determined by the
        ! IdMenuOptions options 1 and 11. The number of visible options in the file and
        ! directory menus (and hence the window height) is controlled via IdMenuOptions
        ! option 6. The colours of the Filename/Directory title fields and the button fields can be
        ! set via IdMenuOptions options 8 and 10 respectively. Alternatively, the colour
        ! scheme and field frame styles for the whole of the form can be set via
        ! IdMenuOptions option 13. The window-close action on exit is controllable via
        ! IdMenuOptions option 12.
        !e.g. CHARACTER*50 PATH
        !LOGICAL EXISTS
        !CHARACTER*3 FSTAT
        !:
        !CALL IWinAction('FPC')
        !PATH = 'c:\datafile\*.dat'
        !CALL IdFilename(PATH)
        !IF (InfoInput(55).NE.23) THEN
        !INQUIRE(FILE,EXIST=EXISTS)
        !IF (EXISTS) THEN
        !FSTAT = 'OLD'
        !ELSE
        !FSTAT = 'NEW'
        !ENDIF
        !OPEN(20,FILE=PATH,STATUS=FSTAT)
        !Portability notes :
        !Four factors vary between implementations :
        !Maximum name length in menus : For reasons of limited screen space, the maximum
        !length of name offered in the file/directory menus is less than the maximum filename
        !length allowed by certain operating systems.
        !Maximum enterable name length : The Filename and Directory fields both use longstrings
        !so that a full filename or pathname can be entered where it is longer than can be
        !held in the menu.
        !Maximum directories and Maximum files : As noted earlier, there are hardcoded limits
        !on the total number of files and directories which can be displayed in the corresponding
        !menus (the figures quoted below are approximate).
        !o.s. Max name Max enterable Max Max
        !length in menus name length Directories Files
        !DOS 12 80 200 1600
        !Win32 20 255 200 1000
        !Unix 20 255 200 1000
        !VMS 30 255 100 600
        !DOS and Windows :
        !Entering a drive spec such as D: in the directory field would move to the current
        !directory on drive D. Entering D:\ in the same field would move to the root directory
        !on that drive.
        !INTERACTER Subroutine Reference Interactive Option Identification
        !2-71
        !Unix :
        !Since IOsDirList is used internally, the name of the temporary directory listings file
        !can optionally be specified using the INTLIST environment variable.
    end subroutine

    subroutine IdFilenameTitle(TITLE)
        character(len=*) TITLE ! File selecter window title (max 50 chars)
        ! Defines the window title to be used by the file selecter routine, IdFilename. The
        ! default title is 'File Selecter'.
        !e.g. CALL IdFilenameTitle('Select project File')
        !CALL IdFilename(PROJFILE)
    end subroutine

    subroutine IdFormButtons(NUMBUT,USRBUT,IBCODE)
        integer NUMBUT ! Number of buttons (1 to 3) or 0 to disable user-buttons
        character(len=*) USRBUT(:) ! Array of NUMBUT button strings (max 6 chars each)
        integer IBCODE(:) ! Array of NUMBUT button exit codes (21-23/26-28/36-70)
        ! Defines 'user-buttons' to be displayed by IdFilename, IdPgStyles,IdScreenDumpOptions, IdGrHardcopyOptions and IdMessage. The first
        ! four routines all display OK/Cancel buttons and add the specified user-buttons if
        ! defined. IdMessage is slightly different, in that the specified buttons replace the
        ! default OK/Cancel/Help buttons rather than adding to them.
        ! The button codes in IBCODE specify the exit 'key' code which will be returned by the
        ! pre-defined form routines via InfoInput(55) if that button is pressed. These values
        ! should normally be one of the usual INTERACTER form exit-key values (i.e. 21-23, 26-
        ! 28 or 36-70). As always, a user-definable key can also be attached to these codes by
        ! calling InControlKey.
        ! The maximum number of user-buttons is three (or two in IdPgStyles).
        !e.g. CHARACTER*6 BUTTS(3)
        !INTEGER IBCODE(3)
        !DATA BUTTS /' Yes ',' No ','Cancel'/
        !DATA IBCODE/21,36,23/
        !100 CALL MyMainMenu
        !CALL IWinAction('BFP')
        !CALL IdFormButtons(3,BUTTS,IBCODE)
        !150 CALL IdMessage('File not saved. Save it now ?',1 'Exit from program',0)
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !CALL SaveFile
        !ELSE IF (KEXIT.EQ.23) THEN
        !GOTO 100
        !ELSE IF (KEXIT.NE.36) THEN
        !GOTO 150
        !ENDIF
        !CALL IScreenClose
        !END
        !Interactive Option Identification INTERACTER Subroutine Reference
        !2-72
    end subroutine

    subroutine IdGrHardcopyDriver(IY)
        integer IY ! Start screen line for prompt and menu
        ! Short-name : IIGHCD
        ! Interactively identifies the required graphics hardcopy driver. The user is asked to
        ! select from a menu of the currently linked drivers, as selected by
        ! IGrHardCopySelect. The drivers which are linked into the current program are
        ! identified automatically. If no drivers are available (because a null version of
        ! IGrHardCopySelect has been linked) an error code is returned via
        ! InfoError(1) and no menu is displayed.
        ! By default, the IY argument specifies the position of a prompt line which is displayed
        ! above a menu generated by IMenuHoriz. However, the style and layout of the menu
        ! can be modified by an earlier call to IdMenuOptions.
        ! Once the user has identifed a hardcopy driver, IdGrHardcopyDriver calls
        ! IGrHardCopySelect to select that driver. The rules on calling order for
        ! IGrHardCopySelect therefore also apply to IdGrHardcopyDriver, i.e. it must
        ! be called before IGrHardCopyOptions/IGrHardCopy.
        ! The selected graphics hardcopy driver can be identified on exit via
        ! InfoGrHardcopy(100).
        !e.g.
        !C vertical pop-up scrolling menu with no prompt above menu
        !CALL IdMenuOptions(2,2)
        !CALL IdMenuOptions(3,0)
        !CALL InPopup('on')
        !CALL IdGrHardcopyDriver(2)
        !CALL InPopup(' ')
        !C get current driver number
        !IHDRIV = InfoGrHardcopy(100)
        !CALL IGrHardCopyOptions(1,NX(IHDRIV))
        !CALL IGrHardCopyOptions(2,NY(IHDRIV))
        !CALL IGrHardCopy(' ')
        !Errors :
        !ErrNullMenu (45) : Null menu (no hardcopy drivers available)
    end subroutine

    subroutine IdGrHardcopyOptions(IUNIT)
        integer IUNIT ! Image size/position units :
        ! HcPoints (0) = Points
        ! HcInches (1) = Inches
        ! HcCentimetres (2) = cm
        ! HcMillimetres (3) = mm
        ! Short-name : IIGHCO
        ! Interactively identifies options for the currently selected graphics hardcopy driver. A
        ! form is presented, consisting of all the options supported by IGrHardCopyOptions
        ! for the current driver.
        ! INTERACTER Subroutine Reference Interactive Option Identification
        ! 2-73
        ! The currently selected hardcopy driver is identified automatically and a suitable form
        ! definition is loaded from disk using IFormLoad. These forms are supplied in a forms
        ! directory as part of the standard INTERACTER distribution, with names such as
        !iighcoXX.ifd where XX identifies the driver and possibly the device type. e.g. the
        !form for driver number 4 (raster) and an HP PaintJet is called iighco4p.ifd. These
        !form definition files must be in the current directory at run-time or in the directory
        !identified by the INTFMDIR o.s. variable or the FORMDIR initialisation file keyword.
        !If the form file cannot be found an error code of 1 is set.
        !Other error conditions can arise, in which case no form is displayed :
        !  If no hardcopy driver is currently selected (or no drivers have been linked) error 46
        !is returned.
        !  If the raster hardcopy driver is selected, but a text-only printer is selected, error 5 is
        !generated.
        !  If the Windows Print Manager driver is selected but no default Windows printer is
        !available error 63 is returned.
        !Once a form has been successfully loaded, the current hardcopy options are identified
        !using InfoGrHardcopy and the form is displayed/edited using IFormShow and
        !IFormEdit. If the user confirms their choice (by pressing the 'confirm' key or by
        !clicking on the 'OK' button), IGrHardCopyOptions is called to update each of the
        !modified options. As a consequence, IdGrHardcopyOptions must be called in the
        !same relative position within a program as IGrHardCopyOptions, i.e. after
        !IGrHardCopySelect or IdGrHardcopyDriver and before IGrHardCopy.
        !The image size and position fields on the various hardcopy options forms can be
        !expressed in various units, selected by the IUNIT argument. Internally,IdGrHardcopyOptions converts the entered values to points, for the sake of
        !IGrHardCopyOptions. If driver #6 is selected (raster image file) the IUNIT
        !argument is not used, since the only meaningful units are pixels.
        !The form is presented in a window which is opened automatically. The window action
        !(frame, pop-up, etc.) is controllable by an earlier call to IWinAction. The window
        !size will vary between drivers. The position of the window is determined by the
        !IdMenuOptions options 1 and 11. The colours of the help and button fields can be
        !set via IdMenuOptions options 9 and 10 respectively. Alternatively, the colour
        !scheme and field frame styles for the whole of the form can be set via
        !IdMenuOptions option 13. The window-close action on exit is controllable via
        !IdMenuOptions option 12.
        !Each form contains OK and Cancel buttons which cause InfoInput(55) to return
        !21 or 23 in the normal manner. Up to 3 program defined 'user buttons' can be added to
        !the form, via IdFormButtons. The code returned via InfoInput corresponds to
        !the IBCODE value supplied to IdFormButtons.
        !Each form includes one or more menu fields. These all have pop-up options. A full
        !vertical menu can be displayed by pressing control key 34 or the right mouse button in
        !a menu field. (See InMouseOptions(102,n)).
        !See also IdScreenDumpOptions which performs the equivalent task for graphics
        !screen dump options.
        !Interactive Option Identification INTERACTER Subroutine Reference
        !2-74
        !e.g. CALL IdGrHardcopyDriver(0)
        !CALL IdGrHardcopyOptions(HcCentimetres)
        !CALL IGrHardCopy(' ')
        !Errors :
        !ErrFileOpen (1) : Unable to open form definition file
        !ErrPrintGfx (5) : Graphics not supported on selected printer type
        !ErrNoDriver (46) : No hardcopy driver currently selected
        !ErrNoWinPrinter (63) : No Windows Print Manager printer available
    end subroutine

    subroutine IdMenuOptions(NOPTN,IVALUE)
        integer NOPTN ! Option number (see below)
        integer IVALUE ! Option value (see below)
        ! NOPTN IVALUE Default
        ! MenuColumn (1) Column of menu/form-window(0=centred) Centred
        ! MenuType (2) Menu type Vertical
        ! Horizontal (1) : horizontal
        ! Vertical (2) : vertical
        ! MessageAbove (3) Message above menu (0/1 = no/yes) No
        ! MenuTitle (4) Vertical menu title (0/1 = no/yes) Yes
        ! MenuFrame (5) Frame (0/1 = no/yes) Yes
        ! ScrollNum (6) Number of visible scrolling menu items 10
        ! MenuModes (7) Mode types to offer in IdScreenMode All text
        ! AllText (0) : all text modes
        ! ColourText (1) : colour text modes
        ! AllGfx (2) : all graphics modes
        ! ColourGfx (3) : colour graphics modes
        ! HeaderColour (8) Header field colours in forms B/yellow on red
        ! HelpColour (9) Help field colours in forms B/yellow on red
        ! ButtonColour (10) Button colours in forms B/green on black
        ! FormRow (11) Row of form-window (0=centred) Centred
        ! WinCloseAction (12) Window-close action on exit from form Clear/Remove
        ! NoWinClose (-1) : Do not close window
        ! NoWinRemove (0) : Close window but
        ! do not clear/remove
        ! CloseRemove (1) : Close window and clear/remove
        ! FormStyle (13) Form style (field colours & frame types) Windows3D
        ! FromFile (0) : As defined in form file
        ! Windows2D (1) : Windows-like colours
        ! Windows3D (2) : Windows-like colour
        ! and 3D field frames
        ! Short-name : IIMOPT
        ! Include : interii.inc, intergen.inc
        ! Defines options which control the behaviour of the interactive identification menus
        ! and forms displayed by the other routines in this group.
        ! Option 1 controls horizontal menu and form positioning. By default this is zero which
        ! gives centred menus/forms.
        ! INTERACTER Subroutine Reference Interactive Option Identification
        ! 2-75
        ! Since the menu routines in the II group act as an interface to one of the menu functions
        ! in the MN group, the type of menu function to be called can be selected using option 2.
        ! Setting IVALUE to 1 selects a horizontal menu using IMenuHoriz. A value of 2
        ! selects a vertical menu (IMenuScroll in all II group menu routines, except
        ! IdGrHardcopyDriver, which uses IMenuVertic).
        ! The menu routines in the II group can display messages of the form 'Please identify
        ! your <hardware type> ...' above the menu. These are helpful but prevent these menu
        ! routines being used in pop-up mode. They are therefore disabled by default. (Note that
        ! enabling the messages above the menu changes the interpretation of the IY parameter
        ! to an II group menu routine. When messages are enabled, IY specifies the first line on
        ! which those messages will be displayed, with the menu displayed immediately below.)
        ! If a vertical menu is selected, a title such as 'Screen Mode' or 'Printer' is displayed. This
        ! can be suppressed using option 4 if not required.
        ! Menus are normally displayed with a frame, but this can be disabled when not required
        ! using option 5.
        ! Option 6 controls the number of visible items in a scrolling menu and corresponds to
        ! the NVISIB argument.
        ! Option 7 determines the type of screen modes which are offered by the
        ! IdScreenMode menu. The choice is between modes which are suitable for selection
        ! as text modes or as graphics modes (on some displays, certain modes may fall into both
        ! categories and may therefore appear in both types of menu). Additionally, this option
        ! can be used to specify that all modes of the specified type are to be offered or only
        ! those with more than two colours available.
        ! Options 8-10 control field colours in forms displayed by IdGrHardcopyOptions,IdScreenDumpOptions, IdPgStyles and IdFilename. IVALUE should be
        ! specified as :
        ! foreground colour + (background colour * 16)
        ! where foregound and background colours are as for ITextColourN and
        !IFormAttributeN. e.g. for bold yellow text on a green background IVALUE would
        !be 10+3*16. To return to the default colour setting for the specified field type, set
        !IVALUE to zero. Options 8 to 10 are ignored on monochrome screens. Option 8 is not
        !used by IdGrHardcopyOptions or IdScreenDumpOptions. Option 9 is not
        !used by IdFilename.
        !Option 11 determines the vertical position of windows opened by the pre-defined form
        !routines (IdGrHardcopyOptions, IdScreenDumpOptions, IdPgStyles,IdFilename). By default this is zero (centred vertically).
        !Option 12 determines whether the predefined form routines close the window which
        !they have opened. If IVALUE is 0 or 1 it is used by the form routines as the argument
        !in a call to IWinClose on exit. If IVALUE is -1, the window is not closed and the
        !caller must decide when/how to close the window.
        !Interactive Option Identification INTERACTER Subroutine Reference
        !2-76
        !Option 13 allows the style of the pre-defined forms (as used by IdFilename,IdPgStyles, IdGrHardcopyOptions and IdScreenDumpOptions) to be
        !changed. The form can use the field colours and frame styles specified in the form
        !definition files or a more Windows-like form style by setting IVALUE to 1.
        !Additionally, IVALUE=2 has the same effect but also changes the field frames from a
        !2D to a 3D style on displays which support graphical frames. The 3D Windows-like
        !style is the default. The Windows-like form styles are best used with either a bold-white
        !or normal-white (i.e. pale grey) window background.
        !e.g. C display a scrolling printer type menu in 'pop-up' mode
        !C at column (15,8)
        !CALL InPopup('ON')
        !IX = 15
        !IY = 8
        !CALL IdMenuOptions(1,IX)
        !CALL IdPrinter(IY)
        !Portability notes :
        !Serial terminals and workstations :
        !To ensure the widest possible portability when selecting display type, IdDisplay
        !ignores options 1 and 5 when the IMenuHoriz menu function is selected. The
        !IdDisplay menu does not use a frame on such displays and the menu is always
        !centred in this case. The use of option 2 to select IMenuScroll with IdDisplay
        !on serial terminals and workstations is not generally recommended.
    end subroutine

    subroutine IdMessage(MESSAGE,TITLE,NUMBUT)
        character(len=*) MESSAGE ! Message to display in window
        character(len=*) TITLE ! Window title (none if blank)
        integer NUMBUT ! Number of pre-defined buttons :
        ! 1 : OK button
        ! 2 : OK and Cancel buttons
        ! 3 : OK, Cancel and Help buttons
        ! or = 0 : Use buttons set by IdFormButtons
        ! Displays a message in a window at the centre of the screen, with up to three buttons
        ! below the message. The routine exits when one of the buttons is selected or an exit key
        ! is pressed. InfoInput(55) returns the code of the selected button or the number of
        ! the exit key.
        ! By default, OK, Cancel and Help buttons are offered which return the conventional
        ! INTERACTER exit codes of 21, 23 or 22 respectively. A different set of button strings
        ! and exit codes can be set via IdFormButtons. Pass NUMBUT as zero if program
        ! defined buttons are to be used. At least one button must be specified, either by setting
        ! NUMBUT=1 or by setting up at least one user-button via IdFormButtons. If
        ! NUMBUT is less than zero, the routine will exit without any action. If NUMBUT is greater
        ! than three, all three default buttons are used. In either case error code 52 will be set.
        ! The left/right cursor keys can be used to move the highlight between the available
        !buttons. The initial letters of the button strings can also be used to exit (e.g. O for OK).
        !Alt/key combinations can also be used for the same purpose (e.g. Alt/O for OK). (Note :
        !Internally control keys 62-70 are reserved for this purpose, though their original values
        !are restored on exit.)
        !INTERACTER Subroutine Reference Interactive Option Identification
        !2-77
        !Internally, IdMessage uses IFormEdit, so any existing form definition will be lost
        !if this routine is called.
        !The message and buttons are presented in a window which is opened automatically.
        !The window action (frame, pop-up, etc.) is controllable by an earlier call to
        !IWinAction. The window size is calculated automatically. The colour of the button
        !fields can be set via IdMenuOptions option 10. Alternatively, the button
        !colours/frame-styles can be set via IdMenuOptions option 13. The window-close
        !action on exit is controllable via IdMenuOptions option 12.
        !e.g.
        !100 CALL MyMainMenu
        !:
        !CALL IWinAction('BFP')
        !150 CALL IdMessageUser('File not saved. Save it now ?',1 'Exit from program',2)
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !CALL SaveFile
        !ELSE IF (KEXIT.EQ.23) THEN
        !GOTO 100
        !ELSE
        !GOTO 150
        !ENDIF
        !CALL IScreenClose
        !END
        !Errors :
        !ErrMsgButtons(52) : Invalid number of buttons specified
    end subroutine

    subroutine IdMouse(IY)
        integer IY ! Start screen line for prompts and menu
        ! Short-name : IIMOUS
        ! Interactively identifies the Mouse type. The user is asked to select from a menu of the
        ! mice supported by the current implementation of INTERACTER.
        ! The IY argument specifies the vertical position of the menu. The style and layout of the
        ! menu can be modified by an earlier call to IdMenuOptions.
        ! This routine need only be used if calling InfoHardware with a parameter of 13
        ! reveals that no mouse is fitted. This may be due to IScreenOpen having been forced
        ! to select a default mouse type. This situation can be checked for by calling the
        ! InfoHardware function with a parameter of 23.
        ! Once the user has identified the required mouse, IdMouse automatically calls
        ! IMouse to ensure that INTERACTER knows precisely what type of mouse (if any) is
        ! to be used.
        ! See chapter 13 of the User Guide for a list of the supported mice.
        !e.g. CALL IScreenOpen(' ','P',640,480,16)
        !C is a mouse available ?
        !IF (InfoHardware(13).EQ.1.AND.InfoHardware(23).EQ.0) THEN
        !CALL IClearScreen
        !CALL IOutCentre(2,'Do You have a Mouse ?')
        !CALL IdMouse(4)
        !ENDIF
        !Interactive Option Identification INTERACTER Subroutine Reference
        !2-78
    end subroutine

    subroutine IdPgStyles(ISET,DESCR)
        integer ISET ! Data set number
        character(len=*) DESCR ! Data set description
        ! Short-name : IISTYL
        ! Interactively identifies styles for a specified data set in a Presentation Graphics display.
        ! A form is presented, consisting of the style settings applicable to the current graph type,as can be defined using the equivalent IPgStyle routine.
        ! The currently selected graph type is identified automatically and a suitable form
        ! definition file is loaded from disk using IFormLoad. These forms are supplied in a
        ! forms directory as part of the standard INTERACTER distribution, with names such as
        ! iistylXX.ifd where XX is a two digit form number. These form definition files
        ! must be in the current directory at run-time or in the directory identified by the
        ! INTFMDIR o.s. variable or the FORMDIR initialisation file keyword. If the form file
        ! cannot be found an error code of 1 is set.
        ! If the data set number is invalid for the current graph, as defined by IPgNewPlot,InfoError(1) returns a value of 48.
        ! Once a form has been successfully loaded, the current style settings are identified. The
        ! form is then displayed and edited using IFormShow/IFormEdit. If the user
        ! confirms their choice (by pressing the 'confirm' key or by clicking on the 'OK' button),IPgStyle is called to update the style settings for the specified data set. As a
        ! consequence, IdPgStyles must be called in the same relative position within a
        ! program as IPgStyle, i.e. after IPgNewPlot and before the graph plotting routine
        !it is intended to affect (e.g. IPgHistogram, IPgLinePlot, etc.).
        !To allow the contents of the form to be related to the current application, a field is
        !reserved for a description of the data set. This can be specified in the DESCR argument.
        !The form is presented in a window which is opened automatically. The window action
        !(frame, pop-up, etc.) is controllable by an earlier call to IWinAction. The window
        !size depends on the selected plot type. The position of the window is determined by the
        !IdMenuOptions options 1 and 11. The colours of the data set name, help and button
        !fields can be set via IdMenuOptions options 8, 9 and 10 respectively. Alternatively,the colour scheme and field frame styles for the whole of the form can be set via
        !IdMenuOptions option 13. The window-close action on exit is controllable via
        !IdMenuOptions option 12.
        !Each form contains OK and Cancel buttons which cause InfoInput(55) to return
        !21 or 23 in the normal manner. Up to 2 program defined 'user buttons' can be added to
        !the form, via IdFormButtons. The code returned via InfoInput corresponds to
        !the IBCODE value supplied to IdFormButtons.
        !Each form includes one or more menu fields, all of which have pop-up options. A full
        !vertical menu can be displayed by pressing control key 34 or the right mouse button in
        !a menu field. (See also InMouseOptions(102,n)).
        !INTERACTER Subroutine Reference Interactive Option Identification
        !2-79
        !e.g. CALL IPgNewPlot(PgLinePlot,1,NVAL,0,0)
        !CALL IWinOpen(0,0,45,19)
        !CALL IdPgStyles(1,'First dataset')
        !CALL IWinClose(1)
        !CALL IPgAxes
        !CALL IPgLinePlot(YVALUE)
        !Errors :
        !ErrFileOpen (1) : Unable to open form definition file
        !ErrDataSetNum (48) : Invalid data set number
    end subroutine

    subroutine IdPlotter(IY)
        integer IY ! Start screen line for prompts and menu
        ! Short-name : IIPLOT
        ! Interactively identifies the HP-GL plotter type. The user is asked to select from a menu
        ! of the plotters supported by the current implementation of INTERACTER.
        ! The IY argument specifies the vertical position of the menu. The style and layout of the
        ! menu can be modified by an earlier call to IdMenuOptions.
        ! This routine need only be used if IScreenOpen has been forced to select a default
        ! plotter type. This situation can be checked for via InfoHardware(22).
        ! Once the user has identified the required plotter, IdPlotter automatically calls
        ! IPlotter to ensure that INTERACTER knows precisely what type of plotter is to be
        ! used.
        ! In general, calls to IdPlotter should precede any calls to IGrHardCopySelect
        ! or IGrHardCopy, since these calls may set parameters which depend on the currently
        ! selected plotter type. If IdPlotter is called, it is advisable to follow it with a call to
        ! IGrHardCopySelect to reinitialise the required hardcopy driver.
        ! See chapter 13 of the User Guide for a list of the supported plotters.
        !e.g. CALL IScreenOpen(' ','P',640,480,16)
        !C has plotter been identified in init file ?
        !IF (InfoHardware(22).EQ.0) THEN
        !CALL IClearScreen
        !CALL IOutCentre(2,'Plotter Type Identification Required')
        !CALL IdPlotter(4)
        !ENDIF
    end subroutine

    subroutine IdPrinter(IY)
        integer IY ! Start screen line for prompts and menu
        ! Short-name : IIPRIN
        ! Interactively identifies the printer type. The user is asked to select from a menu of the
        ! printers supported by the current implementation of INTERACTER.
        ! The IY argument specifies the vertical position of the menu. The style and layout of the
        ! menu can be modified by an earlier call to IdMenuOptions.
        ! This routine need only be used if IScreenOpen has been forced to select a default
        ! printer type. This situation can be checked for via InfoHardware(21).
        ! Interactive Option Identification INTERACTER Subroutine Reference
        ! 2-80
        ! Once the user has identified the required printer, IdPrinter automatically calls
        ! IPrinter to ensure that INTERACTER knows precisely what type of printer is to be
        ! used.
        ! In general, calls to IdPrinter should precede any calls to IGrHardCopySelect
        ! or IGrHardCopy, since these calls may set parameters which depend on the currently
        ! selected printer type.
        ! See chapter 13 of the User Guide for a list of the supported printers.
        !e.g. CALL IScreenOpen(' ','P',640,480,16)
        !C has printer been identified in init file ?
        !IF (InfoHardware(21).EQ.0) THEN
        !CALL IClearScreen
        !CALL IOutCentre(2,'Printer Type Identification Required')
        !CALL IdPrinter(4)
        !ENDIF
    end subroutine

    subroutine IdPrinter2(IY)
        integer IY ! Start screen line for prompts and menu
        ! Interactively identifies the HP-GL/2 printer/plotter type. The user is asked to select
        ! from a menu of the currently supported HP-GL/2 devices.
        ! The IY argument specifies the vertical position of the menu. The style and layout of the
        ! menu can be modified by an earlier call to IdMenuOptions.
        ! This routine need only be used if IScreenOpen has been forced to select a default
        ! HP-GL/2 device type. This situation can be checked for via InfoHardware(25).
        ! Once the user has identified the required device, IdPrinter2 automatically calls
        ! IPrinter2 to ensure that INTERACTER knows precisely what type of HP-GL/2
        ! device is to be used.
        ! In general, calls to IdPrinter2 should precede any calls to IGrHardCopySelect
        ! or IGrHardCopy, since these calls may set parameters which depend on the currently
        ! selected device type. If IdPrinter2 is called, it is advisable to follow it with a call to
        ! IGrHardCopySelect to reinitialise the required hardcopy driver.
        ! See chapter 13 of the User Guide for a list of the supported HP-GL/2 devices.
        !e.g. CALL IScreenOpen(' ','P',640,480,16)
        !C has HP-GL/2 printer been identified in init file ?
        !IF (InfoHardware(25).EQ.0) THEN
        !CALL IClearScreen
        !CALL IOutCentre(2,'HP-GL/2 Device Type Identification Required')
        !CALL IdPrinter2(4)
        !ENDIF
    end subroutine

    subroutine IdScreenDumpOptions(IUNIT)
        integer IUNIT ! Image size/position units
        ! (0=points, 1=inches, 2=cm, 3=mm)
        ! Short-name : IISCDO
        ! Interactively identifies graphics screen dump hardcopy options. A form is presented,consisting of all the relevant options supported by IScreenDumpOptions for the
        ! currently selected printer type.
        ! INTERACTER Subroutine Reference Interactive Option Identification
        ! 2-81
        ! The current printer type is identified automatically and a suitable form definition file is
        ! loaded from disk using IFormLoad. These forms are supplied in the forms directory
        ! as part of the standard INTERACTER distribution. Under DOS or X Windows, one of
        ! the following form files will be loaded depending on the currently selected printer type:
        ! iiscdoe.ifd Epson/IBM
        ! iiscdod.ifd HP DeskJet family (monochrome)
        ! iiscdol.ifd HP LaserJet family (monochrome)
        ! iiscdop.ifd HP PaintJet family (colour)
        ! iiscdoc.ifd Colour HP DeskJet/LaserJet printers
        ! Under DOS or X-Windows, if the current printer type does not support graphics, no
        ! form is loaded and IdScreenDumpOptions will exit with an error.
        ! Under Windows, where Print Manager is always used for screen dumps, a form
        ! definition file called iiscdow.ifd will be loaded instead.
        ! The form definition files must be in the current directory at run-time or in the directory
        ! identified by the INTFMDIR o.s. variable or the FORMDIR initialisation file keyword.
        ! If the form file cannot be found, error code 1 is set.
        ! Once a form has been successfully loaded, the current hardcopy options are identified
        ! using InfoScreen and the form is displayed and edited using
        ! IFormShow/IFormEdit. If the user confirms their choice (by pressing the 'confirm'
        ! key or by clicking on the 'OK' button), IScreenDumpOptions is called to update
        ! each of the options which have been changed.
        ! The image size and position fields on the hardcopy options forms can be expressed in
        ! various units, selected by the IUNIT argument. Internally, IdScreenDumpOptions
        ! converts the entered values to points, for the sake of IScreenDumpOptions.
        ! The form is presented in a window which is opened automatically. The window action
        ! (frame, pop-up, etc.) is controllable by an earlier call to IWinAction. The window
        ! size depends on the selected printer type. The position of the window is determined by
        ! the IdMenuOptions options 1 and 11. The colours of the help and button fields can
        ! be set via IdMenuOptions options 9 and 10 respectively. Alternatively, the colour
        ! scheme and field frame styles for the whole of the form can be set via
        ! IdMenuOptions option 13. The window-close action on exit is controllable via
        ! IdMenuOptions option 12.
        ! Each form contains OK and Cancel buttons which cause InfoInput(55) to return
        ! 21 or 23 in the normal manner. Up to 3 program defined 'user buttons' can be added to
        ! the form, via IdFormButtons. The code returned via InfoInput corresponds to
        ! the IBCODE value supplied to IdFormButtons.
        ! Each form includes one or more menu fields. These all have pop-up options. A full
        ! vertical menu can be displayed by pressing control key 34 or the right mouse button in
        ! a menu field. (See also InMouseOptions(102,n)).
        ! See also IdGrHardcopyOptions which performs the equivalent task for graphics
        ! hardcopy driver options.
        !e.g. INCHES = 1
        !CALL IdScreenDumpOptions(INCHES)
        !CALL DOGRAF
        !CALL IScreenDump(' ')
        !Interactive Option Identification INTERACTER Subroutine Reference
        !2-82
        !Errors :
        !ErrFileOpen (1) : Unable to open form definition file
        !ErrPrintGfx (5) : Graphics not supported on selected printer type
    end subroutine

    subroutine IdScreenMode(IY)
        integer IY ! Start screen line for prompt and menu
        ! Short-name : IIMODE
        ! Interactively identifies the required screen mode. The user is asked to choose from a
        ! menu of currently available screen modes which match a selection criteria specified by
        ! option 7 of IdMenuOptions. By default, a menu of all available text modes is
        ! offered. If no matching modes are available an error code is returned via
        ! InfoError(1) and no menu is displayed.
        ! By default, the IY argument specifies the position of a prompt line which is displayed
        ! above a menu generated by IMenuHoriz. However, the style and layout of the menu
        ! can be modified by an earlier call to IdMenuOptions.
        ! Once the user has identifed a screen mode, IdScreenMode calls IScreenMode to
        ! select that mode. The effect of calling IdScreenMode is therefore the same as calling
        ! IScreenMode, provided the user does not quit from the menu. Consequently, unlike
        ! the other menu routines in this group, IdScreenMode closes the current menu chain
        ! if 'linked pop-up' mode has been selected, before calling IScreenMode. The current
        ! pop-up mode remains unchanged however.
        ! The selected screen mode can be identified on exit via InfoScreen(1).
        !e.g.
        !C vertical scrolling graphics modes menu with no prompt above menu
        !CALL IdMenuOptions(7,2)
        !CALL IdScreenMode(2)
        !MODE = InfoScreen(1)
        !Errors :
        !ErrNullMenu (45) : Null menu (no suitable modes available)
        !INTERACTER Subroutine Reference Text Position Input
        !2-83
        !2.6 Group TI : Text Position Input
        !This group provides a set of self contained, input-device-independent positional input
        !routines which directly complement the equivalent set of graphics mode input routines
        !available in the GI group. Text input mode will be referred to here as TIN mode to
        !differentiate from GIN (Graphics INput) mode.
        !The main difference between TIN and GIN mode is that the former uses an integer coordinate
        !system based on rows and columns, whilst the latter uses a real co-ordinate
        !system which is user defined. The TIN routines follow the usual INTERACTER text coordinate
        !conventions where (1,1) indicates the top left of the screen.
        !ITextInputXY can be used to mark a single on-screen character position or a
        !rectangular screen area can be marked using ITextInputBox. The text input device
        !(keyboard or mouse) can be selected using ITextInputDevice and the area in
        !which the TIN cursor is allowed to move can be restricted with
        !ITextInputLimits. These routines are directly equivalent to IGrInputXY,IGrInputBox, IGrInputDevice and IGrInputLimits in the GI group. The
        !major difference is that the TIN routines are designed to work in both text and graphics
        !modes whereas GIN routines are specifically for use in graphics modes only.
        !Where a mouse is available, access is provided to lower level mouse features via the
        !separate MC (Mouse Cursor Control) and KM (Keyboard/Mouse Event Handling)
        !subroutine groups. These replace the TINMOU routine which was provided in earlier
        !releases, but has now been moved to the OR (Obsolete Routines) group.
    end subroutine

    subroutine ITextInputBox(IX,IY,IWIDTH,IHEIGH,IACTN)
        integer IX ! on entry : Initial column
        ! on exit : Returned column (IACTN>1)
        integer IY ! on entry : Initial row
        ! on exit : Returned row (IACTN>1)
        integer IWIDTH ! on entry : Initial width of box
        ! on exit : Returned width of box (IACTN<>2)
        integer IHEIGH ! on entry : Initial height of box
        ! on exit : Returned height of box (IACTN<>2)
        integer IACTN ! Input action required :
        ! = 1 : Stretch box out from a fixed position
        ! = 2 : Place a box of fixed size
        ! = 3 : Mark both corners of a box
        ! Short-name : TINBOX
        ! Uses TIN mode to enable the user to mark a rectangular text area, using the current text
        ! input device (see ITextInputDevice). The final position and/or size of the area are
        ! returned. The area can be marked in one of three ways, depending on the specified
        ! action.
        ! From the point of view of the calling program, the effect of calling this routine is the
        ! same regardless of operating system or display. However, the precise nature of the user
        ! interface varies, depending on the input device. In general, what happens is as follows :
        ! Text Position Input INTERACTER Subroutine Reference
        ! 2-84
        ! Action 1 : The corner of the rectangle, specified by (IX,IY), remains fixed and TIN
        ! mode is used to specify the second corner of the rectangle by 'rubber-banding' a frame
        ! as the user moves the TIN cursor to the required position.
        ! Action 2 : The size of the rectangle remains fixed, with its initial position determined
        ! by the values of (IX,IY) and IWIDTH/IHEIGH on entry to ITextInputBox. The
        ! text input device is used to 'drag' a frame to a new position. The corner which is
        ! diagonally opposite to (IX,IY) is treated as the TIN cursor position, and it is this
        ! corner which is restricted to the text input area defined by ITextInputLimits.
        ! Hence, on exit, it will lie within the text input area, but (IX,IY) may not.
        ! Action 3 : In this case two character positions must be marked. ITextInputXY is
        ! called to mark the first position, which is initially (IX,IY). Once that position has
        ! been selected, the opposite corner of the rectangle is selected in the same way as Action
        ! type 1. The distance of the second position from the first is returned in
        ! IWIDTH/IHEIGH.
        ! In all cases, positions are marked in the same way as for ITextInputXY, i.e. using
        ! the confirm/quit/help keys or mouse buttons. The 'exit' key/button can be interrogated
        ! via InfoInput.
        ! The hardware text cursor is automatically disabled for the duration of the call.
        ! In a windowing environment a graphics mode expose/resize event may occur during a
        ! call to ITextInputBox. InfoInput(55) will return 259 in this case. A closewindow
        ! request will return InfoInput(55) set to 260.
        !e.g. IX = 5
        !IY = 5
        !IWID = 20
        !IHGT = 3
        !CALL ITextInputBox(IX,IY,IWID,IHGT,3)
        !KEXIT = InfoInput(55)
    end subroutine

    subroutine ITextInputDevice(DEVIC)
        character(len=*) DEVIC ! Text input device (upper or lower case)
        ! = K : Keyboard only
        ! = M : Mouse/pointing device (default, if available)
        ! Short-name : TINDEV
        ! Selects the input device to be used by the TIN routines. By default a mouse or
        ! equivalent pointing device is used, where available, but keyboard input is selected
        ! otherwise. Where a mouse/pointing device is fitted, keyboard input can still be selected
        ! if preferred, using a 'K' parameter.
        ! Where a mouse/pointing device is selected, input is actually accepted from both mouse
        ! and keyboard for maximum user convenience. The 'K' option for keyboard-only input
        !can be used to suppress the use of the mouse (e.g. to test how a program will behave
        !when a mouse is not available).
        !In general, when keyboard input is selected, the TIN cursor appears as a cross. On
        !many displays, the cursor will also flash. If a mouse is selected the TIN cursor depends
        !on the display type, but will usually be an inverse video block, an arrow pointer or a
        !cross hair.
        !INTERACTER Subroutine Reference Text Position Input
        !2-85
        !In general it is recommended that INTERACTER be left to select its own input device,especially on serial terminals, where the best choice is often dependent on both display
        !type and screen mode.
        !e.g. CALL ITextInputDevice('K')
        !C mark two points and open a window
        !CALL ITextInputXY(IX1,IY1)
        !CALL ITextInputXY(IX2,IY2)
        !CALL IWinOpen(MIN0(IX1,IX2),MIN0(IY1,IY2),1 IABS(IX2-IX1)+1,IABS(IY2-IY1)+1)
        !Portability notes :
        !DOS:
        !A mouse with a Microsoft compatible driver is required. MOUSE.COM or the equivalent
        !driver program supplied with the mouse, must have been loaded before running your
        !program. Microsoft compatible mice have two buttons, Mouse Systems compatible
        !mice have three. Where three are fitted, the middle button can be detected by the TIN
        !routines. The presence of MOUSE.COM is sensed automatically at start up by
        !IScreenOpen.
        !Xlib and MS Windows :
        !Both mouse and keyboard input are supported. Simultaneous mouse/keyboard input is
        !supported. Three mouse buttons are assumed unless a two-button mouse has been
        !specified by the user. The mouse is the default TIN device unless suppressed using
        !ITextInputDevice('K') or a MOUSE=1 record in the initialisation file.
        !Terminals :
        !On a serial terminal, in a text screen mode, mouse input is only supported on xterm and
        !DECterm. On other displays, keyboard input is automatically selected in text screen
        !mode. In graphics screen mode the situation is slightly more complex :
        !On a Tek 4100 compatible display with a usable independent dialog area or under Tera
        !Term Pro, TIN mode operates just the same in text and graphics screen modes.
        !On a display which uses Tek 4010/4014 alpha mode for text screen handling in
        !graphics mode, the pointing device capabilities of the terminal are used for TIN mode,equivalent to calling ITextInputDevice('M'). This is also true of ReGIS
        !compatible terminals. Host-controlled keyboard input can be forced on a ReGIS display
        !in graphics mode, using ITextInputDevice('K'). Forcing keyboard input on
        !Tek 4010/4014 type display is not recommended however since these devices do not
        !usually support exclusive-or plotting and cursor key detection, both of which are
        !required for host controlled TIN mode input in graphics mode.
        !xterm and DECterm :
        !A mouse can be selected for use with TIN mode, since both are able to report buttondown
        !events (though not mouse movement events). Under these emulations, the mouse
        !is the default TIN device unless suppressed using ITextInputDevice('K') or a
        !MOUSE=1 record in the initialisation file.
        !Text Position Input INTERACTER Subroutine Reference
        !2-86
    end subroutine

    subroutine ITextInputLimits(IXTOPL,IYTOPL,IXBOTR,IYBOTR)
        integer IXTOPL ! Top left column of text input area
        ! (1 =< IXTOPL < number of screen columns)
        integer IYTOPL ! Top left row of text input area
        ! (1 =< IYTOPL < number of screen rows)
        integer IXBOTR ! Bottom right column of text input area
        ! (1 < IXBOTR =< number of screen columns)
        integer IYBOTR ! Bottom right row of text input area
        ! (1 < IYBOTR =< number of screen rows)
        ! Short-name : TINLIM
        ! Defines the area of the screen in which text position input is allowed. The TIN cursor
        ! will be restricted to the area specified. Since the limits are mode dependent, they are
        ! reset to the full screen at initialisation and each time IScreenMode or
        ! IScreenModeN is called to change mode. You should reset the TIN limits as
        ! required, after a mode change.
        ! Where initial positions are specified (to ITextInputBox and ITextInputXY)
        ! which lie outside the limits set by ITextInputLimits, the TIN cursor is forced to
        ! the nearest character position which lies within the specified text input area.
        ! Mouse input as performed via InKeyEvent and the fixed-field/menu/form routines is
        ! unaffected by these limit settings.
        !e.g. NCOLS = InfoScreen(2)
        !NROWS2 = InfoScreen(3)/2
        !C restrict text input to the top half of the screen ...
        !CALL ITextInputLimits(1,1,NCOLS,NROWS2)
        !CALL ITextInputXY(IX,IY)
    end subroutine

    subroutine ITextInputOptions(NOPTN,IVALUE)
        integer NOPTN ! Option number (see below)
        integer IVALUE ! Option value (see below)
        ! NOPTN IVALUE
        ! TINTerminate (1) TIN mode termination condition :
        ! TINExitKey (0) : Only allow standard exit keys
        ! TINAnyKey (1) : Allow any non-movement key
        ! Short-name : TINOPT
        ! Include : interti.inc
        ! Defines text input mode options. NOPTN values outside the specified range are ignored.
        ! INTERACTER Subroutine Reference Text Position Input
        ! 2-87
        ! Option 1 controls the manner in which key strokes are treated in TIN mode. By default,only the usual confirm, help and quit keys (or mouse buttons) and resize/expose events
        ! are allowed to terminate TIN mode. However, by specifying a non-zero IVALUE, any
        ! non-movement key terminates TIN mode. In this situation, InfoInput(55) will still
        ! return its usual values of 21-23 if an exit key is pressed, 259 for a resize/expose event
        ! or 260 for a close-window request. However, if a non-exit and non-movement key is
        ! pressed, InfoInput(55) will return a value of -1 and the actual InKeyEvent key
        ! code of the key which was pressed will be returned by InfoInput(57). Conversely,InfoInput(57) will be returned as -1 when InfoInput(55) returns 21-
        ! 23/259/260.
        !e.g. IX = 1
        !IY = 1
        !C allow any key to act as an exit key
        !CALL ITextInputOptions(1,1)
        !50 CALL ITextInputXY(IX,IY)
        !KEY = InfoInput(57)
        !IF (KEY.GT.0) THEN
        !CALL IOutStringXY(IX,IY,CHAR(KEY))
        !IX = IX + 1
        !IF (IX.GT.InfoScreen(2)) THEN
        !IX = 1
        !IY = IY + 1
        !IF (IY.GT.InfoScreen(3)) IY = 1
        !ENDIF
        !GO 50
        !ENDIF
        !IF (InfoInput(55).EQ.21) CALL IScreenSaveImage('rubbish.scr')
    end subroutine

    subroutine ITextInputXY(IX,IY)
        integer IX ! On entry: Initial x position of TIN cursor
        ! On exit : Returned x cursor position
        integer IY ! On entry: Initial y position of TIN cursor
        ! On exit : Returned y cursor position
        ! Short-name : TINXY
        ! Presents a TIN cursor which the user can move using the current text input device (see
        ! ITextInputDevice) and returns the position at which an 'exit' key or mouse button
        ! was pressed.
        ! By default, the TIN cursor can be moved to any position on the screen, though this can
        ! be modified by calling ITextInputLimits.
        ! Logically, the effect of calling this routine is the same regardless of operating system or
        ! display. However, the precise nature of the user interface varies, depending on the input
        ! device. In general, what happens is as follows :
        ! a) The input limits as set by ITextInputLimits are enabled
        ! b) A TIN cursor (as described in ITextInputDevice) is displayed.
        ! c) The cursor is moved, using the available input device (mouse, keyboard, etc.). The
        ! extended/extreme movement keys give faster movement when keyboard input is
        ! selected.
        ! Text Position Input INTERACTER Subroutine Reference
        ! 2-88
        ! d) An 'exit' key or equivalent mouse button is pressed to mark a position. All other
        ! keys are ignored. If keyboard input is selected, the three allowable 'exit' keys are
        ! confirm, quit and help, as can be defined using InControlKey or the KEY
        ! initialisation file keyword. The exit key which was used can be interrogated, as
        ! usual, by calling InfoInput(55). If a mouse is used the buttons are treated just
        ! like exit keys :
        ! left button = confirm (exit 'key' 21)
        ! middle button = help (exit 'key' 22 : 3-button mice only)
        ! right button = quit (exit 'key' 23)
        ! In a windowing environment in graphics mode, it is possible for a graphics window
        ! expose/resize event to occur during the call, in which case InfoInput(55) will
        ! return 259. Similarly, a close-window request will return InfoInput(55) set to
        ! 260.
        ! a) Pointing device input limits are reset to the full screen.
        ! The calling program can thus check for exit keys 21 (confirm), 22 (help) or 23 (quit)
        ! without being concerned with what type of input device is in use.
        ! The hardware text cursor is automatically disabled for the duration of the call, if the
        ! display supports this feature, and restored to its previous state on exit.
        !e.g. IX = 10
        !IY = 5
        !CALL ITextInputXY(IX,IY)
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !C confirm pressed at (IX,IY) ...
        !ELSE IF (KEXIT.EQ.23) THEN
        !C quit pressed ...
        !ELSE IF (KEXIT.EQ.259) THEN
        !C expose/resize event : repaint screen
        !ELSE
        !C help pressed ...
        !ENDIF
        !INTERACTER Subroutine Reference Mouse Cursor Control
        !2-89
        !2.7 Group MC : Mouse Cursor Control
        !Where mouse handling is supported, it is normally possible to control the mouse cursor
        !from the application program. This group provides the most basic mouse cursor
        !positioning and enable/disable routines. These can be used in combination with the
        !InEventSelect/InKeyEvent routines in the KM group, which select and report
        !mouse events. In addition, the mouse cursor shape can be selected on some displays
        !using IMouseCursorShape.
        !These routines are entirely separate from those in the TI/GI text/graphics positional
        !input groups.
    end subroutine

    subroutine IMouseCursorHide
        ! Short-name : MCHIDE
        ! Removes the mouse cursor from the screen. In a windowing environment, where the
        ! mouse cursor needs to remain visible at all times, this call is ignored.
        ! See also IMouseCursorShow which displays the mouse cursor.
        !e.g. see the doodlet and doodleg demos
        !Portability notes :
        !DOS :
        !It is advisable to temporarily remove the mouse cursor from the screen before
        !generating screen output, otherwise the cursor may become corrupted. This call is
        !supported in both text and graphics screen modes, provided a mouse is available.
        !MOUSE.COM must be loaded.
        !Xlib and MS Windows :
        !This call has no effect. The cursor remains enabled at all times.
        !Terminals :
        !This call has no effect on serial terminals or terminal emulations.
    end subroutine

    subroutine IMouseCursorShape(ISHAPE,WINDOW)
        integer ISHAPE ! Pointer shape
        ! 0 : Arrow pointer (default)
        ! 1 : Cross hair
        ! 2 : I-beam (also known as a'caret')
        ! 3 : Busy indicator (actual shape varies)
        ! 4 : 4-way arrow (N/S/E/W)
        ! 5 : 2-way arrow (N/S)
        ! 6 : 2-way arrow (E/W)
        ! 7 : Upward arrow
        character(len=*) WINDOW ! No longer used
        ! Short-name : MCSHAP
        ! Selects the shape of the mouse cursor. A choice of eight cursors is provided. The shape
        ! change will take place immediately if the cursor is currently visible. The WINDOW
        ! argument is no longer used, so a blank can be specified.
        !e.g. see the doodleg demo
        !Mouse Cursor Control INTERACTER Subroutine Reference
        !2-90
        !Portability notes :
        !DOS :
        !This call is supported in graphics screen modes. Shape 3 selects a wrist watch cursor.
        !MS Windows :
        !Shape 1 requires that the resource file xhair.cur be incorporated into the executable
        !at link time (the LINKINT and MAKEINT batch files do this automatically). Shape 3
        !selects an hour-glass cursor.
        !Xlib :
        !Shape 3 selects a wrist watch cursor.
        !Terminals :
        !This call has no effect on serial terminals or terminal emulations.
    end subroutine

    subroutine IMouseCursorShow
        ! Short-name : MCSHOW
        ! Displays the mouse cursor at the current mouse position, which can be set previously
        ! by IMouseCursorXYG/T. In a windowing environment, where the mouse cursor
        ! remains visible at all times, this call is ignored.
        ! See also IMouseCursorHide which removes the mouse cursor.
        !e.g. see the doodlet and doodleg demos
        !Portability notes :
        !See IMouseCursorHide.
    end subroutine

    subroutine IMouseCursorXYG(XPOS,YPOS)
        real XPOS ! X co-ordinate at which to place mouse cursor ) Units as set
        real YPOS ! Y co-ordinate at which to place mouse cursor ) by IGrUnits
        ! Short-name : MCUXYG
        ! Moves the mouse cursor to the specified graphics position. The program must be in a
        ! graphics screen mode. The (x,y) co-ordinate is expressed in terms of user units as
        ! defined by the IGrUnits routine.
        ! For this call to have an effect a mouse must be available (InfoHardware(13)>1)
        ! and the InfoHardware(9) must return a value of 2.
        ! See also IMouseCursorXYT which places the mouse cursor using text co-ordinates.
        !e.g. see the doodleg demo
        !Portability notes :
        !DOS :
        !This call is supported in graphics screen modes. MOUSE.COM must be loaded.
        !Terminals :
        !This call has no effect on serial terminals or terminal emulations.
        !INTERACTER Subroutine Reference Mouse Cursor Control
        !2-91

    end subroutine

    subroutine IMouseCursorXYT(IX,IY)
        integer IX ! Column at which to place mouse cursor
        integer IY ! Row at which to place mouse cursor
        ! Short-name : MCUXYT
        ! Moves the mouse cursor to the specified text row/column. This routine can be called in
        ! both text and graphics modes.
        ! For this call to have an effect a mouse must be available (InfoHardware(13)>1)
        ! and the InfoHardware(8) must return a value of 2.
        ! See also IMouseCursorXYG which places the mouse cursor using graphics coordinates.
        !e.g. see the doodlet and doodleg demos
        !Portability notes :
        !DOS :
        !This call is supported in text and graphics screen modes. MOUSE.COM must be loaded.
        !Terminals :
        !This call has no effect on serial terminals or terminal emulations.
        !
        !INTERACTER Subroutine Reference Grid Manager
        !2-93
        !2.8 Group GM : Grid Manager
        !This group implements a set of routines which allow spreadsheet-style input and
        !display of array-based data. Each column in a grid contains data of a single type (string,real, integer or double-precision). Each row of a grid can contain columns of all types
        !in any combination. A grid is displayed and edited within the current window (see
        !IWinOpen, IWinSelect etc. in the WN group). Where the grid is too large to fit
        !into the window, the user can scroll round the grid using the grid editor.
        !To define the size and basic layout of a grid call IGridDefine. To display the grid
        !call IGridShow. To edit it, call IGridEdit. The latter two routines use a common
        !user-supplied routine to get/set individual grid cell values. This user routine is central
        !to the operation of the Grid Manager, ensuring that the contents of the grid are only
        !stored in the calling program and are not duplicated in INTERACTER's own strorage.
        !See IGridEdit for a definition of the user routine.
        !Various supporting routines are also provided :
        !  Range checking is implemented in a similar manner to the Forms Manager, except
        !that ranges apply to entire columns not just single fields. See
        !IGridRangeInteger, IGridRangeReal and IGridRangeDouble.
        !  The colour or monochrome attributes of specific parts of the grid can be set via
        !IGridAttribute.
        !  The Fortran format used to display real or double precision values when a field is
        !about to be modified can be set via IGridFormat.
        !See also InfoGrid in the IF group.
        !A maximum of 200 grid columns are allowed and any number of rows.
        !A grid-handling demo called griddemo is supplied in the demos directory.
    end subroutine

    subroutine IGridAttribute(IPART,ATTRIB,FORCOL,BACCOL)
        integer IPART ! Part of grid :
        ! 1 : Column headings
        ! 2 : Row labels
        ! 3 : Main body of grid
        character(len=*) ATTRIB ! Attributes to use on mono displays, as for
        ! ITextAttribute (not used on colour displays)
        character(len=*) FORCOL ! Foreground colour name ) As for ITextColour
        character(len=*) BACCOL ! Background colour name ) or blank to use default
        ! Sets the attributes or colours for the specified part of the grid. These values are used by
        ! IGridShow and IGridEdit when displaying grid headings, labels and cell values.
        ! IPART determines which part of the grid the specified attributes/colours are to be
        ! applied to. Grid parts for which attributes/colours are undefined will be displayed in the
        ! attributes/colours set most recently by the routines in the AT group.
        ! The ATTRIB argument specifies the combination of highlight attributes to be used on a
        ! monochrome display. This argument is ignored on a colour display. The string should
        ! contain a combination of B, F, I, R and U (or just a blank) as for ITextAttribute.
        ! Grid Manager INTERACTER Subroutine Reference
        ! 2-94
        ! FORCOL and BACCOL are defined in exactly the same way as for ITextColour.
        ! These values are ignored on monochrome displays.
        !e.g.
        !C Define labels with bold-yellow text on blue background
        !C (Reverse video on a mono screen)
        !CALL IGridAttribute(1,'R','BY','BLU')
        !CALL IGridAttribute(2,'R','BY','BLU')
        !C Define cells as bold/white on default background
        !C (Bold on a mono screen)
        !CALL IGridAttribute(3,'B','BW',' ')
        !Portability notes :
        !See ITextAttribute and ITextColour in the AT subroutine group.
    end subroutine

    subroutine IGridDefine(NCOLS,NROWS,IWIDTH,ITYPES,LAYOUT)
        integer NCOLS ! Number of columns
        integer NROWS ! Number of rows
        integer IWIDTH(0:NCOLS) ! Array of column widths
        integer ITYPES(NCOLS) ! Array of column types :
        ! 1 : Fixed-width string
        ! 2 : Integer
        ! 3 : Real
        ! 6 : Double precision
        ! 8 : Long-string
        character(len=*) LAYOUT ! Grid layout options :
        ! 'H' : Add headings
        ! Defines a new grid. All previous grid information is deleted. IGridDefine should be
        ! called to create a new grid before calling other routines in the GM group.
        ! Up to 200 columns and any number of rows are allowed. Where a grid is larger than the
        ! current window, the grid editor IGridEdit allows the user to scroll around the grid
        ! under keyboard or mouse control.
        ! The IWIDTH array determines the width of each column. This must be dimensioned
        ! from 0. IWIDTH(0) defines the width of the row label column. This remains visible at
        ! all times. To suppress this column set IWIDTH(0) to zero.
        ! The ITYPES array defines the data type to be displayed/entered in each column. The
        ! numbering scheme follows that used by the Forms Manager. Long-string fields always
        ! have a maximum enterable length of 255 characters (their visible width is determined
        ! by IWIDTH, exactly as for the other column types).
        ! The presence of column headings is determined by specifying an 'H' in the LAYOUT
        ! argument.
        ! INTERACTER Subroutine Reference Grid Manager
        ! 2-95
        !e.g. PARAMETER (MAXCOLS=3,MAXROWS=36)
        !REAL DATASET1(MAXROWS), DATASET2(MAXROWS)
        !INTEGER DATASET3(MAXROWS), WIDTHS(0:MAXCOLS), TYPES(MAXCOLS)
        !EXTERNAL GMUSER
        !C Define field widths in characters + label width
        !DATA WIDTHS/30, 15, 15, 10/
        !C Define field types : real, real, integer
        !DATA TYPES/3, 3, 2/
        !:
        !C Define a grid of 3 x 36 with labels at top and left
        !CALL IGridDefine(MAXCOLS, MAXROWS, WIDTHS, TYPES, 'H')
        !C Show the grid within the window with cell 1,1 at top corner
        !IX = 1
        !IY = 1
        !100 CALL IGridShow(IX, IY, GMUSER)
        !C Begin editing the grid but move input highlight to column 2
        !IX = 2
        !CALL IGridEdit(IX, IY, GMUSER)
        !C Redraw the window if a resize/expose event occurred
        !IF (InfoInput(LastExitKey).EQ.259) THEN
        !IX = InfoGrid(1)
        !IY = InfoGrid(2)
        !GOTO 100
        !ENDIF
        !Errors :
        !ErrGridColumns (59) : Too many grid columns requested
        !ErrBadGridType (60) : Unknown column type requested
    end subroutine

    subroutine IGridEdit(IXSTART,IYSTART,GMUSER)
        integer IXSTART ! Column to start editing from
        integer IYSTART ! Row to start editing from
        external GMUSER ! User supplied grid value routine
        ! Allows the user to edit the current grid. Data values are passed to/from the calling
        ! program via the user-supplied GMUSER routine. (The actual name of the user routine is
        ! obviously program specific, but it will be referred to here as GMUSER).
        !Each time the user edits a cell or a cell needs to be displayed (e.g. because the grid
        !needs to scroll) the user supplied grid value routine is called. This routine is also used
        !by IGridShow. It is defined as follows :
    end subroutine

    subroutine GMUSER (IX,IY,SETVAL,VALUE)
        integer IX ! Column number (0=row label)
        integer IY ! Row number (0=column heading)
        logical SETVAL !.TRUE. : Update current value
        ! .FALSE. : Return current value
        character(len=*) VALUE ! Cell value
        ! (IX,IY) identifies the cell to be set or returned. The SETVAL argument
        ! determines the direction of transfer of the cell value itself in the VALUE
        ! argument. When passing a value into GMUSER, it will be called with
        ! SETVAL=.TRUE. When a current value needs to be interrogated so it can be
        ! displayed on screen, GMUSER will be called with SETVAL=.FALSE.
        ! Grid Manager INTERACTER Subroutine Reference
        ! 2-96
        ! Cell values are always passed to/from GMUSER as character strings, in VALUE.
        ! Integer, real and double precision values should be converted to/from character
        !using the routines in the CH group, e.g. IntegerToString,IStringToInteger, etc. When SETVAL is .FALSE. the character value
        !passed back is displayed on screen exactly as returned by GMUSER. When a cell
        !is modified by the user, one of the routines in the IN group is used to enter the
        !value (e.g. InIntegerXYDef). Numeric values entered by the user are
        !converted to character before GMUSER is called with a SETVAL=.TRUE..
        !Note that a call to GMUSER with SETVAL=.TRUE. will be immediately
        !followed by a call with SETVAL=.FALSE., allowing GMUSER to amend the
        !entered value if required.
        !When IX or IY are specified to GMUSER as zero, the user supplied routine
        !should return either a row label or a column heading respectively.
        !On entry to IGridEdit, if cell (IXSTART,IYSTART) is not currently visible,IGridShow is called to update the grid display. Otherwise, editing begins at this start
        !cell, regardless of where it lies within the current window without redisplaying the grid.
        !The user can move around the grid using both the mouse and keyboard. Clicking in a
        !cell with the mouse moves the highlight to that cell. Controls are also displayed on the
        !grid window borders allowing movement around the total grid. The keyboard can also
        !be used to achieve this effect using the platform-dependent keys assigned to the
        !following INTERACTER control keys (see InControlKey in the IP group) :
        !InControlKey Key name Action
        !key number
        !1 Cursor up Go to cell above
        !2 Cursor down Go to cell below
        !5 Extended cursor up Next page up
        !6 Extended cursor down Next page down
        !7 Extended cursor right Next page right
        !8 Extended cursor left Next page left
        !9 Extreme up Top of column
        !10 Extreme down Bottom of column
        !11 Extreme right Far right of row
        !12 Extreme left Far left of row
        !21 Confirm Exit from editor
        !22 Help Exit from editor
        !23 Quit Exit from editor
        !24 Tab Go to cell to the right
        !25 Back-Tab Go to cell to the left
        !26-30 Spare exit (group #1) Exit from editor
        !36-60 Spare exit (group #2) Exit from editor
        !The exact keys assigned to the above control keys are listed in the Keyboard Codes
        !chapter in the User Guide. Note that internally, IGridEdit uses control keys 61-70
        !for its own purposes. Their values are maintained on exit, however.
        !INTERACTER Subroutine Reference Grid Manager
        !2-97
        !The grid editor terminates when any of control keys 21-23/26-30/36-60 are pressed or
        !when a resize/expose event occurs in a windowing environment. InfoInput(55)
        !will return 21-23, 26-30, 36-60 or 259 in these cases. A close-window request (see
        !InEventSelect(7,n)) will cause the editor to terminate with an
        !InfoInput(55) set to 260.
        !Each time a cell is edited, routines from the IN subroutine group are used for data entry.
        !This means that the behaviour when editing grid cells is controlled by the routines in
        !the IP group. In particular, the current-cell highlight is determined by InHighlight
        !and InControlKey can be called to redefine the keyboard interface (including the
        !keys listed in the table above).
        !e.g. see IGridDefine
        !Errors :
        !ErrNoGridWin (61) : No window open for grid
        !ErrGridStart (62) : Invalid grid starting position
    end subroutine

    subroutine IGridFormat(ICOL,FRMAT)
        integer ICOL ! Column number
        character(len=*) FRMAT ! Fortran FORMAT to use when editing cell contents
        ! Defines the output format to be used when editing a real or double precision cell in a
        ! grid. If the specified column has not been declared as real or double precision, this
        ! routine has no effect. The format string must be a valid Fortran FORMAT descriptor
        ! enclosed in brackets.
        ! The supplied string is used by IGridEdit each time the user edits the contents of a
        ! non-blank real or double precision cell. Internally, IGridEdit calls InRealXYDef
        ! or InDoubleXYDef with the supplied FRMAT argument.
        ! If no format is defined for a given column a default of Gw.1 is used, where 'w' is the
        ! width of the cell.
        !e.g.
        !C Set format for double, and real columns
        !IGridFormat(1,'(F16.8)')
        !IGridFormat(3,'(F8.4)')
    end subroutine

    subroutine IGridRangeDouble(ICOL,DMIN,DMAX)
        integer ICOL ! Column number
        double precision DMIN ! Minimum allowable double precision value
        double precision DMAX ! Maximum allowable double precision value
        ! Defines a valid range for all cells in a double precision column in a grid. If the column
        ! has not been declared as double precision, the call has no effect. In all other respects
        ! this routine behaves exactly like the equivalent integer range definition routine,IGridRangeInteger. Refer to the IGridRangeInteger documentation for
        ! more information on range checking.
        !e.g. CALL IGridRangeDouble(1,0.0,99.99999999)
        !Grid Manager INTERACTER Subroutine Reference
        !2-98
    end subroutine

    subroutine IGridRangeInteger(ICOL,IMIN,IMAX)
        integer ICOL ! Column number
        integer IMIN ! Minimum allowable integer value
        integer IMAX ! Maximum allowable integer value
        ! Defines a valid range for all cells in an integer column in a grid. If the column has not
        ! been declared as integer, the call has no effect.
        ! This call has no immediate on-screen effect. It should be called before IGridEdit to
        ! define the range of values which the user may type into column ICOL. By default range
        ! checking on all columns is disabled. To disable range checking on a column which has
        ! had a range set by an earlier call to IGridRangeInteger, specify an IMAX value
        ! which is less than IMIN.
        ! To enforce 'minimum-only' range checking simply set the maximum value to a large
        ! positive number. Similarly, specify a large negative number for the minimum value for
        ! a 'maximum-only' range check.
        ! When IGridEdit is called to edit a grid, the user will not be allowed to enter an out
        ! of range value in a range-checked cell. If a range-checked cell is initially undefined (i.e.
        ! it appears on screen as a blank cell) the user will be able to tab across that field without
        ! entering a value. However, once a range-checked cell contains a value, the user cannot
        ! then clear the field to an undefined state.
        ! Pressing the help or quit keys (control keys 22 or 23) in a range-checked cell causes
        ! IGridEdit to terminate immediately, in the normal way. The same is true if a
        ! resize/expose event (259) or close-window request (260) occurs. However, if the user
        ! has just entered an out of range value in that cell, the previous (valid) cell contents will
        ! be restored to that cell. This ensures that it is possible to get out of a grid (to backtrack,display help or redraw the screen) whilst maintaining the integrity of the data in the
        ! grid.
        ! When an invalid value is entered in a range-checked cell and an attempt is made to
        ! move to another cell or to confirm the grid, the bell will sound and the cursor will be
        ! repositioned to the start of the cell with the highlight still on the invalid entry. No error
        ! message is output.
        !e.g. CALL IGridRangeInteger(2, 0, 100)
    end subroutine

    subroutine IGridRangeReal(ICOL,RMIN,RMAX)
        integer ICOL ! Column number
        real RMIN ! Minimum allowable real value
        real RMAX ! Maximum allowable real value
        ! Defines a valid range for all cells in a real column in a grid. If the column has not been
        ! declared as real, the call has no effect. In all other respects this routine behaves exactly
        ! like the equivalent integer range definition routine, IGridRangeInteger. Refer to
        ! the IGridRangeInteger documentation for more information on range checking.
        !e.g.
        !C Range On
        !CALL IGridRangeReal(3, -99.9999, 0.0)
        !C Range off
        !CALL IGridRangeReal(3, 1.0, 0.0)
        !INTERACTER Subroutine Reference Grid Manager
        !2-99
    end subroutine

    subroutine IGridShow(IXSTART,IYSTART,GMUSER)
        integer IXSTART ! Column to start displaying from
        integer IYSTART ! Row to start displaying from
        external GMUSER  ! User supplied grid value routine
        ! Displays the currently defined grid in the current window. The window should have
        ! already been opened by IWinOpen or IWinOpenTitle. The grid is displayed
        ! starting with cell (IXSTART,IYSTART) at the top left corner of the window.
        ! Grid data values are displayed by repeatedly calling the program supplied GMUSER
        ! routine with SETVAL set to .FALSE. to obtain grid cell values. See IGridEdit for
        ! a definition of this routine. The GMUSER routine is also expected to return row labels
        ! and column headings, where enabled. The colour or monochrome attributes of the grid
        ! can be determined by calling IGridAttribute, otherwise the current defaults are
        ! used.
        ! Typically, IGridShow will be called after IGridDefine and before IGridEdit.
        ! The latter routine will not repaint the grid on entry if the starting grid is already visible
        ! as a result of a previous IGridShow call.
        ! If a grid needs to be repainted after a resize/expose event in a windowing environment,the current top left cell can be interrogated via InfoGrid(1)/(2). The resulting
        ! values can then be passed back to IGridShow to redisplay the grid at its current start
        ! position.
        !e.g. See IGridDefine
        !Errors :
        !ErrNoGridWin (61) : No window open for grid
        !ErrGridStart (62) : Invalid grid starting position
        !
        !INTERACTER Subroutine Reference Form Creation & Editing
        !3-1
        !3. Forms Manager : Subroutine Descriptions
        !The Forms Manager provides a set of routines which simplify multiple input field
        !handling. They build on the lower level text screen input/output facilities.
        !A 'form' is simply a set of associated fields into which the user can enter data. A field
        !can contain character, integer, real or double precision data and can be protected or
        !unprotected. A protected field is one which is displayed but which cannot be
        !overwritten by the user. Unprotected fields are those in which the user is allowed to
        !enter data. Other field types are available, namely menus, push buttons and check
        !boxes. Check-box fields can also be grouped together as radio buttons.
        !A form is created by a call to IFormDefine, in group FM(1). This starts a new form
        !and defines the position, size and type of each field on the form. At this stage the form
        !is 'empty' and nothing appears on screen. The initial contents of the form can then be
        !set up using the various field 'put' routines in the FM(3) group. To make the form
        !appear on the screen call IFormShow, then call IFormEdit to allow the user to
        !enter data into the form. The resulting field contents can be retrieved from the internal
        !form data area using the field 'get' routines in the FM(3) group. The field display
        !routines in group FM(4) and the put/get routines can then be called as many times as
        !necessary and in any order until all the required input has been received and validated.
        !As an alternative to calling IFormDefine, a form definition can be loaded from a file
        !using IFormLoad, which is also in group FM(1). In fact this combines calls to several
        !Forms Manager routines and may prove more appropriate where several different forms
        !are required in one program. Form definition files are described in chapter 20 of the
        !User Guide. They can be created manually using a text editor or they can be designed
        !interactively using INTFORM. Note that INTFORM can also generate Form definitions
        !as Fortran source if required.
        !Form validation can be performed at the calling level by checking the values returned
        !by the 'get' routines in group FM(3). Simple range checks can also be activated on
        !individual fields using routines in group FM(2). Application specific validation can be
        !performed using IFormEditUser (FM(1)) an alternative entry point to
        !IFormEdit, which allows a user-supplied external routine to be called.
        !Since some fields may require special instructions to the user which it may not be
        !appropriate to leave on screen all the time, a help-field feature is provided. This is an
        !optional reserved field which can be used to display field dependent messages as the
        !user 'tabs' through the unprotected input fields. IFormHelp (FM(1)) defines the size
        !and position of this special field and IFormPutHelp (FM(3)) defines the help strings
        !which may appear in it.
        !The form 'exit key' can be interrogated on return from IFormEdit (FM(1)) in just the
        !same way as any other INTERACTER input routine. For example, by testing for the
        !help key, more comprehensive on-line help could be provided. Since IFormEdit uses
        !INTERACTER's fixed field input and menu routines, it naturally follows that all of the
        !input parameter control routines in the IP group are also available to control the
        !behaviour of the form editor. However, several of these parameters, including visibility
        !and numeric field justification, can be controlled on a field-by-field basis using the
        !IFormInputParam routine (FM(2)).
        !Form Creation & Editing INTERACTER Subroutine Reference
        !3-2
        !By default, a form is displayed in the attributes and colours which are currently selected
        !when IFormShow (FM(4)) is called (see also IFormDefaults in group FM(1)).
        !Individual field attributes can be set using IFormAttribute (FM(2)) or in a form
        !definition file.
        !Individual fields can be framed via IFormFrame (FM(2)) which sets the frame type
        !and colours. Of particular use here is the ability to specify 'graphical-only' frames, i.e.
        !fields can be framed on displays which support graphical frames but not on displays
        !which must use box characters. The latter can look cluttered or can simply require too
        !much space. Field frames are displayed by IFormShow and/or IFormShowFrame
        !(both in FM(4)).
        !All Forms Manager routines use a common field numbering system. By default, this
        !follows the order in which the form is initially defined using IFormDefine (FM(1).
        !Hence field number 1 is the field defined in element 1 of the arrays passed to
        !IFormDefine, and so on. Alternatively, order-independent field identifiers can be
        !assigned using IFormIdentifier (FM(1)), allowing fields to be added or deleted
        !more easily.
        !Forms are either displayed full-screen or in a window, the choice being made when the
        !form is created via IFormDefine or IFormLoad (both in FM(1)). If the form is to
        !be displayed in a window it should be opened via one of IWinOpen,IWinOpenTitle (both in WN) or IFormOpenWindow (FM(1)).
        !A powerful extension to the windowed form is the tabbed form. This is a multi-part
        !form, where each sub-form is selected via a labelled 'tab' attached to the edge of the
        !form. Tabbed forms are created in exactly the same way as a normal single-part form,except that fields should be grouped together into sub-forms. IFormDefineTabs
        !then identifies the last field on each form. Tabbed forms also support 'global' fields (e.g.
        !common OK/Cancel buttons) which appear on every sub-form.
        !In addition to handling data input/output fields, the Forms Manager also allows 'boxes'
        !to be defined as part of forms. These are character graphics frames or
        !horizontal/vertical lines, which can be used to sub-divide a form. Their use is purely
        !cosmetic. Collectively they are referred to as 'form-boxes'. Their layout can be defined
        !via IFormDefineBox (FM(1)) and their style is selectable via
        !IFormBox/IFormBoxN (FM(2)).
        !Internal Limits
        !The size of the internal Forms Manager storage area for character data (e.g. character
        !field contents, menu option strings, help strings and real field format strings) is fixed.
        !The maximum number of form fields and sub-forms are also fixed. The table below lists
        !these limits.
        !Maximum Character Storage Maximum
        !Fields Area in Bytes Sub-forms
        !300 30000 30
        !INTERACTER Subroutine Reference Form Creation & Editing
        !3-3
        !3.1 Group FM(1) : Form Creation and Editing
        !This group deals with whole-form manipulation, particularly creation and editing of
        !forms. IFormDefine defines a new form, from arrays describing the basic layout of
        !the form fields. Optionally, IFormDefineBox adds a set of form-boxes to a form
        !definition. IFormDefineTabs specifies the additional information required to create
        !a tabbed (multi-part) form.
        !As an alternative to a series of form/field definition subroutine calls, IFormLoad can
        !be used to create a new form in a single call by loading a complete form definition from
        !a disk file. IFormSave saves a form to disk in the same format.
        !To allow the user to enter data in the form, call IFormEdit. Alternatively,IFormEditUser invokes the same form editor, with a 'user-exit' subroutine allowing
        !customised form processing.
        !IFormOpenWindow opens a window for a form, if defined in an IFD file. Similarly,IFormDefaults activates default colours, etc. specified in such a file.
        !Fields and form-boxes can be assigned identifiers via IFormIdentifier and
        !IFormIdentifierBox respectively. Both routines require an array of identifiers for
        !all the fields or boxes in the form.
        !A set of check-boxes can be treated as a radio-button group by calling
        !IFormRadioButton. In such a group, only one check-box is ever enabled at a time.
        !The location of a single 'help' field can be specified via IFormHelp.
    end subroutine

    
    subroutine IScreenBackground(COLOR1,COLOR2)
        character(len=*) COLOR1 ! ) : Colour names in upper or lower case.
        character(len=*) COLOR2 ! ) : Same names as used by ITextColour/IGrColour
        ! (Defaults : COLOR1 = Black , COLOR2 = White)
        ! Short-name : SCBACK
        ! Fills the screen with a background 'desktop' pattern, consisting of a mixture of the
        ! specified colours. When used with the text windowing routines in Group WN, this
        ! routine enables particularly effective displays to be created. In graphics modes, it can
        ! also be used with the IGrAreaClear routine to achieve a similar effect.
        ! In a monochrome mode the default values of COLOR1 and COLOR2 are automatically
        ! used to give a grey effect. If COLOR1 and COLOR2 are the same, a default value will be
        ! used for one or other of them to ensure that a mixed colour pattern is generated. The
        ! simplest way to use the routine is thus to call it using CALL
        ! IScreenBackground('',''), which gives a standard grey background.
        ! If IScreenBackground is called in a graphics mode on a display which supports
        ! independent text and graphics, the text plane/window is simply cleared and the
        ! background effect is applied to the graphics plane/window.
        !e.g. CALL IScreenMode(.T',80,25,16)
        !CALL IScreenBackground(' ',' ')
        !CALL IWinOpen(10,5,70,20)
        !C ...
        !CALL IScreenMode('G',640,480,16)
        !CALL IScreenBackground('C','BLUE')
        !CALL IGrArea(0.2,0.2,0.8,0.8)
        !CALL IGrAreaClear
        !Portability notes :
        !Xlib :
        !In a text mode the window is cleared to the colour specified by COLOR2.
        !Terminals (graphics mode) :
        !The background effect requires support for stippled area fills (e.g. a Tek 410x/420x).
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-2
        !Terminals (text mode) :
        !Whilst feasible on many serial terminals, in practice the effect is unsatisfactory so
        !IScreenBackground simply clears the screen. Where the terminal is able to clear
        !the screen to a specific colour, COLOR2 is used.
    end subroutine

    subroutine IScreenBell(ONOFF)
        character(len=*) ONOFF ! 'ON' : enable the bell ) upper or
        ! = 'OFF' : disable the bell ) lower case
        ! = Any other value to ring bell if currently enabled
        ! Short-name : SCBELL
        ! Rings the bell or switches the bell on/off. By default the bell is enabled so a call to
        ! IScreenBell with a blank argument would ring the bell. However, in some
        ! environments the bell can become irritating if used frequently (it is called by
        ! IGrPause at the end of a graphics screen and by the various fixed field input
        ! routines). To stop IScreenBell producing any sound, the on/off option is provided.
        ! This does not physically switch sound off (as is possible on some hardware), it simply
        ! controls the action taken by IScreenBell when an argument other than 'ON' or
        ! 'OFF' is supplied.
        !e.g. LOGICAL IMenuYesNo
        !IF (IMenuYesNo(1,1,'Sound ?',0,1)) THEN
        !CALL IScreenBell('ON')
        !ELSE
        !CALL IScreenBell('OFF')
        !ENDIF
        !C now check state of bell
        !CALL IScreenBell(' ')
    end subroutine

    subroutine IScreenBuffer(ACTION)
        character(len=*) ACTION ! 'ON' : Enable screen output buffering
        ! = 'FL' : Flush screen output buffer
        ! (leaves buffering state unchanged)
        ! Any other value : Flush output buffer and disable buffering
        ! Short-name : SCBUFF
        ! Controls screen output buffering on a multi-user system. On some systems, use of this
        ! facility can substantially improve performance. By default, buffering is disabled.
        ! When screen output buffering is enabled, control codes and text are not automatically
        ! written to the screen but are stored in an internal buffer. INTERACTER then flushes
        ! that buffer when it becomes full or when performing various operations such as reading
        ! from files or the keyboard. On some hardware, buffering can substantially reduce
        ! overheads associated with frequent small terminal output operations.
        ! As a side-effect of enabling buffering it may be necessary to explicitly flush the output
        ! buffer when performing time consuming operations which INTERACTER is not aware
        ! of, such as complex calculations or file I/O. If the output buffer is not flushed in these
        ! situations small amounts of output may not appear on screen when expected. If this
        ! occurs simply call IScreenBuffer with a 'FL' argument to flush the buffer. This
        ! will ensure that the screen display is synchronised with your program whilst leaving
        ! buffering enabled. Since INTERACTER automatically flushes its output buffer in many
        ! situations, it should rarely be necessary to call IScreenBuffer('FL'), if at all.
        ! INTERACTER Subroutine Reference Screen Manipulation
        ! 4-3
        ! If required, buffering can be enabled and disabled selectively during a program run. To
        ! switch output buffering off, simply call IScreenBuffer with an argument other
        ! than 'ON' or 'FL'. This will flush the current output buffer contents, if any, and restore
        ! the default state of immediate screen output.
        ! As an alternative to enabling buffering using IScreenBuffer, an initialisation file
        ! keyword BUFFEROUT is provided. The easiest way to decide whether buffering is
        ! beneficial on a given system or device is to try including this keyword with a 'YES'
        ! argument in the initialisation file and observe the results. IScreenBuffer('FL')
        ! calls can be included in a program which does not include any explicit buffer enabling
        ! call (i.e. no IScreenBuffer('ON') call), leaving buffering to be enabled if
        ! required using BUFFEROUT=YES.
        !e.g. CALL IScreenOpen(' ','T',80,25,16)
        !CALL IScreenBuffer('ON')
        !CALL IOutMessage('Hang on whilst I crunch some numbers !')
        !CALL IScreenBuffer('FL')
        !CALL CRUNCH
        !Portability notes :
        !DOS and Windows :
        !IScreenBuffer has no effect in these implementations.
        !Xlib :
        !INTERACTER automatically buffers Xlib output regardless of whether
        !IScreenBuffer requests buffering to be enabled or disabled. The flush option is
        !fully supported and will prove useful on all X Windows displays.
        !Serial terminals under VMS and Unix :
        !The precise benefits of using buffering on these operating systems varies considerably
        !and can only be determined by experimentation.
    end subroutine

    subroutine IScreenClose
        ! Quit/terminate INTERACTER screen handling. Call this routine when you have finished
        ! using INTERACTER to tidy up. In a windowing environment, it removes the program
        ! window. In a full-screen environment, it clears the screen and returns to a text mode. If
        ! graphics hardcopy is currently enabled, hardcopy output is terminated, by calling
        ! IGrHardCopy('s'). Any system dependent close down processing is also
        ! performed here. This need not be the last statement in your program, but you should not
        ! call any further INTERACTER routines without calling IScreenOpen again.
        !e.g. CALL IScreenClose
        !C Fortran screen I/O now available again
        !WRITE(*,*)'Bye bye ...'
        !Portability notes :
        !DOS :
        !If opened, the temporary graphics mode window/menu pop-up buffer file is deleted.
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-4
        !Terminals under Unix :
        !When using a serial terminal or terminal emulator under Unix, it is particularly
        !important to call IScreenClose, otherwise the terminal driver gets left in a weird
        !state. If for some reason you exit normally from an INTERACTER program but without
        !calling IScreenClose, enter one of the following commands to restore the terminal
        !to a usable state (Note, you won't be able to see these commands on the screen but they
        !should work all the same.) :
        !reset (BSD based Unix - use Ctrl/J, not Enter)
        !stty sane (Unix System V - use Ctrl/J, not Enter)
!        type(Fields), pointer :: this
!        this => this_
!
!        !hide(this%canvasWindow);
    end subroutine

    subroutine IScreenCode(TOGRAF,TOTEXT)
        character(len=*) TOGRAF ! Control code to switch to graphics from text mode
        character(len=*) TOTEXT ! Control code to switch to text from graphics mode
        ! (each must be no more than 40 characters long)
        ! Short-name : SCCODE
        ! Specifies the control codes to be used to switch to graphics mode from text mode and
        ! vice versa. This is provided to enable INTERACTER to use dual VT/Tektronix
        ! terminals which are not otherwise explicitly supported. i.e. If the display hardware type
        ! has been defined in the initialisation file or in a call to IDisplay as 111/112, call this
        ! routine to ensure that INTERACTER can use the Tektronix graphics mode.
        ! Alternatively, these codes can be specified in the initialisation data file (see chapter 14
        ! of the User Guide).
        ! If both the user and the program fail to select these mode switching control codes,IGrInit/IScreenMode/etc. will not be able to automatically switch between
        ! graphics and text screen modes. (This can be checked for by calling InfoHardware.)
        ! When this occurs, the user will be prompted to change modes manually.
        ! The following example defines the codes as used by a DEC VT240 terminal.
        !e.g. CALL IScreenCode(CHAR(27)//'[?38h',CHAR(27)//'[?38l')
        !Portability notes :
        !DOS and Windows :
        !This call has no effect.
    end subroutine

    subroutine IScreenCopy(IXTOPL,IYTOPL,IXBOTR,IYBOTR,TEXT)
        integer IXTOPL ! Top left corner X text co-ordinate
        integer IYTOPL ! Top left corner Y text co-ordinate
        integer IXBOTR ! Bottom right corner X text co-ordinate
        integer IYBOTR ! Bottom right corner Y text co-ordinate
        character(1) TEXT(*) ! Array to receive text copied from screen
        ! Short-name : SCCOPY
        ! Copies a block of text from the specified area of the screen into the supplied array. Text
        ! can be pasted back to the screen using the companion IScreenPaste routine. The
        ! entire screen can be copied by setting IXTOPL and IYTOPL to one and IXBOTR and
        ! IYBOTR to the appropriate screen dimensions (available via InfoScreen).
        ! INTERACTER Subroutine Reference Screen Manipulation
        ! 4-5
        ! Note that unlike most INTERACTER routines which use passed length CHARACTER
        ! variables, TEXT should be declared as a CHARACTER*1 array. Obviously, TEXT must
        ! be declared to be large enough to hold the amount of text which is to be copied,according to the formula :
        ! TEXT dimension = (IXBOTR-IXTOPL+1) * (IYBOTR-IYTOPL+1)
        ! An alternative method of performing a direct screen-area to screen-area cut and paste
        !would be to open a window (e.g. using IWinOpen), then use IWinMove to move the
        !contents of that window. This method has the advantage of maintaining screen
        !attributes, such as reverse video, etc. On the other hand it has a greater screen
        !processing overhead and does not give the calling program access to the actual screen
        !contents. Each method will be appropriate in different situations.
        !e.g. CHARACTER*1 TEXT(400)
        !C copy top left quarter of screen to top right
        !CALL IScreenCopy(1,1,40,10,TEXT)
        !CALL IScreenPaste(41,1,80,10,TEXT)
        !Portability notes :
        !DOS :
        !Some restrictions apply in graphics modes :
        !(a) Text written in 16/256 colour modes on a background which uses non-zero pixel
        !values cannot be recognised. The exception is text written in reverse video (see
        !below).
        !(b) The Salford FTNxx versions of IScreenCopy reads screen memory directly in all
        !modes. Consequently, it works in all graphics modes with all three text heights (8,14 and 16 scan lines), subject to the limitation described in (a). Reverse video text
        !is recognised in all modes.
        !(c) Non-Salford versions of IScreenCopy read graphics mode screen characters
        !using the BIOS. Text recognition is less reliable as a result. Selecting text heights,using IScreenModeOptions, which do not match the BIOS default for the
        !current mode will cause text not to be recognised.
    end subroutine

    subroutine IScreenDump(PNAME)
        character(len=*) PNAME ! Name of printer device, print file or print command
        ! (uses default for current operating system if blank)
        ! Short-name : SCDUMP
        ! Dumps the current screen on a printer or to a print file ready for subsequent printing.
        ! The PNAME argument is used in text mode dumps and in type 2 graphics mode dumps
        ! (see below). If a blank device/file name is specified. IScreenDump will write to the
        ! default destination assigned in IScreenOpen. This can be specified using the
        ! PRNAME keyword in the initialisation file. If this is not found, a system specific default
        ! is used (see Portability notes). Since it will sometimes be useful to over-ride these
        ! default values, a file or device name can be specified using PNAME. Note that dumping
        ! a screen to a file overwrites what is already in that file. When dumping to a file, a .dmp
        ! suffix is recommended.
        ! Other behaviour depends on whether the screen is in text or graphics mode:
        ! Screen Manipulation INTERACTER Subroutine Reference
        ! 4-6
        ! Text modes :
        ! On Epson compatible printers (including IBM Proprinters and IBM Graphics Printers),various facilities are utilised. Where character graphics are supported (on LQ, IBM and
        ! Shinwa printers), frames drawn with routines such as IFrame will be accurately
        ! reproduced, otherwise +|- characters are used. If a 132 column screen mode is to be
        ! dumped on an 80 column printer, condensed text is used. Underlining, italics and bold
        ! text are also supported. Foreground text colours are reproduced on Epson JX and
        ! colour LQ printers.
        ! On an HP PCL-compatible page printer underlining is supported. 132 column mode
        ! selects the Line-printer font. Bold is also supported, but requires a suitable font card or
        ! a previously downloaded softfont on a LaserJet+. Italics also require a font card or
        ! softfont on some HP printers. Note that IScreenDump sends a printer reset
        ! command, so softfonts must be downloaded as permanent rather than temporary fonts.
        ! The PC character set is selected for frames drawn using character graphics, except on
        ! the LJ+ and LJII where +|- are used. Foreground text colours are reproduced on an HP
        ! PaintJet.
        ! Graphics modes :
        ! In graphics mode INTERACTER can either generate a graphics dump or a text dump. If
        ! a text dump is selected (by IScreenDumpOptions(22,0)) the above text-mode
        ! notes apply. However, by default, a graphics dump is generated. This invokes one of
        ! three types of screen dump (as reported by InfoHardware(30)), depending on the
        ! current platform or display type :
        ! (1) Tek/DEC graphics terminals : The terminal's own hardware dump is used to print
        ! the screen on a locally attached printer. INTERACTER assumes that the connected
        ! printer is compatible with the terminal's built in dump. The PNAME argument and the
        ! dump options set via IScreenDumpOptions are not used.
        ! (2) DOS and X Windows: INTERACTER's own internal screen dump routine is used.
        ! This requires an HP or Epson type printer (see the Supported Hardware chapter in
        ! the User Guide). The type of printer can be selected using IPrinter or
        ! IdPrinter. Alternatively the printer can be identified using the initialisation file. If
        ! the printer type has not been specified, INTERACTER defaults to a LaserJet III.
        ! Various aspects of INTERACTER's HP/Epson screen dumps (size, position, etc.) can be
        ! controlled using IScreenDumpOptions. By default, printer density is selected
        ! automatically, according to the resolution of the graphics screen display and the
        ! required size of the printer image. The resolution of the resulting printer image is
        ! limited to that of the screen since IScreenDump has no concept of how the graphics
        ! display was generated. Typical automatically selected print resolutions will be between
        ! 75 and 120 dots per inch depending on printer type and requested image size. Higher
        ! resolutions can be forced, giving some increase in quality (and volume of output) using
        ! IScreenDumpOptions(13,N) to override the automatic resolution selection. Grey
        ! scaling is supported in colour screen modes on monochrome printers. In a colour screen
        ! mode, eight colour output is supported on colour printers.
        ! INTERACTER Subroutine Reference Screen Manipulation
        ! 4-7
        ! When INTERACTER's own screen dump is used, PNAME can optionally specify a
        ! printing command in the same manner as is supported by the DESTIN argument to
        ! IGrHardCopy. In this case PNAME should specify an operating system command
        ! containing a space delimited @ character in the position where the filename should be
        ! specified. The screen dump will then send output to an automatically selected
        ! temporary print file and print it using the supplied operating system command.
        ! (3) Microsoft Windows : A bit image dump is performed via Print Manager to the
        ! currently selected Windows printer. Image size, position, orientation and number of
        ! copies can be set via IScreenDumpOptions. The PNAME argument is not used.
        ! Note : Higher resolution graphics hardcopy can be obtained using one of the numerous
        ! hardcopy drivers which can be activated using IGrHardCopy.
        !e.g. CALL IScreenMode('G',640,480,16)
        !CALL GRAFS
        !IERROR = InfoError(1)
        !C dump to default file or device set by IScreenOpen
        !CALL IScreenDump(' ')
        !C check for write error
        !IF (InfoError(1).NE.0) THEN
        !CALL IOutString('Error dumping screen')
        !STOP
        !ENDIF
        !CALL GRAFS2
        !C dump direct to parallel port 2 under DOS
        !CALL IScreenDump('LPT2')
        !Errors :
        !ErrFileOpen (1) : Error opening printer device/file
        !ErrFileIO (2) : Error writing to print device/file
        !ErrFileClose (3) : Error closing print device/file
        !ErrPrintGfx (5) : Graphics not supported on requested printer
        !ErrImageDump(64) : Bit image transfer failed under Windows
        !Portability notes :
        !DOS :
        !The default printer device name is PRN. If screen dump output is sent to a file, instead
        !of a printer device, the file can be printed later using a simple DOS copy command
        !(note the /B option which specifies 'Binary') :
        !COPY filename PRN /B
        !If IScreenDumpOptions(22,0) is called to select a text dump in graphics mode,IScreenDump may not be able to recognise and print some screen text. The
        !limitations described in the IScreenCopy Portability notes apply in this case.
        !MS Windows :
        !The default output file name for text screen dumps is interact.dmp. Graphics
        !screen dumps are always generated via Print Manager.
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-8
        !Unix/VMS :
        !By default, text screen output is sent to a file called interact.dmp. Alternatively,output can be sent direct to a device (e.g. LPA0: under VMS or /dev/lp under Unix,
        !as appropriate for your installation), by specifying the device name in your initialisation
        !file or in the PNAME parameter. If a text screen dump is sent to a file, it can be printed
        !in the same way as any other file on your particular system. (Note : The VMS version
        !of INTERACTER adds carriage control in column one of the print file).
    end subroutine

    subroutine IScreenDumpOptions(NOPTN,IVALUE)
        integer NOPTN ! Option number (see table)
        integer IVALUE ! Option value (see table)
        ! Used by
        ! NOPTN IVALUE Epson HP Win
        ! DumpWidth 1 Image width in points (72nd of an inch)   
        ! DumpHeight 2 Image height in points   
        ! DumpHorizPos 3 Horizontal image adjustment in points   
        ! DumpVerticPos 4 Vertical image adjustment in points   
        ! DumpOrientation 5 Orientation
        ! IntPortrait (0) : Portrait
        ! IntLandscape (1) : Landscape
        ! IntPortraitWH (2) : Portrait
        ! IntLandscapeWH (3) : Landscape
        !   
        ! DumpColour 6 Colour printer dump type
        ! OriginalColour (0) : Original
        ! Monochrome (1) : Mono (see opt 7)
        ! InvertBW (2) : Invert black/white
        !  
        ! DumpMono 7 Monochrome dump type
        ! Monotone (0) : Single tone
        ! Greyscale (1) : Greyscaled
        ! MonoInvert (2) : As 0,invert b/w
        ! GreyInvert (3) : As 1, invert b/w
        !  
        ! DumpCopies 8 Number of copies (>=1)  
        ! DumpDensity 13 Print density (Automatic (0) or 1-4)  
        ! DumpReset 19 Printer reset/form feed at start/end (0-3)  
        ! DumpTransparent 20 Transparency mode
        ! IntNo (0) : No
        ! IntYes (1) : Yes
        ! 
        ! DumpBoxSet 21 Box-drawing character set
        ! ASCIIChars (1) : ASCII
        ! IBMChars (2) : IBM
        !  
        ! Dumptype 22 Graphics mode dump type
        ! TextDump (0) : Text
        ! GraphicsDump (1) : Graphics
        !  
        ! Short-name : SCDOPT
        ! Include : intersc.inc, intergen.inc
        ! INTERACTER Subroutine Reference Screen Manipulation
        ! 4-9
        ! Defines screen dump options. If any of these options are to be modified, this routine
        ! should be called before the call to IScreenDump which generates the screen dump.
        ! NOPTN values outside the specified range are ignored.
        ! The options checked in the table under the Epson and HP headings are used by
        ! INTERACTER's built in graphics and text screen dumps on Epson/IBM and HP PCL
        ! type printers. The options checked under the Win heading are used in Windows Print
        ! Manager graphics dumps.
        ! IScreenDumpOptions controls the output of graphics screen dumps in the same
        ! way that IGrHardCopyOptions controls output generated by the hardcopy drivers,activated by IGrHardCopy. Common options use the same option numbers. Some
        !options (e.g. line thickness) which are controllable using IGrHardCopyOptions,are not supported by IScreenDumpOptions since IScreenDump simply
        !reproduces an image of the screen and has no concept of how that image was created.
        !Note : This routine can also be called using the Winteracter-compatible name
        !IGrPrintImageOptions.
        !The first 5 options allow control over the size and position of the image on the printed
        !page. Image dimensions are expressed in points, as for IGrHardCopyOptions.
        !Note however, that in IScreenDumpOptions the vertical image adjustment is
        !relative to the top of the output page, unlike IGrHardCopyOptions which defines
        !vertical adjustment relative to the bottom of the page.
        !When selecting orientation (option 5) values 0 and 1 select portrait or landscape
        !orientation, but leave the image width/height values unchanged. Values 2 and 3 have
        !the same effect except that they also force the width/height. For example, specifying
        !option 5 as 2 will select portrait orientation and force option 1 to be the minimum of
        !options 1/2 and option 2 to the maximum of options 1/2. Hence, specifying option 5 as
        !2 or 3 may also exchange the values of options 1 and 2 as necessary.
        !Image width/height are independent of the requested orientation. They define the size
        !of the printed image independently of whether it has been rotated on the output page.
        !On some printers minimum image dimensions are enforced, dependent on screen and
        !maximum printer resolution, overriding those specified to IScreenDumpOptions.
        !This is only likely to affect requests for relatively small dumps on low resolution
        !devices such as 9 pin Epson/IBM dot-matrix printers.
        !Option 6 controls output on colour printers. By default IVALUE is 2, which generates
        !colour output with black and white inverted. Alternatively, IVALUE=0 suppresses
        !black/white inversion to give the closest possible reproduction of the screen display on
        !the printer. IVALUE=0 is the default setting if black/white reversal is enabled via
        !IScreenOpen. A monochrome dump can be selected by setting IVALUE to 1. This
        !will be quicker than a colour dump. In this case option 7 determines the precise kind of
        !monochrome dump exactly as for a monochrome printer.
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-10
        !Option 7 selects the dump type on monochrome printers (or on colour printers when a
        !mono dump has been selected via option 6). By default a grey scaled dump will be
        !generated, i.e. IVALUE = 1 or 3. When the default white-on-black screen palette is
        !used IVALUE defaults to 3, causing black/white to be inverted when printed. If the
        !black-on-white palette is enabled (usually via IScreenOpen), IVALUE defaults to
        !one (i.e. white on screen gives white on the page). A single tone dump can also be used,i.e. IVALUE = 0 or 2. Again the choice is between matching screen/printer colours (0)
        !or inversion of black/white (2). Two points to note about monochrome screen dumps:
        !1) Monotone dumps are only really suitable for line drawings. Areas of varying
        !colours of solid fills will come out as solid black if a monotone dump is used.
        !2) Printer grey scaling is not available in monochrome screen modes, since grey scales
        !are based on screen colours. A monotone screen dump has to be performed on such
        !displays.
        !Option 8 allows the number of copies to be set, where the selected printer offers such
        !control (e.g. HP LaserJet). Where a printer does not provide copies control, the number
        !of copies parameter is ignored by IScreenDump.
        !Option 13 controls print density. By default, IScreenDump selects printer density
        !automatically, by choosing the lowest density which still ensures at least one printer dot
        !per screen pixel. This is the 'automatic' print density selected by IVALUE=0. However,significantly better print quality can sometimes be achieved by forcing IScreenDump
        !to print at a higher dot density. Rather than specifying the print density directly, a
        !density number of 1-4 is used. For each known output device INTERACTER supports
        !up to 4 different densities. The number of supported densities is returned by
        !InfoHardware(2). Actual densities available are returned by
        !InfoHardware(3-6). For example, an HP PaintJet supports two print densities,180 dpi and 90 dpi. InfoHardware(2) would return a value of two. Printer density
        !1 is 180 dpi and density 2 is 90 dpi. Print density 1 is always the highest available.
        !Note that a minimum print density is always enforced to ensure at least one printer dot
        !per screen pixel, so requests for very low print densities may be ignored.
        !Option 19 controls the output of printer reset/form feed codes on HP PCL and Epson
        !dot-matrix type printers as follows :
        !IVALUE = HP PCL : 0 = don't reset printer at all
        !1 = reset printer at end only
        !2 = reset printer at start only
        !3 = reset printer at start and end
        != Epson : 0/2 = No form feed at end of print
        !1/3 = form feed at end of print
        !By default output to HP PCL printers begins and ends with a printer reset control
        !sequence (ESC E). This resets the printer to its default state and prints out all data from
        !the printer's buffer. Similarly, output to an Epson type dot-matrix printer is always
        !terminated by a form-feed by default. Option number 19 can be used to modify this
        !behaviour. In the case of HP PCL compatible page printers, it can be used to print more
        !than one image on the same page. For Epson printers IVALUE can be set to 0 or 2 to
        !suppress the final form feed, thus allowing additional printout to be added immediately
        !below the printed image.
        !INTERACTER Subroutine Reference Screen Manipulation
        !4-11
        !Note that option 19 is only meaningful where output is sent direct to the printer or
        !where separate output files are generated for each dump. Two consecutive dumps to a
        !named file will cause the data from the first dump to be over-written and lost.
        !Option 20 allows 'transparency mode' to be enabled when dumping graphics screens to
        !an HP PaintJet. This causes the PaintJet to use double pass printing for higher quality
        !when printing on transparency film. This option should not be used for paper hardcopy
        !and is disabled by default.
        !Option 21 selects the printer character set to be used for box-drawing characters and
        !special symbols (pi, etc.) when dumping text screens. By default, ASCII characters (+,-, etc.) are used to substitute for box-drawing characters on Epson MX/FX/JX and HP
        !LJ+/LJII printers. The standard IBM PC character set is used on IBM-type, Epson LQ
        !and other HP printers. The latter gives a much more satisfactory effect. Where
        !INTERACTER does not use the IBM character set by default, but a printer is known to
        !support it (e.g. a LJII with a suitable font cartridge) the PC compatible character set can
        !be utilised by setting IVALUE to 2.
        !Option 22 determines whether a text or graphics dump is performed in graphics screen
        !modes. By default, a graphics dump is performed, but a text dump can be performed if
        !preferred. This will be mainly useful on displays which separate text and graphics
        !output (i.e. xterm, Tek 41xx/42xx terminals, Tera Term Pro) where screen text cannot
        !otherwise be printed in graphics mode. When a text dump is selected IScreenDump
        !essentially behaves in the same way in both text and graphics modes. The only
        !limitation concerns DOS graphics modes - refer to the Portability notes for the
        !IScreenCopy routine, regarding INTERACTER's ability to recognise screen text in
        !such modes.
        !All options which affect graphics screen dumps can be set interactively using the
        !IdScreenDumpOptions subroutine. Current settings can be interrogated via
        !InfoScreen(100+N).
        !The following table lists the default option values :
        !Default IVALUE
        !NOPTN Epson IBM HP Windows
        !1 576 576 576 Set via
        !2 432 432 432 'Printers'
        !3 0 0 100 in
        !4 0 0 70 Control
        !5 Portrait Portrait Landscape Panel
        !6 InvertBW - InvertBW -
        !7 GreyInvert GreyInvert GreyInvert -
        !8 - - 1 copy - " -
        !13 0 0 0 -
        !19 3 3 3 -
        !20 - - no -
        !21 varies IBM varies -
        !22 graphics graphics graphics graphics
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-12
        !Note that the default settings for option 6 and 7 becomes OriginalColour (0) and
        !Greyscale (1) respectively if black/white reversal is enabled via IScreenOpen (or the
        !REVERSE keyword), since screen and hardcopy colours will then match.
        !e.g.
        !C select Portrait and move image down by 40 points
        !CALL IScreenDumpOptions(5,0)
        !CALL IScreenDumpOptions(4,40)
        !C suppress form feed/printer reset at end of dump
        !CALL IScreenDumpOptions(19,2)
        !CALL IScreenDump(' ')
        !Portability notes :
        !Tektronix and ReGIS :
        !On terminals, the built-in hardware graphics printer dump is used which is not
        !controllable via IScreenDumpOptions. InfoHardware(30) reports which type
        !of dump is currently available.
    end subroutine

    subroutine IScreenGet
        ! Short-name : SCGET
        ! Saves the current text screen contents, including 'attribute' information, in an internal
        ! buffer which can be restored later by IScreenPut. Since the internal buffer used to
        ! store the screen contents is not used by any other INTERACTER routine,IScreenGet and IScreenPut can be used to save and restore text screen contents
        ! across calls to any other routines which may result in the loss of text screen contents,such as graphics routines or operating system command execution. The size of the
        ! buffer used by IScreenGet is display dependent (see Portability notes below).
        ! IScreenGet is a memory based alternative to IScreenSaveImage which saves a
        ! screen to disk. In general, IScreenGet will be marginally quicker. It will also be
        ! more reliable since it eliminates the possibility of I/O errors. It should be noted
        ! however, that IScreenGet is designed to be used to save text screen contents. Whilst
        ! it may work on some displays in graphics mode, this is not guaranteed.
        !e.g. CALL IScreenMode('T',80,25,16)
        !:
        !CALL IScreenGet
        !CALL IScreenMode('G',640,480,16)
        !C plot some graphs
        !:
        !C exit from graphics mode
        !CALL IScreenMode('T',80,25,16)
        !C restore text screen
        !CALL IScreenPut
        !Portability notes :
        !DOS :
        !The size of the buffer used by IScreenGet/IScreenPut is 16000 bytes.
        !Xlib, MS Windows and Terminals :
        !The size of the buffer used by IScreenGet/IScreenPut is 20k.
        !INTERACTER Subroutine Reference Screen Manipulation
        !4-13
    end subroutine

    subroutine IScreenLoadImage(FNAME)
        character(len=*) FNAME ! Filename to load
        ! Short-name : SCLOAD
        ! Loads a screen image from the named file. See also IGrLoadImage which loads a
        ! graphics screen image file into the current graphics area rather than the whole screen.
        ! The input file type is screen mode dependent:
        ! In text mode, the file must have been saved by IScreenSaveImage. It will only be
        ! reloadable if a screen mode is available which matches that in which the file was saved.
        ! In general, text screen files are only reloadable on the display type from which they
        ! were originally saved.
        ! In graphics mode, on non-terminal displays, bit image files in PCX (PC Paintbrush) or
        ! BMP (Windows bitmap) format can be loaded. The file type is determined
        ! automatically. See the Portability notes for IGrLoadImage for implementation
        ! specific issues.
        !e.g. CALL DrawGraphs
        !CALL IScreenSaveImage('screen.pcx')
        !C display some data in here
        !:
        !IERROR = InfoError(1)
        !CALL IScreenLoadImage('screen.pcx')
        !IF (InfoError(1).NE.0)
        !1 CALL IOsExitProgram('Cannot reload screen file',21)
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error reading from file
        !ErrFileClose (3) : Error closing file
        !ErrScreenLoadSave (6) : Screen mode not supported
        !ErrNoScreenMode (26) : Cannot find suitable DOS graphics mode to load file
        !ErrBadScreenFile (27) : Incompatible or unsupported screen image file
    end subroutine

    subroutine IScreenMode(TYPE,NX,NY,NCOLOR)
        character(len=*) TYPE ! String describing type of screen mode required
        ! contains 'T' : select text screen mode (default)
        ! contains 'G' : select graphics screen mode
        ! contains 'H' : select graphics screen mode,but disable screen graphics output
        ! contains 'R' : give priority to resolution (default)
        ! contains 'C' : give priority to number of colours
        ! (All upper or lower case)
        integer NX ! Number of columns required (if a text mode requested)
        ! or horizontal pixels (if a graphics mode requested)
        integer NY ! Number or rows required (if a text mode requested)
        ! or vertical pixels (if a graphics mode requested)
        integer NCOLOR ! Number of text or graphics colours required
        ! Short-name : SCREEN
        ! Selects a text or graphics screen mode using a system independent screen description.
        ! Screen Manipulation INTERACTER Subroutine Reference
        ! 4-14
        ! INTERACTER will use its hardware information to select the nearest screen mode for
        ! the current display. The hardware will have been automatically identified or explicitly
        ! defined using an initialisation data file, in the first call to IScreenOpen or a later call
        ! to IDisplay. It is strongly recommended that the IScreenMode routine should be
        ! used to select screen display mode, to ensure portability, in preference to the machine
        ! dependent IScreenModeN routine, unless InfoScreenMode has been used to
        ! verify a particular mode's availability.
        ! The TYPE argument has two purposes. The first is obviously to select Text or Graphics
        ! mode. Its second, more subtle purpose is to specify how to select a mode when more
        ! than one text or graphics mode is available. By default IScreenMode will select a
        ! mode according to the following order of priorities :
        ! a) Select mode with nearest possible horizontal resolution
        ! b) Select mode with nearest possible number of colours
        ! c) Select mode with nearest possible vertical resolution
        ! The first two priorities can be reversed by including a 'C' in the TYPE argument to
        ! indicate that the number of colours should be given priority over horizontal resolution.
        ! This ensures that programs can be written on a machine with one type of display but
        ! still behave as intended on another where different modes may be available. This
        ! facility is of most use in graphics modes where code can be written to request a very
        ! high resolution, with a number of colours, yet still use a colour mode when executed on
        ! a low specification display.
        ! Graphics mode can also be selected by specifying G or H in TYPE. The former also
        ! enables screen graphics output. The latter restricts graphics output to hardcopy only,allowing a graphics screen mode to be used for menus/forms/etc. whilst suppressing
        ! screen graphics output. See the HARDCOPY demo program.
        ! Attempting to select a graphics mode when the currently selected display type does not
        ! support graphics will cause IScreenMode to call the IOsExitProgram routine to
        ! terminate program execution, with exit code 13. See chapter 16 of the User Guide.
        ! Any values are allowed for NX, NY and NCOLOR since INTERACTER will select a
        ! mode with the nearest equivalent. See IScreenModeN for details of display modes
        ! available on the various types of supported hardware. Since IScreenMode calls
        ! IScreenModeN, the comments under that routine regarding the resetting of colours,use of IScreenModeN in graphics mode, etc. also apply when calling
        ! IScreenMode. See also IScreenModeOptions which allows additional screen
        ! mode selection parameters to be specified.
        ! NX, NY and NCOLOR are OPTIONAL under a Fortran 90 compiler, if the
        ! INTERACTER interface definitions module is used. They default to either 80,25,16 or
        ! 800,600,256 where omitted, depending on whether a text or graphics mode is
        ! requested. Programs written to run in graphics mode on non-DOS platforms can safely
        ! omit these arguments, if screen mode option 6 has not been set to 1.
        ! INTERACTER Subroutine Reference Screen Manipulation
        ! 4-15
        !e.g.
        !C select a graphics mode - colour more important than resolution
        !CALL IScreenMode('GC',640,480,16)
        !CALL IGrColourN(12)
        !:
        !C select a text mode : priority is 80 columns then 16 colours
        !CALL IScreenMode('tr',80,25,16)
        !C same as last call, because we are using defaults
        !CALL IScreenMode(' ',80,25,16)
        !Portability notes :
        !Xlib, MS Windows and Terminals :
        !These implementations only identify one graphics mode per display, so the
        !resolution/colour arguments will normally be ignored when selecting a graphics mode.
        !The exception are Windows/Xlib when IScreenModeOptions(6,1) has been
        !called. In this case NX/NY specify the required graphics window size, the first time
        !graphics mode is entered.
    end subroutine

    subroutine IScreenModeN(MODE)
        integer MODE ! Screen mode number (see Portability notes)
        ! Short-name : SCMODE
        ! Selects screen mode by means of a system dependent mode number and clears the
        ! screen. Normally, the system independent IScreenMode should be used instead,since that does not rely on system specific mode numbers. However, IScreenModeN
        ! is provided for those who wish to produce software for a particular target system.
        ! INTERACTER uses IScreenModeN for all internal mode selection, to maintain a
        ! record of screen size/resolution as well as switching between graphics and text modes.
        ! The values allowed for MODE depend on the display hardware being used (see below).
        ! This hardware will have been automatically identified or explicitly defined using an
        ! initialisation file, in the first call to IScreenOpen or a later call to IDisplay.
        ! Selecting a new mode clears the screen and resets the palette to the INTERACTER
        ! default. The screen is normally cleared to a black or 'normal-video' background.
        ! Alternatively, the screen is cleared to a white background if black/white reversal has
        ! been enabled via IScreenOpen or the REVERSE initialisation file keyword.
        ! Selecting an unrecognised or unsupported screen mode clears the screen, sets an error
        ! code and leaves the current mode unchanged. InfoScreenMode can be used to
        ! check whether a mode is available before selecting it.
        ! Certain screen mode parameters can be specified via IScreenModeOptions.
        !e.g. CALL IScreenModeN(18)
        !Errors :
        !ErrBadMode (41) : Unknown or unsupported screen mode requested
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-16
        !Portability notes :
        !DOS :
        !A variety of modes are supported, depending on the display adapter/monitor :
        !MODE Text Graphics Colours Displays
        !3 80x25 16 VGA, SVGA
        !10 132x25V 16 non-VESA SVGA
        !11 100x37V 800x600V 16 non-VESA SVGA
        !12 80x30V 640x480V 256 non-VESA SVGA
        !17 80x30 640x480 mono VGA, SVGA
        !18 80x30 640x480 16 VGA, SVGA
        !19 40x25 320x200 256 VGA, SVGA
        !20 80x28 16 VGA, SVGA
        !21 80x43 16 VGA, SVGA
        !22 80x50 16 VGA, SVGA
        !256 80x28 640x400 256 VESA compatible SVGA
        !257 80x30 640x480 256 VESA compatible SVGA
        !258 100x37 800x600 16 VESA compatible SVGA
        !259 100x37 800x600 256 VESA compatible SVGA
        !260 128x48 1024x768 16 VESA compatible SVGA
        !261 128x48 1024x768 256 VESA compatible SVGA
        !262 160x64 1280x1024 16 VESA compatible SVGA
        !263 160x64 1280x1024 256 VESA compatible SVGA
        !264 80x60 16 VESA compatible SVGA
        !265 132x25 16 VESA compatible SVGA
        !266 132x43 16 VESA compatible SVGA
        !267 132x50 16 VESA compatible SVGA
        !268 132x60 16 VESA compatible SVGA
        !284 200x75 1600x1200 256 VESA compatible SVGA
        !V = mode size redefinable using MODE10/MODE11/MODE12 keyword
        !INTERACTER uses mode numbers 10 to 12 to provide support for non-VESA (i.e.
        !manufacturer specific) SVGA screen modes. By default these modes are disabled. Each
        !of modes 10-12 can be activated on any suitable display using MODEnn keywords in
        !the initialisation file, as documented in chapter 14 of the User Guide. The dimensions
        !of these modes can be specified as MODEnn keyword parameters, providing support for
        !a wide range of extra screen modes. The following mode-specific notes may be useful :
        !10 The size of the 16-colour extended text mode #10 is definable using the MODE10
        !keyword. A mode which is stored at segment B800h with similar internal
        !organisation to mode 3 must be used. This is an alphanumeric mode not a graphics
        !mode. Any text mode up to 8000 characters in size can be used without restriction.
        !Larger modes can also be used, subject to the following restrictions :
        !(a) IScreenLoadImage, IScreenSaveImage and IScreenGet,IScreenPut cannot be used
        !(b) A window moved by IWinMove/IWinMoveInter must not be larger than
        !8000 characters
        !(c) Pop-up menus must not be larger than 8000 characters
        !INTERACTER Subroutine Reference Screen Manipulation
        !4-17
        !11 The size of the 16-colour SVGA graphics mode 11 is definable using the MODE11
        !keyword. Four mode sizes are supported, namely 800x600, 1024x768, 1280x1024
        !and 1600x1200. Due to differences in VGA types, the chipset upon which a VGA
        !board is based must also be defined with the MODE11 keyword for all except
        !800x600 mode.
        !12 The size of the 256-colour SVGA graphics mode 12 is definable using the MODE12
        !keyword. This mode can be anything up to 1600x1200 in size. Due to differences in
        !VGA types, the chipset upon which a VGA board is based must also be defined
        !with the MODE12 keyword, for all modes.
        !All VGA's support three additional 80 column text modes are supported with 28, 43
        !and 50 rows. These have been assigned INTERACTER mode numbers 20, 21 and 22
        !respectively (internally they are variants of screen mode 3).
        !If display type 13 has been selected on a VESA compatible SVGA (either automatically
        !or manually), some or all of mode numbers 256-284 will become available. Availability
        !of these modes is identified automatically, when display 13 is selected. Otherwise, these
        !modes will not be available and SVGA mode availability should be specified via the
        !MODE10/MODE11/MODE12 initialisation file keywords.
        !Text resolutions in graphics modes 11, 12, 17, 18, 256-263 and 284 are redefinable via
        !the IScreenModeOptions routine. The text resolutions shown in the earlier table
        !are the defaults if IScreenModeOptions has not been called.
        !Support for legacy MDA/Hercules/CGA/EGA screen modes 2, 6, 7, 8, 14, 15, 16 was
        !removed at v5.0. Direct requests or these screen modes select the nearest equivalent
        !VGA mode (e.g. requesting mono EGA mode 15 selects VGA mode 17).
        !Xlib and MS Windows :
        !A simplified mode numbering scheme is used for non-DOS implementations:
        !MODE Text/Graphics Size
        !Text Graphics
        !0 Text 80x25 n/a
        !1 Text 132x25 n/a
        !2 Graphics Varies Initially 80% of display, by default
        !In text mode, the size of text font used is selected automatically, but this can be
        !overridden using the TEXTFONT initialisation file keyword (see chapter 14 in the User
        !Guide). The text dimensions in mode 1 can be redefined via IScreenModeOptions
        !(options 10 and 11). Text mode windows are not interactively resizable.
        !The target graphics mode text dimensions can be changed by setting screen mode
        !options 1 and 2. The initial target text resolution in graphics mode is 80x30, but the
        !actual text dimensions will vary slightly depending on the requested window size and
        !available font sizes.
        !The default initial graphics mode window dimensions are set to 80% of the display size,but this can be overridden using the PIXELH and PIXELV initialisation file keywords.
        !Alternatively, the arguments to IScreenOpen, IGrInit or IScreenMode can
        !specify the window size if IScreenModeOptions(6,1) has been called
        !previously. The graphics mode window is interactively resizable, so programs should
        !check for graphics window resize events when performing input handling.
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-18
        !Serial Terminals :
        !As for MS & X Windows, up to three modes are supported per display. The dimensions
        !and available colours in each mode are dependent on the selected display type. The
        !three nominal screen modes supported are :
        !MODE Text/Graphics Comments
        !0 Text Usually 80x24
        !1 Text Usually 132x24, if supported
        !2 Graphics May also support independent text output
        !132 column text modes are not available on some PC-based terminal emulators. If your
        !display type is identified to INTERACTER as 'unspecified' (e.g. display numbers
        !101/102/111/112) or as one of the various terminal emulations, the availability of 132
        !columns can be set using the COLUMNS keyword in the initialisation file. Under xterm,INTERACTER forces 132 column mode number 1 to be available.
        !Graphics and text output is routed to independent windows under xterm. On some other
        !displays it is routed to independent text/graphics planes (e.g. Tek 410x/420x and
        !EM4105). On such displays, the facilities of text mode number 0 remain available in
        !graphics mode number 2. The same is also true of ReGIS terminals, except that text and
        !graphics output share the same screen plane.
        !The default graphics resolution for each terminal type is built into the library. If
        !necessary, the actual resolution of the current display can be specified using the
        !PIXELH and PIXELV initialisation file keywords.
        !On display types 111/112 (unspecified VT/Tektronix terminals), it will not be possible
        !to switch between text and graphics modes automatically. In this case, the screen is
        !cleared and the user is prompted to switch modes manually before pressing a key to
        !continue. This can be prevented by specifying the mode switching codes via
        !IScreenCode or the initialisation file keywords TOTEXT and TOGRAPH.
        !INTERACTER Subroutine Reference Screen Manipulation
        !4-19
    end subroutine

    subroutine IScreenModeOptions (NOPTN,IVALUE)
        integer NOPTN ! Option number (see below)
        integer IVALUE ! Option value (see below)
        ! Short-name : SCMOPT
        ! Include : intersc.inc, intergen.inc, interat.inc
        ! NOPTN IVALUE
        ! GrModeCols (1) Number of text columns in graphics mode
        ! GrModeRows (2) Number of text rows in graphics mode
        ! RaiseTextWin (3) obsolete : no longer supported
        ! GrWinResize (4) obsolete : no longer supported
        ! CombineTextGr (5) obsolete : no longer supported
        ! GrWinSizeSel (6) Graphics window size selection method
        ! 0 : Use default graphics dimensions or init file
        ! values (default)
        ! 1 : Use arguments specified to
        ! IScreenOpen/IGrInit/IScreenMode
        ! TextModeBorder (7) Text mode border colour (as for ITextColourN)
        ! Flashing16 (8) Enable flashing text in 16-colour DOS text modes
        ! IntNo (0) : No
        ! IntYes (1) : Yes
        ! SysFixedFont (9) Force SYSTEM_FIXED_FONT in Windows graphics mode
        ! IntNo (0) : No
        ! IntYes (1) : Yes
        ! TxModeCols (10) Number of text columns in MS or X-Windows mode #1
        ! TxModeRows (11) Number of text rows in MS or X-Windows mode #1
        ! Gr256Colours (12) Graphics colours in 256 colour mode under
        ! MS Windows or X Windows
        ! GrCompressBMP (13) Compress BMP screen image files under DOS
        ! IntNo (0) : No
        ! IntYes (1) : Yes
        ! Defines options to be used by routines in this group (mainly IScreenModeN, and
        ! hence IScreenOpen, IScreenMode and IGrInit). IScreenModeOptions
        ! should be called before the call which it is intended to affect. Unlike most
        ! INTERACTER routines, this means that IScreenModeOptions can therefore be
        ! called before IScreenOpen, allowing initial window size to be controlled by the
        ! program.
        ! When NOPTN = 1 or 2, IVALUE specifies the preferred number of text columns or
        ! rows to be used for menus/windows/etc. in graphics mode. Some displays allow for
        ! varying text resolutions in graphics mode (see Portability notes). IScreenModeN
        ! selects a display-dependent default text resolution if IScreenModeOptions is not
        ! called or if IVALUE is passed as zero.
        ! Option 6 controls the size of the graphics window in a windowing environment :
        ! IVALUE=0 : By default, the initial size of the window is either determined by the
        ! PIXELH/PIXELV initialisation file keywords or the default setting of 80% of the
        ! display size. The window is maintained at its current size at subsequent mode changes.
        ! Screen Manipulation INTERACTER Subroutine Reference
        ! 4-20
        ! IVALUE=1 : When a graphics window is opened for the first time or re-opened on
        ! return from a text-only mode, its size can be forced to the NX/NY arguments of
        ! IScreenOpen, IGrInit or IScreenMode.
        ! Option 7 sets the text mode border colour. Normally this is black but can be changed
        ! on some displays to any one of the colours supported by ITextColourN. The border
        ! colour is only controllable in full-screen applications running in 16-colour text modes.
        ! Option 8 provides control over the availability of flashing text in 16 colour DOS text
        ! modes. By default, this option is disabled, allowing the full range of 16 colours to be
        ! used for both background and foreground text colours in such modes. If flashing text is
        ! enabled, by setting IVALUE=1, display dependent limits apply to colour availability.
        ! See Portability notes.
        ! Option 9 forces the use of the fixed size font (SYSTEM_FIXED_FONT) in graphics
        ! mode under Windows. By default, this option is disabled, allowing INTERACTER to
        ! use a rescalable TrueType Courier font for text in menus/forms/windows.
        ! When NOPTN = 10 or 11, IVALUE specifies the required number of text columns or
        ! rows to be used in mode 1 (the 'alternative text mode') under Windows or X Windows.
        ! By default this mode gives a 132x25 window, but these options allow this to be
        ! redefined up to 144x75. Note that these particular options must be set before calling
        ! IScreenOpen and remain in force until IScreenClose is called.
        ! Option 12 determines the size of the graphics colour palette on a 256 colour display
        ! under Microsoft Windows or X Windows. By default, INTERACTER uses a 16-colour
        ! palette on such a display, but this option can be used to change the palette size to 32, 64
        ! or 128 colours. This allows more simultaneous colours to be displayed, but at the
        ! possible expense of .palette cycling. effects when switching between applications.
        ! Values other than 32, 64 or 128 will always select the default palette size of 16 colours.
        ! This option has no effect on displays with other than 256 colours. Note : This option
        ! must be set before calling IScreenOpen and cannot be set again without an
        ! intervening pair of IScreenOpen/IScreenClose calls.
        ! Option 13 determines the behaviour of IScreenSaveImage and IGrSaveImage
        ! when saving a 16 or 256 colour BMP format file under DOS. When enabled, BMP files
        ! are saved compressed. By default BMP files saved by these routines are saved
        ! uncompressed. Some BMP importers cannot handle compressed BMP files.
        !e.g. CALL IScreenModeOptions(1,100)
        !CALL IScreenModeOptions(2,40)
        !CALL IScreenModeOptions(6,1)
        !C In a windowing environment open an 800x600 window
        !C Where supported, this should have 100x40 text resolution
        !CALL IScreenOpen(' ','G',800,600,16)
        !Portability notes :
        !DOS :
        !Option 2 causes one of three available character heights to be selected in graphics
        !modes with a vertical resolution of 350 pixels or more. The available character heights
        !are 8, 14 or 16 pixels, giving the following possible text resolutions :
        !INTERACTER Subroutine Reference Screen Manipulation
        !4-21
        !Modes Pixels Text Resolutions
        !12 640x350 80x21 80x25 80x43
        !12, 256 640x400 80x25 80x28 80x50
        !12, 17, 18, 257 640x480 80x30 80x34 80x60
        !11, 12, 258, 259 800x600 100x37 100x42 100x75
        !11, 12, 260, 261 1024x768 128x48 128x54 128x96
        !11, 12, 262, 263 1280x1024 160x64 160x73 160x128
        !11, 12, 284 1600x1200 200x75 200x85 200x150
        !IScreenModeN will try to select the nearest suitable vertical text resolution in
        !graphics mode to that specified using IScreenModeOptions(2,IVALUE). A
        !fixed character height of 8 pixels is used in mode 19.
        !Option 7 is supported in all 16 colour text modes : 3, 10, 20-22 and 264-268.
        !Enabling option 8 limits background colours to 'normal' intensity (i.e. just 8 colours).
        !Disabling flashing text allows bold intensity background colours to be selected.
        !Options 1, 6 and 9-12 are not supported.
        !Xlib and MS Windows :
        !Options 1 and 2 can be used to set the target graphics mode text screen resolution. A
        !nearest-fit text font is selected to try to match the requested number of rows and
        !columns into the window, even if a resize event occurs. The default target text
        !resolution is 80x30. In practice, options 1 and 2 should be viewed as guides rather than
        !absolute values. Text resolution in graphics mode will depend on the available font
        !sizes and how well they fit into the required window size.
        !If option 9 is enabled to force a fixed size font, options 1 are 2 are ignored under
        !Windows.
        !Options 7, 8 and 13 are not supported.
        !Terminals :
        !None of the current options affect serial terminals or terminal emulations.
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-22
    end subroutine

    subroutine IScreenOpen(INITFN,TYPE,NX,NY,NCOLOR)
        character(len=*) INITFN ! Initialisation data file name
        ! (blank to open default file and/or use default values)
        character(len=*) TYPE ! String describing type of screen mode required
        ! One of :
        ! 'G' : Select graphics screen mode (default)
        ! 'P' : Select graphics screen mode,if pop-up menus/windows fully supported
        ! 'H' : As 'P' but disable screen graphics output
        ! 'T' : Select text screen mode
        ! And one of
        ! 'R' : Give priority to resolution (default)
        ! 'C' : Give priority to number of colours
        ! And one of
        ! 'B' : Use a white-on-black palette (default)
        ! 'W' : Use a black-on-white palette
        ! (All upper or lower case)
        integer NX ! Number of columns required (if a text mode requested)
        ! or horizontal pixels (if a graphics mode requested)
        integer NY ! Number or rows required (if a text mode requested)
        ! or vertical pixels (if a graphics mode requested)
        integer NCOLOR ! Number of text or graphics colours required
        ! Initialises INTERACTER screen handling, attempts to read an initialisation file and
        ! enters the nearest screen mode to that requested.
        ! This routine supercedes IScreenInit, which was used to initialise INTERACTER in
        ! version 3.xx and earlier. IScreenOpen allows direct entry to graphics mode and
        ! activates a slightly different set of default settings. IScreenInit is retained as a
        ! backwards compatibility routine. It is described in Appendix A, along with details of
        ! the alternative v3.xx compatible default settings which that routine activates.
        ! Initialisation File :
        ! INITFN specifies the name of an optional initialisation data file which can be used to
        ! supply various information, including the display hardware, the printer/plotter types,default filenames and so on. (See chapter 14 of the User Guide for details of the file
        ! format). Where a filename is supplied, a suffix of .ini is recommended.
        ! The file name can be left blank if you prefer. In this case, IScreenOpen takes the
        ! following action :
        !   If the operating system variable INTINIT has been set up, the file which it
        ! specifies will be opened.
        !   If INTINIT has not been set up or the file which it points to cannot be opened,IScreenOpen searches for a file with a default name (see Portability notes).
        ! If none of the above steps result in an initialisation file being found, IScreenOpen
        ! will call the IDisplay, IPrinter, IPrinter2, IPlotter, IMouse and
        ! IDigitiser routines with zero parameters. This causes these routines to either select
        ! default values or to attempt to automatically identify the hardware in use.
        ! INTERACTER Subroutine Reference Screen Manipulation
        ! 4-23
        ! In all cases, default values are assigned for any user definable initialisation values
        ! which have not been read from an initialisation file (see Portability notes).
        ! Screen Mode :
        ! The remaining arguments specify what type of screen mode is required. The TYPE
        ! argument is the most important of these. It should consist of up to three characters, each
        ! of which can be omitted in which case the indicated default is assumed. The first
        ! character can be one of :
        ! G Enter graphics screen mode and initialise screen graphics. This is the default. If
        ! a graphics mode is not available, IScreenOpen enters a text mode (80x25x16
        ! or nearest equivalent) and initialises hardcopy-only graphics.
        ! P Same as 'G' but only enter graphics mode if it has a 'Pop-up' capability. i.e. Popup
        ! menus and text-windows must restore underlying graphics. If such a mode
        ! is not available, IScreenOpen enters a text mode (80x25x16 or nearest
        ! equivalent) and initialises hardcopy-only graphics.
        ! H As for 'P' but only initialise hardcopy-graphics, even if graphics screen mode is
        ! entered. This allows a graphics screen mode to be used for graphical effects on
        ! forms/etc. whilst generating graphics to a hardcopy channel only (See the
        ! hardcopy demo program).
        ! T Enter text mode. Hardcopy-only graphics are initialised.
        ! The second character can be one of :
        ! R Give priority to the specified resolution when more than one graphics mode is
        ! available. This is the default.
        ! C Give priority to the requested number of colours, when more than one graphics
        ! mode is available.
        ! The third character can be one of :
        ! B Use black as the default background colour in both text and graphics modes.
        ! This is the default.
        ! W Use white as the default background colour in text/graphics modes. This
        ! ensures consistent colour handling in screen and hardcopy graphics and is more
        ! common in windowing environments. However, a small number of old obsolete
        ! displays do not support this feature and will still use the black-background
        ! palette (notably Tek 401x compatible graphics modes and non-VT terminals in
        ! text mode).
        ! The NX, NY and NCOLOR arguments then specify the preferred resolution/colour
        ! combination, in the same manner as IScreenMode. Where more than one mode of
        ! the required type is available, the nearest matching mode is selected, based on the
        ! specified priority criteria (resolution or colours). If only a single mode is available and
        ! the program is running in a full screen environment, these variables are ignored. In a
        ! windowing environment, the significance of NX and NY depends on whether
        ! IScreenModeOptions(6,1) has been called.
        ! Screen Manipulation INTERACTER Subroutine Reference
        ! 4-24
        ! NX, NY and NCOLOR are OPTIONAL under a Fortran 90 compiler, if the
        ! INTERACTER interface definitions module is used. They default to either 80,25,16 or
        ! 800,600,256 where omitted, depending on whether a text or graphics mode is
        ! requested. Programs written to run in graphics mode on non-DOS platforms can safely
        ! omit these arguments, if screen mode option 6 has not been set to 1.
        ! General :
        ! IScreenOpen calls IGrInit internally to initialise INTERACTER's graphics
        ! system, with the following effects :
        !   Calls IGrArea with parameters (0.0,0.0,1.0,1.0)
        !   Calls IGrUnits with parameters (0.0,0.0,1.0,1.0)
        !   Sets current plotting position to (0.0,0.0)
        !   Sets fill pattern to default (no fill)
        !   Sets plotting colour to 223
        ! (white or black depending on TYPE)
        !   Sets secondary colour for mixed-colour fills to colour 0
        ! (black or white depending on TYPE)
        !   Sets the colour model to 8-bit
        !   Sets line type to solid
        !   Sets plot mode to normal
        !   Selects hardware character set and fixed spacing
        !   Sets character size to width and height of 1.0
        !   Sets text output direction to horizontal/rotation zero degrees
        !   Switches text underlining off
        !   Sets graphics hardcopy output to 'off'
        ! (i.e. even if TYPE='H' ; hardcopy must be initiated by IGrHardCopy)
        !   Sets graphics input device to mouse, if available
        !   Initialises the Presentation Graphics system
        ! Normally, it should not be necesary to call IGrInit directly, though it can be used to
        ! re-initialise INTERACTER's graphics.
        ! Don't call IScreenOpen twice in your programs without calling IScreenClose
        ! (the equivalent termination routine) in between. In other words, start screen handling
        ! using IScreenOpen, end it using IScreenClose and if you wish to start again call
        ! IScreenOpen, etc.
        !e.g. CALL IScreenOpen('initinfo.ini','P',800,600,16)
        !Portability notes :
        !DOS :
        !Default initialisation data file name : INTERACT.INI
        !Default screen dump output device : PRN
        !Default graphics hardcopy driver output file : INTERACT.PLT
        !Default display : Auto-identified
        !Default software character set file : STANDARD.CHR
        !Default graphics mode menu/window pop-up buffer : C:\INTTEMPW.$$$
        !INTERACTER Subroutine Reference Screen Manipulation
        !4-25
        !Microsoft Windows :
        !Default initialisation file name : INTERACT.INI
        !Default screen dump output file : INTERACT.DMP
        !Default graphics hardcopy driver output file : INTERACT.PLT
        !Default display : Windows (type 454)
        !Default software character set file : STANDARD.CHR
        !Unix :
        !Default initialisation file name : interact.ini
        !Default screen dump output file : interact.dmp
        !Default graphics hardcopy driver output file : interact.plt
        !Default display : Xlib (type 453), otherwise
        !VT100 text-only (type 101)
        !Default software character set : standard.chr
        !The first time that IScreenOpen is called under Unix, various signal handlers are set
        !up to catch the following signals :
        !SIGINT, SIGQUIT, SIGILL, SIGBUS, SIGFPE, SIGSEGV
        !The signal handlers are used to ensure that the terminal driver is restored to a sensible
        !state on abnormal termination. If signal handlers have already been set up by the calling
        !program, INTERACTER saves these handlers so that control can be returned to them
        !after restoring the Unix terminal driver. If you wish to set up your own signal handlers
        !after calling IScreenOpen be sure to pass control to the handler set up by
        !INTERACTER or call IScreenClose in your own handler.
        !VMS :
        !Default initialisation file name : INTERACT.INI
        !Default screen dump output file : INTERACT.DMP
        !Default graphics hardcopy driver output file : INTERACT.PLT
        !Default display : Xlib (type 453), otherwise
        !VT100 text-only (type 101)
        !Default software character set file : STANDARD.CHR
        !Terminals :
        !The black/white reversal option is only available on terminals which meet the following
        !criteria :
        !a) Monochrome VT-compatible terminals in text mode
        !b) ANSI compatible terminals which support 'clear-to-background-colour.
        !c) Tek 4100/4200 and 16-colour ReGIS graphics modes
        !This means that black/white reversal has no effect on :
        !a) Colour text modes which do not support clear-to-background
        !b) Tek 401x graphics modes (mono and colour)
        !c) Non VT/ANSI mono text terminals
        !Screen Manipulation INTERACTER Subroutine Reference
        !4-26
    end subroutine

    subroutine IScreenPaste(IXTOPL,IYTOPL,IXBOTR,IYBOTR,TEXT)
        integer IXTOPL ! Top left corner X text co-ordinate
        integer IYTOPL ! Top left corner Y text co-ordinate
        integer IXBOTR ! Bottom right corner X text co-ordinate
        integer IYBOTR ! Bottom right corner Y text co-ordinate
        character(1) TEXT(*) ! Array containing text to be pasted onto screen
        ! Short-name : SCPAST
        ! Pastes a block of text into the specified area of the screen from the supplied array. This
        ! routine is mainly designed to be used with the companion IScreenCopy routine
        ! which first copies a block of text from the screen. IScreenPaste can however be
        ! used entirely independently of IScreenCopy if you prefer. Text is pasted using the
        ! current attributes as set by the AT group routines.
        ! The entire screen can be pasted by setting IXTOPL and IYTOPL to one, IXBOTR to
        ! InfoScreen(2) and IYBOTR to InfoScreen(3).
        ! Unlike most INTERACTER routines which use passed length CHARACTER variables,TEXT should be declared as a CHARACTER*1 array. IScreenPaste assumes that
        ! TEXT has been declared to be large enough to hold the full area of text which is to be
        ! pasted, according to the formula :
        ! TEXT dimension = (IXBOTR-IXTOPL+1) * (IYBOTR-IYTOPL+1)
        !e.g. CHARACTER*1 TEXT(400)
        !C copy top left quarter of screen to top right
        !CALL IScreenCopy(1,1,40,10,TEXT)
        !CALL IScreenPaste(41,1,80,10,TEXT)
    end subroutine

    subroutine IScreenPut
        ! Short-name : SCPUT
        ! Restores a text screen saved previously by IScreenGet. If IScreenGet has not
        ! been called, a call to IScreenPut has no effect. IScreenPut can be called any
        ! number of times after a call to IScreenGet to repeatedly restore the same screen.
        ! IScreenPut is a memory based equivalent of IScreenLoadImage.
        !e.g.
        !C save screen, issue an o.s. command and restore text screen
        !CALL IScreenGet
        !CALL IOsCommand('ls -l')
        !CALL IScreenPut
        !Portability notes :
        !See IScreenGet
        !INTERACTER Subroutine Reference Screen Manipulation
        !4-27
    end subroutine

    subroutine IScreenSaveImage(FNAME)
        character(len=*) FNAME ! Filename to save
        ! Short-name : SCSAVE
        ! Saves a screen image to the named disk file. The file can be reloaded later (by
        ! IScreenLoadImage or IGrLoadImage) and/or will be suitable for exporting to
        ! third party software. The format of the output file is screen mode dependent:
        ! Text screen images can be saved on all displays using an INTERACTER-specific
        ! format which is only reloadable by IScreenLoadImage. A filename suffix of .scr
        ! is recommended for text mode screen image files.
        ! Graphics screen images can be saved on non-terminal displays in BMP (Windows
        ! bitmap) or PCX (PC Paintbrush) format. Use a .pcx or .bmp file extension to identify
        ! the target format. See also IGrSaveImage which saves the current graphics area. For
        ! platform specific issues refer to the IGrSaveImage Portability notes.
        ! InfoGrScreen(17) can be called to test whether graphics images can be saved
        ! from the current display.
        ! As an alternative to saving a graphics screen image file, IGrHardCopy can be called
        ! to invoke one of the HP-GL, HP-GL/2, WMF, CGM or PIC drivers before generating
        ! your graphics output to log all graphics commands to a file. This file can be replayed
        ! using IGrReplay. IGrHardCopy can also be called to invoke the raster image file
        ! driver which can build a virtual raster image and save it in PCX or BMP format. Files
        ! generated via IGrHardCopy have the advantage of being display independent, but
        ! will not reproduce any text generated by INTERACTER's menu/window/form/etc.
        ! routines.
        !e.g. CALL DrawGraphs
        !CALL IScreenSaveImage('screen.pcx')
        !IF (InfoError(1).NE.0)
        !1 CALL IOsExitProgram('Cannot save screen',21)
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error writing to file
        !ErrFileClose (3) : Error closing file
        !ErrScreenLoadSave (6) : Screen mode not supported for load/save
    end subroutine

    subroutine IScreenScroll(IY1,IY2,NLINES)
        integer IY1 ! Top row of area to scroll
        integer IY2 ! Bottom row of area to scroll
        integer NLINES ! > 0 : scroll lines up by NLINES
        ! < 0 : scroll lines down by ABS(NLINES)
        ! = 0 : clear all lines from IY1 to IY2
        ! Short-name : SCSCRL
        ! Scrolls the text screen lines defined by IY1 to IY2 inclusive, in the specified direction,by the specified number of lines. If NLINES is zero the lines are cleared.
        ! Screen Manipulation INTERACTER Subroutine Reference
        ! 4-28
        !e.g. CALL IOutStringXY(1,12,'This will disappear upwards')
        !CALL IScreenScroll(5,20,10)
        !CALL IOutStringXY(1,12,'This will disappear downwards')
        !CALL IScreenScroll(5,20,-10)
        !CALL IOutStringXY(1,12,'This will disappear without scrolling !')
        !CALL IScreenScroll(5,20,0)
        !Portability notes :
        !Terminals :
        !Full screen width scrolling is generally more efficient than scrolling a window, since
        !hardware scrolling features can be utilised.
        !Tektronix :
        !Scrolling is not supported on displays which do not support independent text/graphics
        !output (e.g. Tek 4014).
    end subroutine

    subroutine IScreenTitle(MODE,TITLE)
        character(len=*) MODE ! Screen mode type :
        ! = T : Text mode (default)
        ! = G : Graphics mode
        character(len=*) TITLE ! Title string (max 60 characters)
        ! Short-name : SCTITL
        ! Sets the title string to be applied to the program window in a windowing environment.
        ! IScreenTitle has no effect where a program runs full-screen.
        ! The window title will be updated immediately, if the program is currently in the mode
        ! type specified. Otherwise the title is updated the next time INTERACTER enters the
        ! specified mode type. The default titles are :
        ! Text mode : 'INTERACTER Text Window'
        ! Graphics mode : 'INTERACTER Graphics Window'
        !e.g. CALL IScreenTitle('G','Scatter Plot of Age versus Size')
        !CALL IPgScatterPlot(X,Y)
        !CALL InKeyEvent(Key)
        !CALL IScreenTitle('G','Table of Results')
        !CALL DisplayMyResults
        !Portability notes :
        !These titles are used by the Xlib and MS Windows drivers.
        !INTERACTER Subroutine Reference Information Functions
        !4-29
        !4.2 Group IF : Information
        !To help you find out exactly what facilities are available on the current system or to
        !simply interrogate the state of certain INTERACTER variables, a number of functions
        !are provided to return information to the calling program. In all cases one call to an
        !Info function returns one item of information. The item number is normally supplied
        !as the only argument to the function, to identify what information is required (except
        !for InfoField and InfoScreenMode functions which take a second argument).
        !Several of the information functions correspond to a specific subroutine group. Hence,for information relating to the text attribute routines in group AT call
        !InfoAttribute. Other functions return infomation which is not specific to one
        !subroutine group, such as InfoError/InfoErrorMessage and InfoFilename
        !which provide error and file name information.
        !Graphics information is accessed through three separate functions InfoGraphics,InfoGrScreen and InfoGrHardcopy. InfoGraphics returns real data,
        !describing the current state of various graphics parameters. InfoGrScreen and
        !InfoGrHardcopy return device capability information relating to the graphics
        !screen and hardcopy devices respectively. Presentation graphics information is
        !available via InfoPgStyle, InfoPgInteger and InfoPgReal.
        !In all cases, specifying an invalid ITEM number to an Info routine returns an
        !undefined result.
    end subroutine

    subroutine InfoDeviceName(ITEM,NAME)
        integer ITEM ! Type of description to return:
        ! 1 : Current printer type
        ! 2 : Current HP-GL plotter type
        ! 3 : Current HP-GL/2 printer/plotter type
        character(len=*) NAME ! Returned printer/plotter description
        !Returns a descriptive string for the current INTERACTER printer or plotter type (e.g.
        !"Epson LQ/SQ"). These correspond to the device types described in the Printers and
        !Plotters chapter of the User Guide.
        !e.g. CHARACTER*27 PRNAME,PLNAME
        !CHARACTER*31 P2NAME
        !CALL InfoDeviceName(1,PRNAME)
        !CALL InfoDeviceName(2,PLNAME)
        !CALL InfoDeviceName(3,P2NAME)
        !Information Functions INTERACTER Subroutine Reference
        !4-30
    end subroutine

    INTEGER function InfoAttribute(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! BoldText (1) : Bold text supported )
        ! FlashingText (2) : Flashing text supported ) IntNo (0) : no
        ! ItalicText (3) : Italics supported ) or
        ! ReverseVideo (4) : Reverse video supported ) IntYes (1) : yes
        ! UnderlineText (5) : Underlining supported )
        ! ForeTextCol (6) : Number of foreground text colours
        ! BackTextCol (7) : Number of background text colours
        ! BoldRequest (8) : Bold text requested )
        ! FlashingRequest (9) : Flashing text requested ) IntNo (0) : no
        ! ItalicRequest (10) : Italics requested ) or
        ! ReverseRequest (11) : Reverse video requested ) IntYes (1) : yes
        ! UnderlineRequest (12) : Underlining requested )
        ! ForeColRequest (13) : Foreground text colour requested (0-15)
        ! BackColRequest (14) : Background text colour requested (0-15)
        ! ClearToBack (15) : Clear-to-background supported
        ! (IntNo (0) : no IntYes (1) : yes)
        ! Short-name : INFOAT
        ! Include : interif.inc, intergen.inc
        ! Returns information about the availability and requests for text attributes.
        ! The first 7 ITEM values return attribute support information for the current screen
        ! mode on the current display. If the current mode is monochrome the number of colours
        ! (ITEM's 6 and 7) are both returned as one, otherwise values of 8 or 16 are returned.
        ! ITEM values 8 to 14 can be used to determine what attributes or colours have been
        ! most recently requested. This information is independent of whether specific attributes
        ! or colour are actually supported on the current display. Text colour numbers are
        ! returned using the same numbering scheme as ITextColourN, regardless of whether
        ! ITextColour or ITextColourN was used to specify text colour originally.
        ! ITEM 15 returns a non-zero value if routines such as IClearLine and
        ! IClearScreen clear to the current background colour. If this returns zero, they
        ! always clear the line or screen to the default for the current display (usually black).
        !e.g. IF (InfoAttribute(6).GT.2) CALL ITextColour('Red',' ')
        !INTERACTER Subroutine Reference Information Functions
        !4-31
    
        res = 0
    end function

    INTEGER function InfoCursor(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! CursorColumn (1) : Current column
        ! CursorRow (2) : Current row
        ! SavedColumn (3) : Saved column ) NotSaved (0) : not saved
        ! SavedRow (4) : Saved row ) - ' -
        ! CursorState (5) : Requested cursor state :
        ! UnderlineOff (0) : off/underline
        ! UnderlineOn (1) : on/underline
        ! BlockOff (2) : off/block
        ! BlockOn (3) : on/block
        ! Short-name : INFOCU
        ! Include : interif.inc
        ! Returns cursor position/state information.
        ! The cursor position returned by ITEM numbers 1 and 2 is INTERACTER's internal
        ! record of the current cursor position. Any use of screen control codes or direct Fortran
        ! I/O to the screen will probably leave the cursor in some other, incorrect, position.
        ! Again, this emphasises the importance of performing all screen access via
        ! INTERACTER routines.
        ! The saved cursor positions returned by ITEM numbers 3 and 4 are only available if
        ! ICursorSave has been called, otherwise they will return zero.
        ! ITEM 5 returns the currently requested hardware cursor state as set by ICursor and
        ! ICursorSize. The returned value may not necessarily reflect the actual state since
        ! not all displays provide hardware cursor on/off and size control.
        ! InfoCursor can be useful if you wish to save more than just one (x,y) text coordinate,as is allowed for by ICursorSave/ICursorRestore.
        !e.g. IX = InfoCursor(1)
        !IY = InfoCursor(2)
        !C do some screen processing
        !:
        !C restore cursor position
        !CALL ICursorXY(IX,IY)
    
        res = 0
    end function

    INTEGER function InfoError(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! LastError (1) : Last error set by INTERACTER
        ! (see chapter 16 of the User Guide for a list)
        ! (0 if no errors since last call to InfoError(1))
        ! IOErrorCode (2) : system dependent I/O code for last type 1 or 2 error
        ! (file open or read/write error) otherwise undefined
        ! OsErrorCode (3) : Operating system error code
        ! Short-name : INFOER
        ! Include : interif.inc
        ! Returns information about the last error to be detected. If no errors have occurred since
        ! start-up or since the last call to InfoError, the last error is returned as zero. If
        ! several errors have occurred since the last call, the most recent error is returned.
        ! Information Functions INTERACTER Subroutine Reference
        ! 4-32
        ! A call to InfoError also resets the 'last error', IOSTAT value or o.s. error code
        ! (depending on the value of ITEM) to zero. This feature can be used to clear the error
        ! flags, when your program is uncertain of what errors may already have occurred.
        ! If a type 1 or type 2 error occurs (error on file/device open, read or write), a call with an
        ! ITEM value of 2 returns the associated Fortran OPEN/READ/WRITE statement
        ! IOSTAT value or operating system I/O routine error code. This IOSTAT value will still
        ! be available if further I/O is performed or other non I/O errors occur. i.e. The error
        ! code for an I/O error remains available until it is cleared using InfoError(2) or
        ! until another I/O error occurs.
        ! ITEM 3 returns the error code set by various routines in the operating system interface
        ! routines such as IOsCommand or IOsDirList. Typically this value will only be set
        ! when ITEM 1 returns a value of 13 (Operating system command error). The meaning of
        ! this code will be entirely system dependent. Refer to your system documentation for
        ! further information. These values may also prove useful when reporting o.s. interface
        ! problems to I.S.S. As for the IOSTAT value described above, this return code remains
        ! available until it is cleared using InfoError(3) or until another o.s. error occurs.
        !e.g.
        !C clear error flag first
        !IERROR = InfoError(1)
        !ISTAT = InfoError(2)
        !CALL IScreenSaveImage('MYPIC.PCX')
        !IERROR = InfoError(1)
        !IF (IERROR.EQ.1.OR.IERROR.EQ.2) THEN
        !CALL IOutString('Save error : I/O error code = ')
        !CALL IOutInteger(InfoError(2),4)
        !ENDIF
    
        res = 0
    end function

    CHARACTER(len=100) function InfoErrorMessage(ITEM) result(res)
        integer ITEM ! INTERACTER error code number
        ! Include : interif.inc
        ! Returns a descriptive string for an INTERACTER error code ITEM. The error code will
        ! normally be a non-zero value returned previously by InfoError(1). The returned
        ! strings are mainly intended for the benefit of INTERACTER developers. They are not
        ! intended as end user diagnostics.
        ! The returned string will be equivalent to the descriptions in chapter 16 of the User
        ! Guide. If an unknown error code is specified (i.e. it is outside the range of values listed
        ! in that chapter) a blank string is returned. The maximum current message length is 62
        ! but this may change in future releases.
        ! Since InfoErrorMessage is a character function the length of the returned value
        ! depends on its declared size in the calling program. See the example.
        !e.g. CHARACTER*62 InfoErrorMessage,MESSAGE
        !CALL IGrHardCopy(plotfile)
        !ierror = InfoError(1)
        !IF (ierror.NE.0) THEN
        !MESSAGE = InfoErrorMessage(ierror)
        !LENMES = IActualLength(MESSAGE)
        !CALL IOutMessage('Error : '//MESSAGE(:LENSTR))
        !CALL InKeyEvent(key)
        !ENDIF
        !INTERACTER Subroutine Reference Information Functions
        !4-33

        res = ""
    
    end function

    INTEGER function InfoField(IFIELD,ITEM) result(res)
        integer IFIELD ! Field number (0 for help field)
        integer ITEM ! Number of information item required :
        ! FieldColumn (1) : column )
        ! FieldRow (2) : row ) as for
        ! FieldWidth (3) : width ) IFormDefine
        ! FieldType (4) : type )
        ! FieldAttribute (5) : attribute ) as for
        ! FieldForeCol (6) : foreground colour ) IFormAttributeN
        ! FieldBackCol (7) : background colour )
        ! InputCtrl (8) : input control parameters as IFormInputParam
        ! ExitCode (9) : exit code in a button field as for IFormPutButton
        ! MenuSize (10) : pop-up/vertical menu size as for
        ! IFormPopUpMenu/IFormVerticalMenu
        ! MenuOptionNum (11) : current number of menu options, as for
        ! IFormPutMenu
        ! MenuOptionMax (12) : maximum number of menu options, as for
        ! IFormPutMenu
        ! FieldFrameType (13) : Frame type as for IFormFrameN
        ! FieldFrameFore (14) : Frame fore colour as for IFormFrameN
        ! FieldFrameBack (15) : Frame back colour as for IFormFrameN
        ! Short-name : INFOFI
        ! Include : interif.inc
        ! Returns information about a specified form field defined earlier to the Forms Manager
        ! via IFormDefine or IFormLoad. Information about the help field (if defined) is
        ! available by specifying field number 0.
        ! ITEM numbers 1 to 4 return the field position, width and type, as would be specified to
        !IFormDefine. e.g. a protected string field would return a value of 1001 for ITEM 4.
        !ITEM's 5-7 return attribute/colour information using the same numbering scheme as
        !IFormAttributeN. Hence colour values may be returned as -1 for 'use the default'.
        !ITEM 8 returns a composite value which combines all the input control parameter
        !values which can be set by IFormInputParam. Assuming that par1 corresponds to
        !the value assigned by IFormInputParam when IPAR=1, and so on, the returned
        !value is constructed as follows :
        !par1 + par2*4 + par3*16 + par4*64
        !+ par5*256 + par6*1024 + par7*4096
        !ITEM 9 returns the exit code associated with a push-button field. The return value is
        !undefined for other field types.
        !ITEM 10 returns the visible size of a vertical menu or pop-up menu availability/size
        !value as would be supplied to IFormVerticalMenu or IFormPopUpMenu
        !respectively. If a cycling menu (type 4) field has not been given a pop-up capability, a
        !value of 1 is returned. The return value is undefined for non-menu fields.
        !Information Functions INTERACTER Subroutine Reference
        !4-34
        !ITEM's 11 and 12 return the current and maximum number of options in a menu field.
        !When a menu field has been defined for the first time, both values will be the same. If
        !however, the menu field is subsequently redefined with fewer options, ITEM 11 will
        !return a smaller value than ITEM 12 which will remain unchanged from its initial
        !value. The return value is undefined for non-menu fields.
        !ITEM's 13-15 return field frame information exactly as would be set by
        !IFormFrameN.
        !If an unknown field is specified InfoField returns zero. Since zero is also a valid
        !result for ITEM's 5+ it is advisable to check the result of InfoField(IFIELD,1)
        !which must always be non-zero for a valid field number or zero otherwise.
        !e.g. CALL IFormEdit(IFINIT,IFEXIT)
        !C get type of exit field
        !IFTYPE = InfoField(IFEXIT,4)

        res = 0
    
        res = 0
    end function

    CHARACTER(len=100) function InfoFilename(ITEM) result (res)
        integer ITEM ! Number of information item required :
        ! DefaultPrintDump (1) : Default printer screen dump output file/device name
        ! DefaultHardcopy (2) : Default graphics hardcopy output file/device name
        ! DefaultCharSet (3) : Default software character set filename
        ! CharSetDir (5) : Software character sets directory name
        ! FormDefsDir (7) : Form definitions directory name
        ! HelpFileDir (8) : Toolkit help files directory name
        ! CurrentCharSet (9) : Current graphics character set filename
        ! Short-name : INFOFN
        ! Include : interif.inc
        ! Returns default filenames. These may have been set up by IScreenOpen, picked up
        ! from operating system variables or defined in the initialisation file. (See chapter 4 of
        ! the User Guide for further information on filename selection).
        ! ITEM 1 returns the file or device which IScreenDump writes to by default, under
        ! DOS and Xlib. If the PRNAME initialisation file keyword has been defined, the assigned
        ! file/device name will be returned.
        ! ITEM 2 gives the default output name which will be used when graphics hardcopy
        ! output is activated using IGrHardCopy. If the PLNAME initialisation file keyword
        ! has been defined, the assigned file/device name will be returned.
        ! ITEM 3 returns the default character set filename used by IGrCharSet when a blank
        ! argument is specified.
        ! ITEM's 5, 7 and 8 are slightly different in that they return the names of directories
        ! rather than files. These directories specify the location of the graphics mode software
        ! character sets, form definition files and Toolkit help files. These are defined either via
        ! the INTCHDIR, INTFMDIR and INTHEDIR operating system variables or the
        ! CHARDIR, FORMDIR and HELPDIR initialisation file keywords.
        ! ITEM 9 returns the current character set filename as set via IGrCharSet. When the
        ! hardware character set is selected, the letter H is returned.
        ! INTERACTER Subroutine Reference Information Functions
        ! 4-35
        ! Since InfoFilename is a character function the length of the returned value depends
        ! on its declared size in the calling program. See the example.
        !e.g. CHARACTER*60 InfoFilename,OUTFIL
        !:
        !C ask for hardcopy output file name, offering current default
        !OUTFIL = InfoFilename(2)
        !CALL InStringXYDef(IX,IY,'Output to :',1,OUTFIL,LENFIL)
        !IF (LENFIL.GT.0) CALL IGrHardCopy(OUTFIL(:LENFIL))
        res = ""
    
    end function

    INTEGER function InfoForm(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! MaxNumField (1) : Maximum number of form fields available
        ! CharSpaceLeft (2) : Remaining space in form character data area
        ! NextFieldId (3) : 'Next-field' identifier in IFormEditUser
        ! user routine
        ! LastErrorLine (4) : Line no. of last error in IFD file
        ! CharSpaceUsed (5) : Space already used in character data area
        ! FormWinWidth (6) : Form-window width, if specified in IFD file
        ! FormWinHeight (7) : Form-window height, if specified in IFD file
        ! CurrentSubForm (8) : Current sub-form number in a multi-part tabbed form
        ! Short-name : INFOFM
        ! Include : interif.inc
        ! Returns information about the Forms Manager.
        ! ITEM 1 returns the maximum number of fields which can be defined. This information
        ! is available at any time regardless of whether a form has been defined.
        ! ITEM 2 returns the remaining space in the Forms Manager's character data storage area.
        ! This data area is used to hold character data field contents, menu options and
        ! real/double-precision field format strings. The amount of space available will diminish
        ! as field contents are defined. The value returned by ITEM 2 is only guaranteed to be
        ! meaningful after a form has been initially defined by IFormDefine or IFormLoad.
        ! ITEM 3 can only be interrogated from within a user routine supplied to the form editor,IFormEditUser. It returns the identifier of the field which the form editor is about
        !to pass control to (e.g. if the user has pressed the tab key, the identifier of the next field
        !in the form will be returned). The value returned by ITEM 3 is undefined if called from
        !anywhere other than a form editor user routine.
        !ITEM 4 identifies the last line number in a form definition file which contained either a
        !fatal or non-fatal error, in the most recent call to IFormLoad. If the last call to
        !IFormLoad encountered no such errors, this will return zero. If IFormLoad has not
        !been called, the returned value is undefined.
        !ITEM 5 reports the amount of space already used (in bytes) in the character data storage
        !area. This is the opposite of ITEM 2. The total of the values returned by ITEM's 2 and 5
        !is equal to the size of the character storage area in the current implementation.
        !ITEM's 6 and 7 report the width and height of the form-window, if the form was loaded
        !via IFormLoad and the form definition file contained a [window] section. ITEM 6
        !will return a value of zero if no form-window is defined.
        !Information Functions INTERACTER Subroutine Reference
        !4-36
        !ITEM 8 reports the number of the mostly recently selected sub-form in a multi-part
        !tabbed form. It is undefined in a single-part form.
        !e.g. IF (InfoForm(1).GT.NFIELD)
        !1 CALL IOsExitProgram('Not enough fields available',99)
        !CALL IFormDefine('W',NFIELD,IX,IY,IWIDTH,ITYPE)
    
        res = 0
    end function

    CHARACTER(len=100) function InfoFormMenu(IFIELD,ITEM) result(res)
        integer IFIELD ! Menu field number
        integer ITEM ! Option number
        ! Short-name : INFOFO
        ! Returns the menu option string associated with option number ITEM in form field
        ! number IFIELD. This routine will mainly prove useful to interrogate the contents of
        ! form definition files loaded via IFormLoad.
        !If IFIELD or ITEM are invalid (e.g. field does not exist or is not a menu) then the
        !returned string is blank filled.
        !e.g. PARAMETER (MAXOPT = 100)
        !CHARACTER*10 OPTION(MAXOPT),InfoFormMenu
        !:
        !C how many options in menu ?
        !NOPT = MIN(InfoField(IFIELD,11),MAXOPT)
        !C get menu options into an array
        !DO 100 IOPT = 1,NOPT
        !OPTION(IOPT) = InfoFormMenu(IFIELD,IOPT)
        !100 CONTINUE
    
        res = ""
    end function

    INTEGER function InfoFrame(ITEM)  result(res)
        integer ITEM ! Number of information item required :
        ! FrameType (1) : Frame type as set by IFrameType
        ! UsingBoxChars (2) : Current display/mode uses box-characters
        ! (IntNo (0) : no IntYes (1) : yes)
        ! 101-107 : Text frame options as controlled by
        ! IFrameOptions
        ! Include : interif.inc, intercg.inc
        ! Returns information about text frame styles and options. These styles/options affect all
        ! routines which use text frames including the window and forms managers, menus, etc.
        ! ITEM 1 returns the frame type as requested via IFrameType.
        ! ITEM 2 can be used to identify the type of text frames being drawn on the current
        ! display in the current screen mode. If box-characters are in use, a non-zero value is
        ! returned. If graphical frames are being used, zero is returned.
        ! ITEM's 101+ return the frame options which are set via IFrameOptions(1+,n).
        !e.g. IF (InfoFrame(UsingBoxChars).EQ.IntNo) THEN
        !CALL IFrameType(10)
        !CALL IFrameOptions(6,15)
        !CALL IFrameOptions(7,0)
        !ENDIF
        !INTERACTER Subroutine Reference Information Functions
        !4-37
    
        res = 0
    end function

    REAL function InfoGraphics(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! GraphicsX (1) : Current X plotting position ) all in
        ! GraphicsY (2) : Current Y plotting position ) user
        ! GraphicsChWidth (3) : Current character width ) units
        ! GraphicsChHeight (4) : Current character height ) as set
        ! GraphicsMouseX (5) : Mouse X pos at last mouse/key event ) by
        ! GraphicsMouseY (6) : Mouse Y pos at last mouse/key event ) IGrUnits
        ! GraphicsAreaMinX (7) : Left limit of main graphics area
        ! GraphicsAreaMinY (8) : Lower limit of main graphics area
        ! GraphicsAreaMaxX (9) : Right limit of main graphics area
        ! GraphicsAreaMaxY (10) : Upper limit of main graphics area
        ! GraphicsUnitMinX (11) : Lower X co-ordinate limit
        ! GraphicsUnitMinY (12) : Lower Y co-ordinate limit
        ! GraphicsUnitMaxX (13) : Upper X co-ordinate limit
        ! GraphicsUnitMaxY (14) : Upper Y co-ordinate limit
        ! Short-name : GRINFO
        ! Include : interif.inc
        ! Returns certain REAL graphics mode parameters. These are dynamic values which
        ! change depending on calls to other routines. See also InfoGrScreen which returns
        ! integer data, mainly describing the capabilities of the current display/mode.
        ! The current plotting position, as set by IGrMoveTo and numerous other routines, is
        ! accessible using ITEM values 1 and 2.
        ! The current graphics text character size (ITEM's 3 and 4) is derived from the size set
        ! using IGrCharSize and converted to user plotting units. This can be useful in
        ! calculating the extent of a graphics string to be output by
        ! IGrCharOut/IGrCharOutRel. Note that these are the width and height of
        ! unrotated characters.
        ! ITEM's 5 and 6 will normally be interrogated as a pair, since they return the graphics
        ! co-ordinate of the mouse cursor at the last mouse or keyboard press. This information
        ! will be meaningful when InfoInput(55) returns -2 or when
        ! InKeyEvent/InKeyEventImm returns anything other than an expose/resize event.
        ! The former situation will occur if a mouse button is pressed outside the input area in a
        ! fixed-field/menu/form input routine and 'exit on click-outside' is enabled (see
        ! InMouseOptions(2,n)).
        ! ITEM's 7 to 10 return the graphics area dimensions as most recently specified to
        ! IGrArea. Similarly, ITEM's 11 to 14 return the user definable graphics area coordinates
        ! as most recently specified to IGrUnits.
        ! Be sure to declare InfoGraphics as REAL, as in the example below.
        ! Information Functions INTERACTER Subroutine Reference
        ! 4-38
        !e.g. REAL InfoGraphics
        !C write a blue string on a white background
        !WIDTH = FLOAT(LEN(STRING))*InfoGraphics(3)
        !HEIGHT = InfoGraphics(4)
        !CALL IGrColour('W')
        !CALL IGrFillPattern(4,0,0)
        !CALL IGrRectangle(X,Y,X+WIDTH,Y+HEIGHT)
        !CALL IGrCharJustify('L')
        !CALL IGrColour('BLU')
        !CALL IGrCharOut(X,Y+HEIGHT/2.0,STRING)
        !Portability notes :
        !Terminals :
        !Under DECterm or xterm, ITEM's 5 and 6 return the position of the mouse cursor for
        !mouse events only. The mouse cursor position is not available for keyboard events.
!        type(Fields), pointer :: this
!        this => this_
!        
!        select case(ITEM)
!            case(1)
!                ! GraphicsX (1) : Current X plotting position ) all in
!                res = this%x
!            case(2)
!                ! GraphicsY (2) : Current Y plotting position ) user
!                res = this%y
!            case(3)
!                ! GraphicsChWidth (3) : Current character width ) units
!                res = this%fontPointSize
!            case(4)
!                ! GraphicsChHeight (4) : Current character height ) as set
!                res = this%fontPointSize
!            case(5)
!                ! GraphicsMouseX (5) : Mouse X pos at last mouse/key event ) by
!                res = this%mouseX
!            case(6)
!                ! GraphicsMouseY (6) : Mouse Y pos at last mouse/key event ) IGrUnits
!                res = this%mouseY
!            case(7)
!                ! GraphicsAreaMinX (7) : Left limit of main graphics area
!                res = getMinVisibleX(this%canvas)
!            case(8)
!                ! GraphicsAreaMinY (8) : Lower limit of main graphics area
!                res = getMinVisibleY(this%canvas)
!            case(9)
!                ! GraphicsAreaMaxX (9) : Right limit of main graphics area
!                res = getMaxVisibleX(this%canvas)
!            case(10)
!                ! GraphicsAreaMaxY (10) : Upper limit of main graphics area
!                res = getMaxVisibleY(this%canvas)
!            case(11)
!                ! GraphicsUnitMinX (11) : Lower X co-ordinate limit
!                res = getMinX(this%canvas)
!            case(12)
!                ! GraphicsUnitMinY (12) : Lower Y co-ordinate limit
!                res = getMinY(this%canvas)
!            case(13)
!                ! GraphicsUnitMaxX (13) : Upper X co-ordinate limit
!                res = getMaxX(this%canvas)
!            case(14)
!                ! GraphicsUnitMaxY (14) : Upper Y co-ordinate limit
!                res = getMaxY(this%canvas)
!            case default
!                res = 0
!        end select
        res = 0.0
    end function

    INTEGER function InfoGrHardcopy(ITEM)  result(res)
        integer ITEM ! Number of information item required :
        ! BrokenLines (6) : Broken lines )
        ! RGBEncoding (7) : RGB palette encoding )
        ! PaletteBack (8) : Background colour redefinable )
        ! PaletteFore (9) : Foreground colours redefinable )
        ! StippleFillRect (10) : Stippled rectangle fills )
        ! StippleFillTri (11) : Stippled triangle fills ) IntNo (0)
        ! StippleFillCirc (12) : Stippled circle/ellipse fills ) = no
        ! SolidFillRect (13) : Solid rectangle fills )
        ! SolidFillTri (14) : Solid triangle fills ) IntYes (1)
        ! SolidFillCirc (15) : Solid circle/ellipse fills ) = yes
        ! HardTextSize (19) : Hardware text size control )
        ! StippleFillArc (22) : Stippled arc fills )
        ! SolidFillArc (23) : Solid arc fills )
        ! PaletteChange (24) : Palette changes affect existing plot )
        ! StippleFillPoly (25) : Stippled polygon fills )
        ! SolidFillPoly (26) : Solid polygon fills )
        ! QualityFonts (27) : Presentation quality hardware fonts )
        ! OutlineArc (28) : Arc outlines use driver primitive )
        ! ColNumAvailable (30) : Number of 8-bit colours currently available
        ! ColNumMax (31) : Number of 8-bit colours supported by driver
        ! AspectRatio (32) : Aspect ratio as a percentage
        ! CharSetTypeHard (38) : Hardware dependent char set size (7=7-bit 8=8-bit)
        ! HardTextRotate (40) : Available hardware text rotation angles (1/4/8/360)
        ! WideLines (41) : Line width control capability
        ! (0=no, 1=solid lines, 2=all line types)
        ! Col24Bits (42) : 24-bit colour specification supported (0=no 1=yes)
        ! PaperWidth (91) : Paper width in points (Print Manager only)
        ! PaperHeight (92) : Paper height in points (Print Manager only)
        ! DriverSelected (100) : Currently selected driver number
        ! 101-207 : Options set by IGrHardCopyOptions
        ! 501-524 : Options set by IScreenDumpOptions
        ! Short-name : INFOGH
        ! Include : interif.inc, intergen.inc
        ! INTERACTER Subroutine Reference Information Functions
        ! 4-39
        ! Returns information about the graphics facilities supported by the currently selected
        ! hardcopy driver and the currently selected hardcopy options.
        ! ITEM codes follow the same sequence as InfoGrScreen (which returns equivalent
        ! screen graphics capability information). ITEM codes which have no hardcopy
        ! equivalent are not implemented and return 0.
        ! All currently supported drivers support broken lines, so ITEM 6 will always return 1.
        ! ITEM 7 reports support for RGB palette encoding. It is now redundant since
        ! INTERACTER can convert interchangeably between HLS and RGB encoding.
        ! ITEM values 8 and 9 report the ability of the current driver to redefine colours using
        ! IGrPaletteHLS or IGrPaletteRGB. If ITEM 8 or 9 returns a non-zero value
        ! then the driver supports palette redefinition. In this case, ITEM 24 identifies whether
        !this only affects subsequent plotting (e.g. PostScript) or all currently plotted data in the
        !redefined colour (e.g. raster image files).
        !ITEM values 10-15, 22/23 and 25/26 return information about the types of fill
        !primitives available. Where a fill primitive is not available INTERACTER performs fills
        !by drawing many adjacent lines (e.g. HP-GL, Lotus PIC, DXF drivers). This is slower
        !than using a primitive, so these ITEM's return zero in this case. Note that support for a
        !triangle fill primitive implies support for parallelogram/trapezium fills.
        !If hardware text size control is available via IGrCharSize,InfoGrHardcopy(19) will return 1.
        !ITEM 27 identifies whether presentation quality hardware fonts are available (i.e.
        !Times Roman, Helvetica and Courier, or equivalents). If so, these are selectable via
        !IGrCharFont or IGrHardCopyOptions(14,n).
        !Some drivers use a device primitive to draw arc outlines, to ensure consistency with arc
        !fills. ITEM 28 reports whether such a primitive is used.
        !ITEM's 30 and 31 return the current and maximum number of colours available via the
        !current graphics hardcopy driver when the 8-bit colour model is selected. The current
        !number of colours may depend on the currently selected output device. Both values will
        !be <=256.
        !The current aspect ratio is returned as a percentage. For example, if the aspect ratio is
        !1.4, InfoGrHardcopy(32) would return a value of 140. This value is determined
        !by the page size settings which are definable via IGrHardCopyOptions(1,n) and
        !IGrHardCopyOptions(2,n).
        !ITEM 38 identifies the type of hardware-dependent character set supported by the
        !currently selected hardcopy driver. If the driver supports 8-bit Latin-1 characters, a
        !value of 8 is returned. If the driver only supports 7-bit characters or cannot be relied
        !upon to use Latin-1 8-bit characters, a value of 7 is returned.
        !ITEM 40 reports the number of angles at which hardware graphics text can be plotted
        !by the current hardcopy driver. A value of 360 actually means 'any angle'.
        !ITEM 41 reports support for hardcopy line width control. If line width control is
        !available for all types this will return 2. If only solid lines can be thickened (e.g.
        !Windows 9x/Me GDI) 1 is returned. If line width control is not available, this item
        !returns zero.
        !Information Functions INTERACTER Subroutine Reference
        !4-40
        !ITEM 42 reports support for 24-bit colour specification. If this reports 1, then use of
        !the 24-bit colour model is available and recommended (see IGrColourModel). If
        !zero is returned, the 24-bit colour model can still be used, but the results may be
        !slightly less predictable, depending on the target output format.
        !ITEM's 91 and 92 return the currently selected Print Manager paper size in points,under Windows. These values are undefined on other operating systems. Note that
        !these values are different to the image size values returned by ITEM codes 101/102.
        !The currently selected graphics hardcopy driver number is returned by ITEM 100. This
        !value corresponds to the IDRIVR argument to the IGrHardCopySelect routine
        !(i.e. 1=HP-GL, 2=PostScript, etc.)
        !The current values of hardcopy options such as page size, position, orientation, etc. are
        !accessible using ITEM's 101-127 and 201-207. These ITEM codes correspond directly
        !to the hardcopy options which can be assigned by IGrHardCopyOptions(1-
        !27/101-107,N). Hardcopy options which are not meaningful for the current driver
        !(e.g. print density when HP-GL output is selected) will return undefined values.
        !The current values of screen dump options such as page size, position, orientation, etc.
        !are accessible using ITEM's 501-524. These ITEM codes correspond directly to the
        !options which can be assigned by IScreenDumpOptions(1-24,N).
        !e.g. IWIDTH = InfoGrHardcopy(101)
        !IHEIGH = InfoGrHardcopy(102)
        !IORIEN = InfoGrHardcopy(105)
        !NTEXTR = InfoGrHardcopy(202)
    
        res = 0
    end function

    INTEGER function InfoGrid(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! GridLeftColumn (1) : Currently visible left-most column
        ! GridTopRow (2) : Currently visible top row
        ! GridMaxColumn (3) : Number of grid columns )
        ! GridMaxRow (4) : Number of grid rows ) As set
        ! 1000 : Label field width ) via
        ! 1000+column : Column widths ) IGridDefine
        ! 2000+column : Column types )
        ! Include : interif.inc
        ! Returns information about the Grid Manager.
        ! Together ITEM's 1 and 2 return the cell number which is currently at the top left corner
        ! of the window. This information can then be fed back to IGridShow if a
        ! resize/expose event occurs and the grid needs to be redrawn.
        ! ITEM's 3 and 4 report the grid dimensions. ITEM 1000 upwards return the label and
        ! column widths. ITEM 2001 upwards return the column types. All of these are as set in
        ! the call to IGridDefine.
        !e.g. EXTERNAL GMUSER
        !100 CALL IGridShow(IXSHOW,IYSHOW,GMUSER)
        !CALL IGridEdit(IX,IY,GMUSER)
        !IF (InfoInput(55).EQ.259) THEN
        !IXSHOW = InfoGrid(1)
        !IYSHOW = InfoGrid(2)
        !GOTO 100
        !ENDIF
        !INTERACTER Subroutine Reference Information Functions
        !4-41
    
        res = 0
    end function

    INTEGER function InfoGrPalette(ITEM)  result(res)
        integer ITEM ! 8-bit colour number (0-255)
        ! Returns the RGB value associated with colour number ITEM in INTERACTER's device
        ! independent 8-bit graphics colour palette, as used by IGrColourN when the 8-bit
        ! colour model is selected. These are the same colour values which can be updated by
        ! IGrPaletteRGB and IGrPaletteHLS.
        ! The returned RGB value is encoded as a 24-bit value of the form:
        ! Red + 256*Green + 256*256*Blue
        ! This can be decoded using the logic:
        ! IRed = MOD(result,256)
        ! IGreen = MOD(result/256,256)
        ! IBlue = MOD(result/65536,256)
        ! Note that the returned value is not necessarily that used by the current screen or
        ! hardcopy output device. The actual colour associated with ITEM may be different if the
        ! current device supports fewer than 256 colours or does not support palette control
        ! Rather, the returned RGB value represents the "target" or "ideal" colour, when colour
        ! number ITEM is requested. This information is available regardless of which colour
        ! model (8-bit or 24-bit) is currently selected.
    
        res = 0
    end function

    INTEGER function InfoGrScreen(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! GraphicsAvail (1) : Graphics available )
        ! AreaClear (2) : Area clearing )
        ! AndPlotMode (3) : AND mode plotting )
        ! OrPlotMode (4) : OR mode plotting )
        ! EorPlotMode (5) : EOR mode plotting )
        ! BrokenLines (6) : Broken lines )
        ! RGBEncoding (7) : RGB palette encoding )
        ! PaletteBack (8) : Background colour redefinable )
        ! PaletteFore (9) : Foreground colours redefinable )
        ! StippleFillRect (10) : Stippled rectangle fills )
        ! StippleFillTri (11) : Stippled triangle fills ) IntNo (0)
        ! StippleFillCirc (12) : Stippled circle/ellipse fills ) = no
        ! SolidFillRect (13) : Solid rectangle fills )
        ! SolidFillTri (14) : Solid triangle fills ) IntYes (1)
        ! SolidFillCirc (15) : Solid circle/ellipse fills ) = yes
        ! BitBlock (16) : Bit block copy/move )
        ! ImageSave (17) : Graphics screen image save )
        ! GrPopUpMode (18) : Graphics mode pop-ups )
        ! HardTextSize (19) : Hardware text size control )
        ! IndepTextGr (20) : Independent graphics/text )
        ! GINMode (21) : GIN mode )
        ! StippleFillArc (22) : Stippled arc fills )
        ! SolidFillArc (23) : Solid arc fills )
        ! PaletteChange (24) : Palette changes affect existing plot )
        ! StippleFillPoly (25) : Stippled polygon fills )
        ! SolidFillPoly (26) : Solid polygon fills )
        ! Information Functions INTERACTER Subroutine Reference
        ! 4-42
        ! QualityFonts (27) : Presentation quality hardware fonts )
        ! OutlineArc (28) : Arc outlines use driver primitive )
        ! ReadPixel (29) : Screen pixels can be read )
        ! ColNumAvailable (30) : Number of 8-bit colours in current mode
        ! ColNumMax (31) : Number of 8-bit colours in any mode
        ! AspectRatio (32) : Aspect ratio as a percentage
        ! TextHandle (33) : Graphics mode text handling capability (see below)
        ! PrevColReq (34) : Last but one requested graphics colour
        ! ColourReq (35) : Most recently requested graphics colour
        ! LineTypeReq (36) : Most recently requested line type
        ! PlotModeReq (37) : Most recently requested plot mode
        ! PlotNormal (0) : normal
        ! PlotOr (1) : or
        ! PlotAnd (2) : and
        ! PlotEor (3) : ex-or
        ! CharSetTypeHard (38) : Hardware dependent char set size (7=7-bit 8=8-bit)
        ! CharSetTypeSoft (39) : Software char set size (0=none 7=7-bit 8=8-bit)
        ! HardTextRotate (40) : Available hardware text rotation angles (1/4/8/360)
        ! WideLines (41) : Line width control capability
        ! (0=no, 1=solid lines, 2=all line types)
        ! Col24Bits (42) : 24-bit colour specification supported (0=no 1=yes)
        ! Short-name : INFOGR
        ! Include : interif.inc, intergen.inc
        ! Returns information about the graphics facilities available on the current display in the
        ! current mode. See also InfoGrHardcopy which reports similar information for the
        ! currently selected graphics hardcopy driver.
        ! Some displays do not support graphics at all. This can be interrogated using an ITEM
        ! value of 1. When called on a display which does not support graphics or in a nongraphics
        ! screen mode, the information returned for other ITEM numbers is undefined.
        ! ITEM 2 identifies the ability of IGrAreaClear to clear the current graphics area to
        ! the background colour. Typically, a Tek401x display would not support this feature.
        ! The plotting mode support flags (ITEM = 3/4/5) refer to the facilities available when
        ! calling IGrPlotMode.
        ! Most, but not all, displays support broken lines. This can be checked with ITEM
        ! number 6.
        ! ITEM 7 reports support for RGB palette encoding. It is now redundant since
        ! INTERACTER can convert interchangeably between HLS and RGB encoding.
        ! ITEM values 8 and 9 report the ability of the current display to redefine the background
        ! or foreground colours, respectively, using IGrPaletteHLS or IGrPaletteRGB. If
        ! palette redefinition is available, ITEM 24 identifies whether this only affects
        !subsequent plotting (e.g. X Windows) or all currently plotted data in the redefined
        !colour (e.g. DOS graphics).
        !INTERACTER Subroutine Reference Information Functions
        !4-43
        !ITEM values 10-15, 22/23 and 25/26 return information about the available fill
        !primitives. This has been split according to the type of fill and the shape to be filled,since some screens offer limited combinations of style/shape. Where a fast fill primitive
        !is not available INTERACTER performs fills by drawing many adjacent lines. This is
        !usually slower than a primitive, so ITEM's 10-15, 22/23 and 25/26 allow a program to
        !check for this performance consideration. Note that ITEM's 25/26 report the polygon
        !filling capability which will be utilised by IGrPolygonComplex, if available. If a
        !solid or stippled polygon fill primitive is available then the other fill types (e.g.
        !rectangle etc.) will also be available. The opposite is not necessarily true, e.g.
        !availability of a rectangle fill does not automatically imply support for a polygon fill.
        !Support for bit block move and copy can be determined by specifying an ITEM value
        !of 16. Where supported, the corresponding plot modes identified by ITEM=3/4/5 will
        !be available for these operations.
        !If graphics screen images can be saved/loaded using IScreenSaveImage and
        !IScreenLoadImage an ITEM value of 17 will return a non-zero result.
        !ITEM's 18/20/33 can be used to determine the degree of support for the text handling
        !routines in the OU, CU, CG, WN, IN, MN, etc. groups, when used in graphics mode :
        !ITEM 18 identifies whether graphics screen data is restored after a window/menu/inputbox
        !pop-up in a graphics screen mode.
        !ITEM 20 identifies support for independent text and graphics output, i.e. text output
        !goes to a different plane (e.g. Tek 4100 series) or window (e.g. xterm). A returned
        !value of 0 indicates that text will obliterate graphics and vice versa, unless pop-up
        !mode is used. If ITEM 20 returns 1, so will ITEM 18, though the reverse is not
        !necessarily true.
        !ITEM 33 identifies the graphics mode text handling capabilities of the current display
        !in a more general way than ITEM's 18 and 20, by returning a value in the range 2-6 :
        !2: The text mode screen driver is not available. Only quite basic text screen handling
        !is performed. e.g. Tektronix 401x and some Tek 4100 emulators.
        !3: The text mode driver is also available in graphics mode and routes output to an
        !independent text plane which overlays the graphics plane. e.g. Tektronix 4100
        !4: As for 3 except that text and graphics output are routed to separate windows within
        !a supervising windowing environment. e.g. xterm and Tera Term Pro.
        !5: Text screen handling functions remain available in graphics mode, but text and
        !graphics output occupy the same screen plane. Hence each type of output can affect
        !the other. Pop-up windows/menus restore underlying graphics data. e.g. DOS,Windows and Xlib.
        !6: As 5 except that pop-up windows/menus only restore underlying text. e.g. ReGIS.
        !Other : No graphics mode available
        !If hardware text size control is available via IGrCharSize, ITEM 19 will return 1.
        !Certain PC based terminal emulators do not support Graphics Input (GIN) mode. ITEM
        !21 returns a binary flag to indicate GIN mode availability.
        !Information Functions INTERACTER Subroutine Reference
        !4-44
        !ITEM 27 identifies whether presentation quality hardware fonts are available (i.e.
        !Times Roman, Helvetica and Courier, or equivalents). If so, these are selectable via
        !IGrCharFont.
        !ITEM 28 reports whether a device specific arc outline primitive is used. This is usually
        !implemented to ensure consistency with arc fills.
        !ITEM 29 reports whether IGrGetPixelRGB will work on the current screen. Some
        !drivers are unable to read screen pixel colour values,ITEM's 30 and 31 report the number of selectable colours in the 8-bit colour model. On
        !all platforms except DOS both ITEM's return the same value (Under DOS, 30 returns
        !the number of colours in the current mode and 31 returns the avalable colours in any
        !mode). In a monochrome mode, 2 is returned if the background colour is selectable for
        !foreground plotting operations otherwise a value of 1 is returned.
        !ITEM 32 returns the aspect ratio of the current display as a percentage. For example a
        !display with an aspect ratio of 1.4, would return a value of 140. This is used internally
        !by INTERACTER when drawing circles/ellipses or rotated text, but can also be useful in
        !applications which require a shape to be rotated without distortion.
        !ITEM's 34 and 35 return the last two colour numbers which have been requested. The
        !colour returned by ITEM 34 is only used in mixed-colour fills.
        !ITEM's 36 and 37 return the last line type and plot mode requested via IGrLineType
        !and IGrPlotMode respectively.
        !ITEM 38 identifies the type of hardware-dependent character set supported by the
        !current screen font. If the font includes 8-bit Latin-1 characters, a value of 8 is returned,otherwise 7 is returned.
        !ITEM 39 returns 8 if the currently loaded software character set includes 8-bit Latin-1
        !characters. If it is only a 7-bit character set, a value of 7 is returned. If no software
        !character set is currently loaded, 0 is returned.
        !ITEM 40 reports the number of angles at which hardware graphics text can be plotted
        !on the current display. A value of 360 actually means 'any angle'.
        !ITEM 41 reports support for line width control on the current display. If line width
        !control is available for all line types this will return 2. If only solid lines can be
        !thickened (e.g. Windows 9x/Me GDI) 1 is returned. If line width control is not
        !available, this item returns zero.
        !ITEM 42 reports support for 24-bit colour specification. This will report 1 on a display
        !with more than 256 colours, or 0 otherwise. In the former case, use of the 24-bit colour
        !model is availabe and recommended (see IGrColourModel). If zero is returned, the
        !24-bit colour model can still be used, but INTERACTER's 8-bit colour palette will be
        !used internally.
        !e.g. IF (InfoGrScreen(1).EQ.0) THEN
        !CALL IOutError('Sorry but you don't have graphics')
        !ENDIF
        !INTERACTER Subroutine Reference Information Functions
        !4-45
    
        select case(ITEM)
            ! GraphicsAvail (1) : Graphics available )
            case(1)
                res = 1
            ! AreaClear (2) : Area clearing )
            ! AndPlotMode (3) : AND mode plotting )
            ! OrPlotMode (4) : OR mode plotting )
            ! EorPlotMode (5) : EOR mode plotting )
            ! BrokenLines (6) : Broken lines )
            ! RGBEncoding (7) : RGB palette encoding )
            case(8)
            ! PaletteBack (8) : Background colour redefinable )
                res = 1
            case(9)
            ! PaletteFore (9) : Foreground colours redefinable )
                res = 1
            case default
                res = 0
        end select
    end function

    INTEGER function InfoHardware(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! AutoModeSwitch (1) : Automatic text/graphics mode switch (0=no 1=yes)
        ! DensityNum (2) : Number of available printer graphics densities (0-4)
        ! PrintDense1 (3) : Printer density number 1 (highest)
        ! PrintDense2 (4) : Printer density number 2
        ! PrintDense3 (5) : Printer density number 3
        ! PrintDense4 (6) : Printer density number 4 (lowest)
        ! PlotPens (7) : Number of plotter pens available
        ! TINCapab (8) : Text mode pointing device capability (0-2)
        ! GINCapab (9) : Graphics mode pointing device capability (0-2)
        ! DisplayType (10) : Display type (see IDisplay)
        ! PrinterType (11) : Printer type (see IPrinter)
        ! PlotterType (12) : Plotter type (see IPlotter)
        ! MouseType (13) : Mouse type (see IMouse )
        ! DigiType (14) : Digitiser type (see IDigitiser)
        ! HPGL2PrinterType (15) : HP-GL/2 device type (see IPrinter2)
        ! DisplayExp (20) : Display identified explicitly ) IntNo (0)
        ! PrinterExp (21) : Printer identified explicitly ) = no
        ! PlotterExp (22) : Plotter identified explicitly ) IntYes (1)
        ! MouseExp (23) : Mouse identified explicitly ) = yes
        ! DigiExp (24) : Digitiser identified explicitly )
        ! HPGL2PrinterExp (25) : HP-GL/2 device identified explicitly )
        ! GScreenDump (30) : Graphics screen dump capability
        ! IntNone (0) : none
        ! HardWare (1) : hardware
        ! ISSDump (2) : INTERACTER
        ! PrintManDump (3) : Print Manager
        ! VESAsupport (32) : Report VESA support
        ! 0 : If VESA BIOS not available
        ! <> 0 : VESA BIOS installed.
        ! WinPrinter (33) : Windows printer availability (0=no 1=yes)
        ! Short-name : INFOHW
        ! Include : interif.inc, intergen.inc
        ! Returns information about the hardware on which the program is currently running.
        ! This is an important portability aid.
        ! ITEM 1 can be used to establish whether it is necessary to manually switch screen
        ! modes before entering graphics from text mode or vice versa. Most displays support
        ! automatic text/graphics switching, but the control codes to do this vary. INTERACTER
        ! enables unsupported displays to be used by providing the IScreenCode routine and
        ! allowing the user to specify these control codes in the initialisation file. However if
        ! these codes are not supplied, IScreenModeN will have no way of switching from one
        ! mode to the other, so this situation can be tested for using ITEM=1. If the current
        ! display does not support graphics, the result is undefined.
        ! Information Functions INTERACTER Subroutine Reference
        ! 4-46
        ! ITEM's 2 to 6 describe the available densities when printing raster graphics on the
        ! currently selected printer. Up to 4 different densities may be available, the actual
        ! number being returned by InfoHardware(2) (zero if a text-only printer is selected).
        ! The available print densities are returned as ITEM's 3 upwards. For example, for an HP
        ! PaintJet which supports 180 and 90 d.p.i., ITEM 2 would return 2, ITEM's 3 & 4 would
        ! return 180 & 90 and ITEM's 5 and 6 would be undefined. This information can be used
        ! to determine the required raster graphics driver print density, as specified to
        ! IGrHardCopyOptions. It can also be used to determine the available screen dump
        ! print densities when InfoHardware(30) returns a value of 2 (i.e. when
        ! INTERACTER's own screen graphics dump routine is available). In the latter case,screen dump printer density is selectable via IScreenDumpOptions(13,N).
        ! ITEM 7 returns the number of pens available on the currently selected plotter.
        ! ITEM's 8 and 9 describe the pointing device capabilities associated with the current
        ! display type. ITEM 8 describes the text mode capability and ITEM 9 describes the
        ! equivalent graphics mode capability, as follows :
        ! 0: No pointing device capability. Any GIN or TIN mode cursor must be maintained by
        ! the INTERACTER program under keyboard control.
        ! 1: The pointing device is under local device control, which returns a 'single-shot'
        !position and button/key report when a button or key is pressed. e.g. Tektronix GIN
        !mode, ReGIS Locator mode, xterm/DECterm text-mode mouse control.
        !2: The position of the input device is continuously trackable. e.g. DOS, Windows and
        !Xlib.
        !Note that ITEM's 8 and 9 describe the general capability of a particular display type
        !with respect to input devices. They do not describe the currently selected input device
        !type. InfoHardware(8)/(9) must return values of 2 to be able to use the routines
        !in the MC group or to report mouse movement events via InKeyEvent. If
        !InfoHardware(8) returns a value of 1 then InKeyEvent will be able to report
        !mouse button-down events.
        !The display hardware number is as specified to or identified by IDisplay. If you
        !have allowed IScreenOpen or IDisplay to automatically identify the display
        !hardware for you, InfoHardware can be used to establish what type of display
        !INTERACTER thinks it is currently running on. Similarly, ITEM values of 11-15 return
        !the device types which have been specified to IPrinter, IPlotter, IMouse,IDigitiser and IPrinter2. See chapter 13 of the User Guide for lists of the
        !supported hardware.
        !ITEM numbers 20-25 can be used to determine whether INTERACTER has had to use a
        !default value for the device types reported by ITEM's 10-15. For example, if the printer
        !has not been identified in the initialisation file and IPrinter/IdPrinter have not
        !been called, InfoHardware will return a value of zero when called with an ITEM
        !value of 21. In this case, it is advisable to call IdPrinter to ask the user what type of
        !printer is being used, before calling the IScreenDump routine or the raster driver.
        !It is worth noting that if the display type has not been specified (by calling
        !IDisplay/IdDisplay or by means of a DISPLAY initialisation file keyword or via
        !an INTTERM o.s. variable), it may still have been possible to identify the display
        !hardware automatically. In this situation, ITEM 20 will return 1.
        !INTERACTER Subroutine Reference Information Functions
        !4-47
        !ITEM 30 identifies the type of graphics screen dump supported by the current display
        !type. Under DOS and Xlib this will return a value of 2 indicating that INTERACTER's
        !own screen dump routine will be used. Under Windows a value of 3 is returned, as the
        !Windows Print Manager is used. On most Tektronix and ReGIS terminals, the built-in
        !hardware dump is used instead so a value of 1 will be returned. If there is no graphics
        !screen dump capability available then a value of zero will be returned.
        !ITEM 32 is intended for use with the DOS version of INTERACTER, but is
        !implemented in such a way that it can safely be used with all implementations. It
        !determines whether a VESA video BIOS is installed (either in hardware or as a TSR).
        !If not, a value of 0 is returned (all non-DOS versions always return 0). A non-zero
        !result means that the video BIOS reports one or more VESA standard SVGA modes as
        !being available. In this case, the returned value bit encodes mode availability. Bit 0 is
        !set if mode 256 is available, bit 1 is set of mode 257 is available and so on. See the
        !Portability notes for IScreenModeN for a list of VESA mode numbers.
        !ITEM 33 reports whether a Windows printer is currently configured. Under Windows
        !this will return 1 if the Print Manager driver has been successfuly identified and
        !initialised. Otherwise this function call will always return zero.
        !e.g. CALL IScreenOpen(' ','G',640,480,16)
        !C force use of VESA modes if available
        !IF (InfoHardware(32).NE.0.AND.InfoHardware(10).NE.13) THEN
        !CALL IDisplay(13)
        !CALL IGrInit(' ',800,600,16)
        !ENDIF

        select case (ITEM)

            ! AutoModeSwitch (1) : Automatic text/graphics mode switch (0=no 1=yes)
            ! DensityNum (2) : Number of available printer graphics densities (0-4)
            ! PrintDense1 (3) : Printer density number 1 (highest)
            ! PrintDense2 (4) : Printer density number 2
            ! PrintDense3 (5) : Printer density number 3
            ! PrintDense4 (6) : Printer density number 4 (lowest)
            ! PlotPens (7) : Number of plotter pens available
            ! TINCapab (8) : Text mode pointing device capability (0-2)
            ! GINCapab (9) : Graphics mode pointing device capability (0-2)
            case (9)
                res = 2
            ! DisplayType (10) : Display type (see IDisplay)
            ! PrinterType (11) : Printer type (see IPrinter)
            ! PlotterType (12) : Plotter type (see IPlotter)
            ! MouseType (13) : Mouse type (see IMouse )
            case (13)
                res = 2
            case default
                res = 0
        end select
            ! DigiType (14) : Digitiser type (see IDigitiser)
            ! HPGL2PrinterType (15) : HP-GL/2 device type (see IPrinter2)
            ! DisplayExp (20) : Display identified explicitly ) IntNo (0)
            ! PrinterExp (21) : Printer identified explicitly ) = no
            ! PlotterExp (22) : Plotter identified explicitly ) IntYes (1)
            ! MouseExp (23) : Mouse identified explicitly ) = yes
            ! DigiExp (24) : Digitiser identified explicitly )
            ! HPGL2PrinterExp (25) : HP-GL/2 device identified explicitly )
            ! GScreenDump (30) : Graphics screen dump capability
            ! IntNone (0) : none
            ! HardWare (1) : hardware
            ! ISSDump (2) : INTERACTER
            ! PrintManDump (3) : Print Manager
            ! VESAsupport (32) : Report VESA support
            ! 0 : If VESA BIOS not available
            ! <> 0 : VESA BIOS installed.
            ! WinPrinter (33) : Windows printer availability (0=no 1=yes)
        
    
        res = 0
    end function

    INTEGER function InfoInput(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! 1-50 : Key code assigned to input control key nos. 1-50
        ! (see InControlKey for list of control keys)
        ! NumFunKeys (51) : No of function keys available
        ! ImmKeyDetect (52) : Support for immediate keyboard detection
        ! IntNo (0) : no
        ! IntYes (1) : yes
        ! KeypadMode (53) : Current keypad mode as set by InKeypad (1-3)
        ! EditMode (54) : Current insert/overtype mode
        ! OverMode (0) : overtype
        ! InsMode (1) : insert
        ! LastExitKey (55) : Last key used to exit from an input or menu routine
        ! ClickOutside (-2) : Mouse click outside
        ! NonExitKey (-1) : Non-exit key in TIN/GIN mode
        ! ResizeEvent (259): Resize/expose event
        ! CloseRequest (260): Close-window request
        ! 21-30, 36-70 : Exit key code
        ! KeypadType (56) : Cursor/keypad keys availability
        ! NoKeypad (-1) : no keypad identification
        ! SharedKP (0) : shared
        ! SeparateKP (1) : separate
        ! LastGINExit (57) : Last key pressed to exit GIN/TIN mode when
        ! 'any-key-to-exit' mode selected
        ! Information Functions INTERACTER Subroutine Reference
        ! 4-48
        ! PopUps (58) : Current 'pop-up' mode as set by InPopup
        ! IntNone (0) : disabled
        ! SinglePop (1) : single
        ! LinkedPop (2) : linked
        ! LastDigiExit (59) : Last digitiser button used to exit GIN mode (1-16)
        ! SingleSelect (60) : Current single-key menu selection mode
        ! IntNone (0) : disabled
        ! MoveSelect (1) : move-and-select
        ! MoveOnly (2) : move-only
        ! ExitMouseButton (61) : Mouse button pressed on exit from field/menu/form
        ! /window-browser/file-editor
        ! IntNone (0) : none
        ! LeftButton (1) : left
        ! MiddleButton (2) : middle
        ! RightButton (3) : right
        ! MouseTextCol (62) : Text column of mouse cursor at last mouse/key event
        ! MouseTextRow (63) : Text row of mouse cursor at last mouse/key event
        ! ExitCursPos (64) : Relative text cursor pos on exit from a fixed field
        ! MultiTagChar (65) : Multiple choice menu tag character (ICHAR value)
        ! EventMask (66) : Event mask as set by InEventSelect
        ! PauseKey (67) : InKeyEvent code returned by IGrPause
        ! ExitOutside (68) : Exit on mouse click outside input area (0=no 1=yes)
        ! Gravity (69) : Current field gravity
        ! LeftGrav (0) : left
        ! RightGrav (1) : right
        ! MouseTime (70) : Time of last mouse event in milliseconds
        ! ExtremeButton (101) : )
        ! PopupButton (102) : )
        ! ConfirmMultiButton (103) : ) Special-action mouse buttons
        ! ToggleMultiButton (104) : ) as set by InMouseOptions
        ! ConfirmCycleButton (105) : )
        ! ConfirmFixedButton (106) : )
        ! 151-174 : Key code assigned to input control key nos. 51-74
        ! (see InControlKey for list of control keys)
        ! Short-name : INFOIN
        ! Include : interif.inc, interip.inc, interkm.inc
        ! Returns information about the input control keys and the input handling facilities. Each
        ! of the input control keys which are definable using InControlKey can be
        ! interrogated using ITEM numbers in the range 1-50 or 151-174.
        ! ITEM 51 returns the number of function keys which INTERACTER expects to be
        ! available on the current display. On some displays (mainly terminals and workstations)
        ! this cannot be guaranteed to be correct, but should be accurate in most cases.
        ! ITEM 52 returns 1 in all implementations.
        ! ITEM 53 returns the keypad mode set via InKeypad.
        ! ITEM 54 identifies the insert/overtype state as most recently set by a call to
        ! InsertOver or by the user pressing the 'toggle insert' key.
        ! INTERACTER Subroutine Reference Information Functions
        ! 4-49
        ! ITEM 55, the last 'exit' key to be pressed, is a particularly useful piece of information
        ! when processing input. It returns a value in the range 21-30 or 36-70 indicating which
        ! of the 'exit' keys (as defined by InControlKey) was pressed to terminate input to the
        ! most recently called input routine. InfoInput(55) is set by any of the routines
        ! from groups IN or MN, the window browsers IWinBrowseFile &
        ! IWinBrowseText, the file editor IWinEditFile, the form editor
        ! IFormEdit/IFormEditUser , the grid editor IGridEdit and various of the
        ! TIN/GIN routines. A value of 22 for example means that the help key was pressed.
        ! Under certain circumstances it can also return other possible values :
        ! a) If ITextInputOptions(1,1) or IGrInputOptions(4,1) has been
        ! called to enable the 'any key to exit' option, ITextInputXY/IGrInputXY and
        ! routines which call them can return InfoInput(55) set to -1. The key which
        ! was pressed to exit TIN/GIN mode will then be available via InfoInput(57).
        ! b) If 'exit on click-outside input area' is enabled, (see InMouseOptions(2,n)),fields/menus/etc. can return InfoInput(55) set to -2. The mouse button
        ! number/position are then available via InfoInput(61-63).
        ! c) If an expose/resize event occurs in graphics mode in a windowing environment,InfoInput(55) will return 259. This is the same code as is returned by
        ! InKeyEvent when such an event occurs. The calling program is responsible for
        ! redrawing the screen when such an event is detected.
        ! d) In a windowing environment, if the user attempts to close the program window via
        ! a border control or Alt/F4, and reporting of close-window requests is enabled (see
        ! InEventSelect(7,n)) InfoInput(55) will return 260. This is the same
        ! code as is returned by InKeyEvent when such an event occurs. The calling
        ! program should perform program termination in response to this event. Note that
        ! INTERACTER screen handling remains fully available at this point, so it is
        !allowable to ask the user for confirmation (e.g. using IdMessage) before
        !terminating the program.
        !ITEM 56 returns a flag which indicates whether keypad keys are identifiable and if so
        !whether separate cursor and keypad keys are available. A return value of -1 indicates
        !that the keypad cannot be identified as such at all. A return value of 0 or 1 means that
        !the keypad can be identified. If the cursor keys and keypad are shared (as on the
        !original PC keyboard) a value of 0 is returned. This may be useful in selecting the
        !keypad mode to use with InKeypad.
        !ITEM 57 is always used in combination with ITEM number 55 when GIN or TIN mode
        !is in operation. If InfoInput(55) returns -1 then InfoInput(57) contains the
        !InKeyEvent code of the non-exit/non-movement key which was pressed to exit from
        !TIN/GIN mode. Conversely, InfoInput(57) will return -1 when TIN/GIN routines
        !return InfoInput(55) set to 21-23/259/260.
        !ITEM 58 returns the current menu/input-box pop-up mode, as set by InPopup.
        !ITEM 59 returns the digitiser stylus button number which was last used to exit GIN
        !mode. This is more specific than the code returned by InfoInput(55) which is
        !designed to be compatible with other types of input device. On a 2-button stylus the
        !returned value will be 1 or 2 and on a 3-button stylus the returned value will be 1, 2 or
        !4. A 4-button stylus will return a value of 1-4 and a 16-button stylus will return 1-16. If
        !a digitiser has not been used for GIN mode, the returned value is undefined.
        !Information Functions INTERACTER Subroutine Reference
        !4-50
        !ITEM 60 returns the current single-key menu selection mode as set by the InSingle
        !routine. A returned value of zero means that single key selection is disabled.
        !ITEM 61 returns the mouse button number used to exit from a fixed field, menu, formeditor,window-browser or file-editor. This will be available when any of these routines
        !return InfoInput(55) set to -2 or when a menu returns a value of 21 or when a
        !push-button field is used to exit a form. In the latter cases, ITEM 61 will return zero if a
        !keyboard key was used to confirm a menu option.
        !ITEM's 62 and 63 will normally be interrogated as a pair, since they return the text
        !column/row position at which a mouse or keyboard event last occurred. These values
        !are updated by any routine which performs input processing, so it is important that they
        !should be interrogated immediately after the subroutine call to which they relate.
        !InfoGraphics(5/6) return the equivalent graphics co-ordinates, in graphics mode.
        !ITEM 64 returns the relative poistion of the text input cursor within a fixed field (e.g.
        !InString, InIntegerXYDef, InRealDef, etc.) when an exit key/button is
        !pressed. So for example, if the cursor were at the start of the field on exit,InfoInput(64) would be returned with a value of 1.
        !ITEM 65 returns the ICHAR code of the currently selected multiple choice menu tag
        !character as set by InMultiple. This can be converted to character using CHAR.
        !ITEM 66 returns the current event mask as set or modified by InEventSelect. This
        !describes the current selection state of all events as would be set by a single call to
        !InEventSelect(0,N). This value is therefore suitable for saving and restoring the
        !event state in a general purpose routine since it can be passed directly to
        !InEventSelect(0,N).
        !ITEM 67 returns the code which was returned by the call to InKeyEvent in the
        !IGrPause routine. This may be a non-keystroke value such as a graphics window
        !expose/resize event code (259), a close-window request (260) or a mouse button code.
        !ITEM 68 returns the current setting of the 'exit on mouse click outside input area'
        !option, selectable via InMouseOptions(2,n).
        !ITEM 69 returns the current field gravity as set by InGravity. A value of zero is
        !equivalent to the default setting of left gravity. Right-handed gravity returns 1.
        !ITEM 70 returns the time of the last mouse button up/down or movement event (but
        !only if the current mouse type supports such events, i.e. InfoHardware(8)=2). The
        !time is reported in milli-seconds since an arbitrary start time, which varies between
        !implementations. The time stamp can wrap round to zero after an implementation
        !dependent period of time, so time stamp checks should allow for this possibility.
        !ITEM's 101-106 return the mouse button numbers assigned to special actions by the
        !equivalent InMouseOptions options (0=none).
        !e.g. CALL IOutStringXY(10,5,'To quit, press Function key F')
        !CALL IOutInteger(InfoInput(51),2)
        !Portability notes :
        !DOS :
        !ITEM 56 can be used to establish whether a standard or enhanced keyboard is being
        !used. A standard keyboard returns 0 and an enhanced keyboard returns 1.
        !INTERACTER Subroutine Reference Information Functions
        !4-51
        !Terminals :
        !VT100/VT200 type terminals and their many variants return a value of 1 for ITEM 56
        !since they have separate cursor keys and keypad which can be identified uniquely. Most
        !other terminal types will return a value of -1, since they do not generally allow the
        !keypad (where fitted) to be identified separately.
        !Under DECterm or xterm, ITEM's 62 and 63 return the position of the mouse cursor for
        !mouse events only. The mouse cursor position is not available for keyboard events.
    
        res = 0
    end function

    INTEGER function InfoOpSystem(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! OSType (1) : Operating system
        ! DOS (1) : DOS
        ! VMS (3) : VMS
        ! Unix (4) : Unix
        ! Win32 (6) : Windows
        ! NumCLArgs (2) : Number of arguments specified on the command line
        ! OSVersion (3) : Operating system version (see Portability notes)
        ! MatchManyChar (4) : ASCII code of 'match-many' wildcard character
        ! MatchSingleChar (5) : ASCII code of 'match-single' wildcard character
        ! DirSepChar (6) : ASCII code of directory/filename separator character
        ! FileCaseSense (7) : Filenames are case sensitive )
        ! FileSuffix (8) : Filename suffixes supported )
        ! CurDirIsRoot (9) : Current directory is root directory ) IntNo (0)
        ! DiskInA (10) : Is a disk present in floppy drive A/0 ) = no
        ! DiskInB (11) : Is a disk present in floppy drive B/1 )
        ! PrinterReady1 (12) : Is printer enabled on parallel port 1 ) IntYes (1)
        ! PrinterReady2 (13) : Is printer enabled on parallel port 2 ) = yes
        ! PrinterReady3 (14) : Is printer enabled on parallel port 3 )
        ! SystemTime (15) : Current system time
        ! (same units as mouse event time stamps)
        ! WindowsVersion (16) : Microsoft Windows variant
        ! NotWindows (0) : DOS, Unix or VMS
        ! Win32s (2) : Windows 3.1x/Win32s
        ! Windows95 (3) : Windows 95/98/Me
        ! WindowsNT (4) : Windows NT/2000
        ! DiskFreeSpace (17) : Free disk space on current drive
        ! ProcessorType (18) : CPU type
        ! CPUx86 (1) : Intel
        ! CPUaxp (2) : Alpha
        ! CPUvax (3) : VAX
        ! CPUsparc (4) : SPARC
        ! CPUmips (5) : MIPS
        ! CPUhp (6) : HP
        ! CPUibm (7) : IBM
        ! Information Functions INTERACTER Subroutine Reference
        ! 4-52
        ! UnixVersion (19) : Unix variant :
        ! NotUnix (0) : Non-Unix system
        ! UnixSunOS (2) : SunOS/Solaris
        ! UnixHPUX (4) : HP/UX
        ! UnixIRIX (8) : SG/IRIX
        ! UnixAIX (9) : IBM AIX
        ! UnixCompaq (13) : Compaq/Digital Unix
        ! UnixLinux (14) : Linux
        ! Short-name : INFOOS
        ! Include : interif.inc, intergen.inc
        ! Returns operating system related information.
        ! ITEM 1 reports the generic operating system. Other ITEM codes identify the specific
        ! operating system version or cpu type.
        ! ITEM=2 returns the number of arguments specified by the user at run time on the
        ! program command line. If no arguments were specified, InfoOpSystem is returned
        ! as zero. For more details of command line argument handling see IOsArgument.
        ! ITEM 3 returns the operating system version number, multiplied by 100. A version
        ! number of 3.10 is returned as 310, 4.0 returns 400, etc.
        ! ITEM's 4 and 5 return the ASCII codes of the wildcard characters which can be used to
        ! match multiple characters or single characters in filename specifications. The returned
        ! codes can be converted to a CHARACTER using CHAR.
        ! ITEM 6 returns the ASCII code of the character which separates the directory name
        ! from the local filename in a full file pathname. The returned code can be converted to a
        !character(len=*) using CHAR.
        ! ITEM 7 returns a binary flag which indicates whether the current operating system is
        !case sensitive in its handling of filenames (e.g. Unix).
        !ITEM 8 returns a binary flag which indicates whether the current operating system
        !supports filename suffixes (e.g. .EXE, .dat, etc.). This will be true for all currently
        !supported operating systems.
        !ITEM 9 returns a binary flag which indicates whether the currently selected directory is
        !the root directory on the current drive. This can be useful when navigating up/down a
        !directory tree structure.
        !ITEM's 10 and 11 return a binary flag which indicates whether a readable disk is
        !present in a floppy disk drive. This can be useful to avoid 'Abort, Retry, Fail?' error
        !messages under DOS or Windows.
        !ITEM's 12 to 14 return a binary flag which indicates whether a printer is enabled on
        !parallel port 1, 2 or 3 under DOS. This can be used to avoid 'Abort, Retry, Fail?' error
        !messages when attempting to print to a printer which is switched off. Bear in mind that
        !(a) this check can only be used on a parallel port and (b) DOS allows device names
        !such as PRN, LPT1, LPT2 and LPT3 to be reassigned to serial ports via the MODE
        !command. If the printer is not enabled (i.e. a value of 0 is returned), a status code will
        !be available via InfoError(3). See Portability notes.
        !INTERACTER Subroutine Reference Information Functions
        !4-53
        !ITEM 15 returns the system time in milliseconds since an arbitrary start point. The
        !returned value is in the same units as mouse event time stamps as returned by
        !InfoInput(70). The difference between the two values therefore gives the time
        !since a mouse event occurred. (Since this system value uses the same time mechanism
        !as mouse input, it is not available on serial terminals or terminal emulators, where it
        !returns -1).
        !ITEM 16 identifies the particular type of Windows operating system under which the
        !program is currently running, i.e Win32s, 9x/Me or NT/2000. ITEM 3 gives the exact
        !version number. On a non-Windows operating system, zero is returned.
        !ITEM 17 reports the free disk space on the current drive, in bytes. Some
        !implementations do not support this function in which case -1 is returned.
        !ITEM 18 reports the processor type (e.g. Intel or Alpha). Note this is a value which is
        !hardcoded into the library. If the executable is running in an emulation mode on a
        !foreign processor, the original target processor type is reported.
        !ITEM 19 identifies the particular type of Unix operating system under which the
        !program is currently running. ITEM 3 gives the exact version number. On a non-Unix
        !operating system, zero is returned.
        !Note that unlike most INTERACTER routines, InfoOpSystem can be called before
        !IScreenOpen if required allowing command line argument processing of
        !initialisation file names.
        !e.g. IF (InfoOpSystem(2).EQ.0)
        !1 CALL IOutStringXY(1,1,'No arguments specified')
        !Portability notes :
        !DOS :
        !If ITEM 10/11 returns zero, InfoError(3) will report a BIOS error code as
        !returned by interrupt 13h.
        !If ITEM's 12-14 return zero, InfoError(3) will report a bit-encoded BIOS error
        !code as returned by interrupt 17h.
        !ITEM 15 returns the time in milliseconds since midnight. The timer itself has only a
        !centisecond resolution (i.e. time values are always a multiple of 10).
        !ITEM 17 is limited to a maximum of 2Gb.
        !MS Windows :
        !ITEM's 10/11 are supported. ITEM codes 167-190 report equivalent information for
        !CD drives C-Z. The latter capability is unique to the Win32 implementation.
        !ITEM's 12-14 always return a value of 1 in the Win32 implementation.
        !ITEM 15 returns the time in milliseconds since Windows was booted.
        !ITEM 17 returns correct values up to a maximum of 2Gb. This limit is imposed to
        !maintain compatibility with Windows 95 Rel. 1 and Win32s.
        !VMS :
        !ITEM's 10 to 14 always return 1.
        !ITEM 15 returns the X server time under X Windows, otherwise it returns -1.
        !ITEM 17 always returns -1.
        !Information Functions INTERACTER Subroutine Reference
        !4-54
        !Unix :
        !ITEM's 10 to 14 always return 1.
        !ITEM 15 returns the X server time under X Windows. Otherwise -1 is returned.
        !ITEM 17 always returns -1.
    
        res = 0
    end function

    INTEGER function InfoPgInteger(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! 1 : Graph type
        ! 2 : Number of data sets
        ! 3 : Number of data values (#1)
        ! 4 : Number of data values (#2)
        ! 5 : Number of data values (#3)
        ! 6 : Requested layout (bit encoded)
        ! 7 : Outline colour for histograms/bar-charts/pie-charts
        ! 8 : 2D filled contour plot granularity
        ! 9 : Marker frequency (start)
        ! 10 : Marker frequency (every)
        ! 11 : No. of decimal places in E/F format scale values
        ! 12 : X axis scaling (0=linear 1=logarithmic)
        ! 13 : Y axis scaling (0=linear 1=logarithmic)
        ! 14 : Clip rectangle (0=graphics area 1=PG area)
        ! 15 : 3D surface plot grid colour
        ! 16 : 3D surface plot grid direction
        ! 17 : 3D axes fill style
        ! 18 : 3D axes primary fill colour (panel #1)
        ! 19 : 3D axes primary fill colour (panel #2)
        ! 20 : 3D axes primary fill colour (panel #3)
        ! 21 : 3D axes secondary fill colour (panel #1)
        ! 22 : 3D axes secondary fill colour (panel #2)
        ! 23 : 3D axes secondary fill colour (panel #3)
        ! 24 : No. of user defined X axis scale points ) Auto-scale
        ! 25 : No. of user defined Y axis scale points ) if <=0
        ! 26 : No. of user defined Z axis scale points )
        ! 27 : No. of user def. histogram X axis scale points
        ! 28 : No. of user def. bar-chart Y axis scale points
        ! Returns integer presentation graphics information, as set by routines in the PG(1)
        ! group. See also InfoPgReal and InfoPgStyle.
        ! ITEM Routine ITEM Routine
        ! 1-6 IPgNewPlot 16 IPgGridDirection
        ! 7 IPgStyleOutline 17-23 IPgStyle3DAxes
        ! 8 IPgConFill2Granul 24 IPgXUserScale
        ! 9-10 IPgMarkerFrequency 25 IPgYUserScale
        ! 11 IPgDecimalPlaces 26 IPgZUserScale
        ! 12-13 IPgScaling 27 IPgXUserScaleHist
        ! 14 IPgClipRectangle 28 IPgYUserScaleBar
        ! 15 IPgGridLines
        ! INTERACTER Subroutine Reference Information Functions
        ! 4-55
    
        res = 0
    end function

    REAL function InfoPgReal(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! 1 : PG area X minimum
        ! 2 : PG area Y minimum
        ! 3 : PG area X maximum
        ! 4 : PG area Y maximum
        ! 5 : PG units X minimum
        ! 6 : PG units Y minimum
        ! 7 : PG units Z minimum
        ! 8 : PG units X maximum
        ! 9 : PG units Y maximum
        ! 10 : PG units Z maximum
        ! 11 : Max radius (polar plots)
        ! 12 : 3D elevation angle
        ! 13 : 3D rotation angle
        ! 14 : X scale position
        ! 15 : Y scale position
        ! 16 : X label position
        ! 17 : Y label position
        ! 18 : Z label position
        ! 19 : X key position
        ! 20 : X tick length
        ! 21 : Y tick length
        ! 22 : Z tick length
        ! 23 : X axis tick angle
        ! 24 : Y axis tick angle
        ! 25 : Z axis tick angle
        ! 26 : X axis scale value angle
        ! 27 : Y axis scale value angle
        ! 28 : Z axis scale value angle
        ! 29 : X tick pos (Y bottom)
        ! 30 : X tick pos (Y top)
        ! 31 : Y tick pos (X left)
        ! 32 : Y tick pos (X right)
        ! Include : intfuncs.inc
        ! Returns real presentation graphics information, as set by routines in the PG(1) group.
        ! Note that this routine must be declared as REAL in the calling program. This can be
        ! done by including intfuncs.inc or, in a Fortran 90 program, by USE.ing the
        ! INTERACTER module.
        ! Information Functions INTERACTER Subroutine Reference
        ! 4-56
        ! ITEM Routine(s) ITEM Routine
        ! 1-4 IPgArea 19 IPgXKeyPos
        ! 5-10 IPgUnits/IPgUnitsZ 20 IPgXTickLength
        ! 11 IPgUnitsPolar 21 IPgYTickLength
        ! 12 IPgElevation 22 IPgZTickLength
        ! 13 IPgRotation 23/26 IPgXScaleAngle
        ! 14 IPgXScalePos 24/27 IPgYScaleAngle
        ! 15 IPgYScalePos 25/28 IPgZScaleAngle
        ! 16 IPgXLabelPos 29/30 IPgXTickPos
        ! 17 IPgYLabelPos 31/32 IPgYTickPos
        ! 18 IPgZLabelPos
        ! See also InfoPgInteger and InfoPgStyle.
    
        res = 0
    end function

    INTEGER function InfoPgStyle(ISET,ITEM) result(res)
        integer ISET ! Data set number
        integer ITEM ! Number of information item required :
        ! 1 : Style #1 as set by IPgStyle
        ! 2 : Style #2 as set by IPgStyle
        ! 3 : Style #3 as set by IPgStyle
        ! 4 : Colour #1 as set by IPgStyle
        ! 5 : Colour #2 as set by IPgStyle
        ! 6 : Marker as set by IPgMarker
        ! Returns information about presentation graphics style values for PG data set ISET.
        ! ITEM's 1 to 5 correspond to the ISTYL1 - ICOL2 style arguments supplied to
        ! IPgStyle.
        ! ITEM 6 returns the marker number, as specified via IPgMarker.
    
        res = 0
    end function

    INTEGER function InfoScreen(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! ScrMode (1) : Current screen mode
        ! TextColumns (2) : Number of text columns in current mode
        ! TextRows (3) : Number of text rows in current mode
        ! HorizPixels (4) : Horizontal graphics pixel resolution (zero in a)
        ! VerticPixels (5) : Vertical graphics pixel resolution (text mode)
        ! ScrMaxModes (6) : Max number of modes available
        ! ScrWidth (7) : Full screen width in pixels ) Windowing
        ! ScrHeight (8) : Full screen height in pixels ) environments
        ! ScrColours (9) : Full screen colours ) only
        ! 101-124 : Options set by IScreenDumpOptions
        ! Short-name : INFOSC
        ! Include : interif.inc, intersc.inc
        ! Returns information about the current screen mode and screen dump options. See also
        ! InfoScreenMode which returns information about any mode.
        ! INTERACTER Subroutine Reference Information Functions
        ! 4-57
        ! The current screen mode number is display dependent. See IScreenModeN for lists
        ! of supported screen mode numbers.
        ! The number of columns and rows returned by ITEM's 2 and 3 define the dimensions of
        ! the text screen as written to by the text handling routines in the OU, CU, CG, WN, IN,MN, etc. groups. When called in a graphics mode these values have nothing to do with
        ! the dimensions of graphics hardware text as output by IGrCharOut.
        ! The pixel resolution of the current graphics mode should not normally be required since
        ! the graphics routines are independent of screen resolution, but this information is made
        ! available for those wishing to produce hardware dependent graphics displays.
        ! ITEM 6 returns the highest valid screen mode number recognised by IScreenModeN
        ! in the current implementation of INTERACTER. This is also the highest mode number
        ! which can be specified to the complementary InfoScreenMode function which can
        ! return information about any screen mode.
        ! ITEM's 7-9 return information about the video mode that the underlying windowing
        ! environment is currently using (they return zero in a full screen environment). ITEM's 7
        ! and 8 report the width and height of the display in pixels. ITEM 9 returns the number
        ! of colours which will usually be greater than the number of available graphics colours
        ! reported by InfoGrScreen(31).
        ! The current values of screen dump options such as page size, position, orientation, etc.
        ! are accessible using ITEM's 101-124. These ITEM codes correspond directly to the
        ! options which can be assigned by IScreenDumpOptions(1-24,N).
        !e.g. NROWS = InfoScreen(3)
        !CALL IOutCentre(NROWS,'This is on the bottom screen row')
        !Portability notes :
        !DOS:
        !ITEM's 7-9 return zero.
        !Terminals :
        !On some Tektronix or ReGIS compatible displays the pixel resolutions returned by
        !InfoScreen(4) and InfoScreen(5) have to be approximated since the exact
        !pixel resolution of the screen may well not be known. The returned values are intended
        !to reflect the true physical resolution of the screen rather than the 'virtual' co-ordinate
        !system used by these devices. If required, these dimensions can be set in the
        !initialisation file using the PIXELH and PIXELV keywords.
        !ITEM's 7-9 return zero.
        !Information Functions INTERACTER Subroutine Reference
        !4-58


        select case (item)
            ! ScrMode (1) : Current screen mode
            case (1)
                res = 261
            ! TextColumns (2) : Number of text columns in current mode
            case (2)
                res = 128
            ! TextRows (3) : Number of text rows in current mode
            case (3)
                res = 48
            ! HorizPixels (4) : Horizontal graphics pixel resolution (zero in a)
            case (4)
                res = 1024
            ! VerticPixels (5) : Vertical graphics pixel resolution (text mode)
            case (5)
                res = 768
            ! ScrMaxModes (6) : Max number of modes available
            case (6)
                res = 1
            ! ScrWidth (7) : Full screen width in pixels ) Windowing
            case (7)
                res = 1024
            ! ScrHeight (8) : Full screen height in pixels ) environments
            case (8)
                res = 768
            ! ScrColours (9) : Full screen colours ) only
            case (9)
                res = 256
        end select
    
    end function

    INTEGER function InfoScreenMode(ITEM,MODE) result(res)
        integer ITEM ! Number of information item required :
        ! ModeType (1) : Mode availability/type
        ! TextColumns (2) : Number of text columns in specified mode
        ! TextRows (3) : Number of text rows in specified mode
        ! HorizPixels (4) : Horizontal graphics pixel resolution (zero in a)
        ! VerticPixels (5) : Vertical graphics pixel resolution (text mode)
        ! NumColours (6) : Number of colours
        integer MODE ! Screen mode number (0 to InfoScreen(6))
        ! Short-name : INFOMD
        ! Include : interif.inc, intergen.inc
        ! Returns information about the availability and characteristics of the specifed screen
        ! mode. See also InfoScreen which returns information about the current mode.
        ! Unlike most other functions in the IF subroutine group, InfoScreenMode takes two
        ! arguments. The MODE argument must be a valid screen mode number in the range 0 to
        ! InfoScreen(6). The latter is the highest valid mode number on the current display.
        ! Specifying a mode number which is outside this range will return a value of 0.
        ! ITEM 1 identifies whether a mode is available and, if so, its type :
        ! IntNo (0) : Unavailable
        ! TextOnly (1) : Text-only mode
        ! TextAndGraphics (2) : Graphics+Text mode
        ! The values returned by ITEM's 2-6 are undefined if ITEM 1 returns 0. Always check
        ! that a mode is available, before interrogating its dimensions or number of colours.
        ! The number of columns and rows returned by ITEM values 2 and 3 define the
        ! dimensions of the text screen as written to by the text handling routines in the OU, CU,CG, WN, MN, etc. groups. When MODE identifies a graphics mode these values have
        ! nothing to do with the dimensions of graphics hardware text output by IGrCharOut.
        ! The pixel resolutions returned by ITEM's 4 and 5 will only be non-zero if MODE
        ! identifies a graphics mode. They reflect the true pixel resolution of the screen wherever
        ! possible, rather than virtual device dimensions as supported by some screens.
        ! A demo program called whatmode is supplied which shows how InfoScreenMode
        ! can be used to build a menu of available graphics modes, to allow mode selection on
        ! screens which support more than one graphics mode. The IdScreenMode routine in
        ! the II group performs a similar task.
        !e.g. MAXMOD = InfoScreen(6)
        !DO 100 MODE = 0,MAXMOD
        !IF (InfoScreenMode(1,MODE).EQ.1.OR.
        !1 InfoScreenMode(1,MODE).EQ.3) THEN
        !IF (InfoScreenMode(2,MODE).EQ.132) THEN
        !CALL IScreenMode('T',132,1 InfoScreenMode(3,MODE),InfoScreenMode(6,MODE))
        !GOTO 200
        !ENDIF
        !ENDIF
        !100 CONTINUE
        !CALL IOsExitProgram('Cannot find a 132 column text mode.',99)
        !200 ...
        !INTERACTER Subroutine Reference Information Functions
        !4-59
        select case (ITEM)
            ! ModeType (1) : Mode availability/type
            ! TextColumns (2) : Number of text columns in specified mode
            ! TextRows (3) : Number of text rows in specified mode
            ! HorizPixels (4) : Horizontal graphics pixel resolution (zero in a)
            ! VerticPixels (5) : Vertical graphics pixel resolution (text mode)
            case (6)
            ! NumColours (6) : Number of colours
                res = 256
            case default
                res = 0
        end select
    end function

    character(len = 100) function InfoVersion(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! IntVersion (1) : INTERACTER library version number
        ! Short-name : INFOVN
        ! Include : interif.inc
        ! Returns the version number of the INTERACTER library in the form of a character
        ! string, consisting of a major version number, a full stop (period) and a minor version
        !number. The string may be terminated with a bug-fix release letter (e.g. '5.0a'). This is
        !the version string which is displayed when the VER= initialisation file keyword is used.
    
        res = ""
    end function

    INTEGER function InfoWindow(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! WinCurNumber (1) : Current window number
        ! WinAvailable (2) : Number of windows still available to be opened
        ! WinBufferSapce (3) : Remaining space in the internal window buffer
        ! WinLeftColumn (4) : Screen column of top left corner of window
        ! WinTopRow (5) : Screen row of top left corner of window
        ! WinWidth (6) : Width of current window excluding frame
        ! WinHeight (7) : Height of current window excluding frame
        ! WinTopNumber (8) : Top window number (i.e. number of open windows)
        ! WinCursorX (9) : Current window (x) cursor position
        ! WinCursorY (10) : Current window (y) cursor position
        ! WinFrameMode (11) : Frame mode selected
        ! (0=none 1=Titled 3=Boxed title)
        ! WinPopupMode (12) : Pop-up mode selected ) IntNo (0) : no
        ! WinClearMode (13) : Clear mode selected ) IntYes (1) : yes
        ! WinTitle (14) : Title justification :
        ! WindowLeft (1) : left
        ! WindowCentre (2) : centre
        ! WindowRight (3) : right
        ! WinLenFindStr (15) : Significant length of last search string
        ! WinTagChar (16) : ASCII code of current tag character
        ! WinTitleMode (17) : Wide title mode selected (0=no 1=yes)
        ! WinFileSaved (18) : File saved in editor since last change (0=no 1=yes)
        ! Short-name : INFOWN
        ! Include : interif.inc, intergen.inc
        ! Returns information about the current status of the text window management system.
        ! The current and top window numbers can be interrogated using ITEM numbers 1 and 8
        ! respectively. By default, these will be the same when IWinOpen has just been called.
        ! There is a limit on the number of simultaneously open windows. Specify an ITEM
        ! value of 2 to find how many are still available to be opened.
        ! Information Functions INTERACTER Subroutine Reference
        ! 4-60
        ! The internal window buffer is used to store the old screen contents when 'pop-up' mode
        ! has been enabled by IWinAction. There must be sufficient space available in this
        ! buffer to enable the pop-up window feature to operate correctly. The returned value is
        ! expressed in terms of the number of screen character positions which can still be copied
        ! into the buffer. This information is consistent across all displays in all screen modes.
        ! Hence, if a window is to be opened which will occupy 40 columns by 10 rows
        ! (including frame), there must be room for at least 400 screen characters in the buffer.
        ! ITEM's 4-7 return the position and size of the current window, excluding any frame.
        ! The current position of the window cursor, as set by IWinCursorXY or any of the
        ! window output routines, can be obtained using ITEM values 9 and 10. These are cursor
        ! positions relative to the top left corner of the window.
        ! ITEM's 11-14 and 17 return the various modes used by the window manager when
        ! opening a window, as set by IWinAction.
        ! ITEM 15 returns the significant length of the last search string to be entered in one of
        ! the browser or editor routines (IWinBrowseText, IWinBrowseFile,IWinEditFile or IWinEditText) via the Find option. This may include trailing
        ! blanks if these were explicitly entered by the user. If no string has been entered, the
        ! length is returned as zero. The search string itself is available via
        ! InfoWinString(1).
        ! ITEM 16 returns the ASCII code of the embedded tag indicator character as set via
        ! IWinTagChar. By default this is set to a blank (for 'none') which will return a value
        ! of 32.
        ! ITEM 18 can be called after IWinEditFile to determine whether the edited text
        ! buffer has been saved since the last time it was modified.
        !e.g. IAVAIL = InfoWindow(2)
        !IF (IAVAIL.GT.0) CALL IWinOpen(20,10,60,20)
    
        res = 0
    end function

    character(len = 100) function InfoWinString(ITEM) result(res)
        integer ITEM ! Number of information item required :
        ! WinFindStr (1) : Last search string entered in window browser/editor
        ! Include : interif.inc
        ! Returns the most recently entered search string entered in a text window browser or file
        ! editor via the Find option. The significant length of the string, including entered trailing
        ! blanks, is available via InfoWindow(15). If no search string has been entered, a
        ! blank string is returned.
        !e.g. CHARACTER*40 SearchString,InfoWinString
        !:
        !CALL IWinBrowseFile(Fname,LRSTEP,IPOS,'')
        !LenSearch = InfoWindow(15)
        !IF (LenSearch.GT.0) THEN
        !SearchString = InfoWinString(1)
        !INTERACTER Subroutine Reference Operating System Interface
        !4-61
        !4.3 Group OS : Operating System Interface
        !As far as possible, the routines in this group provide a standardised interface to the
        !operating system. Broadly, they can be split into those routines which return
        !information and those which execute commands or programs. The informational
        !routines comprise : IOsArgument (run-time command line arguments),IOsVariable (o.s. variables), IOsDirInfo/IOsDirList (directory file
        !info/list), IOsDirCount (count files in a directory), IOsDirName (name of current
        !directory) and IOsDate/IOsTime (system date and time). Files can be copied,renamed or deleted via IOsCopyFile, IOsRenameFile and IOsDeleteFile.
        !The remaining routines are IOsCommand/IOsCommandSilent (execute an o.s
        !command), IOsDirChange/IOsDirMake/IOsDirDelete (change, make or
        !delete a directory), IOsExecute ('chain' another program) and IOsExitProgram
        !(abort with message and return code). Note that operating system related information is
        !also available via the InfoOpSystem routine.
        !Inevitably, these facilities will depend on the precise environment in which a program
        !is running, i.e. how exactly you have set the operating system up to run your
        !INTERACTER program. Take particular care to read the Portability notes when using
        !routines in this group. The implications of using routines such as IOsCommand or
        !IOsExecute on different machines are, by their nature, non-trivial.
    
        res = ""
    end function

    subroutine IOsArgument(N,STRING)
        integer N ! Number of argument to return (>=1)
        ! (0 returns program name under Win32 & Unix)
        character(len=*) STRING ! Returned command line argument
        ! Short-name : OSARG
        ! Returns command line argument number N in STRING. In other words, when you run a
        ! program using INTERACTER, you can supply run-time arguments after the name of the
        ! program. This routine provides access to those command line arguments. Each space
        ! delimited string is treated as a single argument, with the first string after the program
        ! name being argument number 1. Note that strings enclosed in double quotes (.) will be
        ! returned as a single argument, with the quotes removed, allowing arguments with
        ! embedded spaces to be specified. On most systems a null string (two double quotes)
        ! will be ignored.
        ! On some operating systems, argument zero will return the name of the current program.
        ! See the Portability notes for details.
        ! If STRING is longer than a particular command line argument, it will be padded with
        ! spaces. If it is shorter than the argument, the argument will be truncated. If N is greater
        ! than the number of command line arguments available, STRING is filled with blanks.
        ! Call InfoOpSystem to find out how many command line arguments were supplied.
        ! The following example is a complete program which reads a filename and a numeric
        ! value from the command line, then displays the specified line of the named file,provided that file and line exist. It assumes the user has typed something of the form :
        ! LIST FILE.DAT 20
        ! Operating System Interface INTERACTER Subroutine Reference
        ! 4-62
        ! Note that unlike most INTERACTER routines, IOsArgument (and InfoOpSystem)
        ! can be called before IScreenOpen if required allowing command line argument
        ! processing of initialisation file names.
        !e.g. CHARACTER*80 RECORD
        !CHARACTER*12 FILNAM
        !CHARACTER*3 NUMBER
        !CALL IScreenOpen(' ','T',80,25,16)
        !C how many command line arguments ?
        !IF (InfoOpSystem(2).LT.2)
        !1 CALL IOsExitProgram('Syntax : LIST file line',21)
        !CALL IOsArgument(1,FILNAM)
        !CALL IOsArgument(2,NUMBER)
        !C convert string argument to an integer
        !CALL IStringToInteger(NUMBER,LINENO)
        !CALL OPEN(20,FILE=FILNAM,STATUS='OLD',ERR=200)
        !DO 100 LINE = 1,LINENO
        !READ(20,'(A80)',END=200) RECORD
        !100 CONTINUE
        !CALL IOutStringXY(1,1,RECORD)
        !200 CALL IScreenClose
        !END
        !Portability notes :
        !DOS:
        !Argument zero returns a blank string.
        !Windows :
        !In addition to accepting conventional command line arguments, the 'drag and drop'
        !program invocation feature is also supported. Under Windows 4.x or later, dragging
        !one or more file icons onto a program icon will feed the names of those files to the
        !program as command line arguments. Under Windows 3.x a more limited
        !implementation of the same functionality is provided within File Manager, where a
        !single file can be dragged onto a program icon and a confirming message box appears
        !before program invocation.
        !Additionally, under Windows 4.x or later, file type association is also supported. A file
        !type association can be established between files with a given extension and a specified
        !program (in Explorer select View->Options->File Types->New Type). Double clicking
        !on a file of the specified type then invokes the associated program with the data file
        !name as the command line argument.
        !Argument number 0 will return the full path name of the current executable.
        !Unix :
        !The Shell will automatically expand any wildcards (regular expressions in Unix
        !terminology) before passing arguments to your program. Argument zero will return the
        !entered program name on most Unix systems (but not on all and this may not include
        !the full path name).
        !VMS :
        !You will need to set up a DCL foreign command to run your program to allow
        !INTERACTER to read arguments from the command line. This will be of the form :
        !RUNPROG := $WHEREVER:[DIRNAME]PROG
        !You would then execute your program by typing :
        !RUNPROG arg1 arg2 ... etc
        !Argument zero returns a blank string.
        !INTERACTER Subroutine Reference Operating System Interface
        !4-63
    end subroutine

    subroutine IOsCommand(COMMAND)
        character(len=*) COMMAND ! Command to pass to the operating system
        ! (maximum length 250 characters)
        ! Short-name : OSCMND
        ! Executes the supplied string as an operating system command. The calling program will
        ! block until the specified command completes. Control then returns to the calling
        ! routine. If you wish to execute a non-returning program rather than an o.s. command,see the IOsExecute routine. If the supplied command string is blank, IOsCommand
        ! takes no action.
        ! Whilst this is a very powerful facility, it must obviously be used with caution. The
        ! commands which are allowed to be passed to this routine are entirely operating system
        ! dependent. Avoid the use of commands which may change screen mode, since
        ! INTERACTER expects to remain in the mode it was in on entry to IOsCommand.
        ! In full-screen environments or workstation terminal emulations, when execution of the
        ! command is complete the user is prompted to press a key and the screen is cleared (in
        ! case the command has generated any screen output). Since this feature can be a
        ! nuisance in the situation where an operating system command generates no output, the
        ! alternative IOsCommandSilent is also provided for the execution of 'silent'
        ! commands (i.e. those which will perform no screen I/O).
        !e.g. CHARACTER*20 COMAND
        !CALL IOutStringXY(1,1,'Enter o.s. command : ')
        !CALL InString(COMAND,LENCOM)
        !CALL IOsCommand(COMAND(:LENCOM))
        !IF (InfoError(1).EQ.13) THEN
        !CALL IOutStringXY(1,1,'Operating system error code : ')
        !CALL IOutInteger(InfoError(3),6)
        !ENDIF
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !Portability notes :
        !DOS :
        !Executing a DOS command requires that a copy of COMMAND.COM be temporarily
        !loaded in from disk. DOS needs to know where to find this, so it is advisable to include
        !a SET COMPSEC command in your AUTOEXEC.BAT file. e.g.
        !SET COMSPEC=C:\COMMAND.COM
        !A limitation of COMMAND.COM is that it does not return a result code for the supplied
        !DOS command (i.e. the code which is normally accessible using an IF ERRORLEVEL
        !command). As a result, the only meaningful errors returned in most implementations
        !are 'command.com not found' (InfoError(3)=2) or 'insufficient memory'
        !(InfoError(3)=8).
        !DOS (Lahey F77L-EM/32 and LF90) :
        !Under the Lahey F77L-EM/32 and LF90 protected mode compilers, IOsCommand
        !calls the Lahey SYSTEM subroutine. Commands are thus limited to 77 characters and
        !no error code can be returned.
        !Operating System Interface INTERACTER Subroutine Reference
        !4-64
        !DOS (Microsoft Fortran PowerStation) :
        !The MS PowerStation implementation uses the Microsoft SYSTEMQQ run-time library
        !routine. The possible error codes which can be returned by InfoError(3) are
        !therefore the same as can be returned by GETLASTERRORQQ. See the PowerStation
        !Language Guide for details.
        !DOS (Salford FTNxx) :
        !Under the Salford compilers, IOsCommand calls the CISSUE library routine.
        !Consequently, the only error code which can be returned is InfoError(3)=1.
        !MS Windows :
        !IOsCommand executes the supplied command via the Windows API using
        !CreateProcess (Win32) or WinExec (Win32s). Under Win32 the calling program
        !will wait until execution of the sub-command has completed. Under Win32s control
        !returns to the caller as soon as the command has been invoked.
        !Both DOS and Windows programs with a .EXE extension can be executed by
        !specifying the program name (without an extension). Batch files, PIF files and COM
        !files can also be run, but the extension must be specificied. Internal DOS commands
        !(e.g. DIR) can only be executed by specifying commands of the form :
        !command.com /c dir
        !or : command.com /k dir
        !Alternatively, the DOS prompt PIF file can be used to execute such a command :
        !dosprmpt.pif /c dir
        !The latter method has the advantage that the 'Close Window on exit' field in the PIF
        !editor can be used to determine whether the resulting DOS output remains visible in a
        !DOS box. These methods of command execution can also be used for non-internal
        !DOS commands, where appropriate.
        !InfoError(3) returns the API function return code in the event of an error.
        !Xlib :
        !Operating system commands issued from a program which uses the Xlib driver will
        !send their output to the terminal emulation window from which the current program
        !was initiated rather than to the program's own output window.
        !Unix :
        !Any command which can be entered at the operating system prompt can be entered
        !here, since the Unix 'system' library function is invoked.
        !VMS :
        !The VMS implementation of IOsCommand uses the 'spawn' facility to temporarily
        !generate a sub-process which then executes the required command. This can be slower
        !than other implementations since the time taken by VMS to spawn a sub-process can be
        !somewhat variable. If you simply want to execute a non-returning DCL command, try
        !using IOsExecute, which does not use the spawn facility.
        !INTERACTER Subroutine Reference Operating System Interface
        !4-65
    end subroutine

    subroutine IOsCommandSilent(COMMAND)
        character(len=*) COMMAND ! Command to pass to the operating system
        ! (maximum length 250 characters)
        ! Short-name : OSCMNS
        ! Executes the supplied string as a 'silent' operating system command. i.e. the command
        ! must be one which will send no output to the screen and which will not require any
        ! keyboard input. Unlike the equivalent IOsCommand, it does not clear the screen or
        ! prompt the user to press a key to continue, when the command has been executed. In all
        ! other respects this routine is equivalent to IOsCommand. If there is any possibility that
        ! a command will perform screen I/O, then IOsCommand should be used instead.
        !e.g. CALL IOsCommandSilent('MODE COM2:96,N,8,1 > NUL')
        !CALL IOsCommandSilent('ls -l > file.list')
        !Portability notes :
        !As for IOsCommand, plus :
        !MS Windows:
        !IOsCommandSilent is functionally identical to IOsCommand, except that the
        !command is issued in a hidden window. This can be beneficial with DOS commands
        !since it suppresses the console window (or full screen DOS session) which is otherwise
        !generated by IOsCommand.
        !Xlib:
        !IOsCommandSilent is functionally identical to IOsCommand. Neither routine
        !generates a key-press prompt or clears the screen.
    end subroutine

    subroutine IOsCopyFile(FROM,TO)
        character(len=*) FROM ! File name to copy from
        character(len=*) TO ! File/directory/drive to copy to
        ! Copy the file named in FROM to the file, directory or drive named in TO. Some
        ! operating systems may accept wildcards in OLDFIL (see the Portability notes). If the
        ! file cannot be copied, the InfoError(1) error flag is set. If FROM and TO specify
        ! the same file, error code 55 is set.
        !e.g. CHARACTER*5 ERRCOD
        !CALL IOsCopyFile('results.dat','results.bak')
        !IF (InfoError(1).EQ.13) THEN
        !CALL IntegerToString(InfoError(3),ERRCOD,'(I5)')
        !CALL IOutError('Failed to back up data file. Code='//ERRCOD)
        !ENDIF
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !ErrSameNames (55) : Source and target file names are the same
        !Portability notes :
        !DOS :
        !Files are copied using repeated binary reads/writes. Only a single file can be copied.
        !Operating System Interface INTERACTER Subroutine Reference
        !4-66
        !Windows :
        !The CopyFile API function is used. Only a single file can be copied. If TO specifies
        !a directory or drive, specify a trailing backslash.
        !Unix :
        !The C library system() function is used to execute a suitable cp command.
        !Wildcards are therefore allowed in the source file specification.
        !VMS :
        !The VMS run-time library routine LIB$SPAWN is used to execute a DCL COPY
        !command. Wildcards are therefore allowed in the source file specification.
    end subroutine

    subroutine IOsDate(IYEAR,MONTH,IDAY)
        integer IYEAR ! Year expressed as a four digit number
        integer MONTH ! Month (1-12)
        integer IDAY ! Day of month (1-31)
        ! Short-name : OSDATE
        ! Returns the system date in a machine independent 3-integer format. See also
        ! IOsTime.
        !e.g. CALL IOsDate(IY,MONTH,IDAY)
        !IF (MONTH.EQ.4.AND.IDAY.EQ.1) CALL IOutString('April Fool!')
    end subroutine

    subroutine IOsDeleteFile(FILNAM)
        character(len=*) FILNAM ! Name of file(s) to delete
        ! Short-name : OSDELF
        ! Deletes the named file(s). The file specification can include wildcards allowing
        ! multiple files to be deleted in a single operation. If a file cannot be deleted, the
        ! InfoError(1) error flag is set. If FILNAM is blank, IOsDeleteFile has no
        ! effect. See also IOsRenameFile.
        !e.g. CHARACTER*5 ERRCOD
        !CALL IOsDeleteFile('work*.dat')
        !IF (InfoError(1).EQ.13) THEN
        !CALL IntegerToString(InfoError(3),ERRCOD,'(I5)')
        !CALL IOutError('Failed to delete work files. Code='//ERRCOD)
        !ENDIF
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !Portability notes :
        !DOS :
        !The DOS find-first/find-next functions are used to expand the file-specification in
        !FILNAM. The DOS delete-file function is used to delete each matched file. Warning : A
        !side-effect of this function is that an open file can be deleted without an error.
        !Windows :
        !Files are deleted in a similar manner to the DOS version except that Win32 API
        !routines are used.
        !INTERACTER Subroutine Reference Operating System Interface
        !4-67
        !Unix :
        !The C library system() function is used to execute an rm command. Hence, the file
        !specification can include the usual regular expressions/wildcards accepted by the shell.
        !VMS :
        !The VMS run-time library routine LIB$DELETE_FILE is used to delete the specified
        !files. The file spec syntax is therefore the same as for the DCL DELETE command.
    end subroutine

    subroutine IOsDirChange(DIRECT)
        character(len=*) DIRECT ! Directory name
        ! Short-name : OSDIRC
        ! Changes the current directory. Equivalent to the operating system cd, set def, or
        ! dir command. The format of the directory name is dependent on the conventions used
        ! by the current operating system, except that the name .. (i.e. two full stops) is
        ! recognised on all systems as meaning the parent directory. This is a standard
        ! Unix/DOS/Windows concept which INTERACTER extends to VMS.
        ! Note that the change of directory may or may not persist after the program terminates
        ! depending on the current operating system. Under DOS the new directory becomes the
        ! current directory on program exit, for example.
        !e.g. CHARACTER*40 DIRNAM
        !CALL IOutStringXY(10,2,'Directory to move to (..=parent) : ')
        !CALL InString(DIRNAM,LENGTH)
        !IF (LENGTH.GT.0) CALL IOsDirChange(DIRNAM(:LENGTH))
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !Portability notes :
        !DOS and Windows :
        !If the directory name includes a drive specification (e.g. D:\BIN) then
        !IOsDirChange will change both directory and drive. IOsDirChange can also be
        !used to simply change drive, e.g. CALL IOsDirChange('D:'). If DIRECT
        !includes a floppy drive spec (e.g. A:\TMP), IOsDirChange first checks for a
        !readable disk in that drive. The current dir/drive is not changed if no disk is found.
    end subroutine

    subroutine IOsDirCount(DIRECT,MATCH,NUMFIL)
        character(len=*) DIRECT ! Directory name (current directory if blank)
        character(len=*) MATCH ! File matching pattern (all files if blank)
        integer NUMFIL ! Number of matching files (returned)
        ! Counts the number of files in the specified directory. The meaning of DIRECT and
        ! MATCH is identical to IOsDirList and IOsDirInfo. In fact, IOsDirCount can
        ! be called before these routines to determine how large their array arguments should be.
        ! This is useful in Fortran 90 programs, where arrays can be allocated dynamically.
        ! The total number of matching files is returned in NUMFIL.
        !e.g.
        !C How many data files in current directory ?
        !CALL IOsDirCount(' ','*.DAT',NDATAFILES)
        !Operating System Interface INTERACTER Subroutine Reference
        !4-68
        !Portability notes :
        !See IOsDirList
    end subroutine

    subroutine IOsDirDelete(DIRECT)
        character(len=*) DIRECT ! Directory name
        ! Delete the specified directory. Equivalent to the operating system rmdir command
        ! under DOS, Windows and Unix. The format of the directory name is dependent on the
        ! conventions used by the current operating system. The directory must be empty
        !e.g. CALL IOsDirDelete('C:\TEMP')
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !Portability notes :
        !VMS :
        !The directory name must be specified in the form of a file name with a .DIR; extension
        !(e.g. 'TEMP.DIR;')
    end subroutine

    subroutine IOsDirEntryType(TYPE)
        character(len=*) TYPE ! Type of directory entries to be returned by
        ! IOsDirList/Info :
        ! F : Files
        ! D : Directories
        ! Short-name : OSDIRT
        ! Specifies the type of directory entries to be returned by the IOsDirList and
        ! IOsDirInfo directory interrogation routines. By default, these routines return
        ! information about files only and not sub-directories. Call IOsDirEntryType with a
        ! 'D' argument to cause sub-directory information to be returned instead. Alternatively,'FD' causes both file and directory information to be returned in the same call.
        !e.g. PARAMETER (MAXDIR = 40)
        !CHARACTER*14 DIRNAM(MAXDIR)
        !C get a list of sub-directories in current directory
        !NUMDIR = MAXDIR
        !CALL IOsDirEntryType('D')
        !CALL IOsDirList(' ',' ',DIRNAM,NUMDIR)
        !INTERACTER Subroutine Reference Operating System Interface
        !4-69
    end subroutine

    subroutine IOsDirInfo(DIRECT,MATCH,FILNAM,NUMFIL,IFDATE,IFSIZE)
        character(len=*) DIRECT ! Directory name (current directory if blank)
        character(len=*) MATCH ! File matching pattern (all files if blank)
        integer NUMFIL ! On entry : Max number of files to read
        ! On exit : Actual number of files read
        ! (<= entry value)
        character(len=*) FILNAM(NUMFIL) ! Array to receive list of files
        integer IFDATE(NUMFIL) ! Array to receive date/time of last write access
        integer IFSIZE(NUMFIL) ! Array to receive file sizes in bytes
        ! Short-name : OSDIRI
        ! Reads file information from the specified directory. This routine is exactly equivalent to
        ! IOsDirList except that file date/time/size information is also returned.
        ! Date and time values are those when the file was created or last written to. They are
        ! returned as a single system dependent value for each file, which can then be converted
        ! to the date and/or time components as required using the routines IOsFileDate and
        ! IOsFileTime. The size of each file is returned in terms of bytes in IFSIZE.
        ! For further information, refer to IOsDirList.
        !e.g. PARAMETER (MAXFIL = 10)
        !CHARACTER*14 FILNAM(MAXFIL)
        !INTEGER IFDATE(MAXFIL),IFSIZE(MAXFIL)
        !NUMFIL = MAXFIL
        !CALL IOsDirInfo(' ','*.DAT',FILNAM,NUMFIL,IFDATE,IFSIZE)
        !IF (NUMFIL.EQ.0) THEN
        !CALL IOutError('No files matched')
        !ELSE
        !DO 100 IFILE = 1,NUMFIL
        !CALL IOsFileDate(IFDATE(IFILE),IYEAR,MONTH,IDAY)
        !IF (IYEAR.LT.1997) CALL UPDATE(FILNAM(IFILE))
        !100 CONTINUE
        !ENDIF
        !Portability notes :
        !See IOsDirList
        !Operating System Interface INTERACTER Subroutine Reference
        !4-70
        NUMFIL=0
    end subroutine

    subroutine IOsDirList(DIRECT,MATCH,FILNAM,NUMFIL)
        character(len=*) DIRECT ! Directory name (current directory if blank)
        character(len=*) MATCH ! File matching pattern (all files if blank)
        integer NUMFIL ! On entry : Max number of files to read
        ! On exit : Actual number of files read (<= entry value)
        character(len=*) FILNAM(NUMFIL)
        ! = Array to receive list of files
        ! Short-name : OSDIRL
        ! Reads a list of filenames from the specified directory, matching only those filenames
        ! which correspond to the supplied pattern. The filenames are returned in alphabetical
        ! order in FILNAM. No more than NUMFIL files are returned (error code 40 is returned
        ! if more than NUMFIL files are matched). The actual number of names placed in
        ! FILNAM is returned in NUMFIL. Be sure to pass NUMFIL as a variable, since this is
        ! an input/output argument.
        ! The format of the directory name and matching pattern are system dependent. Whatever
        ! format you normally use to display a directory listing from the operating system prompt
        ! should be equally acceptable here. The matching pattern can contain wildcards or
        ! regular expressions as are accepted by the current operating system. Valid 'match-many'
        ! and 'match-single' wildcard characters for the current operating system are available via
        ! InfoOpSystem. The default directory and matching pattern are 'current' and 'all files'
        ! respectively. The directory name is not returned as part of the filenames in FILNAM.
        ! By default this routine returns information about ordinary files in the specified
        ! directory, but not sub-directories of that directory. The type of directory entries to be
        ! returned by IOsDirList (i.e. Files and/or sub-directories) can be specified by
        ! calling IOsDirEntryType before IOsDirList.
        !e.g. CHARACTER*14 FILNAM(40),MATCH
        !NUMFIL = 40
        !CALL IOutStringXY(10,2,'Match files with : ')
        !MATCH = '*.dat'
        !CALL InStringDef(MATCH,LENGTH)
        !CALL IOsDirList(' ',MATCH(:LENGTH),FILNAM,NUMFIL)
        !IF (NUMFIL.EQ.0) THEN
        !CALL IOutError('No files matched')
        !ELSE
        !IFILE = IMenuScroll(FILNAM,NUMFIL,30,2,'Files',5,1,1)
        !OPEN(20,FILE=FILNAM(IFILE),STATUS='OLD')
        !ENDIF
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !ErrFileListSize (40) : Number of matched files exceeds NUMFIL.
        !Only the first NUMFIL matched names are returned
        !Portability notes :
        !DOS and Windows :
        !Directory names are the normal drive:\dir\dir format. A trailing '\' at the end of the
        !directory name is optional. The matching pattern can include * and/or ? wildcards.
        !e.g. CALL IOsDirList('\usr\data','a*.dat',FILNAM,NUMFIL)
        !CALL IOsDirList('a:','*.doc',FILNAM,NUMFIL)
        !CALL IOsDirList(' ','sales???.dat',FILNAM,NUMFIL)
        !INTERACTER Subroutine Reference Operating System Interface
        !4-71
        !Unix :
        !Directory names are the normal /dir/dir format. A trailing '/' at the end of the directory
        !name is optional. The matching pattern can include the usual * , ? , [] , etc. wildcards. A
        !temporary output file is used which is deleted automatically by IOsDirList on exit.
        !The temporary file name is of the form /tmp/filesNNNNN.tmp where NNNNN is a
        !5-digit user i.d. number. If problems are encountered, the name of this temporary file
        !can be specified explicitly via an environment variable called INTLIST.
        !e.g. CALL IOsDirList('/usr/data','a*.dat',FILNAM,NUMFIL)
        !CALL IOsDirList(' ','*.doc',FILNAM,NUMFIL)
        !CALL IOsDirList(' ','sales???.dat',FILNAM,NUMFIL)
        !VMS :
        !Directory names are the normal device:[dir.dir] format. The matching pattern can
        !include * and/or % wildcards.
        !e.g. CALL IOsDirList('[.USER.DATA]','A*.DAT',FILNAM,NUMFIL)
        !CALL IOsDirList('SYS$USER:[DATA]','*.DOC',FILNAM,NUMFIL)
        !CALL IOsDirList(' ','SALES%%%.DAT',FILNAM,NUMFIL)
    end subroutine

    subroutine IOsDirMake(DIRECT)
        character(len=*) DIRECT ! Directory name
        ! Short-name : OSDIRM
        ! Makes a new directory. Equivalent to the operating system mkdir or cre/dir
        ! command. The format of the directory name is dependent on the conventions used by
        ! the current operating system.
        !e.g. CHARACTER*40 DIRNAM
        !CALL IOutStringXY(10,2,'Directory to make : ')
        !CALL InString(DIRNAM,LENGTH)
        !IF (LENGTH.GT.0) CALL IOsDirMake(DIRNAM(:LENGTH))
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !Portability notes :
        !DOS :
        !If DIRECT includes a floppy drive spec (e.g. A:\TMP), IOsDirMake first checks for
        !a readable disk in that drive. A directory is not created if a disk is not found.
    end subroutine

    subroutine IOsDirName(DIRECT)
        character(len=*) DIRECT ! Directory name
        ! Short-name : OSDIRN
        ! Returns the name of the current directory. The format of the returned name will be
        ! operating system dependent.
        !e.g. CHARACTER*60 OLDDIR,NEWDIR
        !CALL IOsDirName(OLDDIR)
        !CALL IOutStringXY(2,2,'Old directory : ',OLDDIR)
        !NEWDIR = OLDDIR
        !CALL InStringXYDef(2,3,'New directory : ',0,NEWDIR,LENGTH)
        !IF (LENGTH.GT.0) CALL IOsDirChange(NEWDIR(:LENGTH))
        !Operating System Interface INTERACTER Subroutine Reference
        !4-72
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !Portability notes :
        !DOS and Windows :
        !The returned directory name includes the drive specification, e.g. C:\INT
    end subroutine

    subroutine IOsExecute(PRGNAM)
        character(len=*) PRGNAM ! Name of program to execute including any arguments
        ! (maximum length 250 characters)
        ! Short-name : OSEXEC
        ! Terminates the current program and executes a new one. The string PRGNAM can
        ! include any run-time command line arguments, following the program name. If the
        ! program to be executed uses INTERACTER, these command line arguments will be
        ! accessible using IOsArgument.
        ! To improve portability, it is recommended that full directory pathnames are not
        ! included within the program name, since these are the main source of machine
        ! dependency within filenames. IOsExecute will search the currently defined program
        ! execution search path, provided the current operating system supports that feature.
        ! Control should not return to the calling program, so IOsExecute will call
        ! IOsExitProgram with an exit code of 2 if this does occur. See chapter 16 of the
        ! User Guide for a list of INTERACTER exit codes. If the supplied program name is
        ! blank, an error code is set and program execution continues.
        !e.g. CHARACTER*20 PRGNAM
        !CALL IOutStringXY(1,1,'Enter program name : ')
        !CALL InString(PRGNAM,LENPRG)
        !IF (LENPRG.GT.0) CALL IOsExecute(PRGNAM(:LENPRG))
        !Errors :
        !ErrNoProgName (23) : No program name specified (i.e. PRGNAM is blank)
        !Portability notes :
        !DOS (Salford FTNxx) :
        !IOsExecute uses START_PROGRAM@. This function can only be used to run other
        !DBOS-based programs. Where supplied, command line arguments are passed using the
        !Salford SET_COMMAND_LINE@ routine, if this is available. Under older releases of
        !FTN77 which do not support this function, command line arguments are not passed.
        !The command execution path is searched for the specified program before calling
        !START_PROGRAM@. If no extension is supplied, .EXE is appended.
        !DOS (non-Salford compilers) :
        !Chaining is not supported under non-Salford DOS compilers.
        !Windows :
        !The specified program name is passed to the Windows API routine WinExec.
        !Typically this would be used to run another Windows program.
        !INTERACTER Subroutine Reference Operating System Interface
        !4-73
        !Unix :
        !If the full pathname is not specified, the program will need to lie in the current
        !execution path as defined in the shell PATH variable. For portability, it is recommended
        !that the full pathname is omitted.
        !VMS :
        !The program name is passed direct to DCL prefixed only by a $, assuming that a 'RUN
        ![directory_name]program_name' DCL symbol has been set up for the required
        !program. Alternatively, the program name within PRGNAM can be preceded by the
        !command RUN, but this obviously makes your code VMS specific. In general, it is
        !strongly recommended that you set up DCL symbols to run your programs, since this
        !has the added advantage that command line arguments can be detected using
        !IOsArgument. It has the further advantage that a VMS directory path name can also
        !be omitted from the program name, leaving a potentially machine independent program
        !name in your call to IOsExecute.
    end subroutine

    subroutine IOsExitProgram(ERRMES,IEXCOD)
        character(len=*) ERRMES ! Error message to display to the user.
        ! (if blank, error message display is suppressed)
        integer IEXCOD ! Exit code to return to operating system
        ! Short-name : OSEXIT
        ! Aborts the current program, in a controlled manner. This routine is designed to be used
        ! when an unexpected fatal error is encountered. It first tidies up the screen and keyboard
        ! handling, then exits from the program. An exit code is returned to the operating system
        ! and the following optional message is displayed on the screen :
        ! ** Abnormal exit
        ! ** Exit code : nn
        ! ** your-error-message
        ! The actual exit code and message will depend on what was passed in IERCOD and
        ! ERRMES. If you do not want a message to be displayed, but prefer to check the returned
        ! exit code within an operating system command procedure, leave ERRMES blank. The
        ! above error message will then be suppressed. See the Portability notes for more
        ! information on checking program exit codes.
        ! In general, exit codes greater than 20 are recommended. Codes 1-20 are reserved for
        ! use by INTERACTER. See chapter 16 of the User Guide for a list of the possible exit
        ! codes which INTERACTER can generate. These exit codes should not be confused with
        ! the error codes which are documented in the same chapter. INTERACTER will virtually
        ! always set an error code in preference to calling IOsExitProgram, as this enables
        ! the calling application to decide what action is appropriate.
        ! If you wish to leave a program immediately without issuing either an error message or a
        ! non-zero exit code, simply supply a blank error message and an IEXCOD value of zero.
        !e.g. CALL IGrCharSet('chars.chr')
        !IF (InfoError(1).EQ.1)
        !1 CALL IOsExitProgram('Cannot open character set file',21)
        !Operating System Interface INTERACTER Subroutine Reference
        !4-74
        !Portability notes :
        !DOS :
        !In a DOS batch file, the exit code can be checked using IF ERRORLEVEL , e.g.
        !INTPROG
        !IF ERRORLEVEL 21 GOTO USERERR
        !IF ERRORLEVEL 1 GOTO INTERR
        !GOTO EXIT
        !:USERERR
        !ECHO User programmed abort.
        !GOTO EXIT
        !:INTERR
        !ECHO INTERACTER generated abort
        !:EXIT
        !DOS (Salford FTNxx) :
        !The behaviour of IOsExitProgram under Salford's compilers depends on the setting
        !of the DBOS QUIT_ON_ERROR flag. By default this flag is set and causes any nonzero
        !exit code to simulate a Ctrl/Break. In this state, batch file ERRORLEVEL tests
        !cannot be used. The more useful state, where exit codes are returned to DOS in the
        !conventional manner, can be selected using DBOS_RESET QUIT_ON_ERROR.
        !DOS (Microsoft Fortran Powerstation) :
        !The value of IEXCOD should not exceed 30 under the Microsoft 32-bit Fortran
        !compiler. The standard DOS exit function (4Ch) which is used by other DOS versions
        !of INTERACTER does not work under Microsoft's compiler. This implementation of
        !IOsExitProgram therefore has to use a series of hardcoded STOP statements
        !instead, hence the exit code upper limit .
        !Windows :
        !The 'Abnormal exit' message is displayed in a standard message box.
        !Unix :
        !The special shell variables $? (Bourne shell) or $status (C shell) will contain the
        !program exit code. It should be zero on normal termination.
        !VMS :
        !The VMS version of INTERACTER sets a DCL variable called INTEXIT to the value
        !of the exit code. It is recommended that this be initialised in your controlling DCL (to a
        !blank or 0) before running your program, if you wish to test the return code.
        !INTERACTER will not set this variable on normal exit.
    end subroutine

    subroutine IOsFileDate(IFDATE,IYEAR,MONTH,IDAY)
        integer IFDATE ! File date/time value
        integer IYEAR ! Returned year (4 digit value, e.g. 1998)
        integer MONTH != Returned month (1-12)
        integer IDAY ! Returned day (1-31)
        !Short-name : OSFDAT
        !Converts a file date/time value returned by IOsDirInfo to its component year,month and day elements. The IFDATE value should have been returned by
        !IOsDirInfo.
        !If a date is required in string format, the returned integer values can be converted using
        !the routines in the CH group.
        !INTERACTER Subroutine Reference Operating System Interface
        !4-75
        !e.g. PARAMETER (MAXFIL = 10)
        !CHARACTER*14 FILNAM(MAXFIL)
        !INTEGER IFDATE(MAXFIL),IFSIZE(MAXFIL)
        !NUMFIL = MAXFIL
        !CALL IOsDirInfo(' ','*.DAT',FILNAM,NUMFIL,IFDATE,IFSIZE)
        !DO 100 IFILE = 1,MAX0(NUMFIL,20)
        !CALL IOsFileDate(IFDATE(IFILE),IYEAR,MONTH,IDAY)
        !CALL IOutStringXY(1 ,IFILE,FILNAM(IFILE)//'- / / ')
        !CALL IOutIntegerXY(16,IFILE,IDAY ,2)
        !CALL IOutIntegerXY(19,IFILE,MONTH,2)
        !CALL IOutIntegerXY(22,IFILE,IYEAR,2)
        !100 CONTINUE
    end subroutine

    subroutine IOsFileTime(IFDATE,IHOUR,MINUTE,ISECND)
        integer IFDATE ! File date/time value
        integer IHOUR ! Returned hour (0-23)
        integer MINUTE ! Returned minute (0-59)
        integer ISECND ! Returned second (0-59)
        ! Short-name : OSFTIM
        ! Converts a file date/time value returned by IOsDirInfo to its component hours,minutes and seconds elements. The IFDATE value should have been returned by
        ! IOsDirInfo.
        ! Due to the way time information is held on various operating systems, the accuracy of
        ! the seconds value cannot be 100% guaranteed (see Portability notes) but will be
        ! perfectly acceptable for the vast majority of applications.
        ! If a time is required in string format, the returned integer values can be converted using
        ! the routines in the CH group.
        !e.g. PARAMETER (MAXFIL = 10)
        !CHARACTER*14 FILNAM(MAXFIL)
        !INTEGER IFDATE(MAXFIL),IFSIZE(MAXFIL)
        !NUMFIL = MAXFIL
        !CALL IOsDirInfo(' ','*.DAT',FILNAM,NUMFIL,IFDATE,IFSIZE)
        !DO 100 IFILE = 1,MAX0(NUMFIL,20)
        !CALL IOsFileTime(IFDATE(IFILE),IYEAR,MONTH,IDAY)
        !CALL IOutStringXY(1 ,IFILE,FILNAM(IFILE)//'- : : ')
        !CALL IOutIntegerXY(16,IFILE,IHOUR ,2)
        !CALL IOutIntegerXY(19,IFILE,MINUTE,2)
        !CALL IOutIntegerXY(22,IFILE,ISECND,2)
        !100 CONTINUE
        !Portability notes :
        !DOS and Windows :
        !Times are accurate to the nearest two seconds.
    end subroutine

    subroutine IOsRenameFile(OLDFIL,NEWFIL)
        character(len=*) OLDFIL ! Old file name
        character(len=*) NEWFIL ! New file name
        ! Short-name : OSRENF
        ! Rename a file from the old name specified in OLDFIL to the new name specified in
        ! NEWFIL. If the file cannot be renamed, the InfoError(1) error flag is set. Some
        ! operating systems may accept wildcards in OLDFIL and/or a directory name in
        ! NEWFIL, but neither of these features should be relied upon if portability is required.
        ! Operating System Interface INTERACTER Subroutine Reference
        ! 4-76
        ! If OLDFIL or NEWFIL are blank, IOsRenameFile has no effect. See also
        ! IOsDeleteFile.
        !e.g. CHARACTER*5 ERRCOD
        !:
        !CALL IOsRenameFile('data.dat','result.dat')
        !IF (InfoError(1).EQ.13) THEN
        !CALL IntegerToString(InfoError(3),ERRCOD,'(I5)')
        !CALL IOutError('Failed to rename data file. Code='//ERRCOD)
        !ENDIF
        !Errors :
        !ErrOSCommand (13) : An operating system error occurred.
        !InfoError(3) gives actual error
        !Portability notes :
        !DOS :
        !The DOS rename-file function (56h) is used. This can rename a single file and/or move
        !it to another directory on the same disk. Directories can also be renamed.
        !Windows :
        !A Win32 library routine is used to rename the file. This can rename a single file and/or
        !move it to another directory on the same disk.
        !Unix :
        !The C library system() function is used to execute a suitable mv command.
        !VMS :
        !The VMS run-time library routine LIB$RENAME_FILE is used to rename/move the
        !specified file(s). The file syntax is therefore the same as the DCL RENAME command.
    end subroutine

    subroutine IOsTime(IHOUR,MINUTE,ISECND)
        integer IHOUR ! Hours (0-23)
        integer MINUTE ! Minutes (0-59)
        integer ISECND ! Seconds (0-59)
        ! Short-name : OSTIME
        ! Returns the current system time in a machine independent 3-integer format. See also
        ! IOsDate.
        !e.g. CALL IOsTime(IHOUR,MINUTE,ISECND)
        !IF (IHOUR.EQ.12.AND.MINUTE.EQ.0.AND.ISECND.EQ.0)
        !1 CALL IOutStringXY(10,5,'Noon !')
    end subroutine

    subroutine IOsVariable(VNAME,VALUE)
        character(len=*) VNAME ! Name of variable to interrogate
        character(len=*) VALUE ! Returned value (blank if not found)
        ! Short-name : OSVAR
        ! Returns the value of the specified o.s. variable. On different operating systems these
        ! variables are variously known as environment variables, symbols or aliases. In all cases
        ! they provide a useful method of passing system dependent values, such as filenames, to
        ! a program without the need to use a data file or command line arguments.
        ! If the specified variable name has not been initialised or has no value, VALUE will be
        ! returned blank.
        ! INTERACTER Subroutine Reference Operating System Interface
        ! 4-77
        ! In general it is a good idea to stick to upper case for operating system variables. Some
        ! operating systems are case sensitive, but others are not. IOsVariable performs no
        ! case translation, so it pays to be consistent.
        !e.g. CHARACTER*80 FILNAM
        !:
        !CALL IOsVariable('DEFDATA',FILNAM)
        !IF (IActualLength(FILNAM).GT.0) THEN
        !OPEN(20,FILE=FILNAM,STATUS='OLD')
        !ELSE
        !OPEN(20,FILE='default',STATUS='OLD')
        !ENDIF
        !Portability notes :
        !DOS and Windows :
        !IOsVariable returns environment variables as assigned using the SET command
        !(or Control Panel, under Windows NT/2000). The operating system converts all
        !variable names to upper case, so the supplied variable name VNAME must also be in
        !upper case. When defining environment variables using SET, avoid trailing spaces
        !between the variable name and the '=' since these will be treated as part of the variable
        !name. IOsVariable strips trailing blanks from the supplied variable name.
        !Under Windows, an error code will be set if the return buffer (VALUE) is too small.
        !VALUE is returned blank in this case.
        !Unix :
        !If the C shell (csh) is in use it is important to distinguish between environment
        !variables and operating system variables. IOsVariable returns environment
        !variables, which are assigned in the C shell using the setenv command. If the Bourne
        !shell (sh) is being used, environment variables are assigned using commands of the
        !form :
        !VARNAME=string ; export VARNAME
        !VMS :
        !IOsVariable can return the value of either a DCL symbol or a logical. By default,IOsVariable searches for a DCL symbol which matches the specified name. If
        !none is found, a logical name is searched for. If a matching logical name is found, one
        !level of translation is performed. If neither a symbol or logical is identified, VALUE is
        !returned blank.
        !Errors :
        !ErrEnvVarBuffer (65) : Return variable too small to receive string (Win32)
    end subroutine

    subroutine IOsWait(NCSECS)
        integer NCSECS ! Number of centiseconds to wait for
        ! Short-name : OSWAIT
        ! Halts program execution, temporarily, for the specified length of time. Where possible,the program is put into a 'hibernating' state where it effectively consumes no resources.
        !e.g. CALL IScreenLoadImage('screen1.scr')
        !C wait for 5 seconds
        !CALL IOsWait(500)
        !CALL IScreenLoadImage('screen2.scr')
        !CALL IOsWait(500)
        !CALL IScreenLoadImage('screen3.scr')
        !Operating System Interface INTERACTER Subroutine Reference
        !4-78
        !Portability notes :
        !DOS :
        !System resources continue to be consumed by IOsWait under DOS. This will only
        !affect INTERACTER programs running under multi-tasking environments such as
        !Windows. An AT BIOS delay function is used to suspend program execution.
        !Windows :
        !A timer is used to ensure that the application does nothing till the specified time has
        !elapsed whilst still allowing other Windows processes to continue unhindered. Under
        !Windows 3.1x/Win32s the timer is limited to a maximum of about 65 seconds. The
        !limit on a true Win32 system is much higher (more than 49 days !).
        !Unix :
        !The minimum time delay supported under Unix depends on the selected display type.
        !Under the Xlib driver, the minimum delay is 1 centisecond. On other display types
        !(terminals and terminal emulators) the minimum delay is one second. All delays greater
        !than one second are rounded up to the nearest whole second regardless of display type.
        !INTERACTER Subroutine Reference Binary File Handling
        !4-79
        !4.4 Group BF : Binary File Handling
        !The routines in this group provide low level file i/o routines which treat a file as a
        !stream of binary information. They provide a powerful alternative to Fortran's more
        !limited i/o capabilities, which do not include 'stream' i/o as standard. The routines in
        !the BF group simply see a file as a series of bytes with no inherent file or data structure
        !(unlike the implementation dependent file structures enforced by standard Fortran i/o).
        !Binary files should be opened via IFileOpen which returns an integer file handle.
        !This handle is then specified in all subsequent read/write/seek/close calls. Note : This is
        !not a Fortran unit number.
        !Data is read from a file using IFileRead or IFileReadChar. The former is for
        !use with non-CHARACTER data types. Similarly, IFileWrite and
        !IFileWriteChar are used to write non-character and character data respectively.
        !Any position in a binary file can be accessed randomly via IFileSeek. The file
        !pointer can be set for both read and write operations. It can also be interrogated.
        !When binary i/o operations on a file are complete it should be closed via
        !IFileClose.
        !These routines should be used with care, since they simply move the specified number
        !of bytes to/from a file from/to a specified memory address. In particular, note that the
        !read/write routines transfer a specified number of bytes, so it's important to consider
        !how many bytes are required to store particular data types. Provided this is clearly
        !understood, these routines represent a very powerful low level facility. They are
        !particularly useful for manipulating bitmap graphics files, database files, etc.
        !In most cases errors are reported by returning a value of -1 for one of the arguments. In
        !this case InfoError(1) will return a value of 1 or 2 and InfoError(2) will
        !return an operating system dependent error code. The latter allows the precise cause to
        !be diagnosed, if required. These error codes follow the standard numbering system for
        !the current operating system (i.e. they are returned from the operating system without
        !further interpretation by the BF group routines).
!        type(Fields), pointer :: this
!        this => this_
!        call processEvents(this%canvasWindow)
    end subroutine

    subroutine IFileClose(IHANDLE)
        integer IHANDLE ! File handle from IFileOpen
        ! Closes a file opened previously by IFileOpen.
        !e.g. See IFileOpen
        !Binary File Handling INTERACTER Subroutine Reference
        !4-80
    end subroutine

    subroutine IFileOpen(NAME,IACCESS,IHANDLE)
        character(len=*) NAME ! File name
        integer IACCESS ! How to access the file
        ! ReadOnly (0) : Read-only
        ! WriteOnly (1) : Write-only
        ! ReadWrite (2) : Read/write
        integer IHANDLE ! Returned file handle (-1 if open fails)
        ! Opens a file for binary i/o. Opening a file in write mode will cause all information in
        ! the file to be lost. Read and read/write modes preserve the existing contents. This
        ! routine must be called for a given file, before other routines in this group can be called.
        ! The returned file handle must be stored and passed to other BF group routines.
        !In theory, a name of a device can be specified in NAME (e.g. CON under DOS).
        !However, the BF group routines provide no special controls over device i/o (e.g.
        !selection of 'raw' or 'cooked' modes) so in general, we don't guarantee their suitability
        !for this purpose.
        !Opening a read-only file (i.e. one which has a protection level or attribute of 'read-only'
        !at the operating system level) in write-only or read/write mode will not generate an
        !immediate error. Instead, an error will be returned the first time a write operation is
        !attempted on the file.
        !If the open fails, IHANDLE returns -1 and InfoError(1) will be set to 1.
        !InfoError(2) will return an implementation-dependent i/o system error code in this
        !case.
        !e.g. PARAMETER (NVAL = 50)
        !INTEGER IVAL(NVAL)
        !CHARACTER*7 COMMENT
        !C Open file in read/write mode
        !CALL IFileOpen('temp.dat',2,IHANDLE)
        !IF (IHANDLE.EQ.-1)
        !1 CALL IOsExitProgram('Cannot open temp.dat',20)
        !C Write mixture of integer and character data to file
        !CALL IFileWrite(IHANDLE,IVAL,NVAL*4,NWRITTEN)
        !IF (NWRITTEN.LT.NVAL*4) GOTO 1000
        !CALL IFileWriteChar(IHANDLE,'comment',7,NWRITTEN)
        !IF (NWRITTEN.LT.7) GOTO 1000
        !:
        !C Re-position file pointer to start of file
        !CALL IFileSeek(IHANDLE,0,0)
        !C Read same data back in
        !CALL IFileRead(IHANDLE,IVAL,NVAL*4,NREAD)
        !IF (NWRITTEN.LT.NVAL*4) GOTO 2000
        !CALL IFileReadChar(IHANDLE,COMMENT,7,NREAD)
        !IF (NWRITTEN.LT.7) GOTO 2000
        !CALL IFileClose(IHANDLE)
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !INTERACTER Subroutine Reference Binary File Handling
        !4-81
    end subroutine

    subroutine IFileRead(IHANDLE,BUFFER,NTOREAD,NREAD)
        integer IHANDLE ! File handle from IFileOpen
        integer BUFFER(:) ! Non-CHARACTER buffer to receive data
        integer NTOREAD ! Number of bytes to be read
        integer NREAD ! Number of bytes actually read
        ! Reads NTOREAD bytes into the variable/array specified by BUFFER which can be
        ! INTEGER, REAL, DOUBLE PRECISION or LOGICAL. The actual number of bytes
        ! read is returned in NREAD. If this is not the same as NTOREAD, this usually means endof-
        ! file has been encountered.
        ! If an error occurs, NREAD is returned as -1 and InfoError(1) returns 2.
        ! InfoError(2) returns an implementation dependent i/o error code in this case.
        !e.g. See IFileOpen
        !Errors :
        !ErrFileIO (2) : Error reading from file
    end subroutine

    subroutine IFileReadChar(IHANDLE,CBUFFER,NTOREAD,NREAD)
        integer IHANDLE ! File handle from IFileOpen
        character(len=*) CBUFFER ! Buffer to receive data
        integer NTOREAD ! Number of bytes to be read
        integer NREAD ! Number of bytes actually read
        ! Reads NTOREAD bytes into the CHARACTER variable/array specified by CBUFFER.
        ! Otherwise, behaviour is the same as IFileRead.
        !e.g. See IFileOpen
        !Errors :
        !ErrFileIO (2) : Error reading from file
    end subroutine

    subroutine IFileSeek(IHANDLE,IPOS,METHOD)
        integer IHANDLE ! File handle from IFileOpen
        integer IPOS ! Entry : Required position in bytes (0=start)
        ! Exit : Updated position in bytes
        integer METHOD ! How to interpret IPOS
        ! FromStart (0) : Relative to start of file
        ! FromCurrent (1) : Relative to current pos
        ! FromEnd (2) : Relative to end of file
        ! Updates the file pointer. Initially this points to the start of the file and is updated by
        !read/write requests. e.g. writing four bytes of data immediately after opening the file
        !would move the file pointer forward to position 4. This routine allows the pointer to be
        !updated without any data transfer taking place.
        !This routine can also be used to interrogate the size of a file. Simply pass METHOD=2
        !and IPOS=0. The returned IPOS value will be the file size in bytes.
        !A seek past the end of the file may not generate an error until the next i/o operation, or
        !it may not generate an error at all. This is operating system dependent.
        !Binary File Handling INTERACTER Subroutine Reference
        !4-82
        !IPOS returns -1 if an error occurred. InfoError(1) returns 2 in this case and
        !InfoError(2) returns an implementation dependent i/o error code.
        !e.g. See IFileOpen
        !Errors :
        !ErrFileIO (2) : Seek error
    end subroutine

    subroutine IFileWrite(IHANDLE,BUFFER,NTOWRITE,NWRITTEN)
        integer IHANDLE ! File handle from IFileOpen
        integer BUFFER(:) ! Non-CHARACTER buffer holding data to write
        integer NTOWRITE ! Number of bytes to be written
        integer NWRITTEN ! Number of bytes actually written
        ! Writes NTOWRITE bytes from the variable/array specified by BUFFER which can be
        ! INTEGER, REAL, DOUBLE PRECISION or LOGICAL. The actual number of bytes
        ! written is returned in NWRITTEN.
        !If NWRITTEN<NTOWRITE, this usually indicates an error of some sort, e.g. disk full. If
        !the operating system specifically reports that an error occurred, NWRITTEN is returned
        !as -1 and InfoError(1) will return 2. InfoError(2) returns an implementation
        !dependent i/o error code in this case.
        !e.g. See IFileOpen
        !Errors :
        !ErrFileIO (2) : Error writing to file
    end subroutine

    subroutine IFileWriteChar(IHANDLE,CBUFFER,NTOWRITE,NWRITTEN)
        integer IHANDLE ! File handle from IFileOpen
        character(len=*) CBUFFER ! Buffer holding data to write
        integer NTOWRITE ! Number of bytes to be written
        integer NWRITTEN ! Number of bytes actually written
        ! Write NTOWRITE bytes from the CHARACTER variable/array specified by CBUFFER.
        ! Otherwise, behaviour is the same as IFileWrite.
        !e.g. See IFileOpen
        !Errors :
        !ErrFileIO (2) : Error writing to file
        !INTERACTER Subroutine Reference Hardware Identification
        !4-83
        !4.5 Group HW : Hardware Identification
        !These routines are used to identify the display, printer, plotter, mouse and digitising
        !tablet hardware being used. In general, there should be no need to call these routines
        !directly. They are all called automatically by IScreenOpen, so the information they
        !require is better supplied via the initialisation file. Alternatively, hardware types can be
        !identified interactively via the IdDigitiser/IdDisplay/etc. routines in the II
        !group.
    end subroutine

    subroutine IDigitiser(IDIGTR)
        integer IDIGTR ! Digitiser number (see chapter 13 in the User Guide)
        ! Short-name : DIGTSR
        ! Defines the type of digitising tablet being used.
        ! This routine is always called by the start up routine IScreenOpen, either with a
        ! parameter of zero or a value specified in the initialisation file using the DIGITISER
        ! keyword. If the digitiser type is not defined explicitly at start up, IDigitiser can be
        ! called directly, later in your program to ensure that INTERACTER operates correctly
        ! with the connected tablet. More usefully, the alternative routine IdDigitiser can be
        ! called to interactively identify the digitiser type. That routine prompts the user to
        ! identify the connected digitiser and calls IDigitiser itself.
        ! If a value other than those listed in chapter 13 of the User Guide is specified,INTERACTER defaults to a type 1 digitiser, i.e. 'none connected'. However, there will
        ! normally be little advantage in doing this since IScreenOpen will already have
        ! called IDigitiser with at least a zero parameter.
        ! Whatever method of digitiser identification is used, you can interrogate the currently
        ! identified hardware type using InfoHardware.
        !e.g. CALL IScreenOpen(' ','G',800,600,16)
        !C select a Summagraphics Bit Pad One
        !CALL IDigitiser(2)
        !Portability notes :
        !See chapter 14 of the User Guide
    end subroutine

    subroutine IDisplay(IDISPL)
        integer IDISPL ! Display type number (see chapter 13 of the User Guide)
        ! Short-name : DISPLY
        ! Defines the display hardware, and clears the screen. This ensures that INTERACTER
        ! knows precisely what screen facilities are available and what is on the screen.
        ! This routine is always called by the start up routine IScreenOpen, either with a
        ! parameter of zero or with a user supplied display number (specified via the INTTERM
        ! o.s. variable or the initialisation file DISPLAY keyword). If you can't specify the
        ! hardware at start up, IDisplay can be called directly, later in your program to ensure
        ! that INTERACTER takes best advantage of the screen hardware being used. More
        ! usefully, the alternative routine IdDisplay can be called to interactively identify the
        ! display type. That routine prompts the user to identify the current display and calls
        ! IDisplay itself.
        ! Hardware Identification INTERACTER Subroutine Reference
        ! 4-84
        !If an invalid display number is specified (e.g. zero), IDisplay attempts to identify the
        !display being used or selects a 'lowest common denominator' default value. However,there will normally be little advantage in doing this since IScreenOpen will already
        !have called IDisplay with at least a zero parameter.
        !Whatever method of display identification is used, you can interrogate the currently
        !identified hardware type using InfoHardware(14).
        !e.g. CALL IScreenOpen(' ','T',80,25,16)
        !C this program requires an IBM PC with VGA/colour
        !CALL IDisplay(10)
        !Portability notes :
        !See chapter 13 of the User Guide
    end subroutine

    subroutine IMouse(IMOUS)
        integer IMOUS ! Mouse number (see chapter 13 of the User Guide)
        ! Short-name : MOUSE
        ! Defines the type of mouse to be used. A value of 1 for IMOUS indicates that no mouse
        ! is fitted (or is to be disabled), in which case the keyboard will always be used.
        ! This routine is always called by the start up routine IScreenOpen, either with a
        ! parameter of zero or a value specified in the initialisation file using the MOUSE
        ! keyword. If the mouse type is not defined explicitly at start up, IMouse can be called
        ! directly, later in your program to ensure that INTERACTER takes best advantage of the
        ! mouse type being used. More usefully, the alternative routine IdMouse can be called
        ! to interactively identify the mouse type. That routine prompts the user to identify the
        ! required mouse and calls IMouse itself.
        !If a value other than those listed in chapter 13 of the User Guide is specified (e.g.
        !zero, as may be the case when IScreenOpen calls IMouse), INTERACTER will
        !select its own value. See the Portability notes for the precise action.
        !Whatever method of mouse identification is used, you can interrogate the currently
        !identified hardware type using InfoHardware(13).
        !e.g. CALL IScreenOpen(' ','P',640,480,16)
        !C this program requires at least a two-button mouse
        !IF (InfoHardware(13).EQ.1) THEN
        !CALL IOutCentre(2,'This program requires a mouse')
        !IMOUS = IMenuTwo('Two button','Three button',25,4,' ',0,1)
        !CALL IMouse(1+IMOUS)
        !ENDIF
        !Portability notes :
        !DOS :
        !IMouse always checks whether the mouse driver has been installed and whether the
        !mouse hardware is responding. If no mouse is found, the mouse type is forced to 1,regardless of the value of IMOUS. If a mouse is found, action depends on IMOUS :
        !IMOUS = 1 : Mouse will be ignored
        != 2/3 : 2 or 3 button mouse, as specified
        != any other value : 2 or 3 button mouse according to information
        !returned by mouse driver software
        !INTERACTER Subroutine Reference Hardware Identification
        !4-85
        !Terminals :
        !Since most displays in the serial terminal/workstation library do not support a mouse,an IMOUS value of 0 causes IMouse to assume mouse type 1.
    end subroutine

    subroutine IPlotter(IPLOTR)
        integer IPLOTR ! Plotter number (see chapter 13 of the User Guide)
        ! Short-name : PLOTTR
        ! Defines the type of plotter to be used by the HP-GL graphics hardcopy driver.
        ! This routine is always called by the start up routine IScreenOpen, either with a
        ! parameter of zero or a value specified in the initialisation file using the PLOTTER
        ! keyword. If the plotter type is not defined explicitly at start up, IPlotter can be
        ! called directly, later in your program to ensure that INTERACTER takes best advantage
        ! of the plotter hardware being used. More usefully, the alternative routine IdPlotter
        ! can be called to interactively identify the plotter type. That routine prompts the user to
        ! identify the required plotter and calls IPlotter itself.
        ! If a value other than those listed in chapter 13 of the User Guide is specified,INTERACTER defaults to a generic 4-pen HP-GL plotter. However, there will normally
        ! be little advantage in doing this since IScreenOpen will already have called
        ! IPlotter with at least a zero parameter.
        ! In general, calls to IPlotter should precede any calls to IGrHardCopySelect
        ! or IGrHardCopy, since these calls may set parameters which depend on the currently
        ! selected plotter type. If IPlotter is called, it is advisable to follow it with a call to
        ! IGrHardCopySelect to reinitialise the HP-GL hardcopy driver.
        ! Whatever method of plotter identification is used, you can interrogate the currently
        ! identified hardware type using InfoHardware(12).
        !e.g. CALL IScreenOpen(' ','H',1000,1000,16)
        !C this program requires a 6 pen A4 plotter
        !CALL IPlotter(3)
    end subroutine

    subroutine IPrinter(IPRINT)
        integer IPRINT ! Printer number (see chapter 13 of the User Guide)
        ! Short-name : PRINTR
        !Defines the type of printer to be used by the IScreenDump routine (e.g. 2 for IBM
        !Graphics Printer) and the raster graphics hardcopy driver.
        !This routine is always called by the start up routine IScreenOpen, either with a
        !parameter of zero or a value specified in the initialisation file using the PRINTER
        !keyword. If the printer type is not defined explicitly at start up, IPrinter can be
        !called directly, later in your program, to ensure that INTERACTER takes best advantage
        !of the printer hardware being used. More usefully, the alternative routine IdPrinter
        !can be called to interactively identify the printer type. That routine prompts the user to
        !identify the required printer and calls IPrinter itself.
        !If a value other than those listed in chapter 13 of the User Guide is specified,INTERACTER defaults to a LaserJet III. However, there will normally be little
        !advantage in doing this since IScreenOpen will already have called IPrinter
        !with at least a zero parameter.
        !Hardware Identification INTERACTER Subroutine Reference
        !4-86
        !In general, calls to IPrinter should precede any calls to IGrHardCopySelect or
        !IGrHardCopy, since these calls may set parameters which depend on the currently
        !selected printer type.
        !Whatever method of printer identification is used, you can interrogate the currently
        !identified hardware type using InfoHardware(11).
        !e.g. CALL IScreenOpen(' ','P',640,480,16)
        !C this program requires an IBM graphics printer
        !CALL IPrinter(2)
    end subroutine

    subroutine IPrinter2(IPRINT)
        integer IPRINT ! HP-GL/2 device number (see chapter 13 of the User Guide)
        ! Defines the type of printer/plotter to be used by the HP-GL/2 graphics hardcopy driver.
        ! This routine is always called by the start up routine IScreenOpen, either with a
        ! parameter of zero or a value specified in the initialisation file using the HPGL2
        ! keyword. In particular, if the printer type (as set via IPrinter) defines an HP-GL/2
        ! compatible printer this will also set the HP-GL/2 device type without needing to call
        ! this routine Alternatively IdPrinter2 can be called to interactively identify the HPGL/
        ! 2 device type. That routine prompts the user to identify the required device and
        ! calls IPrinter2 itself.
        ! If a value other than those listed in chapter 13 of the User Guide is specified, a
        ! LaserJet III is selected by default. However, there will normally be little advantage in
        ! doing this since IScreenOpen will already have called IPrinter2 with at least a
        ! zero parameter.
        ! In general, calls to IPrinter2 should precede any calls to IGrHardCopySelect
        ! or IGrHardCopy, since these may set parameters which depend on the currently
        ! selected plotter type. If IPrinter2 is called, it is advisable to follow it with a call to
        ! IGrHardCopySelect to reinitialise the HP-GL/2 hardcopy driver.
        ! Whatever method of plotter identification is used, you can interrogate the currently
        ! identified hardware type using InfoHardware(15).
        !e.g. CALL IScreenOpen(' ','H',1000,1000,16)
        !C this program requires a LaserJet 4/5
        !CALL IPrinter2(3)
        !INTERACTER Subroutine Reference Debugging
        !4-87
        !4.6 Group DG : Debugging
        !These routines provide basic debugging facilities.
        !IDebugLevel determines the error reporting level.
        !IDebug, IDebugInteger, IDebugReal and IDebugDouble write values to a
        !diagnostics file. By default, the diagnostics file is called debug. In the unlikely event
        !that opening of this file fails, alternative names of debug.txt or debug.dat are
        !used.
    end subroutine

    subroutine IDebug(STRING)
        character(len=*) STRING ! String to write to diagnostic file
        ! Writes the specified string to the diagnostic file. This file is also written to by the
        ! complementary numeric diagnostic routines IDebugInteger, IDebugReal and
        ! IDebugDouble. Using these routines has various advantages over using conventional
        ! Fortran WRITE statements for debugging/diagnostics:
        !   The debug file is created automatically in the current directory when any of the
        ! IDebugXXXX routines is first called. This allows debug statements to be added as
        ! needed without the need to introduce an explicit OPEN statement. Any existing
        ! debug file will be overwritten.
        !   Access to the diagnostics file does not use a Fortran unit number, avoiding conflicts
        ! with unit numbers used by the application program.
        !   The output file is flushed automatically on each write, so all diagnostics will be
        ! available in the event of a program crash.
        !e.g. CALL IDebug('About to load form')
        !CALL IFormLoad('w','FORM.IFD',lfnerr)
        !CALL IDebugInteger('Error',InfoError(1))
        !CALL IFormEdit(ifinit,ifexit)
        !CALL IFormGetReal(IDREAL1,RVAL)
        !CALL IDebugReal('Retrieved RVAL',RVAL)
        !CALL IFormGetDouble(IDDOUBLE1,DVAL)
        !CALL IDebugDouble('Retrieved DVAL',DVAL)
    end subroutine

    subroutine IDebugDouble(STRING,DVAL,FORMAT)
        character(len=*) STRING ! String to write to diagnostic file
        double precision DVAL ! Double precision value to write
        character(len=*) FORMAT ! Fortran format to use for DVAL
        ! Writes the specified string and double precision value to the diagnostic file in the form
        ! string = value. The double precision value is formatted using the specified format
        ! string. If this is blank a default of (G15.5E2) is used. Users of the Fortran 90
        ! INTERACTER module can omit the FORMAT argument, in which case the same default
        ! format is used.
        ! See also IDebug.
        !e.g. See IDebug
        !Debugging INTERACTER Subroutine Reference
        !4-88
    end subroutine

    subroutine IDebugInteger(STRING,IVAL)
        character(len=*) STRING ! String to write to diagnostic file
        integer IVAL ! Integer value to write
        ! Writes the specified string and integer value to the diagnostic file in the form string =
        ! value. See also IDebug.
        !e.g. See IDebug
    end subroutine

    subroutine IDebugLevel(LEVEL)
        integer LEVEL ! Error reporting level:
        ! DbgSilent (0) : Record errors silently (default)
        ! DbgStdOut (1) : Report errors to standard output
        ! DbgFile (2) : Report errors via IDebug
        ! DbgStatBar (3) : Report errors to status bar
        ! (i.e. bottom line of screen)
        ! DbgMsgBox (4) : Report errors to a message box
        ! Controls the error reporting level. By default errors are recorded silently in a global
        ! error flag which can be interrogated via InfoError(1). This routine allows errors to
        ! be reported to one of several destinations, determined by LEVEL. It also ensures that
        ! all library errors can be seen, not just the error which occurred most recently.
        ! LEVEL=0 : This is is the default state. Errors are recorded silently in the global error
        ! flag.
        ! LEVEL=1 : An error number and description will be written to standard output. The
        ! suitability of this form of 'console' output depends on the individual compiler/platform.
        ! It will rarely be tidy but can provide a useful 'quick and dirty' diagnostic mechanism.
        ! LEVEL=2 : Errors will be reported via IDebug (i.e. to the diagnostics file). This is a
        ! neater mechanism than LEVEL=1, allowing program generated diagnostics and library
        ! errors to be merged in the same output channel for subsequent analysis. However, no
        ! on-screen indication of an error is provided.
        ! LEVEL=3 : Error messages will be printed on the bottom line of the screen or program
        ! window.
        ! LEVEL=4 : A simple message window will be used to report errors. The program will
        ! wait for Enter or Space to be pressed, or 'O' for OK before continuing. Pressing Escape
        ! terminates the program.
        ! As an alternative to calling this routine directly, the initial default error reporting level
        ! can be changed in two ways:
        !   The INTDEBUG operating system variable can be set to the same values as the
        ! LEVEL argument.
        !   The DEBUG initialisation file keyword can also be set to the same values as LEVEL.
        ! Either of these mechanisms can be used to enable error reporting in any program. i.e. A
        ! program need not contain explicit calls to IDebugLevel to take advantage of error
        ! reporting. This can be particularly useful when performing remote problem diagnosis
        ! when program recompilation may not be an option.
        !e.g. CALL IDebugLevel(2)
        !INTERACTER Subroutine Reference Debugging
        !4-89
        !CALL IFormLoad('w',filename,lfnerr)
        !CALL IDebugLevel(0)
    end subroutine

    subroutine IDebugReal(STRING,RVAL,FORMAT)
        character(len=*) STRING ! String to write to diagnostic file
        real RVAL ! Real value to write
        character(len=*) FORMAT ! Fortran format to use for RVAL
        ! Writes the specified string and real value to the diagnostic file in the form string =
        ! value. The real value is formatted using the specified format string. If this is blank a
        ! default of (G15.5E2) is used. Users of the Fortran 90 INTERACTER module can omit
        ! the FORMAT argument, in which case the same default format is used.
        ! See also IDebug.
        !e.g. See IDebug
        !
        !INTERACTER Subroutine Reference Miscellaneous
        !4-91
        !4.7 Group MI : Miscellaneous
        !This group is for routines which have no obvious home elsewhere.
    end subroutine

    REAL function IRandomNumber(ISEED) result(res)
        integer ISEED !> 0 : Return next random number in sequence
        ! < 0 : Re-seed the random number generator
        ! Short-name : RANNUM
        ! Returns a random number in the range 0 to 1. To start a fresh random number sequence,supply a negative seed. Note that random sequences are repeatable. i.e. Supplying the
        ! same seed restarts the same pseudo random number sequence.
        ! This routine is provided mainly as a convenience for demonstrations where a random
        ! element can be useful or for program testing (to generate test data simply and quickly).
        ! IRandomNumber could also be used for purposes such as statistical analysis or
        ! simulation, but its suitability is not guaranteed.
        ! Be sure to declare IRandomNumber as REAL as in the example below. Alternatively,intfuncs.inc and the INTERACTER module both contain suitable declarations.
        !e.g. DIMENSION XVAL(100),YVAL(100)
        !REAL IRandomNumber
        !:
        !SEED = IRandomNumber(-99)
        !DO 100 I = 1,100
        !YVAL(I) = IRandomNumber(0)*1000.
        !XVAL(I) = IRandomNumber(0)*1000.
        !100 CONTINUE
        !CALL IPgUnits(0.0,0.0,1000.0,1000.0)
        !CALL IPgScatterPlot(XVAL,YVAL)
        !
        !INTERACTER Subroutine Reference Character Manipulation
        !4-93
        !4.8 Group CH : Character Manipulation
        !The routines in this group are not strictly screen control functions. However, since any
        !screen handling involves considerable manipulation of textual information, they
        !provide useful basic facilities such as string to numeric conversion, sub-string location,case conversion and so on.
    
        res = 0
    end function

    integer function IActualLength(STRING) result(res)
        character(len=*) STRING ! String to search
        ! Short-name : LENACT
        ! Returns the actual length of the character string held in STRING, excluding any trailing
        ! spaces or nulls. If the string is completely blank, (i.e. only contains spaces and/or nulls)
        ! zero is returned. IActualLength is a replacement for the standard LEN function
        ! which simply returns the length of a character variable not the length of the string
        ! which is held in it.
        !e.g. CHARACTER*20 STR
        !LASTCH = IActualLength(STR)
        !IF (LASTCH.NE.LEN(STR)) IOutString('STR has trailing blanks')
    
        res = len_trim(STRING)
    end function

    subroutine IDoubleToString(DVALUE,STRING,FRMAT)
        double precision DVALUE ! Real value to convert to a string
        character(len=*) STRING ! Character variable to receive numeric
        character(len=*) FRMAT ! Character string defining format to use
        ! (bracketed expression as in a Fortran FORMAT)
        ! Short-name : DBLSTR
        ! Converts a double precision value into a string using the specified Fortran format. If an
        ! error occurs, STRING is filled with asterisks. IDoubleToString is the reverse of
        ! IStringToDouble. See also IntegerToString and IRealToString.
        !e.g. DOUBLE PRECISION D
        !CHARACTER*10 CHR
        !D = 1.0000001
        !CALL IDoubleToString(D,CHR,'(F10.7)')
        !CALL IOutString(CHR)
        !Errors :
        !ErrNumToStr (18) : Numeric-to-string conversion error.
    end subroutine

    subroutine IFillString(STRING,CHR)
        character(len=*) STRING ! String to be filled
        character(len=*) CHR ! Character to fill STRING with
        ! (note : only first character of CHR is used)
        ! Short-name : FILSTR
        ! Fills the whole of STRING with the first character of CHR.
        !e.g. CHARACTER*80 STARS
        !CALL IFillString(STARS,'*')
        !Character Manipulation INTERACTER Subroutine Reference
        !4-94
    end subroutine

    subroutine IJustifyString(STRING,LCR)
        character(len=*) STRING ! Variable containing string to justify
        ! (also receives returned string)
        character(len=*) LCR ! Justification required :
        ! = 'L' : Left justify ) either
        ! = 'C' : Centre justify (default) ) upper or
        ! = 'R' : Right justify ) lower case
        ! Short-name : JUSTIF
        ! Justifies a string within the character variable which holds it.
        ! This routine is provided to overcome the inability of many Fortran compilers to
        ! reference the same character variable on both sides of an assignment statement. Moving
        ! a string within a character variable normally requires two steps via a temporary
        ! variable. IJustifyString packages up this operation into a simple subroutine call,dealing at the same time with the chores of calculating the old and new string positions.
        ! Note that in the sense used here, a 'string' is defined as all characters from the first nonblank
        ! character to the last non-blank character within the character variable STRING.
        ! Since IJustifyString justifies the string within the supplied variable itself,STRING must be passed as a variable rather than as a literal string. If STRING is
        ! blank, IJustifyString takes no action.
        !e.g. CHARACTER*12 TITLE
        !TITLE = ' Help Menu '
        !CALL IJustifyString(TITLE,'L')
        !C variable TITLE will now contain : 'Help menu '
        !CALL IJustifyString(TITLE,'C')
        !C variable TITLE will now contain : ' Help menu '
        !CALL IJustifyString(TITLE,'R')
        !C variable TITLE will now contain : ' Help menu'
    end subroutine

    integer function ILocateChar(STRING) result(res)
        character(len=*) STRING ! String to search
        ! Short-name : LOCCHR
        ! Locates and returns the position of the first non-blank/non-null character within
        ! STRING. If the string contains only blanks and/or nulls, zero is returned.
        !e.g. CHARACTER*20 FILNAM
        !CALL InString(FILNAM,LEN)
        !IPOS1 = ILocateChar(FILNAM)
    
        res = 0
    end function

    subroutine ILocateString(STRING,ISTART,IEND)
        character(len=*) STRING ! String to search
        integer ISTART ! Start position of first non-blank string
        integer IEND ! End position of first non-blank string
        ! Short-name : LOCSTR
        ! Locates the first sub-string within STRING, returning the start and end positions in
        ! ISTART and IEND. If STRING is blank ISTART and IEND are returned as zero. This
        ! routine is similar to the function ILocateChar except here the start and end
        ! positions are returned, rather than just the start position.
        ! INTERACTER Subroutine Reference Character Manipulation
        ! 4-95
        !e.g. CHARACTER*80 STRING
        !READ(LFN,'(A80)') STRING
        !CALL ILocateString(STRING,ISTART,IEND)
        !IF (ISTART.GT.0) THEN
        !CALL IOutStringXY(10,4,1 'First substring is ',STRING(ISTART:IEND))
        !ELSE
        !CALL IOutStringXY(10,4,'Blank string')
        !ENDIF
    end subroutine

    subroutine ILowerCase(STRING)
        character(len=*) STRING ! String to be converted to lower case
        ! Short-name : LOWERC
        ! Converts any upper case characters in STRING to lower case.
        !e.g. CHARACTER*10 STRING
        !STRING = 'ABCDE12345'
        !CALL ILowerCase(STRING)
        !C string should now be abcde12345
    end subroutine

    subroutine INextDouble(STRING,DVALUE)
        character(len=*) STRING ! String containing number to be
        ! converted and cleared
        double precision DVALUE ! Double precision value to be returned
        ! Short-name : NXTDBL
        ! Converts the first substring of STRING into a double precision value, using
        ! IStringToDouble. The substring within STRING is then cleared allowing
        ! INextDouble (or INextInteger, INextReal or INextString) to be called
        ! again to extract the next substring value. This routine is mainly useful where a character
        ! string must be scanned for a series of space delimited values.
        ! If STRING is blank on entry, INextDouble will behave like IStringToDouble.
        ! i.e. DVALUE will be set to zero and the error flag will be set.
        !e.g. CHARACTER*40 LINE1,LINE2
        !DOUBLE PRECISION DVAL
        !100 CALL InStringXYDef(IX,IY,' ',0,LINE1,LENLIN)
        !LINE2 = LINE1
        !C extract an integer and a double from a copy of the entered string
        !CALL INextInteger(LINE2,IVAL)
        !CALL INextDouble(LINE2,DVAL)
        !C any errors ?
        !IF (InfoError(1).NE.0) THEN
        !CALL IOutError('Integer and Double required')
        !GOTO 100
        !ENDIF
        !Errors :
        !ErrNoSubstring (10) : No substring found (STRING is blank)
        !ErrDecPoint (11) : More than one decimal point in the number
        !ErrBadChar (12) : Invalid character detected
        !(i.e. not one of 0123456789.-+DdEe )
        !Character Manipulation INTERACTER Subroutine Reference
        !4-96
    end subroutine

    subroutine INextInteger(STRING,IVALUE)
        character(len=*) STRING ! String containing number to be converted and cleared
        integer IVALUE ! Integer value to be returned
        ! Short-name : NXTINT
        ! Converts the first substring of STRING into an integer value, using
        ! IStringToInteger. The substring within STRING is then cleared allowing
        ! INextInteger (or INextDouble, INextReal or INextString) to be called
        ! again to extract the next substring value. This routine is mainly useful where a character
        ! string must be scanned for a series of space delimited values.
        ! If STRING is blank on entry, INextInteger will behave like
        ! IStringToInteger. i.e. IVALUE will be set to zero and the error flag will be set.
        !e.g. CHARACTER*80 LINE
        !INTEGER IVALUE(5)
        !:
        !C get a string containing up to 5 space separated integers
        !CALL InString(LINE,LENLIN)
        !NVAL = 0
        !C get next integer from string
        !100 CALL INextInteger(LINE(:LENLIN),IVAL)
        !IERR = InfoError(1)
        !C is string blank ?
        !IF (IERR.NE.10.AND.NVAL.LT.5) THEN
        !C no - was conversion successful ?
        !IF (IERR.EQ.0) THEN
        !C yes - save value, increment counter
        !IVALUE(NVAL) = IVAL
        !NVAL = NVAL + 1
        !ENDIF
        !C get next value
        !GOTO 100
        !ENDIF
        !Errors :
        !ErrLargeNum (4) : Number too large (exceeds 4-byte integer limits)
        !ErrNoSubstring (10) : No substring found (STRING is blank)
        !ErrBadChar (12) : Invalid character detected
        !(i.e. not 0123456789 or leading +/-)
    end subroutine

    subroutine INextReal(STRING,RVALUE)
        character(len=*) STRING ! String containing number to be converted and cleared
        real RVALUE ! Real value to be returned
        ! Short-name : NXTREA
        ! Converts the first substring of STRING into a real value, using IStringToReal. The
        ! substring within STRING is then cleared allowing INextReal (or INextDouble,INextInteger or INextString) to be called again to extract the next substring
        ! value. This routine is mainly useful where a character string must be scanned for a
        ! series of space delimited values.
        ! If STRING is blank on entry, INextReal will behave like IStringToReal. i.e.
        ! RVALUE will be set to zero and the error flag will be set.
        ! INTERACTER Subroutine Reference Character Manipulation
        ! 4-97
        !e.g. CHARACTER*40 LINE1,LINE2
        !100 CALL InStringXYDef(IX,IY,' ',0,LINE1,LENLIN)
        !LINE2 = LINE1
        !C extract an integer and two reals from a copy of the entered string
        !CALL INextInteger(LINE2,IVAL)
        !CALL INextReal(LINE2,RVAL)
        !CALL INextReal(LINE2,RVAL)
        !C any errors ?
        !IF (InfoError(1).NE.0) THEN
        !CALL IOutError('Integer and two reals required')
        !GOTO 100
        !ENDIF
        !Errors :
        !ErrLargeNum (4) : Number too large (exceeds 4-byte real limits)
        !ErrNoSubstring (10) : No substring found (STRING is blank)
        !ErrDecPoint (11) : More than one decimal point in the number
        !ErrBadChar (12) : Invalid character detected (i.e. not one of 0123456789.-+Ee )
    end subroutine

    subroutine INextString(STRING,CVALUE)
        character(len=*) STRING ! String containing substring to be extracted and cleared
        character(len=*) CVALUE ! Extracted substring
        ! Short-name : NXTSTR
        ! Extracts the first substring of STRING and returns it, left justified, in CVALUE. The
        ! substring within STRING is then cleared allowing INextString (or
        ! INextDouble, INextInteger or INextReal) to be called again to extract the
        ! next substring value. This routine is mainly useful where a character string must be
        ! scanned for a series of space delimited values.
        ! If STRING is blank on entry, INextString will return a blank CVALUE.
        !e.g. CHARACTER*80 LINE
        !CHARACTER*5 TOKENS(20),TEMP
        !:
        !CALL InString(LINE,LENLIN)
        !DO 100 ISTR = 1,20
        !CALL INextString(LINE(:LENLIN),TOKENS(ISTR))
        !IF (TOKENS(ISTR)(:1).EQ.' ') THEN
        !NSTR = ISTR - 1
        !GOTO 200
        !ENDIF
        !100 CONTINUE
        !NSTR = 20
        !200 ....
    end subroutine

    subroutine IntegerToString(IVALUE,STRING,FRMAT)
        integer IVALUE ! Integer value to convert to a string
        character(len=*) STRING ! Character variable to receive numeric
        character(len=*) FRMAT ! Character string defining format to use
        ! (a bracketed expression as in a Fortran FORMAT)
        ! Short-name : INTSTR
        ! Converts an integer value into a string using the specified Fortran format. If an error
        !occurs, (e.g. IVALUE is too large) STRING is filled with asterisks.
        !IntegerToString is the reverse of IStringToInteger. See also
        !IRealToString and IDoubleToString.
        !Character Manipulation INTERACTER Subroutine Reference
        !4-98
        !e.g. CHARACTER*5 CHR
        !I = 100
        !CALL IntegerToString(I,CHR,'(I5)')
        !CALL IOutString(CHR)
        !Errors :
        !ErrNumToStr (18) : Numeric-to-string conversion error.
    end subroutine

    integer function IntValueOfChar(CHR) result(res)
        character(len=*) CHR ! Character to convert
        ! (only first character if longer than one)
        ! Short-name : IDIGIT
        ! Returns the value of the digit (0 to 9) represented by the first character in CHR. If CHR
        ! contains any character other than 0123456789 IntValueOfChar is returned with the
        ! value -1.
        !e.g. CHARACTER*1 CHR
        !CALL IOutStringXY(10,1,'Press a key from 0 to 9')
        !CALL InKeyEvent(KEY)
        !CHR = CHAR(KEY)
        !IF (IntValueOfChar(CHR).LT.0)
        !1 CALL IOutStringXY(10,2,'Not a number !')
    
        res = 0
    end function

    subroutine IRealToString(RVALUE,STRING,FRMAT)
        real RVALUE ! Real value to convert to a string
        character(len=*) STRING ! Character variable to receive numeric
        character(len=*) FRMAT ! Character string defining format to use
        ! (a bracketed expression as in a Fortran FORMAT)
        ! Short-name : REASTR
        ! Converts a real value into a string using the specified Fortran format. If an error occurs
        !(e.g. RVALUE is too large), STRING is filled with asterisks. IRealToString is
        !the reverse of IStringToReal. See also IntegerToString and
        !IDoubleToString.
        !e.g. CHARACTER*10 CHR
        !A = 100.0
        !CALL IRealToString(A,CHR,'(F10.2)')
        !CALL IOutString(CHR)
        !Errors :
        !ErrNumToStr (18) : Numeric-to-string conversion error.
    end subroutine

    subroutine IStringToDouble(STRING,DVALUE)
        character(len=*) STRING ! String containing number to be converted.
        double precision DVALUE ! Double precision value to be returned
        ! Short-name : STRDBL
        ! Converts the first substring of STRING into a double precision (i.e 8-byte real) value.
        ! If an error occurs during conversion, DVALUE is returned as zero and the
        ! INTERACTER error flag is set. IStringToDouble is the reverse of
        ! IDoubleToString. See also IStringToInteger and IStringToReal.
        ! INTERACTER Subroutine Reference Character Manipulation
        ! 4-99
        !e.g. CHARACTER*80 LINE
        !CHARACTER*20 VALSTR
        !DOUBLE PRECISION DVALUE
        !CALL InString(LINE,LENLIN)
        !CALL IStringToDouble(LINE(:LENLIN),DVALUE)
        !IF (InfoError(1).GT.0) THEN
        !CALL IOutStringXY(10,4,'Wrong !!')
        !ELSE
        !CALL IDoubleToString(DVALUE,VALSTR,'(F20.10)')
        !CALL IOutStringXY(10,4,'Value = '//VALSTR)
        !ENDIF
        !Errors :
        !ErrNoSubstring (10) : No substring found (STRING is blank)
        !ErrDecPoint (11) : More than one decimal point in the number
        !ErrBadChar (12) : Invalid character detected
        !(i.e. not one of 0123456789.-+DdEe )
    end subroutine

    subroutine IStringToInteger(STRING,IVALUE)
        character(len=*) STRING ! String containing number to be converted.
        integer IVALUE ! Integer value to be returned
        ! Short-name : STRINT
        ! Converts the first substring of STRING into an integer value. The numeric in STRING
        ! must be a valid integer, optionally including a leading +/- sign. If an error occurs during
        ! conversion IVALUE is returned as zero and the INTERACTER error flag is set.
        ! IStringToInteger is the reverse of IntegerToString. See also
        ! IStringToReal.
        !e.g. CHARACTER*80 LINE
        !CHARACTER*10 VALSTR
        !CALL InString(LINE,LENLIN)
        !CALL IStringToInteger(LINE(:LENLIN),IVALUE)
        !IF (InfoError(1).GT.0) THEN
        !CALL IOutStringXY(10,4,'Wrong !!')
        !ELSE
        !CALL IntegerToString(IVALUE,VALSTR,'(I10)')
        !CALL IOutStringXY(10,4,'Value = '//VALSTR)
        !ENDIF
        !Errors :
        !ErrLargeNum (4) : Number too large (exceeds 4-byte integer limits)
        !ErrNoSubstring (10) : No substring found (STRING is blank)
        !ErrBadChar (12) : Invalid character detected
        !(i.e. not 0123456789 or leading +/-)
    end subroutine

    subroutine IStringToReal(STRING,RVALUE)
        character(len=*) STRING ! String containing number to be converted.
        real RVALUE ! Real value to be returned
        ! Short-name : STRREA
        ! Converts the first substring of STRING into a real value. Note that the result is a 4-byte
        ! real. If an error occurs during conversion, RVALUE is returned as zero and the
        ! INTERACTER error flag is set. IStringToReal is the reverse of
        ! IRealToString. See also IStringToInteger/IntegerToString and
        ! IStringToDouble/IDoubleToString.
        ! Character Manipulation INTERACTER Subroutine Reference
        ! 4-100
        !e.g. CHARACTER*80 LINE
        !CHARACTER*10 VALSTR
        !CALL InString(LINE,LENLIN)
        !CALL IStringToReal(LINE(:LENLIN),RVALUE)
        !IF (InfoError(1).GT.0) THEN
        !CALL IOutStringXY(10,4,'Wrong !!')
        !ELSE
        !CALL IRealToString(RVALUE,VALSTR,'(F10.2)')
        !CALL IOutStringXY(10,4,'Value = '//VALSTR)
        !ENDIF
        !Errors :
        !ErrLargeNum (4) : Number too large (exceeds 4-byte integer limits)
        !ErrNoSubstring (10) : No substring found (STRING is blank)
        !ErrDecPoint (11) : More than one decimal point in the number
        !ErrBadChar (12) : Invalid character detected
        !(i.e. not one of 0123456789.-+Ee )
    end subroutine

    subroutine IUpperCase(STRING)
        character(len=*) STRING ! String to be converted to upper case
        ! Short-name : UPPERC
        ! Converts any lower case characters in STRING to upper case.
        !e.g. CHARACTER*10 STRING
        !STRING = 'abcde12345'
        !CALL IUpperCase(STRING)
        !C string should now be ABCDE12345
        !INTERACTER Subroutine Reference Max/Min Calculations
        !4-101
        !4.9 Group MM : Maximum/Minimum Calculations
        !This group comprises of a set of subroutines and functions which calculate the
        !maximum or minimum values of supplied arrays or functions. They are primarily
        !designed to be used with the IPgUnits/IPgUnitsZ routines in the PG group, to
        !simplify the calculation of plotting unit ranges. However the functions are general and
        !can equally well be used independently of the PG routines.
        !The subroutines in this group return both a minimum and maximum value, whereas the
        !functions give just one or the other as their return value. Most routines take REAL
        !arguments and return REAL results, since this is the data type required by the PG
        !routines. However, a set of DOUBLE PRECISION max/min routines are also included
        !for the sake of completeness.
        !Note that the various routines which take a function as an argument are not
        !optimisation routines ! They simply calculate NVAL or NVALX*NVALY values of the
        !supplied function FUNC and return the min/max calculated results.
    end subroutine

    DOUBLE PRECISION function IDoubleMax1(DARRAY,IDIM) result(res)
        double precision DARRAY ! Array from which max value is to be returned
        integer IDIM ! Size of array
        ! Short-name : DPMAX1
        ! Returns the maximum value held in the supplied double precision array up to element
        ! IDIM.
        !e.g. DOUBLE PRECISION DVALS(50),DVMAX,IDoubleMax1
        !DVMAX = IDoubleMax1(DVALS,20)
    
        res = 0
    end function

    DOUBLE PRECISION function IDoubleMax2(DARRAY,IDIM1,IDIM2,MDIM1,MDIM2) result(res)
        double precision DARRAY ! Array from which max value is to be returned
        integer IDIM1 ! First declared dimension of passed array
        integer IDIM2 ! Second declared dimension of passed array
        integer MDIM1 ! First dimension to use in max calculation
        integer MDIM2 ! Second dimension to use in max calculation
        ! Short-name : DPMAX2
        ! Returns the maximum value held in the supplied double precision array, within the
        ! dimensions defined by MDIM1/MDIM2, i.e. the largest value in the sub-matrix (1,1) to
        ! (MDIM1,MDIM2) is identified and returned. IDIM1/IDIM2 should be passed with the
        ! size of the array as it has been declared in the calling program. MDIM1 and MDIM2
        ! should obviously be less than or equal IDIM1 and IDIM2 respectively, though
        ! IDoubleMax2 will check for this condition and use the smaller value in each case.
        !e.g. DOUBLE PRECISION DVALS(50,10),DVMAX,IDoubleMax2
        !DVMAX = IDoubleMax2(DVALS,50,10,20,5)
        !Max/Min Calculations INTERACTER Subroutine Reference
        !4-102
    
        res = 0
    end function

    subroutine IDoubleMaxMin1(DARRAY,IDIM,DPMIN,DPMAX)
        double precision DARRAY ! Array from which to return min/max values
        integer IDIM ! Size of array
        double precision DPMIN ! Returned minimum array value
        double precision DPMAX ! Returned maximum array value
        ! Short-name : DPMM1
        ! Returns both the minimum and maximum values held in the supplied double precision
        ! array up to element IDIM.
        !e.g. DOUBLE PRECISION DVALS(50),DVMIN,DVMAX
        !CALL IDoubleMaxMin1(DVALS,20,DVMIN,DVMAX)
    end subroutine

    subroutine IDoubleMaxMin2(DARRAY,IDIM1,IDIM2,MDIM1,MDIM2,DPMIN,DPMAX)
        double precision DARRAY ! Array from which to return min/max values
        integer IDIM1 ! First declared dimension of passed array
        integer IDIM2 ! Second declared dimension of passed array
        integer MDIM1 ! 1st dimension to use in min/max calculation
        integer MDIM2 ! 2nd dimension to use in min/max calculation
        double precision DPMIN ! Returned minimum array value
        double precision DPMAX ! Returned maximum array value
        ! Short-name : DPMM2
        ! Returns the minimum and maximum values held in the supplied double precision array,within the dimensions defined by MDIM1/MDIM2, i.e. the minimum and maximum
        ! values in the sub-matrix (1,1) to (MDIM1,MDIM2) are identified and returned.
        ! IDIM1/IDIM2 should be passed with the size of the array as it has been declared in
        ! the calling program. MDIM1 and MDIM2 should obviously be less than or equal
        ! IDIM1 and IDIM2 respectively, though IDoubleMaxMin2 will check for this
        ! condition and use the smaller value in each case.
        !e.g. DOUBLE PRECISION DVALS(50,10),DVMIN,DVMAX
        !CALL IDoubleMaxMin2(DVALS,50,10,20,5,DVMIN,DVMAX)
    end subroutine

    DOUBLE PRECISION function IDoubleMin1(DARRAY,IDIM) result(res)
        double precision DARRAY ! Array from which min value is to be returned
        integer IDIM ! Size of array
        ! Short-name : DPMIN1
        ! Returns the minimum value held in the supplied double precision array up to element
        ! IDIM.
        !e.g. DOUBLE PRECISION DVALS(50),DVMIN,IDoubleMin1
        !DVMIN = IDoubleMin1(DVALS,20)
        !INTERACTER Subroutine Reference Max/Min Calculations
        !4-103
    
        res = 0
    end function

    DOUBLE PRECISION function IDoubleMin2(DARRAY,IDIM1,IDIM2,MDIM1,MDIM2)  result(res)
        double precision DARRAY ! Array from which min value is to be returned
        integer IDIM1 ! First declared dimension of passed array
        integer IDIM2 ! Second declared dimension of passed array
        integer MDIM1 ! First dimension to use in max calculation
        integer MDIM2 ! Second dimension to use in max calculation
        ! Short-name : DPMIN2
        ! Returns the minimum value held in the supplied double precision array, within the
        ! dimensions defined by MDIM1/MDIM2, i.e. the lowest value in the sub-matrix (1,1) to
        ! (MDIM1,MDIM2) is identified and returned. IDIM1/IDIM2 should be passed with the
        ! size of the array as it has been declared in the calling program. MDIM1 and MDIM2
        ! should obviously be less than or equal IDIM1 and IDIM2 respectively, though
        ! IDoubleMin2 will check for this condition and use the smaller value in each case.
        !e.g. DOUBLE PRECISION DVALS(50,10),DVMIN,IDoubleMin2
        !:
        !DVMIN = IDoubleMin2(DVALS,50,10,20,5)
    
        res = 0
    end function

    REAL function IRealMax1(ARRAY,IDIM) result(res)
        real ARRAY ! Array from which maximum value is to be returned
        integer IDIM ! Size of array
        ! Short-name : ARMAX1
        ! Returns the maximum value held in the supplied real array up to element IDIM.
        !e.g. REAL YVALS(50),IRealMax1
        !YMAX = IRealMax1(YVALS,20)
        !CALL IPgUnits(1.0,0.0,20.0,YMAX)
    
        res = 0
    end function

    REAL function IRealMax2(ARRAY,IDIM1,IDIM2,MDIM1,MDIM2) result(res)
        real ARRAY ! Array from which maximum value is to be returned
        integer IDIM1 ! First declared dimension of passed array
        integer IDIM2 ! Second declared dimension of passed array
        integer MDIM1 ! First dimension to use in max value calculation
        integer MDIM2 ! Second dimension to use in max value calculation
        ! Short-name : ARMAX2
        ! Returns the maximum value held in the supplied real array, within the dimensions
        ! defined by MDIM1/MDIM2, i.e. the largest value in the sub-matrix (1,1) to
        ! (MDIM1,MDIM2) is identified and returned. IDIM1/IDIM2 should be passed with the
        ! size of the array as it has been declared in the calling program. MDIM1 and MDIM2
        ! should obviously be less than or equal IDIM1 and IDIM2 respectively, though
        ! IRealMax2 will check for this condition and use the smaller value in each case.
        !e.g. REAL YVALS(50,10),IRealMax2
        !YMAX = IRealMax2(YVALS,50,10,20,5)
        !CALL IPgUnits(1.0,0.0,20.0,YMAX)
        !Max/Min Calculations INTERACTER Subroutine Reference
        !4-104
    
        res = 0
    end function

    REAL function IRealMaxCum2(ARRAY,IDIM1,IDIM2,MDIM1,MDIM2) result(res)
        real ARRAY ! Array from which to return max cumulative value
        integer IDIM1 ! First declared dimension of passed array
        integer IDIM2 ! Second declared dimension of passed array
        integer MDIM1 ! First dimension to use in max value calculation
        integer MDIM2 ! Second dimension to use in max value calculation
        ! Short-name : CUMAX2
        ! Returns the maximum cumulative value calculated across the rows of the supplied real
        ! array. This function is particularly useful when plotting cumulative data using routines
        ! such as IPgHistogram, IPgBarChart and IPgLinePlot. Since each data set
        ! for such routines is likely to be stored in array columns, IRealMaxCum2 sums across
        ! each row to find the maximum cumulative value which will be plotted.
        ! When used with the PG routines, the dimensions defined by MDIM1/MDIM2 will
        ! normally correspond to the number of data points and the number of data sets
        ! respectively. IDIM1/IDIM2 should be passed with the size of the array as it has been
        ! declared in the calling program. MDIM1 and MDIM2 should obviously be less than or
        ! equal IDIM1 and IDIM2, though IRealMaxCum2 will check for this condition and
        ! use the smaller value in each case.
        !e.g. REAL YVALS(50,10),IRealMaxCum2
        !CALL IPgNewPlot(PgHistogram,5,20,PgLayStacked)
        !YMAX = IRealMaxCum2(YVALS,50,10,20,5)
        !CALL IPgUnits(1.0,0.0,20.0,YMAX)
    
        res = 0
    end function

    real function IRealMaxFunc1(FUNC,XMIN,XMAX,NVAL) result(res)
        external FUNC ! Function for which maximum value is to be calculated
        real XMIN ! Minimum input value
        real XMAX ! Maximum input value
        integer NVAL ! Number of function values to calculate
        ! (including XMAX and XMIN)
        ! Short-name : FNMAX1
        ! Returns the maximum value of the supplied function, for a number of evenly spaced
        ! input values in the range XMIN to XMAX. It is mainly intended to be used when plotting
        ! functions using the IPgFunctionLine routine.
        ! The function supplied must be declared in the calling program as either EXTERNAL (if
        ! it is a user supplied function) or INTRINSIC (for a standard Fortran function such as
        ! SIN or COS). The function must take one and only one REAL argument and return a
        ! real result.
        !e.g. EXTERNAL MYFUNC
        !REAL MYFUNC,IRealMaxFunc1
        !YMAX = IRealMaxFunc1(MYFUNC,0.0,3.0,100)
        !CALL IPgUnits(0.0,0.0,3.0,YMAX)
        !INTERACTER Subroutine Reference Max/Min Calculations
        !4-105
    
        res = 0
    end function

    real function IRealMaxFunc2(FUNC,XMIN,YMIN,XMAX,YMAX,NVALX,NVALY) result(res)
        external FUNC ! Function for which maximum value is to be calculated
        real XMIN ! Minimum input value (fn argument 1)
        real YMIN ! Minimum input value (fn argument 1)
        real XMAX ! Maximum input value (fn argument 2)
        real YMAX ! Maximum input value (fn argument 2)
        integer NVALX ! Number of x fn. values to calculate
        ! (including XMAX and XMIN)
        integer NVALY ! Number of y fn. values to calculate
        ! (including YMAX and YMIN)
        ! Short-name : FNMAX2
        ! Returns the maximum value of the supplied function, which should take 2 input
        ! arguments, for a number of evenly spaced x/y grid values in the range XMIN-to-XMAX
        ! and YMIN-to-YMAX. It is mainly intended to be used when plotting functions using the
        ! IPgSurf3Func/IPgSurf3FuncCont routines.
        ! The function supplied must be declared in the calling program as EXTERNAL. The
        ! function must take two and only two REAL arguments and return a REAL result.
        !e.g. EXTERNAL MYFUNC
        !REAL MYFUNC,IRealMaxFunc2
        !ZMAX = IRealMaxFunc2(MYFUNC,0.0,0.0,3.0,10.0,100,50)
        !CALL IPgUnitsZ(0.0,ZMAX)
    
        res = 0
    end function

    subroutine IRealMaxMin1(ARRAY,IDIM,ARMIN,ARMAX)
        real ARRAY ! Array from which min/max values are to be returned
        integer IDIM ! Size of array
        real ARMIN ! Returned minimum array value
        real ARMAX ! Returned maximum array value
        ! Short-name : ARMM1
        ! Returns both the minimum and maximum values held in the supplied real array up to
        ! element IDIM.
        !e.g. REAL YVALS(50)
        !CALL IRealMaxMin1(YVALS,20,YMIN,YMAX)
        !CALL IPgUnits(1.0,YMIN,20.0,YMAX)
        !Max/Min Calculations INTERACTER Subroutine Reference
        !4-106
    end subroutine

    subroutine IRealMaxMin2(ARRAY,IDIM1,IDIM2,MDIM1,MDIM2,ARMIN,ARMAX)
        real ARRAY ! Array from which min/max values are to be returned
        integer IDIM1 ! First declared dimension of passed array
        integer IDIM2 ! Second declared dimension of passed array
        integer MDIM1 ! First dimension to use in min/max value calculation
        integer MDIM2 ! Second dimension to use in min/max value calculation
        real ARMIN ! Returned minimum array value
        real ARMAX ! Returned maximum array value
        ! Short-name : ARMM2
        ! Returns the minimum and maximum values held in the supplied real array, within the
        ! dimensions defined by MDIM1/MDIM2, i.e. the minimum and maximum values in the
        ! sub-matrix (1,1) to (MDIM1,MDIM2) are identified and returned. IDIM1/IDIM2
        ! should be passed with the size of the array as it has been declared in the calling
        ! program. MDIM1 and MDIM2 should obviously be less than or equal IDIM1 and
        ! IDIM2 respectively, though IRealMaxMin2 will check for this condition and use
        ! the smaller value in each case.
        !e.g. REAL YVALS(50,10)
        !CALL IRealMaxMin2(YVALS,50,10,20,5,YMIN,YMAX)
        !CALL IPgUnits(1.0,YMIN,20.0,YMAX)
    end subroutine

    subroutine IRealMaxMinFunc1(FUNC,XMIN,XMAX,NVAL,FNMIN,FNMAX)
        EXTERNAL FUNC ! Function for which min/max values are to be calculated
        real XMIN ! Minimum input value
        real XMAX ! Maximum input value
        integer NVAL ! Number of function values to calculate
        ! (including XMAX and XMIN)
        real FNMIN ! Returned minimum function value
        real FNMAX ! Returned maximum function value
        ! Short-name : FNMM1
        ! Returns the minimum and maximum values of the supplied function, for a number of
        ! evenly spaced input values in the range XMIN to XMAX. It is mainly intended to be used
        ! when plotting functions using the IPgFunctionLine routine.
        ! The function supplied must be declared in the calling program as either EXTERNAL (if
        ! it is a user supplied function) or INTRINSIC (for a standard Fortran function such as
        ! SIN or COS). The function must take one and only one REAL argument and return a
        ! real result.
        !e.g. INTRINSIC SIN
        !CALL IRealMaxMinFunc1(SIN,0.0,3.0,100,YMIN,YMAX)
        !CALL IPgUnits(0.0,YMIN,3.0,YMAX)
        !INTERACTER Subroutine Reference Max/Min Calculations
        !4-107
    end subroutine

    subroutine IRealMaxMinFunc2(FUNC,XMIN,YMIN,XMAX,YMAX,NVALX,NVALY,FNMIN,FNMAX)
        EXTERNAL FUNC ! Function for which min/max values are to be calculated
        real XMIN ! Minimum input value (fn argument 1)
        real YMIN ! Minimum input value (fn argument 1)
        real XMAX ! Maximum input value (fn argument 2)
        real YMAX ! Maximum input value (fn argument 2)
        integer NVALX ! Number of x fn. values to calculate
        ! (including XMAX and XMIN)
        integer NVALY ! Number of y fn. values to calculate
        ! (including YMAX and YMIN)
        real FNMIN ! Returned minimum function value
        real FNMAX ! Returned maximum function value
        ! Short-name : FNMM2
        ! Returns the minimum and maximum values of the supplied function, which should take
        ! 2 input arguments, for a number of evenly spaced x/y grid values in the range XMIN to
        ! XMAX and YMIN to YMAX. It is mainly intended to be used when plotting functions
        ! using the IPgSurf3Func/IPgSurf3FuncCont routines.
        ! The function supplied must be declared in the calling program as EXTERNAL. The
        ! function must take two and only two REAL arguments and return a REAL result.
        !e.g. EXTERNAL MYFUNC
        !REAL MYFUNC
        !CALL IRealMaxMinFunc2(MYFUNC,0.0,0.0,3.0,10.0,100,50,ZMIN,ZMAX)
        !CALL IPgUnitsZ(ZMIN,ZMAX)
    end subroutine

    REAL function IRealMin1(ARRAY,IDIM) result(res)
        real ARRAY ! Array from which minimum value is to be returned
        integer IDIM ! Size of array
        ! Short-name : ARMIN1
        ! Returns the minimum value held in the supplied real array up to element IDIM.
        !e.g. REAL YVALS(50),IRealMin1
        !YMIN = IRealMin1(YVALS,20)
        !YMAX = IRealMax1(YVALS,20)
        !CALL IPgUnits(1.0,YMIN,20.0,YMAX)
        !Max/Min Calculations INTERACTER Subroutine Reference
        !4-108
    
        res = 0
    end function

    REAL function IRealMin2(ARRAY,IDIM1,IDIM2,MDIM1,MDIM2) result(res)
        real ARRAY ! Array from which minimum value is to be returned
        integer IDIM1 ! First declared dimension of passed array
        integer IDIM2 ! Second declared dimension of passed array
        integer MDIM1 ! First dimension to use in min value calculation
        integer MDIM2 ! Second dimension to use in min value calculation
        ! Short-name : ARMIN2
        ! Returns the minimum value held in the supplied real array, within the dimensions
        ! defined by MDIM1/MDIM2, i.e. the lowest value in the sub-matrix (1,1) to
        ! (MDIM1,MDIM2) is identified and returned. IDIM1/IDIM2 should be passed with the
        ! size of the array as it has been declared in the calling program. MDIM1 and MDIM2
        ! should obviously be less than or equal IDIM1 and IDIM2 respectively, though
        ! IRealMin2 will check for this condition and use the smaller value in each case.
        !e.g. REAL YVALS(50,10),IRealMin2
        !YMIN = IRealMin2(YVALS,50,10,20,5)
        !YMAX = IRealMax2(YVALS,50,10,20,5)
        !CALL IPgUnits(1.0,YMIN,20.0,YMAX)
    
        res = 0
    end function

    REAL function IRealMinFunc1(FUNC,XMIN,XMAX,NVAL) result(res)
        EXTERNAL FUNC ! Function for which minimum value is to be calculated
        real XMIN ! Minimum input value
        real XMAX ! Maximum input value
        integer NVAL ! Number of function values to calculate
        ! (including XMAX and XMIN)
        ! Short-name : FNMIN1
        ! Returns the minimum value of the supplied function, for a number of evenly spaced
        ! input values in the range XMIN to XMAX. It is mainly intended to be used when plotting
        ! functions using the IPgFunctionLine routine.
        ! The function supplied must be declared in the calling program as either EXTERNAL (a
        ! user supplied function) or INTRINSIC (a standard Fortran function such as
        ! SIN/COS). The function must take one and only one REAL argument and return a
        ! real result.
        !e.g. EXTERNAL MYFUNC
        !REAL MYFUNC,IRealMinFunc1
        !YMIN = IRealMinFunc1(MYFUNC,0.0,3.0,100)
        !CALL IPgUnits(0.0,YMIN,3.0,1.0)
        !INTERACTER Subroutine Reference Max/Min Calculations
        !4-109
    
        res = 0
    end function

    REAL function IRealMinFunc2(FUNC,XMIN,YMIN,XMAX,YMAX,NVALX,NVALY) result(res)
        EXTERNAL FUNC ! Function for which minimum value is to be calculated
        real XMIN ! Minimum input value (fn argument 1)
        real YMIN ! Minimum input value (fn argument 1)
        real XMAX ! Maximum input value (fn argument 2)
        real YMAX ! Maximum input value (fn argument 2)
        integer NVALX ! Number of x fn. values to calculate
        ! (including XMAX and XMIN)
        integer NVALY ! Number of y fn. values to calculate
        ! (including XMAX and XMIN)
        ! Short-name : FNMIN2
        ! Returns the minimum value of the supplied function, which should take 2 input
        ! arguments, for a number of evenly spaced x/y grid values in the range XMIN-to-XMAX
        ! and YMIN-to-YMAX. It is mainly intended to be used when plotting functions using the
        ! IPgSurf3Func/IPgSurf3FuncCont routines.
        ! The function supplied must be declared in the calling program as EXTERNAL. The
        ! function must take two and only two REAL arguments and return a REAL result.
        !e.g. EXTERNAL MYFUNC
        !REAL MYFUNC,IRealMinFunc2
        !ZMIN = IRealMinFunc2(MYFUNC,0.0,0.0,3.0,10.0,100,50)
        !CALL IPgUnitsZ(ZMIN,1.0)
        !
        !INTERACTER Subroutine Reference Bit Manipulation
        !4-111
        !4.10 Group BT : Bit Manipulation
        !Most Fortran 77 compilers provide a set of bit manipulation functions which conform
        !to the U.S. military standard MIL-STD-1753. More recently, these same functions
        !became part of the Fortran 90 standard.
        !Inevitably, some Fortran 77 compilers use different names, or omit all/some of these
        !required functions. The main compilers which fall into this category are Salford FTN77
        !and most Unix f77's. Hence, INTERACTER supports the 8 most commonly used bit
        !manipulation routines by providing the missing functions where not otherwise
        !available. If a compiler already supplies the required functions those are used instead.
        !In general, it is recommended that the size of the arguments should be INTEGER*4.
        !INTEGER*2 or *1 variables can be used on some compilers provided the specified bit
        !numbers do not exceed the valid range for the supplied variable type (0-15 for 2-byte
        !integers, or 0-7 for 1-byte integers). If this doesn't mean much to you, then you
        !probably shouldn't be using the bit-manipulation functions anyway.
        !In all cases, the result of the bit manipulation is the function's return value. All results
        !are INTEGER except BTEST which is LOGICAL. The arguments to all these functions
        !remain unchanged.
        !Bit numbers are counted from 0 (for the least significant or 'right-hand' bit) up to 31
        !(for the most significant or 'left-hand' bit). This is the commonly accepted numbering
        !scheme and is used by INTERACTER on all systems :
        !31 30 29 28 l l l l 3 2 1 0
    
        res = 0.0
    end function

    LOGICAL function BTEST(IVALUE,IBIT) result(res)
        integer IVALUE ! Value to test
        integer IBIT ! Number of bit to test (0-31)
        ! Tests the specified bit of IVALUE and returns a LOGICAL result, .TRUE. if the bit is
        ! set, .FALSE. if it is clear. Be sure to declare BTEST as logical in your calling program.
    
        res = .true.
    end function

    integer function IAND(IVAL1,IVAL2) result(res)
        integer IVAL1 ! First value for logical and
        integer IVAL2 ! Second value for logical and
        ! Returns the result of a logical AND performed on the supplied arguments.
    
        res = 0
    end function

    integer function IBCLR(IVALUE,IBIT) result(res)
        integer IVALUE ! Value containing bit to be cleared
        integer IBIT ! Number of bit to clear (0-31)
        ! Returns the supplied value with the specified bit cleared.
    
        res = 0
    end function

    integer function IBSET(IVALUE,IBIT) result(res)
        integer IVALUE ! Value containing bit to be set
        integer IBIT ! Number of bit to set (0-31)
        ! Returns the supplied value with the specified bit set.
        ! Bit Manipulation INTERACTER Subroutine Reference
        ! 4-112
    
        res = 0
    end function

    integer function IEOR(IVAL1,IVAL2) result(res)
        integer IVAL1 ! First value for logical exclusive-or
        integer IVAL2 ! Second value for logical exclusive-or
        ! Returns the result of a logical exclusive-OR performed on the supplied arguments.
    
        res = 0
    end function

    integer function IOR(IVAL1,IVAL2) result(res)
        integer IVAL1 ! First value for logical or
        integer IVAL2 ! Second value for logical or
        ! Returns the result of a logical inclusive-OR performed on the supplied arguments.
    
        res = 0
    end function

    integer function ISHFT(IVALUE,NBIT) result(res)
        integer IVALUE ! Value to be shifted
        integer NBIT ! Number of bits to shift (-32 to +32)
        ! Returns the result of shifting the supplied value left or right by the specified number of
        ! bits. The value is shifted left if NBIT is positive or right if NBIT is negative. Bits
        ! shifted out are lost, with zeros introduced at the other end.
    
        res = 0
    end function

    integer function NOT(IVALUE) result(res)
        integer IVALUE ! Value to logically complement
        ! Returns the logical complement of IVALUE (i.e. all bits flipped).
        ! INTERACTER Subroutine Reference Obsolete Routines
        ! A-1
        ! Appendix A : Obsolete Routines
        ! Routines which are no longer required or recommended are moved to this 'Obsolete
        ! Routines' group. Mostly, they are routines which are still supported, for the sake of
        ! backwards compatibility but are not intended to be used in new applications.
    
        res = 0
    end function

    subroutine GINMOU(IFUNC,IBUTN,XPOS,YPOS)
        integer IFUNC ! Function number
        integer IBUTN ! Mouse button
        real XPOS ! X co-ordinate
        real YPOS ! Y co-ordinate
        ! Low level graphics mode mouse driver interface. The functionality of this routine has
        ! been replaced by the event handling capability of InKeyEvent/InEventSelect
        ! and the mouse cursor control routines in the MC group.
    end subroutine

    subroutine IGrHardCopyGrey(NCOLOR,IGREY)
        integer NCOLOR ! INTERACTER 8-bit colour number, as for IGrColourN
        integer IGREY ! Grey scale value (bit pattern defines 4 rows of 8 bits)
        ! Short-name : GHCGRY
        ! Defines the grey scale value to be used by the raster graphics hardcopy/image-file
        ! driver when using INTERACTER 8-bit colour NCOLOR to generate fills for
        ! monochrome printers or bit image files. This routine has no effect when the 24-bit
        ! colour model is selected.
        ! This routine was introduced when the raster driver only used 16 different predefined
        ! grey scale patterns in monochrome output to perform area fills. The raster driver now
        ! automatically generates separate grey scales for all INTERACTER colours, taking
        ! account of palette redefinition or direct 24-bit colour specification.
        ! IGrHardCopyGrey allows automatic grey scale selection to be overridden by
        ! assigning 8x4 bit patterns to individual 8-bit INTERACTER colour numbers. i.e. The
        ! pattern of bits defined by the supplied IGREY value will be applied across the entire
        ! area of a fill whenever colour NCOLOR is selected. (Note that the raster driver mixes
        ! alternate bits from two grey scale patterns when mixed fills are selected.)
        ! User defined grey scale values are initialised by the raster hardcopy driver to 'unset'
        ! whenever IGrHardCopySelect(1,4) or IGrHardCopySelect(1,6) is
        ! called to initialise the raster hardcopy or image-file driver. They can be redefined at any
        ! time thereafter, even after IGrHardCopy has been called to initiate hardcopy output.
        ! Obsolete Routines INTERACTER Subroutine Reference
        ! A-2
    end subroutine

    INTEGER function IGrInputMenu(ISYOPT,MAXOPT,XPOS,YPOS,WIDTH,HEIGHT,IFRAME,ISTOPT) result(res)
        integer MAXOPT ! Number of options in ISYOPT array
        integer ISYOPT(MAXOPT)
        ! = Array of symbol numbers to be displayed
        real XPOS ! X position of bottom left corner of menu area
        real YPOS ! Y position of bottom left corner of menu area
        real WIDTH ! Width of menu area
        real HEIGHT ! Height of menu area
        integer IFRAME ! Colour of frame (0 for no frame)
        integer ISTOPT ! Number of option to initially place GIN cursor over
        ! (If negative don't redraw menu)
        ! Short-name : GINMNU
        ! Presents a pictorial menu, consisting of the symbols listed in the ISYOPT array and
        ! obtains a selection using GIN mode. The menu will be displayed in the rectangular
        ! screen area described by (XPOS,YPOS) and WIDTH/HEIGHT. The position and size
        ! of the menu area are specified in terms of the graphics units defined using IGrUnits.
        ! IGrInputMenu automatically calculates the layout of the symbols within the menu
        ! area, so as to give the most even symbol spacing.
        ! By default, exit key/button presses are ignored when the GIN cursor is outside of the
        ! menu area. However, these can cause IGrInputMenu to exit with a return value of
        ! zero if IGrInputOptions(8,1) is called.
        ! If a menu item is selected, it can be highlighted on exit. This feature is controlled by
        ! IGrInputOptions(9,n) and is disabled by default. InfoInput(55) can be
        ! used to determine the exit key or button used to terminate the menu.
        ! In a windowing environment it is possible for a graphics window expose/resize event to
        ! occur during a call to IGrInputMenu. InfoInput(55) will return 259.
        ! This routine relies on a symbol set having already been loaded using IGrSymbSet.
        ! The symbol numbers used are the same as would be specified to IGrSymbOut.
        ! Consequently, use of this routine is discouraged.
        ! Portability notes :
        ! See IGrInputXY
    
        res = 0
    end function

    subroutine IGrQuit
        ! Short-name : GRQUIT
        ! Terminates graphics processing, closing hardcopy output (if open) and returning to the
        ! mode which was selected when IGrInit was last called. Since IScreenOpen and
        ! IScreenClose, now incorporate graphics initialisation and termination, there is no
        ! longer any need to call this routine. It should only be used in programs which use
        ! IScreenInit/IScreenQuit and only in combination with IGrInit.
        ! Errors :
        ! ErrFileClose (3) : Error closing hardcopy device/file
        ! (if previously opened by IGrHardCopy)
        ! INTERACTER Subroutine Reference Obsolete Routines
        ! A-3
    end subroutine

    subroutine IGrReplayToN(FILNAM,NPLOT,OPTION)
        character(len=*) FILNAM ! Name of graphics file to be replayed
        integer NPLOT ! Number of plot to replay to
        ! (all plots displayed if NPLOT <= 0)
        character(len=*) OPTION ! String containing characters specifying further options
        ! = C : Continuous re-run (pause between plots otherwise)
        ! Short-name : GRPL2N
        ! Replays a graphics file by calling IGrReplay. This routine has been superceded by
        ! IGrReplayOptions.
    end subroutine

    subroutine IGrSymbConvert(INFIL,OUTFIL)
        character(len=*) INFIL ! Input file name
        character(len=*) OUTFIL ! Output file name
        ! Short-name : GSYCNV
        ! In v3.xx and earlier, INTERACTER supported symbol sets as a separate file type. From
        ! v4 onwards, character and symbol sets have been merged, i.e. symbol sets are treated
        ! just like character sets. IGrCharConvert should be used to create character set files.
        ! IGrSymbConvert therefore no longer has a purpose. Calling this routine will cause a
        ! program to terminate with fatal error code 14.
    end subroutine

    subroutine IGrSymbOut(XPOS,YPOS,NUMSYM)
        real XPOS ! X co-ordinate
        real YPOS ! Y co-ordinate
        integer NUMSYM ! Number of symbol to be written (1-25)
        ! Short-name : GSYOUA
        ! Outputs a symbol at the graphics co-ordinate (XPOS,YPOS). In v3.xx and earlier,symbols were supplied in separate 25-character symbol-set files. From v4 onwards,
        ! character and symbol set handling has been merged. All of the five previously supplied
        ! 25-piece symbol sets are now supplied in a single 8-bit character set file called
        ! symbols.chr. Calls of the form :
        ! CALL IGrSymbSet(symbol set file name)
        ! CALL IGrSymbOut(XPOS,YPOS,NUMSYM)
        ! can be replaced with :
        ! CALL IGrCharSet('symbols.chr')
        ! CALL IGrCharOut(XPOS,YPOS,CHAR(IBASE+NUMSYM))
        ! where IBASE is determined by the symbol set that was originally being used. The
        ! appropriate IBASE values are listed later in this Appendix under IGrSymbSet.
        ! Internally, IGrSymbOut performs the above conversion automatically, taking account
        ! of which symbol set was most recently requested via IGrSymbSet. If
        ! symbols.chr is not currently loaded, IGrSymbOut temporarily loads it then
        ! reloads the previous character set. Depending on how symbols are used, this may be
        ! inefficient, so conversion to the unified character handling interface (i.e.
        ! IGrCharSet/IGrCharOut) is recommended.
        ! Obsolete Routines INTERACTER Subroutine Reference
        ! A-4
    end subroutine

    subroutine IGrSymbOutRel(NUMSYM)
        integer NUMSYM ! Number of symbol to be written (1-25)
        ! Short-name : GSYOUR
        ! Outputs a symbol at the current plotting position. This is exactly equivalent to calling
        ! IGrSymbOut, except that no (x,y) co-ordinate need be specified. This routine can be
        ! replaced by a calling sequence of the form :
        ! CALL IGrCharSet('symbols.chr')
        ! CALL IGrCharOutRel(CHAR(IBASE+NUMSYM))
        ! Where IBASE depends on the original symbol set used. See IGrSymbSet and
        ! IGrSymbOut for further details.
    end subroutine

    subroutine IGrSymbSet(FILNAM)
        character(len=*) FILNAM ! Name of symbol set file to load :
        ! arrows.smb : Arrows
        ! calctek.smb : CalComp/Tektronix
        ! computer.smb: Computer
        ! general.smb : Miscellaneous
        ! maths.smb : Mathematical
        ! Short-name : GSYSET
        ! Selects the symbol set to be used by future calls to IGrSymbOut. In v3.xx and earlier
        ! this loaded a symbol set file containing 25 characters which used the same file format
        ! as software characters (see IGrCharSet). From v4 onwards, character and symbol set
        ! handling has been unified. The five symbol sets listed are now all supplied in a single
        ! 8-bit character set file called symbols.chr which includes about 60 additional
        ! symbols. Each of the five original symbol sets are stored in contiguous blocks in the
        ! new 'Symbols' character set allowing symbols to be referenced by their old position
        ! plus an offset value. The offset values (referred to as IBASE in the IGrSymbOut
        ! documentation earlier in this Appendix) are as follows :
        ! Symbol Set IBASE
        ! arrows.smb 32
        ! calctek.smb 202
        ! computer.smb 82
        ! general.smb 57
        ! maths.smb 161
        ! Calling IGrSymbSet therefore now updates the internal copy of IBASE which is then
        ! used by IGrSymbOut when it calls IGrCharOut to write a character from the
        ! 'Symbols' character set. The default IBASE value is 82, since the default symbol set in
        ! v3.xx and earlier was the 'Computer' symbol set.
        ! Specifying an unknown symbol set file name has no effect other than setting the error
        ! flag to 1 (for backwards compatibility). User-defined symbol sets should be converted
        ! to character set files. See IGrCharConvert and chapter 15 of the User Guide.
        ! INTERACTER Subroutine Reference Obsolete Routines
        ! A-5
    end subroutine


    subroutine IPgNewGraph(NSETS,NVALUE,CUMUL,LAYOUT,GRTYPE)
        integer NSETS ! Number of data sets, wedges, contours or columns
        integer NVALUE ! Number of values to plot
        character(len=*) CUMUL ! .C. for cumulative (i.e. stacked) plot. Blank otherwise.
        character(len=*) LAYOUT ! String specifying layout. Recognised option letters are
        ! 3, A, C, F, H, S, T, V
        character(len=*) GRTYPE ! Graph type specified by first letter of string
        ! B, C, F, H, L, P, S, T, X
        ! Short-name : PGRAPH
        ! Introduces a new Presentation Graphics plot. This interface was used by versions 1.xx-
        ! 4.xx, but has been superceded at v5.0 by IPgNewPlot.
    end subroutine

    subroutine IScreenInit(INITFN)
        character(len=*) INITFN ! Initialisation data file name (blank : use default)
        ! Short-name : SCINIT or SHINIT
        ! Initialises INTERACTER screen handling, attempts to read an initialisation file and
        ! clears the screen to an 80 column text mode. This routine has been superceded by
        ! IScreenOpen which performs the same task except that it also initialises
        ! INTERACTER's graphics and provides the capability of entering graphics screen mode
        ! directly. All pre v4 INTERACTER programs will use IScreenInit, so it is an
        ! essential backwards compatibility routine. However, we strongly recommend the use of
        ! IScreenOpen in new software.
        ! Calling IScreenInit activates certain v3.xx compatible defaults, which have been
        ! changed from version 4 onwards :
        !   Text window title bars do not occupy the full window width, when character
        ! graphic frames are in use (See IWinAction).
        !   Keyboard input under DOS is performed via BIOS interrupts instead of DOS
        ! interrupts (See InKeyVia).
        !   Graphics mode resize/expose event reporting in windowing environments is
        ! disabled (See InEventSelect).
        !   Window text wrapping mode is set to left justified/ragged right margin (See
        ! IWinWordWrap).
        !   Frame titles are displayed in the current colours as set by ITextColour (See
        ! IFrameOptions(4/5,n)).
        !   The click-outside-to-exit option is disabled (See InMouseOptions(2,n)).
        !   All mouse button options are disabled (See InMouseOptions(101-106,n)).
        !   Condensed horizontal help menus are disabled (See InCondenseHelpMenu).
        !   The default menu highlight is reverse video (See InHighlight).
        !   Menu option single-key selection characters are not highlighted (See
        ! InSelectionChars).
        !   Insert/Overstrike mode defaults to overstrike mode (See InsertOver).
        !   Pre-defined hardware menus are displayed as horizontal menus with a message
        ! above the menu (See IdMenuOptions(2/3,n)).
        ! Obsolete Routines INTERACTER Subroutine Reference
        ! A-6
        !   Pre-defined forms use the style defined in the form definition file (see
        ! IdMenuOptions(13,n)).
        !   If not specified in the initialisation file, the default printer type is 'generic text-only'.
    end subroutine

    subroutine IScreenQuit(ACTION)
        character(len=*) ACTION ! Action to take on exit
        ! = 'C' : Clear the screen
        ! Short-name : SCQUIT or SHQUIT
        ! Quit/terminate INTERACTER screen handling. This routine was used in combination
        ! with IScreenInit in pre v4 programs. It clears the screen if requested, reselecting
        ! the screen mode which was in use on entry to the program if possible. Any system
        ! dependent close down processing is also performed here. This routine has been
        ! superceded by IScreenClose which always clears the screen on full screen displays
        ! and simply removes the program window in windowing environments (thereby
        ! eliminating the temporary text mode window on exit from graphics mode programs
        ! which will be observed when calling IScreenQuit('c')). IScreenQuit should
        ! only continue to be used in programs which still use IScreenInit.
    end subroutine

    subroutine IScreenRaise(WINDOW)
        character(len=*) WINDOW ! Window to raise (T or G)
        ! Short-name : SCRAIS
        ! Raise the text or graphics window to the top of the stacking order in a windowing
        ! environment. This routine was intended for use with the Xlib driver option which
        ! allowed separate text and graphics windows in graphics mode. This option is no longer
        ! supported.
    end subroutine

    subroutine IScreenResize(ONOFF)
        character(len=*) ONOFF ! Enable/disable graphics window resizing :
        ! = 'ON' (enable) or 'OFF' (disable)
        ! Enable or disable resizing of the graphics window in a windowing environment. This
        ! routine was only implemented in the Xlib driver in earlier versions. This feature is no
        ! longer supported. The graphics mode window is always resizable.
    end subroutine

    subroutine TINMOU(IFUNC,IBUTN,IXPOS,IYPOS)
        integer IFUNC ! Function number
        integer IBUTN ! Mouse button
        integer IXPOS ! Column
        integer IYPOS ! Row
        ! Low level text-mode mouse driver interface. The functionality of this routine has been
        ! replaced by the event handling capability of InKeyEvent/InEventSelect and
        ! the mouse cursor control routines in the MC group.
        ! INTERACTER Subroutine Reference Obsolete Routines
        ! A-7
    end subroutine

    subroutine WNBROW(TEXT,NLINES,LRSTEP,IPOS)
        integer NLINES ! Number of elements in TEXT array
        character(len=*) TEXT(NLINES) ! Array of text strings to browse
        integer LRSTEP ! Left/right step size in columns
        ! (zero to suppress left/right scrolling)
        integer IPOS ! Position in text array :
        ! Entry : Start browsing from this position
        ! Exit : Final position on exit
        ! Window based text array browser. Displays the contents of the array TEXT in the
        ! current window, allowing the user to browse freely through the text. This routine was
        ! introduced in INTERACTER v1.60 but has since been superceded by
        ! IWinBrowseText which provides an interface which is consistent with
        ! IWinBrowseFile. Developers are encouraged to use IWinBrowseText in future.
        ! Functionally, WNBROW is equivalent to IWinBrowseText with the following
        ! exceptions :
        ! a) A message line is not displayed at the bottom of the window and hence there is no
        ! user-definable button or line-number display.
        ! b) There are no string-search, goto-line or help-screen options.
        ! c) The Q/H/F/N/G keys have no effect.
        ! In practice, WNBROW is an entry point to IWinBrowseText with the above features
        ! disabled.
    end subroutine

    INTEGER function IGrGetPixel(XPOS,YPOS) result(res)
        real XPOS ! X co-ordinate
        real YPOS ! Y co-ordinate
        ! Returns the colour of the specified co-ordinate in the current drawable, as a 24-bit
        ! colour value (i.e. Red+256*Green+256*256*Blue). The (x,y) co-ordinate should be
        ! expressed in user units as set via IGrUnits. Results are undefined when screen
        ! graphics are not enabled.
        ! On a monochrome screen, the returned RGB value does not take account of palette
        ! changes applied to the two foreground/background colours. Background pixels return
        ! black and foreground pixels return white.
        ! Since this function is not available on graphics terminals (see Portability notes) the
        ! information function InfoGrScreen(29) is provided to report support for screen
        ! pixel interrogation.
        ! If the specified co-ordinate lies outside the graphics area, -1 is returned.
        ! Portability notes :
        ! Tektronix & ReGIS :
        ! This function is not available on Tektronix and ReGIS graphics terminals.
    
        res = 0
    end function

    subroutine IGrGetPixelRGB(XPOS,YPOS,IRED,IGREEN,IBLUE)
        real XPOS ! X co-ordinate
        real YPOS ! Y co-ordinate
        integer IRED ! Red component of specified point (0-255)
        integer IGREEN ! Green component of specified point (0-255)
        integer IBLUE ! Blue component of specified point (0-255)
        ! Returns the colour of the specified co-ordinate in the current drawable, as an (r,g,b)
        ! triplet. If the specified co-ordinate lies outside the graphics area the RGB value is
        ! returned as (-1,-1,-1).
        ! This is an alternative routine to IGrGetPixel which returns a single 24-bit colour
        ! value consistent with other INTERACTER graphics routines.
        ! INTERACTER Subroutine Reference General Graphics
        ! 1-5

!        type(Fields), pointer :: this
!        integer(INT32) color
!        this => this_
!        color = getPixelColor(this%canvas, real(XPOS, DOUBLE), real(YPOS, DOUBLE));
!
!        IRED = ibits(color, 16, 8)
!        IGREEN = ibits(color, 8, 8)
!        IBLUE = ibits(color, 0, 8)
!
    end subroutine

    subroutine IGrInit(TYPE,NX,NY,NCOLOR)
        character(len=*) TYPE ! Type of output, one only of the following :
        ! H : Hardcopy-only
        ! C : Screen output, priority to number of Colours when
        ! selecting screen mode
        ! R : Screen output, priority to Resolution
        ! when selecting screen mode (default)
        ! And optionally :
        ! P : Preserve any hardcopy options set previously
        ! by IGrHardCopyOptions
        integer NX ! Preferred number of horizontal screen pixels
        integer NY ! Preferred number or vertical screen pixels
        integer NCOLOR ! Preferred number of screen colours
        ! Short-name : GRINIT
        ! Re-initialises graphics output. This routine is called by IScreenOpen, so it should
        ! not normally be necessary to call it again unless the whole of the graphics system needs
        ! to be reset to its default state. In INTERACTER v3.xx and earlier, IGrInit needed to
        ! be called before any graphics processing, but this is no longer the case. In general, use
        ! of IGrInit is discouraged, though its use for re-initialisation remains valid.
        ! If TYPE is other than 'H' ('hardcopy-only'), IGrInit calls IScreenMode to enter
        ! graphics screen mode. The arguments then have the same meaning as IScreenMode.
        ! If hardcopy-only graphics mode is specified, NX, NY and NCOLOR are not used.
        ! If screen output is requested, the graphics mode with the nearest resolution to that
        ! requested will be selected by default. However, the mode with the nearest number of
        ! colours can be given priority by specifying TYPE as 'C'. If screen output is required, but
        ! the type of mode to be selected is not important, TYPE can be left blank. Attempting to
        ! enter graphics screen mode when the currently selected display type does not support
        ! graphics will cause IGrInit to call the IOsExitProgram routine to terminate
        ! program execution, with exit code 13. See the Error and Exit Codes chapter of the
        ! User Guide.
        ! If hardcopy-only output is requested, INTERACTER's graphics routines behave in
        ! exactly the same way, except that the screen mode does not change and no screen
        ! graphics output is generated. Screen graphics output can be selectively enabled or
        ! disabled via subsequent calls to IScreenMode with a 'G' or 'H' mode type argument.
        ! For example, calling IScreenMode('G',...) to enter graphics screen mode after
        ! an earlier IGrInit('H',...) will re-enable screen graphics output. Similarly,calling IScreenMode('T',...) to enter text screen mode will disable screen
        ! graphics output.
        ! NX, NY and NCOLOR are OPTIONAL under a Fortran 90 compiler, if the
        ! INTERACTER interface definitions module is used. They default to 800,600,256 where
        ! omitted. Programs written to run in graphics mode on non-DOS platforms can safely
        ! omit these arguments, if screen mode option 6 has not been set to 1.
        ! General Graphics INTERACTER Subroutine Reference
        ! 1-6
        ! By default, IGrInit reinitialises the currently selected hardcopy driver (initially this
        ! is normally the HP-GL/2 driver). This will reset the hardcopy options associated with
        ! that driver to their default values. Specify a 'P' in the TYPE argument to preserve any
        ! hardcopy options previously set via IGrHardCopyOptions.
        ! Since IGrInit uses IScreenMode to enter graphics screen mode, it indirectly calls
        ! IScreenModeN. Therefore options which can be set via IScreenModeOptions
        ! have an effect when IGrInit is called to enter graphics screen mode. Similarly,Portability notes relating to IScreenModeN apply equally to IGrInit.
        ! The default graphics settings initialised by IGrInit are the same as those documented
        ! under IScreenOpen.
        !e.g. CALL IGrInit('C',800,600,16)
        !CALL IGrUnits(0.,0.,1000.,1000.)
        !CALL MYGRAF
        !CALL IGrPause(' ')
        !CALL IScreenMode('t',80,25,16)
        !CALL IOutMessage('Back to text mode')
        !CALL InKeyEvent(K)
        !CALL IScreenMode('G',800,600,16)
        !Portability notes :
        !Terminals :
        !On an unspecified Tektronix compatible terminal (i.e. display type 111 or 112), it may
        !not be possible to switch from text to graphics mode automatically. In this case, the
        !screen is cleared and the user is prompted to switch modes manually before pressing a
        !key to continue.
    end subroutine

    subroutine IGrPause(ACTION)
        character(len=*) ACTION ! String describing required action
        ! (default is wait for confirm key then clear screen)
        ! = 'A' : Any key can be pressed instead of just 'confirm'
        ! = 'P' : Preserve contents of graphics screen
        ! Short-name : GPAUSE
        ! This should be called when the drawing of a graphics screen has been completed.
        ! IGrPause sounds the bell, then proceeds according to the ACTION argument :
        !   If ACTION contains an 'A' any key can be pressed to continue. By default, the user
        ! must press the 'confirm' key. The resulting InKeyEvent code is available via
        ! InfoInput(67).
        !   The screen is cleared unless ACTION contains a 'P' to indicate that the contents of
        ! the screen must be preserved.
        ! Both upper and lower case are accepted for ACTION arguments. The 'P' argument has
        ! no effect if hardcopy-only graphics are currently enabled.
        ! If graphics hardcopy output has been activated, an 'end-of-page' command is written to
        ! the output channel by calling IGrEndPage. The latter routine should be called
        ! directly if the key press feature is not required.
        !e.g. CALL IGrCharOut(1000,200,'Press any key to continue')
        !CALL IGrPause('a')
        !INTERACTER Subroutine Reference General Graphics
        !1-7
        !Portability notes :
        !Xlib and MS Windows :
        !An expose/resize event may occur while IGrPause is waiting for a key to be pressed.
        !If so, IGrPause will exit with InfoInput(67) set to 259 (the InKeyEvent code
        !for an expose/resize event) regardless of whether 'A' was specified in the ACTION
        !argument. It is up to the calling program whether to redraw the image at this point and
        !re-enter IGrPause. A close-window request can also occur, in which case
        !InfoInput(67) will return 260.
        !
        !INTERACTER Subroutine Reference Graphics Area/Units
        !1-9
        !1.2 Group GA : Graphics Area/Units
        !These routines control where graphics are drawn and the associated co-ordinate system.
        !The area of the screen or output page to be used for graphics output is determined by
        !IGrArea. The graphics co-ordinate system used within that area is user-definable via
        !IGrUnits. Initially, the main graphics area is set to the full screen/page and (0.,0.) is
        !the bottom left corner of the graphics area.
        !Attempts to draw outside the graphics area will be clipped. A view port can be defined
        !within the graphics area by IGrViewPort. This changes the clipping rectangle
        !without redefining the graphics area or plotting units. The graphics area can be cleared
        !by calling IGrAreaClear.
        !INTERACTER.s graphics units are not related to the physical resolution of the output
        !device, making graphics based programs device independent. However, it is possible to
        !convert to/from screen pixel co-ordinates if required by calling IGrUnitsToPixels
        !or IGrUnitsFromPixels.
    end subroutine

    subroutine IGrArea(XLEFT,YLOWER,XRIGHT,YUPPER)
        real XLEFT ! Left limit of main graphics area (0.0=<XLEFT <1.0)
        real YLOWER ! Lower limit of main graphics area (0.0=<YLOWER <1.0)
        real XRIGHT ! Right limit of main graphics area (0.0 <XRIGHT=<1.0)
        real YUPPER ! Upper limit of main graphics area (0.0 <YUPPER=<1.0)
        ! Short-name : GAREA
        ! Defines the area of the screen (and hardcopy page, if selected) to be used by all
        ! following graphics commands. The full screen is defined as being 1 unit high and 1 unit
        ! wide, so you should describe your area using values in the range 0.0 - 1.0 as shown
        ! above. When you call IGrUnits, that then defines the co-ordinate system to be used
        ! within the area defined by IGrArea. The default values for both the IGrArea and
        ! IGrUnits ranges are 0.0 to 1.0, occupying the whole of the graphics screen or
        ! hardcopy page. The current graphics area dimensions can be interrogated via the
        ! InfoGraphics function.
        ! IGrArea is particularly useful when you wish to rescale a graphics image without
        ! changing your co-ordinate system or any other parameters. In the example which
        ! follows, a full screen display is reduced to a quarter size, at the top right of the screen,
        ! by a single call to IGrArea. Alternatively, the graphics area can also be redefined
        ! without rescaling images to fit the new area size, by setting the graphics viewport using
        ! IGrViewport. The latter routine calls IGrArea to set the graphics area but also
        ! recalculates the user units in order to maintain the current image size.
        ! It is important to appreciate that if you set a graphics area in which the sides are no
        !longer equal (e.g. 0.5 high and 1.0 wide) then regular shapes will be distorted
        !accordingly. e.g. Circles become elliptical, squares become rectangular and so on.
        !Calls to IGrArea automatically reset the GIN (graphics input) limits to match the
        !specified graphics area. These limits can be reset with a subsequent call to
        !IGrInputLimits.
        !Graphics Area/Units INTERACTER Subroutine Reference
        !1-10
        !e.g. CALL IGrArea(0.0,0.0,1.0,1.0)
        !CALL MYGRAF
        !CALL IGrPause(' ')
        !CALL IGrArea(0.5,0.5,1.0,1.0)
        !CALL MYGRAF
        !Errors :
        !ErrBadArea (44) : Invalid X and/or Y range. Range reset to 0.0-1.0
!        type(Fields), pointer :: this
!        double precision minX
!        double precision maxX
!        double precision minY
!        double precision maxY
!        double precision x1
!        double precision x2
!        double precision y1
!        double precision y2
!        this => this_
!        
!        minX = getMinX(this%canvas)
!        minY = getMinY(this%canvas)
!        maxX = getMaxX(this%canvas)
!        maxY = getMaxY(this%canvas)
!
!        x1 = XLEFT * (maxX - minX)
!        x2 = XRIGHT * (maxX - minX)
!        y1 = YLOWER * (maxY - minY)
!        y2 = YUPPER * (maxY - minY)
!
!    !    call zoomToExtend(this%canvas, x1, x2 , y1, y2)
!
    end subroutine

    subroutine IGrAreaClear
        ! Short-name : GCLEAR
        ! Clears the graphics area, as defined by IGrArea, to the current background colour. On
        ! those displays which support it, part of the graphics screen can therefore be cleared
        ! without affecting the rest of the screen. This feature can be tested for using the
        ! InfoGrScreen function.
        ! When the graphics area is defined to be 0.0-1.0 in both x and y directions (the default at
        ! initialisation), the whole screen is cleared. Hardcopy is not affected by this call.
        !e.g. CALL IScreenBackground('BLU','WHIT')
        !CALL IGrArea(0.05,0.05,0.4,0.4)
        !CALL IGrAreaClear
        !CALL MYGRAF
        !Portability notes :
        !Tektronix :
        !On a standard Tek4010/14 type terminal, only full-screen clearing is supported. In this
        !case, calls to IGrAreaClear when the graphics area is less than the full screen will
        !have no effect. However, on displays which support a solid rectangle fill primitive,part-screen clearing is fully supported. Call InfoGrScreen to determine whether
        !solid rectangle fills are available.
!        type(Fields), pointer :: this
!        this => this_
!
!        this%drawing = .true.
!        call startDrawing(this%canvas)
    end subroutine

    subroutine IGrUnits(XLEFT,YLOWER,XRIGHT,YUPPER)
        real XLEFT ! Lower X co-ordinate limit
        real YLOWER ! Lower Y co-ordinate limit
        real XRIGHT ! Upper X co-ordinate limit
        real YUPPER ! Upper Y co-ordinate limit
        ! Short-name : GUNIT
        ! IGrUnits defines the plotting units (the 'user co-ordinate system') to be used when
        ! drawing in the main graphics area defined by IGrArea. The initial ranges are 0.0 to
        ! 1.0 on both axes. The following example shows how to plot values in the range 500-
        ! 1000 on the x-axis and values of 300-600 on the y-axis. The current plotting units can
        ! be interrogated via the InfoGraphics function.
        ! Selecting an invalid X or Y range, sets the limits for that axis to 0.0-1.0.
        !e.g. CALL IGrUnits(500.0,300.0,1000.0,600.0)
        !CALL IGrCircle(750.,450.,50.)
        !Errors :
        !ErrBadUnits (16) : Lower X or Y value is greater than or equal to upper X or Y
        !INTERACTER Subroutine Reference Graphics Area/Units
        !1-11
!        type(Fields), pointer :: this
!        double precision minX
!        double precision maxX
!        double precision minY
!        double precision maxY
!        this => this_
!
!        minX = XLEFT
!        maxX = XRIGHT
!        minY = YLOWER
!        maxY = YUPPER
!        call setFullExtend(this%canvas, minX, maxX , minY, maxY)
    end subroutine

    subroutine IGrUnitsFromPixels(IXPIXL,IYPIXL,XPOS,YPOS)
        integer IXPIXL ! X pixel co-ordinate
        integer IYPIXL ! Y pixel co-ordinate
        real XPOS ! X user co-ordinate ) returned
        real YPOS ! Y user co-ordinate ) -"-
        ! Short-name : GUFRPX
        ! Converts from the supplied screen pixel co-ordinate to the equivalent user co-ordinate
        ! (XPOS,YPOS) . The values supplied in (IXPIXL,IYPIXL) should be based on the
        ! current graphics screen dimensions, as reported by InfoScreen(4) and
        ! InfoScreen(5), assuming a bottom left origin. The user co-ordinate will be
        ! returned in the usual plotting units as defined by IGrUnits. The complementary
        ! routine IGrUnitsToPixels converts to pixels from user units.
        ! The use of pixel co-ordinates is not normally encouraged, since this introduces device
        ! dependencies. However, some users may find this facility useful, particularly when
        ! converting existing raster oriented software. Remember that pixel co-ordinates may not
        ! be entirely meaningful when operating via a graphics terminal emulator or within a
        ! windowing environment. Furthermore, they have no specific meaning when hardcopyonly
        ! graphics have been selected.
        !e.g. CALL IGrUnitsFromPixels(IX1,IY1,XPOS1,YPOS1)
        !CALL IGrUnitsFromPixels(IX2,IY2,XPOS2,YPOS2)
        !CALL IGrJoin(XPOS1,YPOS1,XPOS2,YPOS2)
        
!        type(Fields), pointer :: this
!        this => this_
!        XPOS = getXFromPixel(this%canvas, IXPIXL, -IYPIXL)
!        YPOS = getYFromPixel(this%canvas, IXPIXL, -IYPIXL)
    end subroutine

    subroutine IGrUnitsToPixels(XPOS,YPOS,IXPIXL,IYPIXL)
        real XPOS ! X user co-ordinate
        real YPOS ! Y user co-ordinate
        integer IXPIXL ! X pixel co-ordinate ) returned
        integer IYPIXL ! Y pixel co-ordinate ) -"-
        ! Short-name : GUTOPX
        ! Converts the supplied user co-ordinate (XPOS,YPOS) to the equivalent screen pixel
        ! co-ordinate. The user co-ordinate should be expressed in the usual plotting units as
        ! defined by IGrUnits. The values returned in (IXPIXL,IYPIXL) are based on the
        ! current graphics screen dimensions, as reported by InfoScreen(4) and
        ! InfoScreen(5), assuming a bottom left origin. The complementary routine
        ! IGrUnitsFromPixels converts from pixels to user units.
        ! The same comments about use of pixel co-ordinates apply as noted under
        ! IGrUnitsFromPixels.
        !e.g. CALL IGrUnits(0.0,0.0,1.0,1.0)
        !C get pixel co-ords of bottom left/top right corners of graphics area
        !CALL IGrUnitsToPixels(0.0,0.0,IXPMIN,IYPMIN)
        !CALL IGrUnitsToPixels(1.0,1.0,IXPMAX,IYPMAX)
        !Graphics Area/Units INTERACTER Subroutine Reference
        !1-12
!        type(Fields), pointer :: this
!        this => this_
!        IXPIXL = getPixelXFromXY(this%canvas, real(XPOS, DOUBLE), real(YPOS, DOUBLE))
!        IYPIXL = -getPixelYFromXY(this%canvas, real(XPOS, DOUBLE), real(YPOS, DOUBLE))
    end subroutine

    subroutine IGrViewport(XLEFT,YLOWER,XRIGHT,YUPPER)
        real XLEFT ! Left limit of viewport (0.0=<XLEFT <1.0)
        real YLOWER ! Lower limit of viewport (0.0=<YLOWER <1.0)
        real XRIGHT ! Right limit of viewport (0.0 <XRIGHT=<1.0)
        real YUPPER ! Upper limit of viewport (0.0 <YUPPER=<1.0)
        ! Short-name : GVIEW
        ! Defines the graphics viewport, i.e. the area of the screen (and hardcopy page, if
        ! selected) to be used by all following graphics commands. Calling IGrViewport is
        ! identical to calling IGrArea except that :
        ! (a) The current user units are recalculated to ensure that the image size remains
        ! unchanged, instead of being rescaled to fit in the new graphics area.
        ! (b) Character size remains unchanged, since this is defined in terms of the graphics
        ! area set by the most recent call to IGrArea.
        ! Changing the viewport therefore changes the clipping rectangle without changing
        ! image dimensions.
        !e.g. CALL IGrArea(0.0,0.0,1.0,1.0)
        !CALL TEST
        !CALL IGrViewport(0.25,0.25,0.75,0.75)
        !CALL TEST
        !CALL IGrViewport(0.40,0.40,0.95,0.85)
        !CALL TEST
        !CALL IGrViewport(0.10,0.45,0.58,0.99)
        !CALL TEST
        !CALL IGrPause('a')
        !:
    end subroutine

    subroutine TEST
        ! CALL IGrBorder
        ! CALL IGrJoin(0.5,0.0,0.5,1.0)
        ! CALL IGrLineToRel(0.1,-1.0)
        ! CALL IGrCharOut(0.5,0.5,'MIDDLE')
        ! CALL IGrPause(' ')
        ! RETURN
        ! END
        ! Errors :
        ! ErrBadArea (44) : Invalid X and/or Y range. Range reset to 0.0-1.0
        ! INTERACTER Subroutine Reference Graphics Style Selection
        ! 1-13
        ! 1.3 Group GS : Graphics Style Selection
        ! This group controls the appearance of output from other graphics routines.
        ! Probably the most commonly used routines in this group will be those which control
        ! colour. The current graphics colour is selected using IGrColourN or IGrColour
        ! (one selects by number, the other by name). The number of available colours is highly
        ! device dependent, so INTERACTER uses a common 8-bit colour numbering scheme on
        ! all devices, by default. This provides 256 nominal colours (a near equivalent is selected
        ! where fewer than 256 colours are available). Alternatively, some video modes and
        ! hardcopy formats support 24-bit colour mode where colours are specified directly as an
        ! RGB value. IGrColourN can use either an 8-bit or a 24-bit colour model, selectable
        ! via IGrColourModel.
        ! On monochrome devices, the colour handling routines can still be called but their effect
        ! will be limited to selecting either background / foreground colour or they may have no
        ! effect at all.
        ! In the 8-bit colour model, colour 0 is treated as the background colour and all others as
        ! foreground. However, colour 0 can still be selected as the current colour for graphics
        ! operations, though it will only be visible if the operation takes place on top of some
        ! non-background colour.
        ! The 8-bit colour palette (the relationship between the 256 colour numbers in the 8-bit
        ! model and the actual colours displayed) can be redefined on many devices using
        ! IGrPaletteRGB or IGrPaletteHLS. By default the background colour is black,and the other displayed colours depend on the screen mode selected. Alternatively, a
        ! palette which uses a white background is selectable via IScreenOpen. The palette
        ! can be reinitialised by calling IGrPaletteInit.
        ! In addition to colour control, line type, line width, plot mode and fill style are
        ! selectable on most devices via IGrLineType, IGrLineWidth, IGrPlotMode
        ! and IGrFillPattern.
        ! Graphics Style Selection INTERACTER Subroutine Reference
        ! 1-14
    end subroutine

    subroutine IGrColour(COLOUR)
        character(len=*) COLOUR ! Colour name (see below)
        ! Short-name : GCOL
        ! Colour name Equivalent IGrColourN
        ! 8-bit colour number
        ! Equivalent IGrColourN
        ! 24-bit colour number
        ! black 0 or 223 0
        ! red 31 255
        ! yellow 63 65535
        ! green 95 65280
        ! cyan 127 16776960
        ! blue 159 16711680
        ! magenta 191 16711935
        ! white 223 or 0 16777215
        ! Selects the graphics colour for lines, points, text and fills, using a colour name. The
        ! colour can be specified in full for readability or it can be any unambiguous abbreviation
        ! (i.e. BLA, C, R, BLU, Y, M, G, W). If an unrecognised colour name is specified,IGrColour has no effect.
        ! IGrColour is a more readable alternative to the IGrColourN routine which selects
        ! a colour by number. IGrColour converts the supplied name into an equivalent
        ! INTERACTER colour number which corresponds to a full intensity shade of that colour
        ! in all palettes. Under the default 8-bit colour model, care must be taken if the palette
        ! has been redefined in any way using IGrPaletteRGB or IGrPaletteHLS, since
        ! IGrColour still assumes the default colour scheme.
        ! Requesting black or white selects a different colour number in the 8-bit colour model,depending on whether a black/white reversal has been requested via IScreenOpen or
        ! the REVERSE keyword. By default a black-background palette is used, in which case
        ! black and white select colours 0 and 223 respectively. When a white-background
        ! palette is enabled, black and white select colour numbers 223 and 0 instead.
        ! Note that two consecutive calls to IGrColour and/or IGrColourN will select the
        ! colours to be used by mixed-colour area fills (see IGrFillPattern). The default
        ! foreground colour at initialisation is white.
        ! See also IGrHardColourToPen which controls the mapping between
        ! INTERACTER 8-bit colour numbers and certain hardcopy driver pen/colour numbers.
        !e.g.
        !C the following calls are equivalent in the 8-bit colour model
        !CALL IGrColour('Red')
        !CALL IGrColourN(31)
        !Errors and Portability notes :
        !See IGrColourN
        !INTERACTER Subroutine Reference Graphics Style Selection
        !1-15
    end subroutine

    subroutine IGrColourModel(NBITS)
        integer NBITS ! Colour model : 8 or 24 bits
        ! Selects the current colour model used by IGrColourN, IPgStyle, etc. NBITS
        ! should either be 8, for an 8-bit/256-colour palette based colour model, or 24 for a 24-
        ! bit RGB based model.
        ! By default, an 8-bit model is used, where colours are specified as values in the range 0-
        ! 255. These represent index values in a nominal 256 colour palette. On devices which
        ! support fewer than 256 simultaneous colours, INTERACTER automatically uses a
        ! subset of this palette. Each of the 256 colours in the 8-bit palette can be redefined using
        ! a 24-bit RGB value via IGrPaletteRGB, but no more than 256 colours are available
        ! at one time.
        ! When the 24-bit colour model is selected, colours are specified to IGrColourN or
        ! IPgStyle as an RGB value of the form red+256*green+256*256*blue. This
        ! eliminates the indirection enforced by the use of a palette and allows for a theoretical
        ! maximum of 16 million simultaneous colours. This colour specification model does not
        !necessarily require a device which supports full 24-bit colour (e.g. it can be used
        !successfully on a 16-bit colour display). Where a target device, screen mode or
        !hardcopy/export format does not support 24-bit/RGB colour specification.
        !INTERACTER identifies the nearest matching colour in its own nominal 8-bit palette
        !and uses the corresponding 8-bit colour number as though that had been specified
        !directly to IGrColourN or IPgStyle. This allows the 24-bit colour model to be
        !used on all devices and with all formats with no significant loss of generality.
        !The ability of the current screen or hardcopy driver to take advantage of 24-bit colour
        !specification is reported by InfoGrScreen(42) and InfoGrHardcopy(42).
        !While it is generally advisable to select a single colour model throughout an
        !application, it is feasible to switch between colour models as needed. Internally,INTERACTER stores the 'current' colour both as an 8-bit colour index and as a 24-bit
        !RGB value, so changes in the current colour model should be transparent to the
        !underlying screen and hardcopy drivers.
        !See IGrColourN for a further explanation of the implications of calling this routine.
        !e.g.
        !C select bright red in any of three different ways
        !CALL IGrColour('Red')
        !CALL IGrColourModel(8)
        !CALL IGrColourN(31)
        !CALL IGrColourModel(24)
        !CALL IGrColourN(255)
        !Portability notes :
        !See IGrColourN
        !Graphics Style Selection INTERACTER Subroutine Reference
        !1-16
    end subroutine

    subroutine IGrColourN(NCOLOR)
        integer NCOLOR ! Colour number
        ! 8-bit model : 0-255
        ! 24-bit model : Red + Green*256 + Blue *256*256
        ! Selects the graphics colour for lines, points, text and fills, using a single colour number.
        ! The meaning and valid range of NCOLOR depends on the colour model selected by
        ! IGrColourModel:
        ! 8-bit Colour model
        ! By default, INTERACTER uses an 8-bit colour numbering scheme based on a device
        ! independent palette of 256 colours. The same colour numbers are used regardless of the
        ! actual number of colours available on the output device. INTERACTER performs an
        ! internal mapping between its device independent colour scheme and the actual colour
        ! numbers used by the current hardware. The 256 colour numbers are organised into 16
        ! groups, each consisting of 16 shades of a given colour. On devices which support less
        ! than 256 colours, INTERACTER sub-divides the palette according to the number of
        ! available colours. For example, where only 16 colours are available, values of 16-31 all
        ! give bright red. Each colour in the palette can be redefined via IGrPaletteRGB or
        ! IGrPaletteHLS, giving a maximum of 256 simultaneously different colours
        ! selected from a theoretical palette of 16 million.
        ! 24-bit Colour model
        ! When the alternative 24-bit colour model is selected, NCOLOR specifies, the exact
        ! combination of red, green and blue to be used, according to the formula shown above.
        ! Each of the red, green and blue components should be specified as a value in the range
        ! 0-255. This gives a theoretical maximum of 16 million simultaneously different
        ! colours. On devices where 24-bit colour selection is not supported, INTERACTER
        ! identifies the nearest equivalent colour in its 8-bit palette and treats the resulting colour
        ! number as though it had been selected using the 8-bit colour model.
        ! 8-bit versus 24-bit ?
        ! So which of the above colour models should a program use ? INTERACTER.s 8-bit
        ! colour model was devised in the late 1980's when 24-bit colour hardware was rare
        ! and/or expensive. Applications developed using earlier releases of INTERACTER will
        ! therefore exclusively use the 8-bit model, so this is the default for compatibility
        ! reasons. However, modern hardware offers cheap access to 24-bit colour (or 16-bit
        ! colour which INTERACTER treats as logically equivalent). Use of the 24-bit model is
        ! therefore recommended in new development. This is particularly true, given that
        ! INTERACTER will automatically determine the equivalent 8-bit palette value to use if
        ! 24-bit colour is not available.
        ! More about the 8-bit Colour Model
        ! While the 24-bit colour model may be preferable in new software, a lot of code will
        ! already exist which uses the default 8-bit model. The following notes therefore apply
        ! specifically to the 8-bit colour model:
        !   Colour zero is treated specially by INTERACTER as the background colour. This
        ! can still be selected as the current graphics colour, enabling you to draw or fill in
        ! one foreground colour and then plot on top of that using the current background
        ! colour.
        ! INTERACTER Subroutine Reference Graphics Style Selection
        ! 1-17
        !   The default palette associated with the INTERACTER 8-bit colour model is as
        ! follows (values are (r,g,b) triplets where maximum intensity = 255) :
        ! Actual
        ! Colour
        ! Colour
        ! #
        ! 256-colour
        ! palette
        ! Black 0-15 ( 0, 0, 0)  ( 60, 60, 60)
        ! Light red 16-31 (195, 0, 0)  (255, 0, 0)
        ! Dark red 32-47 (131, 0, 0)  (191, 0, 0)
        ! Light yellow 48-63 (195,195, 0)  (255,255, 0)
        ! Dark yellow 64-79 (131,131, 0)  (191,191, 0)
        ! Light green 80-95 ( 0,195, 0)  ( 0,255, 0)
        ! Dark green 96-111 ( 0,131, 0)  ( 0,191, 0)
        ! Light cyan 112-127 ( 0,195,195)  ( 0,255,255)
        ! Dark cyan 128-143 ( 0,131,131)  ( 0,191,191)
        ! Light blue 144-159 ( 0, 0,195)  ( 0, 0,255)
        ! Dark blue 160-175 ( 0, 0,131)  ( 0, 0,191)
        ! Light magenta 176-191 (195, 0,195)  (255, 0,255)
        ! Dark magenta 192-207 (131, 0,131)  (191, 0,191)
        ! White 208-223 (195,195,195)  (255,255,255)
        ! Light grey 224-239 (131,131,131)  (191,191,191)
        ! Dark grey 240-255 ( 64, 64, 64)  (124,124,124)
        ! In 16 and 8 colour output, a subset of the above palette is used :
        ! Actual
        ! Colour
        ! Colour
        ! #
        ! 16-colour
        ! palette
        ! 8-colour
        ! palette
        ! Black 0-15 ( 0, 0, 0) ( 0, 0, 0)
        ! Light red 16-31 (255, 0, 0) (255, 0, 0)
        ! Dark red 32-47 (191, 0, 0) (255, 0, 0)
        ! Light yellow 48-63 (255,255, 0) (255,255, 0)
        ! Dark yellow 64-79 (191,191, 0) (255,255, 0)
        ! Light green 80-95 ( 0,255, 0) ( 0,255, 0)
        ! Dark green 96-111 ( 0,191, 0) ( 0,255, 0)
        ! Light cyan 112-127 ( 0,255,255) ( 0,255,255)
        ! Dark cyan 128-143 ( 0,191,191) ( 0,255,255)
        ! Light blue 144-159 ( 0, 0,255) ( 0, 0,255)
        ! Dark blue 160-175 ( 0, 0,191) ( 0, 0,255)
        ! Light magenta 176-191 (255, 0,255) (255, 0,255)
        ! Dark magenta 192-207 (191, 0,191) (255, 0,255)
        ! White 208-223 (255,255,255) (255,255,255)
        ! Light grey 224-239 (191,191,191) (255,255,255)
        ! Dark grey 240-255 ( 64, 64, 64) ( 0, 0, 0)
        ! Graphics Style Selection INTERACTER Subroutine Reference
        ! 1-18
        ! If black and white are reversed, by specifying a 'W' in the TYPE argument to
        ! IScreenOpen (or via the REVERSE initialisation file keyword), black, grey and
        ! white shades are exchanged to give the following alternative palette :
        ! Actual
        ! Colour
        ! Colour
        ! #
        ! 256-colour
        ! palette
        ! White 0-15 (255,255,255)  (195,195,195)
        ! Light red 16-31 (195, 0, 0)  (255, 0, 0)
        ! Dark red 32-47 (131, 0, 0)  (191, 0, 0)
        ! Light yellow 48-63 (195,195, 0)  (255,255, 0)
        ! Dark yellow 64-79 (131,131, 0)  (191,191, 0)
        ! Light green 80-95 ( 0,195, 0)  ( 0,255, 0)
        ! Dark green 96-111 ( 0,131, 0)  ( 0,191, 0)
        ! Light cyan 112-127 ( 0,195,195)  ( 0,255,255)
        ! Dark cyan 128-143 ( 0,131,131)  ( 0,191,191)
        ! Light blue 144-159 ( 0, 0,195)  ( 0, 0,255)
        ! Dark blue 160-175 ( 0, 0,131)  ( 0, 0,191)
        ! Light magenta 176-191 (195, 0,195)  (255, 0,255)
        ! Dark magenta 192-207 (131, 0,131)  (191, 0,191)
        ! Black 208-223 ( 60, 60, 60)  ( 0, 0, 0)
        ! Dark grey 224-239 (124,124,124)  ( 64, 64, 64)
        ! Light grey 240-255 (191,191,191)  (131,131,131)
        ! The 16 and 8 colour palettes then become:
        ! Actual
        ! Colour
        ! Colour
        ! #
        ! 16-colour
        ! palette
        ! 8-colour
        ! palette
        ! White 0-15 (255,255,255) (255,255,255)
        ! Light red 16-31 (255, 0, 0) (255, 0, 0)
        ! Dark red 32-47 (191, 0, 0) (255, 0, 0)
        ! Light yellow 48-63 (255,255, 0) (255,255, 0)
        ! Dark yellow 64-79 (191,191, 0) (255,255, 0)
        ! Light green 80-95 ( 0,255, 0) ( 0,255, 0)
        ! Dark green 96-111 ( 0,191, 0) ( 0,255, 0)
        ! Light cyan 112-127 ( 0,255,255) ( 0,255,255)
        ! Dark cyan 128-143 ( 0,191,191) ( 0,255,255)
        ! Light blue 144-159 ( 0, 0,255) ( 0, 0,255)
        ! Dark blue 160-175 ( 0, 0,191) ( 0, 0,255)
        ! Light magenta 176-191 (255, 0,255) (255, 0,255)
        ! Dark magenta 192-207 (191, 0,191) (255, 0,255)
        ! Black 208-223 ( 0, 0, 0) ( 0, 0, 0)
        ! Dark grey 224-239 ( 64, 64, 64) ( 0, 0, 0)
        ! Light grey 240-255 (191,191,191) (255,255,255)
        ! INTERACTER Subroutine Reference Graphics Style Selection
        ! 1-19
        !   On monochrome devices colour zero selects the background colour and any nonzero
        ! colour number is treated as a foreground colour. The default monochrome
        ! palette is white-on-black unless reversed by IScreenOpen or the REVERSE
        ! keyword.
        !   Whatever 8-bit colour number is used, IGrColourN has no effect on the actual
        ! colour which is associated with that number. It simply sets the logical colour
        ! number to be used by any following graphics operations. To redefine the
        ! association of displayed colours with logical colours you should use
        ! IGrPaletteRGB or IGrPaletteHLS. Note that IGrColour allows colours
        ! to be selected by name, but is otherwise identical to calling IGrColourN.
        !   IGrHardColourToPen controls the mapping between 8-bit colour numbers and
        ! certain hardcopy driver pen/colour numbers.
        !   Requesting a colour number outside the range 0-255, in the 8-bit model, is ignored
        ! and an error code is set.
        !   The number of colours available in the 8-bit colour model can be checked using
        ! InfoGrScreen and InfoGrHardcopy with ITEM values of 30 and 31. (The
        ! actual number of screen colours in a windowing environment may be different and
        ! can be obtained via InfoScreen(9).)
        ! When the 24-bit colour model is selected, but the current display or output format does
        !not allow 24-bit colour selection (e.g. a 256 colour screen), INTERACTER reverts
        !internally to using the 8-bit colour model and all of the above rules apply even though
        !the 8-bit model was not explicitly requested. InfoGrScreen(42) and
        !InfoGrHardcopy(42) report the ability of the current screen or hardcopy/export
        !driver to take advantage of 24-bit colour specification.
        !Two consecutive calls to IGrColourN and/or IGrColour will select the colours to
        !be used by mixed-colour area fills (see IGrFillPattern). The two most recently
        !requested colours are available via InfoGrScreen(34) and (35). The default
        !graphics colour at initialisation is black.
        !See the col256 and col24bit demo programs which illustrate both colour selection
        !methods.
        !e.g. DO 100 ICOL = 31,255,32
        !CALL IGrColourN(ICOL)
        !CALL IGrMoveTo(0.0,0.0)
        !CALL IGrLineToRel(0.,REAL(ICOL))
        !100 CONTINUE
        !Errors :
        !ErrColourFail (39) : Failed to select requested colour. Current colour unchanged
        !ErrBadColour (42) : Unknown colour number. Current colour unchanged
        !Portability notes :
        !DOS :
        !Support for 24-bit colour is limited to hardcopy output. 24-bit colour screen modes are
        !not supported.
        !Graphics Style Selection INTERACTER Subroutine Reference
        !1-20
        !MS Windows and Xlib:
        !The number of colours supported by INTERACTER's 8-bit colour model is related to
        !the number of colours provided by the Windows video driver or the X server (the
        !number of colours specified to IScreenOpen, IGrInit or IScreenMode is not
        !relevant) :
        !Available Screen Size of 8-bit Palette
        !Colours used by INTERACTER
        !2 2
        !16 8
        !256 16/32/64/128
        !32k/65k/16M 256
        !On a 256 colour screen, a 16-colour palette is used as shown in the earlier tables.
        !However, a larger palette of 32, 64 or 128 colours can optionally be used in such a
        !video mode, as specified via IScreenModeOptions(12,n). When a 32/16/128
        !colour palette is selected, the default 256-colour palette is sub-divided accordingly (e.g.
        !in a 32-colour palette, colours 0-7 are the same whereas in a 64 colour palette only
        !colours 0-3 are the same).
        !When the 24-bit colour model is requested, INTERACTER will use the supplied RGB
        !values directly on 15/16/24/32 bit colour displays and will revert to its 8-bit model
        !internally on 2/16/256 colour displays.
        !Tektronix:
        !On a standard Tek 401x, IGrColourN has no effect. On such displays
        !InfoGrScreen(30) returns 1 indicating that there is only one plotting colour. Eight
        !colours are supported on Tek 4105 compatible displays or 16 colours on a Tek
        !4107/420x.
        !On a VT240 compatible device (including VT330, Smarterm 340 and DOS Reflection)
        !the comments for monochrome modes apply. i.e. 0 selects the background colour, any
        !other value selects the foreground colour. InfoGrScreen(30) will return 2.
        !16 colours are supported on a PC running ZSTEM240, Kermit, Reflection for
        !Windows, Tera Term Pro or EM4105.
        !24-bit colour selection is not available.
        !ReGIS :
        !On a VT240 or VT330 black, white and two shades of grey are supported. On a VT241
        !4 colours (black, red, green and blue) are supported. A VT340 supports the normal 16
        !colour palettes described earlier. 24-bit colour selection is not available.
        !Windows Print Manager :
        !The number of available colours is dependent on the installed Windows printer driver.
        !The 24-bit colour model is fully supported.
        !HP-GL and Lotus PIC :
        !The 24-bit colour model has no effect, except that 24-bit RGB values are logged for
        !replay purposes in HP-GL files, allowing them to be reproduced by IGrReplay when
        !reimported. See also IGrHardColourToPen.
        !INTERACTER Subroutine Reference Graphics Style Selection
        !1-21
        !Raster hardcopy driver :
        !On colour HP and Epson/IBM printers, the raster driver supports an 8 colour palette for
        !line drawing. Fills use dithering which allows the full range of 256 or 16 million
        !colours to be supported in the 8 or 24 bit colour models. Palette changes in the 8-bit
        !colour model via IGrPaletteRGB or IGrPaletteHLS are supported.
        !Raster image file driver :
        !The virtual raster image file driver can create 1/4/8/24-bit colour PCX/BMP files (i.e.
        !2, 16, 256 or 16 million colours). 8-bit palette information is used in 16/256 colour
        !files. 24-bit files can be generated to take full advantage of the 24-bit colour model, by
        !setting hardcopy option 23 to 24.
        !HP-GL/2, PostScript, CGM, WMF :
        !The full 256 colour palette is supported in the 8-bit colour model. The 24-bit colour
        !model is also supported. Use of colour is affected by IGrHardCopyOptions.
        !DXF :
        !The DXF driver will select the nearest matching colour in the standard 255 colour
        !AutoCAD palette. In practice, the default INTERACTER palette is very differently
        !organised to the AutoCAD palette, so far fewer than 255 distinct colours will actually
        !be used. See the dxfcolor demo and the DXF section of the Graphics
        !Hardcopy/Export Drivers chapter in the User Guide.
        !Graphics Style Selection INTERACTER Subroutine Reference
        !1-22
!        type(Fields), pointer :: this
!        this => this_
!        
!        if (this%activeColor == this%colors(NCOLOR)) return
!
!        call flushLine(this)
!        call ensureDrawing(this)
!        call setLineColor(this%canvas, this%colors(NCOLOR))
!        call setFillColor(this%canvas, this%colors(NCOLOR))
!
!        this%activeColor = this%colors(NCOLOR)
    end subroutine

    subroutine IGrFillPattern(ISTYLE,IDENSE,IANGLE)
        integer ISTYLE ! Fill style
        ! Outline (0) : outline only (default)
        ! Hatched (1) : hatched
        ! HatchedNoOut (-1) : hatched, no outline
        ! CrossHatch (2) : cross-hatched
        ! CrossHatchNoOut (-2) : cross-hatched, no outline
        !MixedColour (3) : mixed-colours (e.g. stippled)
        !Solid (4) : solid colour
        INTEGER IDENSE ! Hatched fill density
        !Sparse (1) : sparse
        !Medium (2) : medium (default)
        !Dense1 (3) : dense
        !Dense2 (4) : very dense
        !Dense3 (5) : very very dense
        !or = Arc outline radial selector (if ISTYLE=0)
        !ArcToCentre (1) : Join arc outline to centre of
        !circle (default)
        !NoArcCentre (3) : Don't join arc outline to centre
        INTEGER IANGLE ! Hatched line angle
        !DiagUp (1) : diagonal lines, sloping up
        !DiagDown (2) : diagonal lines, sloping down
        !FillHoriz (3) : horizontal lines (default)
        !FillVertic (4) : vertical lines
        !Short-name : GFILL
        !Include : intergs.inc
        !IGrFillPattern defines the fill pattern, if any, to be used by the shape drawing
        !routines: IGrRectangle, IGrTriangle, IGrEllipse, IGrCircle, IGrArc,IGrArrow, IGrParallel, IGrTrapezium, (and their relative plotting
        !equivalents) or IGrPolygonSimple and IGrPolygonComplex.
        !The default fill style is zero which gives outlines only. In this case, the density and
        !angle parameters are ignored, except when plotting arc outlines using
        !IGrArc/IGrArcRel. In this case an IDENSE value of 1 or 2 causes the arc outline
        !to be joined to the circle centre by radial lines, otherwise these are not drawn.
        !Hatched fills draw lines at intervals across the area to be filled. If a hatched fill is
        !selected, the density and angle parameters define the precise style of the fill. A dense
        !fill uses roughly twice as many lines to fill the area as a sparse fill. The angle parameter
        !controls the direction of the fill lines. Type 1 hatched fills draw lines in one direction
        !only, but type 2 (cross-hatched) fills draw lines in two directions, according to the
        !selected IANGLE value. Hatched fills are normally drawn with an outline. Specify a
        !negative ISTYLE value to suppress this outline.
        !Diagonal fills in both directions are only available when filling rectangles. When filling
        !parallelograms, diagonal fills always follow the slope of the parallelogram itself. The
        !triangle, trapezium, circle, ellipse, arc and polygon routines only support vertical and
        !horizontal fills, so requesting diagonal fills will select the default horizontal.
        !INTERACTER Subroutine Reference Graphics Style Selection
        !1-23
        !Type 4 (solid) fills use a pure colour, as most recently defined by a call to IGrColour
        !or IGrColourN. On devices which do not support fill primitives, a series of adjacent
        !horizontal lines are drawn to fill the area. This is slower, but achieves the same effect.
        !Type 3 (mixed) fills are similar to solid ones, except that the two colours as defined by
        !the last two calls to IGrColour/IGrColourN are mixed. Hence if two successive
        !calls to IGrColour specify Yellow then Red, a type 3 fill will mix these colours.
        !Usually, this will either use a stippled fill (where alternate pixels are plotted in each
        !colour) or an (r,g,b) value will be selected which is exactly halfway between the two
        !specified colours. This can give the appearance of many more colour shades than some
        !devices actually support. Selecting the same colour twice in succession gives a solid
        !fill. On monochrome devices, the foreground/background colours are automatically
        !mixed in stippled fills, regardless of the last two colours specified, unless those colours
        !were identical in which case a solid fill is selected. On devices which do not support
        !stippled fills, colour mixing is achieved using horizontal fill lines of alternating colour.
        !When solid/mixed-colour fills are requested, angle and density are ignored. The
        !availability of fast solid/stippled fills can be checked using the InfoGrScreen
        !function.
        !When hardcopy output is selected using IGrHardCopy, certain drivers perform solid
        !and mixed-colour fills by drawing extremely dense hatched fills, the precise density of
        !which can be controlled using IGrHardCopyOptions(12,n). Device fill
        !primitives may also be selectable in such drivers, by calling
        !IGrHardCopyOptions(25,1). See IGrHardCopyOptions in section 1.6 and
        !the hardcopy driver notes in chapter 17 of the User Guide.
        !Under Fortran 90 compilers, IDENSE and IANGLE have OPTIONAL attributes, whn
        !the INTERACTER module is USE'd.
        !If an invalid style, density or angle is specified (or density and angle arguments are
        !omitted in Fortran 90), then the indicated defaults are used.
        !e.g. CALL IGrFillPattern(1,2,3)
        !CALL IGrRectangle(100.,0.0,200.,1000.)
        !CALL IGrColourN(48)
        !CALL IGrColourN(144)
        !CALL IGrFillPattern(3,1,1)
        !CALL IGrCircle(150.,500.,30.)
        !Portability notes :
        !Tektronix :
        !Solid and stippled fill primitives are supported on a Tek 410x/420x and on a PC
        !running EM4105. Solid and stippled rectangle fills are supported under PC/Kermit v3.
        !On other Tektronix-type terminals, solid and mixed fills are generated by drawing a
        !series of adjacent horizontal lines across the area to be filled. This requires that the
        !physical pixel resolution of the screen be accurately defined. The resolution
        !information held in the library may not exactly match that of the current display. If
        !solid fills appear with gaps then the PIXELH and/or the PIXELV keywords can be
        !used to define the true pixel resolution of the screen. See chapter 14 of the User Guide.
        !ReGIS :
        !Solid fills are fully supported. Mixed fills give horizontal lines of alternate colours.
        !This is not quite as satisfactory as a true stippled fill but is adequate for many purposes.
        !Graphics Style Selection INTERACTER Subroutine Reference
        !1-24
    end subroutine

    subroutine IGrLineType(LTYPE)
        integer LTYPE ! Line type:
        ! SolidLine (0) : Solid (default)
        ! Dotted (1) : Dots
        ! Dashed (2) : Dashes
        ! DotDash (3) : Dot/dash
        ! DotDotDash (4) : Dot/dot/dash ) May be
        ! LongShort (5) : Long/short dashes ) device
        ! ShortDash (6) : Short dashes ) dependent
        ! Short-name : GLITYP
        ! Include : intergs.inc
        ! Selects the line type for subsequent drawing. Calling IGrLineType restarts the
        ! specified dot pattern, even if that pattern was already selected.
        ! Line type 4 is partly device dependent, and may thus sometimes use a different pattern.
        ! It will however always be distinguishable from line types 0-3, so long as broken lines
        ! are supported. Line types 5 and/or 6 are not available on certain devices, in which case
        ! they duplicate the nearest equivalent line type on that device.
        ! Under Fortran 90 compilers, LTYPE has the OPTIONAL attribute. Solid lines are
        ! selected if it is omitted. This feature requires that calling programs USE the
        ! INTERACTER module.
        ! The currently requested line type is available via InfoGrScreen(36). Broken line
        ! support is reported via InfoGrScreen(6) and InfoGrHardcopy(6).
        !e.g. CALL IGrLineType(1)
        !C draw a grid of dotted lines
        !DO 100 A = 0.1,0.91,0.1
        !CALL IGrMoveTo(0.0,A)
        !CALL IGrLineToRel(1.0,0.0)
        !CALL IGrMoveTo(A,0.0)
        !CALL IGrLineToRel(0.0,1.0)
        !100 CONTINUE
        !Portability notes :
        !MS Windows :
        !Only 5 line types are available in GDI output (i.e. Windows screen, printer and
        !metafile). Line types 2 and 3 duplicate 6 and 5 respectively. See also IGrLineWidth.
        !Tektronix :
        !Broken lines require a Tek4014 compatible device (e.g. VT240, Tek 410x/420x, etc.).
        !On 4010 displays all lines are solid and calls to IGrLineType will have no effect.
        !Support for line types 4-6 varies widely between nominally Tek4014 compatible
        !devices. Only 5 different line types are supported on DEC VT terminals. The same
        !restriction applies to xterm, Falco terminals, DOS Reflection and Smarterm 340. On
        !these devices, line types 4 and 6 both give short dashes. Similarly, line types 3 and 5
        !are also identical. Tera Term Pro also supports 5 line types, with line types 6 and 5
        !duplicating types 2 and 3 respectively.
        !INTERACTER Subroutine Reference Graphics Style Selection
        !1-25
        !On a true 4014 compatible device all 7 line types are available, but line type 4 appears
        !as three dots and a dash. However several 4014 or VT240 emulators use 2 dots and a
        !dash. Kermit 3, ZSTEM, Reflection 4 for Windows and Tek 410x compatible displays
        !support all 7 line types.
    end subroutine

    subroutine IGrLineWidth(ISCRNW,IHARDW)
        integer ISCRNW ! Screen line width in pixels
        integer IHARDW ! Hardcopy line width in tenths of a point
        ! Include : intergs.inc
        ! Sets the line width independently for screen and hardcopy output. The default screen
        ! line width is one pixel. Setting hardcopy line width via IHARDW is identical to calling
        ! IGrHardcopyOptions(9,n).
        ! Under Fortran 90 compilers, ISCRNW and IHARDW have the OPTIONAL attribute in
        ! calling programs which USE the INTERACTER module. When these arguments are
        ! omitted, or specified with a non-positive value, the corresponding screen or hardcopy
        ! line width parameter is left unchanged,Support for line width control can be interrogated via InfoGrScreen(41) or
        ! InfoGrHardcopy(41).
        !e.g.
        !C draw 9 vertical lines of increasing width on screen
        !DO 100 I = 1,9
        !CALL IGrLineWidth(I,-1)
        !X = REAL(I)/10.
        !CALL IGrJoin(X,0.0,X,1.0)
        !100 CONTINUE
        !Portability notes :
        !MS Windows :
        !Under Windows 9x/Me, GDI output to the screen, Print Manager or a WMF/EMF
        !metafile will normally give a solid line when a line width greater than one device unit is
        !selected. The same effect will be observed under NT/2000 in 16-bit WMF files. This is
        !a limitation imposed by the the Windows GDI, though some Windows 9x/Me printer
        !drivers ignore this restriction and render thickened non-solid lines correctly. Windows
        !NT/2000 renders thickened lines correctly in screen, printer and Enhanced metafile
        !output.
        !Tektronix & ReGIS terminals:
        !Graphics terminals do not support line width control.
        !Graphics Style Selection INTERACTER Subroutine Reference
        !1-26

!        type(Fields), pointer :: this
!        integer(INT32) w
!        this => this_
!        w = ISCRNW
!        call setLineWidth(this%canvas, w)
    end subroutine

    subroutine IGrPaletteHLS(NCOLOR,IHUE,LIGHT,ISATUR)
        integer NCOLOR ! 8-bit colour number (0-255)
        integer IHUE ! Hue expressed as an angle (0-359)
        ! 0=Blue 60=Magenta 120=Red
        ! 180=Yellow 240=Green 300=Cyan
        integer LIGHT ! Lightness as a percentage (0=Black 100=White)
        integer ISATUR ! Saturation (0=Grey 100=Pure colour)
        ! Short-name : GPAHLS
        ! Controls the 8-bit graphics colour palette, using the Hue, Lightness and Saturation
        ! (HLS) colour model. HLS defines colour in terms of a position within a pair of cones.
        ! Full intensity colours occur when LIGHT=50 and ISATUR=100. LIGHT specifies a
        ! shade of grey when zero saturation is specified.
        ! This routine is an alternative to IGrPaletteRGB which defines the palette in terms
        ! of red, green and blue components which are more easily visualised than HLS.
        ! Internally, IGrPaletteHLS converts the required colour to RGB, where necessary.
        ! For more information on palette redefinition see IGrPaletteRGB.
        ! This routine only affects the colours used by the 8-bit colour model. However, bear in
        ! mind that this colour model can still be employed internally on certain devices, even
        ! when the 24-bit colour model has been selected.
        !e.g.
        !C define background colour as mid grey and colour 7 as pure yellow
        !CALL IGrPaletteHLS(0,0,50,0)
        !CALL IGrPaletteHLS(7,180,50,100)
        !Portability notes :
        !See IGrPaletteRGB.

!        type(Fields), pointer :: this
!        real(FLOAT) h
!        real(FLOAT) l
!        real(FLOAT) s
!
!        this => this_
!        call flushLine(this)
!
!        h= IHUE
!        l = real(LIGHT) / 100
!        s = real(ISATUR) / 100
!
!        this%colors(NCOLOR) = ColorUtils_getRGBFromHLS(h, l, s)
    end subroutine

    subroutine IGrPaletteInit
        ! Reinitialises the graphics palette to the default settings as documented under
        ! IGrColourN.
        ! Portability notes :
        ! See IGrPaletteRGB.
        ! INTERACTER Subroutine Reference Graphics Style Selection
        ! 1-27
        
!        type(Fields), pointer :: this
!        integer(INT32), dimension(:), pointer :: colors
!        
!        this => this_
!        
!        colors => this%colors
!
!        colors(0) = 0
!        colors(1) = 263172
!        colors(2) = 0
!        colors(3) = 789516
!        colors(4) = 1052688
!        colors(5) = 1315860
!        colors(6) = 1579032
!        colors(7) = 1842204
!        colors(8) = 2105376
!        colors(9) = 2368548
!        colors(10) = 2631720
!        colors(11) = 2894892
!        colors(12) = 3158064
!        colors(13) = 3421236
!        colors(14) = 3684408
!        colors(15) = 3947580
!        colors(16) = 12779520
!        colors(17) = 13041664
!        colors(18) = 13303808
!        colors(19) = 13565952
!        colors(20) = 13828096
!        colors(21) = 14090240
!        colors(22) = 14352384
!        colors(23) = 14614528
!        colors(24) = 14876672
!        colors(25) = 15138816
!        colors(26) = 15400960
!        colors(27) = 15663104
!        colors(28) = 15925248
!        colors(29) = 16187392
!        colors(30) = 16449536
!        colors(31) = 16711680
!        colors(32) = 8585216
!        colors(33) = 8847360
!        colors(34) = 9109504
!        colors(35) = 9371648
!        colors(36) = 9633792
!        colors(37) = 9895936
!        colors(38) = 10158080
!        colors(39) = 10420224
!        colors(40) = 10682368
!        colors(41) = 10944512
!        colors(42) = 11206656
!        colors(43) = 11468800
!        colors(44) = 11730944
!        colors(45) = 11993088
!        colors(46) = 12255232
!        colors(47) = 12517376
!        colors(48) = 12829440
!        colors(49) = 13092608
!        colors(50) = 13355776
!        colors(51) = 13618944
!        colors(52) = 13882112
!        colors(53) = 14145280
!        colors(54) = 14408448
!        colors(55) = 14671616
!        colors(56) = 14934784
!        colors(57) = 15197952
!        colors(58) = 15461120
!        colors(59) = 15724288
!        colors(60) = 15987456
!        colors(61) = 16250624
!        colors(62) = 16513792
!        colors(63) = 16776960
!        colors(64) = 8618752
!        colors(65) = 8881920
!        colors(66) = 9145088
!        colors(67) = 9408256
!        colors(68) = 9671424
!        colors(69) = 9934592
!        colors(70) = 10197760
!        colors(71) = 10460928
!        colors(72) = 10724096
!        colors(73) = 10987264
!        colors(74) = 11250432
!        colors(75) = 11513600
!        colors(76) = 11776768
!        colors(77) = 12039936
!        colors(78) = 12303104
!        colors(79) = 12566272
!        colors(80) = 49920
!        colors(81) = 50944
!        colors(82) = 51968
!        colors(83) = 52992
!        colors(84) = 54016
!        colors(85) = 55040
!        colors(86) = 56064
!        colors(87) = 57088
!        colors(88) = 58112
!        colors(89) = 59136
!        colors(90) = 60160
!        colors(91) = 61184
!        colors(92) = 62208
!        colors(93) = 63232
!        colors(94) = 64256
!        colors(95) = 65280
!        colors(96) = 33536
!        colors(97) = 34560
!        colors(98) = 35584
!        colors(99) = 36608
!        colors(100) = 37632
!        colors(101) = 38656
!        colors(102) = 39680
!        colors(103) = 40704
!        colors(104) = 41728
!        colors(105) = 42752
!        colors(106) = 43776
!        colors(107) = 44800
!        colors(108) = 45824
!        colors(109) = 46848
!        colors(110) = 47872
!        colors(111) = 48896
!        colors(112) = 50115
!        colors(113) = 51143
!        colors(114) = 52171
!        colors(115) = 53199
!        colors(116) = 54227
!        colors(117) = 55255
!        colors(118) = 56283
!        colors(119) = 57311
!        colors(120) = 58339
!        colors(121) = 59367
!        colors(122) = 60395
!        colors(123) = 61423
!        colors(124) = 62451
!        colors(125) = 63479
!        colors(126) = 64507
!        colors(127) = 65535
!        colors(128) = 33667
!        colors(129) = 34695
!        colors(130) = 35723
!        colors(131) = 36751
!        colors(132) = 37779
!        colors(133) = 38807
!        colors(134) = 39835
!        colors(135) = 40863
!        colors(136) = 41891
!        colors(137) = 42919
!        colors(138) = 43947
!        colors(139) = 44975
!        colors(140) = 46003
!        colors(141) = 47031
!        colors(142) = 48059
!        colors(143) = 49087
!        colors(144) = 195
!        colors(145) = 199
!        colors(146) = 203
!        colors(147) = 207
!        colors(148) = 211
!        colors(149) = 215
!        colors(150) = 219
!        colors(151) = 223
!        colors(152) = 227
!        colors(153) = 231
!        colors(154) = 235
!        colors(155) = 239
!        colors(156) = 243
!        colors(157) = 247
!        colors(158) = 251
!        colors(159) = 255
!        colors(160) = 131
!        colors(161) = 135
!        colors(162) = 139
!        colors(163) = 143
!        colors(164) = 147
!        colors(165) = 151
!        colors(166) = 155
!        colors(167) = 159
!        colors(168) = 163
!        colors(169) = 167
!        colors(170) = 171
!        colors(171) = 175
!        colors(172) = 179
!        colors(173) = 183
!        colors(174) = 187
!        colors(175) = 191
!        colors(176) = 12779715
!        colors(177) = 13041863
!        colors(178) = 13304011
!        colors(179) = 13566159
!        colors(180) = 13828307
!        colors(181) = 14090455
!        colors(182) = 14352603
!        colors(183) = 14614751
!        colors(184) = 14876899
!        colors(185) = 15139047
!        colors(186) = 15401195
!        colors(187) = 15663343
!        colors(188) = 15925491
!        colors(189) = 16187639
!        colors(190) = 16449787
!        colors(191) = 16711935
!        colors(192) = 8585347
!        colors(193) = 8847495
!        colors(194) = 9109643
!        colors(195) = 9371791
!        colors(196) = 9633939
!        colors(197) = 9896087
!        colors(198) = 10158235
!        colors(199) = 10420383
!        colors(200) = 10682531
!        colors(201) = 10944679
!        colors(202) = 11206827
!        colors(203) = 11468975
!        colors(204) = 11731123
!        colors(205) = 11993271
!        colors(206) = 12255419
!        colors(207) = 12517567
!        colors(208) = 12829635
!        colors(209) = 13092807
!        colors(210) = 13355979
!        colors(211) = 13619151
!        colors(212) = 13882323
!        colors(213) = 14145495
!        colors(214) = 14408667
!        colors(215) = 14671839
!        colors(216) = 14935011
!        colors(217) = 15198183
!        colors(218) = 15461355
!        colors(219) = 15724527
!        colors(220) = 15987699
!        colors(221) = 16250871
!        colors(222) = 16514043
!        colors(223) = 16777215
!        colors(224) = 8618883
!        colors(225) = 8882055
!        colors(226) = 9145227
!        colors(227) = 9408399
!        colors(228) = 9671571
!        colors(229) = 9934743
!        colors(230) = 10197915
!        colors(231) = 10461087
!        colors(232) = 10724259
!        colors(233) = 10987431
!        colors(234) = 11250603
!        colors(235) = 11513775
!        colors(236) = 11776947
!        colors(237) = 12040119
!        colors(238) = 12303291
!        colors(239) = 12566463
!        colors(240) = 4210752
!        colors(241) = 4473924
!        colors(242) = 4737096
!        colors(243) = 5000268
!        colors(244) = 5263440
!        colors(245) = 5526612
!        colors(246) = 5789784
!        colors(247) = 6052956
!        colors(248) = 6316128
!        colors(249) = 6579300
!        colors(250) = 6842472
!        colors(251) = 7105644
!        colors(252) = 7368816
!        colors(253) = 7631988
!        colors(254) = 7895160
!        colors(255) = 8158332
!        
    end subroutine

    subroutine IGrPaletteRGB(NCOLOR,IRED,IGREEN,IBLUE)
        integer NCOLOR ! 8-bit colour number (0-255)
        integer IRED ! Amount of red to assign to displayed colour (0-255)
        integer IGREEN ! Amount of green to assign to displayed colour (0-255)
        integer IBLUE ! Amount of blue to assign to displayed colour (0-255)
        ! Short-name : GPARGB
        ! Controls the 8-bit graphics colour palette, using the Red/Green/Blue (RGB) colour
        ! scheme. An actual colour combination is assigned to a specified 8-bit colour number.
        ! On a screen, redefinition of the palette may take place immediately (but see the
        ! Portability notes) so that all screen pixels of the specified logical colour number are
        ! displayed in the specified actual colour. Note that the whole of the background colour
        ! can be reset by calling IGrPaletteRGB with an NCOLOR value of 0.
        ! The displayed colour is specified in terms of its RGB components. Since the number of
        ! colours available on different devices varies widely, the RGB components are
        ! expressed in an arbitrary range of 0-255. In theory this allows for up 16 million
        ! different colours. In practice, many output devices support significantly fewer colours
        ! (see Portability notes), so each RGB value is scaled accordingly. For example, where a
        ! display supports 64 shades of each colour (giving 64x64x64=256k colours) each
        ! supplied RGB component will be scaled to a value in the range 0 to 15.
        ! The colour number specifies the colour which would be selected by supplying the same
        ! value to IGrColourN using the 8-bit colour model. Hence NCOLOR should lie in the
        ! range 0 to 255 and will be converted to an appropriate actual colour number for the
        ! current screen mode or output format, using the same rules as IGrColourN. When the
        ! 24-bit colour model is selected, this routine is limited to setting the RGB value in the 8-
        ! bit palette which will still be internally used on colour limited devices. The current 8-
        ! bit palette values can be interrogated via InfoGrPalette.
        ! Palette redefinition capabilities vary between devices. The following information is
        ! available via InfoGrScreen and InfoGrHardcopy in the IF group, to identify the
        ! capabilities of the current device :
        ! 1. InfoGrScreen(8) and (9) identify whether the current display supports
        ! redefinition of the background and foreground palettes respectively. Equivalent
        ! hardcopy driver information is available via InfoGrHardcopy.
        ! 2. On some devices colour redefinition only affects subsequent plotting, a condition
        ! which can be identified using InfoGrScreen(24). The same behaviour is also
        ! true of certain hardcopy drivers. Again, this can be tested for using
        ! InfoGrHardcopy(24).
        ! The default palettes are reset when IScreenOpen, IScreenMode,IScreenModeN, or IGrInit are called. See IGrColourN for a description of the
        ! colours available in the default palettes.
        ! See also IGrPaletteHLS. Internally, IGrPaletteRGB converts the required
        ! colour to HLS, where necessary.
        ! Graphics Style Selection INTERACTER Subroutine Reference
        ! 1-28
        !e.g.
        !C if foreground palette redefiniton available set to black
        !IF (InfoGrScreen(9).GT.0) CALL IGrPaletteRGB(223,0,0,0)
        !C draw some graphs in black on black, then make graphs appear
        !CALL GRAPHS
        !CALL IGrPaletteRGB(223,255,255,255)
        !Portability notes :
        !DOS :
        !All logical colours can be programmed using 64 levels of RGB component, giving
        !262,144 possible actual colours in all available graphics modes.
        !MS Windows :
        !All subsequent plotting in colour NCOLOR uses the specified RGB combination, but
        !existing graphics plotted using that colour may remain unchanged. Typically, colour
        !redefinition is only effective when the current Windows video driver operates in a
        !screen mode with 256 colours or more. When a 16-colour mode video driver is used,INTERACTER has to rely on the reserved colours provided by Windows which are not
        !redefinable. In this case the 'nearest' available colour is used when plotting
        !subsequently in colour NCOLOR.
        !On a display which provides more than 256 colours, use of the alternative 24-bit colour
        !model is recommended, since this allows RGB values to be specified directly to
        !IGrColourN, rather than indirectly via IGrPaletteRGB.
        !Xlib :
        !Palette control has been implemented so that all subsequent plotting in colour NCOLOR
        !uses the specified RGB combination. Existing graphics plotted using that colour may
        !remain unchanged. It is therefore recommended that any redefinition of the palette be
        !performed before plotting begins. If the background palette (colour 0) is redefined, call
        !IGrAreaClear after IGrPaletteRGB, to reset the background colour.
        !On a display which provides more than 256 colours, use of the alternative 24-bit colour
        !model is recommended, since this allows RGB values to be specified directly to
        !IGrColourN, rather than indirectly via IGrPaletteRGB.
        !Tektronix :
        !IGrPaletteRGB is supported on a Tektronix 410x/420x and on compatible terminal
        !emulators. Both the background and foreground colours can be redefined.
        !ReGIS :
        !Both foreground and background colours can be redefined.
        !HP-GL and Lotus PIC files :
        !Palette information is not included in HP-GL and PIC files. Use
        !IGrHardColourToPen to determine the mapping between INTERACTER and HP.
        !GL/PIC colour numbers.
        !HP-GL/2, PostScript and CGM :
        !IGrPaletteRGB affects the colours selected by these hardcopy drivers. All plotting
        !in colour NCOLOR subsequent to the call to IGrPaletteRGB will use the specified
        !RGB combination, subject to the setting of the graphics hardcopy options 6 and 7.
        !Windows Print Manager and Windows Metafiles :
        !Full palette information is included in Print Manager and WMF output. How this is
        !interpreted depends on the target printer driver or importing software.
        !INTERACTER Subroutine Reference Graphics Style Selection
        !1-29
        !Raster hardcopy :
        !Palette information is only fully used when selecting dither or grey-scale patterns for
        !area fills. Lines are drawn in the nearest of the 8 primary colours.
        !Raster Image files :
        !16-colour and 256-colour PCX/BMP files generated by the raster image file driver
        !include palette information, which can be modified by IGrPaletteRGB. All pixels of
        !the specified colour in the bit image are set to the specified RGB combination.
        !DXF :
        !Palette information is not included in DXF files. However, setting the INTERACTER
        !palette to match that used by DXF can result in significantly more colours actually
        !being used in DXF output. See the dxfcolor demo program.
!        type(Fields), pointer :: this
!        this => this_
!        call flushLine(this)
!        this%colors(NCOLOR) = IRED * 256 * 256 + IGREEN * 256 + IBLUE
    end subroutine

    subroutine IGrPlotMode(PLMODE)
        character(len=*) PLMODE ! N : Normal over-write plotting mode (default)
        ! = O : OR plotting mode
        ! = A : AND plotting mode
        ! = E : EOR/XOR (Exclusive-or) plotting mode
        ! Short-name : GPLOTM
        ! Selects the plotting mode for all lines, points, text and fills. In normal over-write mode,the line/point/text/fill simply replaces what was already on the screen. In EOR mode,
        ! the colour is exclusive or'ed with that already on the screen. The main use of this is that
        ! lines, text or whatever can be drawn in EOR mode then erased again, still using EOR
        ! mode, without disturbing what was previously on screen.
        ! Only the first character of the supplied argument is used to determine the required plot
        ! mode. If no plot mode is specified, normal plotting is the default. The plot mode
        ! argument can be in upper or lower case.
        ! Under Fortran 90 compilers, PLMODE has the OPTIONAL attribute. Normal plotting is
        ! selected if it is omitted. This feature requires that calling programs USE the
        ! INTERACTER module.
        ! Since some displays only support certain plotting modes, you should call the
        ! InfoGrScreen function to check which are available. Exclusive-or plotting is
        ! supported on the majority of displays and is generally more useful than the less
        ! commonly available AND/OR modes.
        ! Plot mode selection has no effect on hardcopy output initiated by IGrHardCopy,though it can affect screen dumps generated by IScreenDump.
        ! The currently requested plot mode is available via InfoGrScreen(37).
        !e.g. CALL IGrPlotMode('EOR')
        !C now you see it ...
        !CALL IGrPoint(X,Y)
        !CALL InKeyEvent(KEY)
        !C now you don't ...
        !CALL IGrPoint(X,Y)
        !C and back to normal
        !CALL IGrPlotMode(' ')
        !Graphics Style Selection INTERACTER Subroutine Reference
        !1-30
        !Portability notes :
        !DOS :
        !AND/OR plot modes are not available in monochrome screen modes.
        !MS Windows :
        !All four plot modes are supported. Due to a Windows GDI limitation, plot mode
        !selection does not affect hardware text, which is always drawn in normal (over-write)
        !mode. Software text must be used if plot mode control is required.
        !Xlib :
        !All four plot modes are supported, but problems with exclusive-or mode can arise on
        !colour Sun displays. Unlike most manufacturers, Sun use an internal pixel value of 1
        !for black and zero for white. EOR plotting in white on black thus has no effect ! Avoid
        !using this combination of colours and plot mode on colour Sun displays. (Note : Whilst
        !the same problem exists on monochrome Sun displays INTERACTER works round the
        !problem by using NOT(EOR) mode when EOR plotting is selected).
        !Tektronix :
        !On an unspecified Tek4010/4014 type terminal (display type 111/112) only normal
        !over-write plotting is available. Exclusive-or plotting is available on a number of
        !devices : VT240 compatible (including VT330/VT340, ZSTEM240, Smarterm 340,DOS/Reflection and Windows/Reflection), Falco Infinity and Falco 5000 series
        !ReGIS :
        !The ReGIS driver supports Exclusive-or plotting, but not OR/AND.
        !INTERACTER Subroutine Reference Graphics Primitives
        !1-31
        !1.4 Group GD : Graphics Drawing/Movement
        !This group provides the main INTERACTER graphics drawing primitives. An important
        !concept here is the 'current plotting position'. This can be set explicitly using
        !IGrMoveTo and IGrMoveToRel, but is automatically updated by many of the
        !drawing routines. You will notice that many routines have both relative and absolute
        !variants. The absolute plotting routines require an exact value at or to which plotting is
        !to be carried out. Relative plotting is always related to the 'current plotting position'.
        !You will be able to use either of the following routine types depending on your needs:
        !Absolute Relative
        !IGrArc IGrMarker IGrArcRel IGrMarkerRel
        !IGrCircle IGrParallel IGrCircleRel IGrParallelRel
        !IGrEllipse IGrPoint IGrEllipseRel IGrPointRel
        !IGrJoin IGrRectangle IGrJoinRel IGrRectangleRel
        !IGrLineTo IGrTrapezium IGrLineToRel IGrTrapeziumRel
        !IGrMoveTo IGrTriangle IGrMoveToRel IGrTriangleRel
        !Routines such as IGrArc, IGrCircle, IGrEllipse, IGrParallel,IGrRectangle, IGrTrapezium, IGrTriangle and their relative plotting
        !equivalents, can all draw shapes in a variety of styles which are determined by the
        !IGrFillPattern routine in the GS group. By default they simply draw an outline
        !of the appropriate shape, but they can also perform hatched, mixed-colour or solid fills.
        !For more general shapes, the IGrPolygonSimple and IGrPolygonComplex
        !polygon routines are also supplied. IGrPolygonGrad offers a graduated colour fill.
        !Simple straight line drawing can be performed using IGrLineTo and IGrJoin.
        !Poly-lines can be drawn by repeated calls to these routines or by calling
        !IGrPolyLine. Alternatively spline curve fitting is available using IGrCurve.
        !Arrows can be drawn using IGrArrow or IGrArrowJoin. Simple bit block
        !move/copy facilities are provided by IGrBlockMove and IGrBlockCopy.
    end subroutine

    subroutine IGrArc(XPOS,YPOS,RADIUS,SANGLE,AANGLE)
        real XPOS ! X co-ordinate of circle centre
        real YPOS ! Y co-ordinate of circle centre
        real RADIUS ! Radius of circle in current plotting units
        real SANGLE ! Arc start angle in degrees counter-clockwise from 3 o'clock
        real AANGLE ! Arc angle in degrees counter-clockwise from SANGLE
        ! Short-name : GCARCA
        ! Draws a circular arc of a given radius centred at the specified absolute plotting position,in the current graphics colour and plotting mode as selected by IGrColour,
        ! IGrColourN and IGrPlotMode. The arc will be filled, if required, using the fill
        ! pattern selected by IGrFillPattern. The current plotting position becomes
        ! (XPOS,YPOS). Aspect ratio is preserved regardless of output device.
        ! If an outline only is selected, radial lines will be drawn from the centre of the circle to
        ! the start and end of the arc, if the second parameter to IGrFillPattern is 1 or 2.
        ! This is the default.
        ! The arc angle AANGLE can be either positive or negative, but must be non-zero.
        ! Graphics Primitives INTERACTER Subroutine Reference
        ! 1-32
        !e.g. CALL IGrFillPattern(2,2,3)
        !C draw a hatched semi circle from 12 o'clock
        !C filling right hand side of circle
        !CALL IGrArc(0.5,0.5,0.3,90.,-180.)
        !Errors :
        !ErrBadRadius (20) : Radius <= zero or Arc angle = 0. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern.
    end subroutine

    subroutine IGrArcRel(RADIUS,SANGLE,AANGLE)
        real RADIUS ! Radius of circle in current plotting units
        real SANGLE ! Arc start angle in degrees counter-clockwise from 3 o'clock
        real AANGLE ! Arc angle in degrees counter-clockwise from SANGLE
        ! Short-name : GCARCR
        ! Draws a circular arc of a given radius centred at the current plotting position, in the
        ! current graphics colour and plotting mode as selected by IGrColour, IGrColourN
        ! and IGrPlotMode. The arc will be filled, if required, using the fill pattern selected by
        ! IGrFillPattern. The current plotting position is not affected. Aspect ratio is
        ! preserved regardless of output device.
        ! If an outline only is selected, radial lines will be drawn from the centre of the circle to
        ! the start and end of the arc, if the second parameter to IGrFillPattern is 1 or 2.
        ! This is the default.
        ! The arc angle AANGLE can be either positive or negative, but must be non-zero.
        !e.g. CALL IGrFillPattern(2,2,3)
        !C draw a hatched semi circle from 12 o'clock
        !C filling right hand side of circle
        !CALL IGrMoveTo(0.5,0.5)
        !CALL IGrArcRel(0.3,90.,-180.)
        !Errors :
        !ErrBadRadius (20) : Radius <= zero or Arc angle = 0. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern.
        !INTERACTER Subroutine Reference Graphics Primitives
        !1-33
    end subroutine

    subroutine IGrArrow(XPOS,YPOS,ALEN,ANGLE,IATYPE)
        real XPOS ! X co-ordinate pointed to by arrow head
        real YPOS ! Y co-ordinate pointed to by arrow head
        real ALEN ! Arrow length in X units (length when drawn at zero rotation)
        real ANGLE ! Arrow angle in degrees counter-clockwise from horiz.
        integer IATYPE ! Arrow type :
        ! 1 : Simple line arrow
        ! 2 : Outline/filled arrow (IGrFillPattern sets style)
        ! Draws an arrow pointing to the specified co-ordinate, in the current graphics colour and
        ! plotting mode as selected by IGrColour/IGrColourN/IGrPlotMode. If type 1
        ! is selected, a simple line arrow is drawn using the currently selected line type. A type 2
        ! arrow is drawn in the current fill style, as set by IGrFillPattern.
        ! The arrow can be drawn in any direction. An angle of zero gives a horizontal arrow
        ! which extends to the left from the specified position. The length of the arrow is
        ! specified in terms of the arrow length when drawn in this position using X user units.
        ! When the arrow is rotated the aspect ratio and length is maintained to ensure a
        ! consistent arrow shape regardless of its direction.
        ! Changing the graphics area dimensions so they are non-equal will deform rotated
        ! arrows in the same way as circles/ellipses/arcs
        ! On exit, (XPOS,YPOS) becomes the current plotting position. See also
        ! IGrArrowJoin.
        !e.g. CALL IGrFillPattern(4,0,0)
        !C draw solid arrow pointing straight up
        !CALL IGrArrow(XPOS,YPOS,0.3,90.0,2)
        !Portability notes :
        !See IGrFillPattern.
    end subroutine

    subroutine IGrArrowJoin(XFROM,YFROM,XTO,YTO,IATYPE)
        real XFROM ! X co-ordinate of arrow tail
        real YFROM ! Y co-ordinate of arrow tail
        real XTO ! X co-ordinate of arrow head
        real YTO ! Y co-ordinate of arrow head
        integer IATYPE ! Arrow type :
        ! 1 : Simple line arrow
        ! 2 : Outline/filled arrow (IGrFillPattern sets style)
        ! Draws an arrow connecting the specified points. Internally, IGrArrowJoin
        ! calculates the length and angle of the resulting arrow and calls IGrArrow. The notes
        ! for that routine therefore apply equally to IGrArrowJoin.
        ! On exit, (XTO,YTO) becomes the current plotting position.
        !e.g. CALL IGrFillPattern(0,0,0)
        !C draw outline arrow between two points
        !CALL IGrArrowJoin(XPOS(1),YPOS(1),XPOS(2),YPOS(2),2)
        !Portability notes :
        !See IGrFillPattern.
        !Graphics Primitives INTERACTER Subroutine Reference
        !1-34
    end subroutine

    subroutine IGrBlockCopy(XSOUR,YSOUR,XDEST,YDEST,WIDTH,HEIGHT)
        real XSOUR ! x co-ordinate of a corner of the source area
        real YSOUR ! y co-ordinate of a corner of the source area
        real XDEST ! x co-ordinate of same corner of destination area
        real YDEST ! y co-ordinate of same corner of destination area
        real WIDTH ! width of area to copy
        real HEIGHT ! height of area to copy
        ! Short-name : GBCOPY
        ! Copies a rectangular block of pixels from a source area to a destination area. The
        ! positions of the source and target areas are expressed in terms of user-coordinates as
        ! defined by IGrUnits.
        ! The source co-ordinate will normally be the lower left corner of the target area in which
        ! case both width and height will be positive. However, width and/or height can be
        ! negative if required. In all cases the destination co-ordinate specifies the same corner of
        ! the rectangle as the source co-ordinate.
        ! Where the source rectangle lies partly outside the current graphics area, only that part
        ! of the source area which lies within the graphics area is copied. Similarly, where only
        ! part of the destination area lies within the graphics area the destination image is clipped
        ! accordingly. Where either the entire source or the entire destination rectangle lies
        ! wholly outside the current graphics area, IGrBlockCopy takes no action. Also,where the source and destination coincide, IGrBlockCopy has no effect.
        ! The current plot mode, as selected by IGrPlotMode, is applied to the destination
        ! area when copying the rectangle. Hence, if exclusive-or mode has been selected, the bit
        ! block will be EOR'ed onto the target area.
        ! A number of displays support the bit-block copy operation, but some serial terminals do
        ! not. Use InfoGrScreen(16) to determine whether block copy is available.
        !e.g. X = 1.0
        !Y = 2.0
        !WID = .5
        !HGT = .5
        !CALL MYGRAF(X,Y,WID,HGT)
        !C copy image to 1 unit up and 1 across
        !CALL IGrBlockCopy(X,Y,X+1.0,Y+1.0,WID,HGT)
        !Portability notes :
        !DOS :
        !Block copy/move is supported in replace and exclusive-or modes.
        !Xlib and MS Windows :
        !Block copy/move is supported in all 4 plot modes.
        !Tektronix :
        !On a Tektronix 4107/4207/4208 block copy/move is supported in all 4 plot modes.
        !Standard Tek 4010/4014/4105 terminals do not support block copying. Some 4105
        !emulators (e.g. EM4105) implement block copying.
        !ReGIS :
        !Block copy/move operations are not supported.
        !INTERACTER Subroutine Reference Graphics Primitives
        !1-35
    end subroutine

    subroutine IGrBlockMove(XSOUR,YSOUR,XDEST,YDEST,WIDTH,HEIGHT)
        real XSOUR ! x co-ordinate of a corner of the source area
        real YSOUR ! y co-ordinate of a corner of the source area
        real XDEST ! x co-ordinate of same corner of destination area
        real YDEST ! y co-ordinate of same corner of destination area
        real WIDTH ! width of area to move
        real HEIGHT ! height of area to move
        ! Short-name : GBMOVE
        ! Moves a rectangular block of pixels from a source area to a destination area. This is
        ! exactly equivalent to calling IGrBlockCopy except that the non-overlapping part of
        ! the source area which lies within the graphics area is cleared to the background colour.
        ! Refer to IGrBlockCopy for further information.
        ! Portability notes :
        ! See IGrBlockCopy.
    end subroutine

    subroutine IGrBorder
        ! Short-name : GBORDR
        ! Draws a border around the extreme of the main graphics area as currently defined by
        ! IGrArea, in the current colour and plot mode as set by IGrColour, IGrColourN
        ! and IGrPlotMode.
        !e.g. CALL IGrArea(0.1,0.1,0.9,0.4)
        !CALL IGrBorder
        !CALL IGrArea(0.1,0.6,0.9,0.9)
        !CALL IGrBorder
    end subroutine

    subroutine IGrCircle(XPOS,YPOS,RADIUS)
        real XPOS ! X co-ordinate of circle centre
        real YPOS ! Y co-ordinate of circle centre
        real RADIUS ! Radius of circle in current X plotting units
        ! Short-name : GCIRCA
        ! Draws a circle of a given radius centred at the specified absolute plotting position, in
        ! the current graphics colour and plotting mode as selected by IGrColour,IGrColourN and IGrPlotMode. The circle will be filled, if required, using the fill
        ! pattern selected by IGrFillPattern. The current plotting position becomes
        ! (XPOS,YPOS). Aspect ratio is preserved regardless of output device. The radius is
        ! expressed in terms of the X co-ordinate system.
        !e.g. CALL IGrUnits(50.,100.,500.,300.)
        !CALL IGrFillPattern(2,2,3)
        !CALL IGrCircle(100.,200.,20.)
        !Errors :
        !ErrBadRadius (20) : Radius <= zero. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern.
        !Graphics Primitives INTERACTER Subroutine Reference
        !1-36

        call IGrPoint(XPOS,YPOS)
    end subroutine

    subroutine IGrCircleRel(RADIUS)
        real RADIUS ! Radius of circle in current X plotting units
        ! Short-name : GCIRCR
        ! Draws a circle of a given radius centred at the current plotting position, in the current
        ! graphics colour and plotting mode as selected by IGrColour, IGrColourN and
        ! IGrPlotMode. The circle will be filled, if required, using the fill pattern selected by
        ! IGrFillPattern. The current plotting position is not affected. Aspect ratio is
        ! preserved regardless of output device. The radius is expressed in terms of the X coordinate
        ! system.
        !e.g. CALL IGrMoveTo(100.0,200.0)
        !RADIUS = 50.0
        !CALL IGrFillPattern(1,1,4)
        !CALL IGrCircleRel(RADIUS)
        !Errors :
        !ErrBadRadius (20) : Radius <= zero. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern.
!        type(Fields), pointer :: this
!        if (radius == 0) return
!        this => this_
!        call ensureDrawing(this)
!        call setPointSize(this%canvas, 4)
!        call drawPoint(this%canvas, this%x, this%y)
    end subroutine

    subroutine IGrCurve(X,Y,NVERT,NSTEP)
        integer NVERT ! Number of vertices supplied in the X/Y arrays
        ! (at least 3 to produce a curve)
        real X(NVERT) ! Array of X co-ordinates
        real Y(NVERT) ! Array of Y co-ordinates
        integer NSTEP ! Number of steps between points (OPTIONAL)
        ! (minimum=4 suggested=32)
        ! Short-name : GCURVA
        ! Draws a spline (a smooth curve) through a series of (x,y) co-ordinates. In fact, the curve
        ! is approximated by a series of short straight lines. At least three pairs of co-ordinates
        ! must be specified to produce a curve. If only two points are specified a straight line is
        ! drawn. If only one point is specified, the current plotting position is simply updated.
        ! The exact number of lines drawn between each adjacent pair of points can be controlled
        ! using the NSTEP parameter. The minimum number of steps between points is four, but
        ! this will rarely give a smooth curve. More usually, a value of 32 will give a good
        ! compromise between smoothness and additional processing overheads. There is no
        ! upper limit on NSTEP but the larger its value the longer the curve will take to draw
        ! (and the larger the output file, if any of the vector based hardcopy drivers are used).
        ! Under Fortran 90 compilers, NSTEP has the OPTIONAL attribute. The suggested value
        ! of 32 is used if it is omitted. This feature requires that calling programs USE the
        ! INTERACTER module.
        ! Curves drawn by IGrCurve are 'open', i.e. the first and last points are not joined. To
        ! produce a closed curve simply add an extra data value to the X/Y arrays containing the
        ! same data value as the first element of the array. This is demonstrated in the example.
        ! INTERACTER Subroutine Reference Graphics Primitives
        ! 1-37
        !e.g. DIMENSION X(1000),Y(1000)
        !:
        !C read data from a file
        !READ(20,*) N
        !DO 100 I = 1,N
        !READ(20,*) X(I),Y(I)
        !100 CONTINUE
        !C close the curve
        !N = N + 1
        !X(N) = X(1)
        !Y(N) = Y(1)
        !C now fit a spline through data points using recommended smoothness
        !CALL IGrCurve(X,Y,N,32)
    end subroutine

    subroutine IGrEllipse(XPOS,YPOS,RADIUS,RATIO)
        real XPOS ! X co-ordinate of ellipse centre
        real YPOS ! Y co-ordinate of ellipse centre
        real RADIUS ! Radius of ellipse in current X plotting units
        real RATIO ! Ratio of the height of the ellipse to the width
        ! Short-name : GELIPA
        ! Draws an axis-aligned ellipse of a given radius centred at the specified absolute plotting
        ! position, in the current graphics colour and plotting mode as selected by
        ! IGrColour/IGrColourN/IGrPlotMode. The ellipse will be filled, if required,using the fill pattern selected by IGrFillPattern. The current plotting position
        ! becomes (XPOS,YPOS). The radius is expressed in terms of the X co-ordinate system.
        ! The ratio parameter controls the relative height and width of the ellipse. So, a RATIO
        ! value of 2.0 would give an ellipse which is twice as high as it is wide. Similarly a value
        ! of 0.33 would produce an ellipse which has a width approximately 3 times its height. A
        ! RATIO of 1.0 will give a true circle. It should not be confused with the aspect ratio (a
        ! device dependant factor which your programs need not normally be concerned with).
        !e.g. CALL IGrUnits(50.,100.,500.0,300.0)
        !CALL IGrFillPattern(2,2,3)
        !CALL IGrEllipse(100.,200.,20.,0.25)
        !Errors :
        !ErrBadRadius (20) : Radius <= zero. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern.
    end subroutine

    subroutine IGrEllipseRel(RADIUS,RATIO)
        real RADIUS ! Radius of ellipse in current X plotting units
        real RATIO ! Ratio of the height of the ellipse to the width
        ! Short-name : GELIPR
        ! Draws an axis-aligned ellipse of a given radius centred at the current plotting position,in the current graphics colour and plotting mode as selected by
        ! IGrColour/IGrColourN/IGrPlotMode. The ellipse will be filled, if required,using the fill pattern selected by IGrFillPattern. The current plotting position is
        ! not affected. The radius is expressed in terms of the X co-ordinate system.
        ! The RATIO value has the same meaning as for IGrEllipse.
        ! Graphics Primitives INTERACTER Subroutine Reference
        ! 1-38
        !e.g. CALL IGrMoveTo(100.0,200.0)
        !RADIUS = 50.0
        !RATIO = 2.5
        !CALL IGrFillPattern(1,1,4)
        !CALL IGrEllipseRel(RADIUS,RATIO)
        !Errors :
        !ErrBadRadius (20) : Radius <= zero. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern.
    end subroutine

    subroutine IGrJoin(XPOS1,YPOS1,XPOS2,YPOS2)
        real XPOS1 ! X co-ordinate to draw from
        real YPOS1 ! Y co-ordinate to draw from
        real XPOS2 ! X co-ordinate to draw to
        real YPOS2 ! Y co-ordinate to draw to
        ! Short-name : GJOINA
        ! Draws a line between the two specified absolute co-ordinates (XPOS1,YPOS1) and
        ! (XPOS2,YPOS2) in the current colour, plot mode and style as set by
        ! IGrColour/IGrColourN/IGrPlotMode/IGrLineType. (XPOS2,YPOS2)
        ! becomes the current plotting position. See also IGrLineTo.
        !e.g. CALL IGrUnits(0.0,0.0,1000.0,500.0)
        !C draw a line horizontally across the centre of the graphics area
        !CALL IGrJoin(0.0,250.0,1000.0,250.0)
    end subroutine

    subroutine IGrJoinRel(XPOS,YPOS,DXPOS,DYPOS)
        real XPOS ! Absolute X co-ordinate to draw from
        real YPOS ! Absolute Y co-ordinate to draw from
        real DXPOS ! Distance to X co-ordinate to draw to
        real DYPOS ! Distance to Y co-ordinate to draw to
        ! Short-name : GJOINR
        ! Draws a line from the specified absolute co-ordinate (XPOS,YPOS) to a new relative
        ! plotting position specified by (DXPOS,DYPOS). i.e. A line is drawn to a point
        ! (DXPOS,DYPOS) away from (XPOS,YPOS). The current plotting position becomes
        ! the point which IGrJoinRel has drawn to. See also IGrLineToRel.
        !e.g. CALL IGrUnits(0.0,0.0,1000.0,500.0)
        !C draw a line horizontally across the centre of the graphics area
        !CALL IGrJoinRel(0.0,250.0,1000.0,0.0)
    end subroutine

    subroutine IGrLineTo(XPOS,YPOS)
        real XPOS ! X co-ordinate to draw to
        real YPOS ! Y co-ordinate to draw to
        ! Short-name : GLINEA
        ! Draws a line from the current plotting position (as set by a previous call to
        ! IGrMoveTo, IGrMoveToRel or IGrLineToRel, etc.) to the new absolute
        ! plotting position specified by (XPOS,YPOS). Note that (XPOS,YPOS) becomes the
        ! current plotting position.
        ! INTERACTER Subroutine Reference Graphics Primitives
        ! 1-39
        !e.g. CALL IGrUnits(0.0,0.0,1000.0,500.0)
        !CALL IGrMoveTo(200.0,100.0)
        !CALL IGrLineTo(800.0,100.0)
!        type(Fields), pointer :: this
!        type(Points), pointer :: pts
!        this => this_
!        pts => this%pts
!        if (pts%size == 0) then
!            call ensureCapacityPoints(pts, 1)
!            pts%xs(0) = this%x
!            pts%ys(0) = this%y
!            pts%size = 1           
!        end if
!
!        call ensureCapacityPoints(pts, pts%size + 1)
!        pts%size = pts%size + 1
!        this%x = XPOS
!        this%y = YPOS
!        pts%xs(pts%size - 1) = this%x
!        pts%ys(pts%size - 1) = this%y
    end subroutine

    subroutine IGrLineToRel(DXPOS,DYPOS)
        real DXPOS ! Distance to X co-ordinate to draw to
        real DYPOS ! Distance to Y co-ordinate to draw to
        ! Short-name : GLINER
        ! Draws a line from the current plotting position (as set by a previous call to
        ! IGrMoveTo, IGrMoveToRel, IGrLineTo, etc.) to the new relative plotting
        ! position specified by (DXPOS,DYPOS). i.e. A line is drawn to a point
        ! (DXPOS,DYPOS) away from the current plotting position. The current plotting position
        ! becomes the point which IGrLineToRel has drawn to.
        !e.g. CALL IGrUnits(0.0,0.0,1000.0,500.0)
        !CALL IGrMoveTo(200.0,100.0)
        !C draw to a point 600 units to the right of the current position
        !CALL IGrLineToRel(600.0,0.0)
!        type(Fields), pointer :: this
!        type(Points), pointer :: pts
!        this => this_
!        pts => this%pts
!        if (pts%size == 0) then
!            call ensureCapacityPoints(pts, 1)
!            pts%xs(0) = this%x
!            pts%ys(0) = this%y
!            pts%size = 1           
!        end if
!
!        call ensureCapacityPoints(pts, pts%size + 1)
!        pts%size = pts%size + 1
!        this%x = this%x + DXPOS
!        this%y = this%y + DYPOS
!        pts%xs(pts%size - 1) = this%x
!        pts%ys(pts%size - 1) = this%y
        
    end subroutine

    subroutine IGrMarker(XPOS,YPOS,MARKER)
        real XPOS ! X position at which marker is to be plotted
        real YPOS ! Y position at which marker is to be plotted
        integer MARKER ! Number of marker to be plotted (1-20) :
        ! 1 2 3 4 5
        ! 6 7 8 9 10
        ! 11 12 13 14 15
        ! 16 17 18 19 20
        ! Short-name : GMRKRA
        ! Draws the required marker at the specified absolute plotting position in the current
        ! graphics colour and plotting mode. The marker is centred on the specified position and
        ! is drawn in the current graphics character size as defined by IGrCharSize
        ! (regardless of whether the hardware or software character set is currently selected). This
        ! is a particularly useful routine for marking points on a graph or diagram and is used for
        ! this purpose by the Presentation Graphics routines in the PG group.
        ! Graphics Primitives INTERACTER Subroutine Reference
        ! 1-40
        !e.g. CALL IGrColourN(48)
        !CALL IGrMarker(0.9,0.5,1)
        !CALL IGrCharOut(0.95,0.5,'= Year 1')
        !CALL IGrColourN(32)
        !CALL IGrMarker(0.9,0.4,3)
        !CALL IGrCharOut(0.95,0.4,'= Year 2')
        call IGrPoint(XPOS, YPOS)
    end subroutine

    subroutine IGrMarkerRel(MARKER)
        integer MARKER ! Number of marker to be plotted (1-20)
        ! (see IGrMarker)
        ! Short-name : GMRKRR
        ! Draws the required marker at the current plotting position in the same manner as
        ! IGrMarker.
        !e.g. CALL IGrMoveTo(XPOS,YPOS)
        !CALL IGrMarkerRel(5)
    end subroutine

    subroutine IGrMoveTo(XPOS,YPOS)
        real XPOS ! X co-ordinate
        real YPOS ! Y co-ordinate
        ! Short-name : GMOVEA
        ! Moves the current plotting position to the absolute position (XPOS,YPOS) without any
        ! visible effect.
        !e.g. CALL IGrUnits(100.,0.,300.,400.)
        !CALL IGrMoveTo(150.,200.)
        !CALL IGrLineTo(200.,300.)
!        type(Fields), pointer :: this
!        this => this_
!        if (this%x == XPOS .and. this%y == YPOS) return
!        call flushLine(this)
!        this%x = XPOS
!        this%y = YPOS
    end subroutine

    subroutine IGrMoveToRel(DXPOS,DYPOS)
        real DXPOS ! Distance to move X co-ordinate by
        real DYPOS ! Distance to move Y co-ordinate by
        ! Short-name : GMOVER
        ! Moves the current plotting position to the relative position (DXPOS,DYPOS) without
        ! any visible effect. i.e. Moves to the position which is (DXPOS,DYPOS) away from the
        ! current position.
        !e.g. CALL IGrUnits(100.,0.,300.,400.)
        !CALL IGrMoveTo(150.,200.)
        !C move to a point 20 units to the left of the current position
        !CALL IGrMoveToRel(-20.0,0.0)
        !INTERACTER Subroutine Reference Graphics Primitives
        !1-41
!        type(Fields), pointer :: this
!        this => this_
!        if (DXPOS == 0 .and. DYPOS == 0) return
!        call flushLine(this)
!        this%x = this%x + DXPOS
!        this%y = this%y + DYPOS
    end subroutine

    subroutine IGrParallel(XPOS1,YPOS1,XPOS2,YPOS2,APSLEN,ITYPE)
        real XPOS1 ! X co-ordinate of lower-left corner
        real YPOS1 ! Y co-ordinate of lower-left corner
        real XPOS2 ! X co-ordinate of upper-right corner
        real YPOS2 ! Y co-ordinate of upper-right corner
        real APSLEN ! Length of axis-parallel side
        integer ITYPE ! 1 : Parallelogram is Y-axis parallel
        ! = 2 : Parallelogram is X-axis parallel (default)
        ! Short-name : GPARLA
        ! Draws an axis-aligned parallelogram at the specified absolute plotting positions, in the
        ! current graphics colour and plotting mode as selected by
        ! IGrColour/IGrColourN/IGrPlotMode. The specified co-ordinates are
        ! assumed to define the lower left and upper right corners of the parallelogram. It will be
        ! filled, if required, using the fill pattern selected by IGrFillPattern. The current
        ! plotting position becomes (XPOS1,YPOS1).
        ! Parallelograms drawn with this routine have one pair of sides which are parallel with
        ! either the Y or X axis. This is determined using ITYPE. The length of the axis-parallel
        ! side is specified in APSLEN, as shown in the diagram:
        !e.g. CALL IGrColourN(48)
        !CALL IGrFillPattern(1,2,1)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !CALL IGrParallel(30.0,30.0,50.0,50.0,10.0,2)
        !Errors :
        !ErrBadSideLen (21) : Length of axis parallel side is <= zero. It must be positive.
        !ErrNoWidHgt (22) : Parallelogram does not have either height or width.
        !Portability notes :
        !See IGrFillPattern.
        !Graphics Primitives INTERACTER Subroutine Reference
        !1-42
    end subroutine

    subroutine IGrParallelRel(DXPOS,DYPOS,APSLEN,ITYPE)
        real DXPOS ! X distance to opposite corner ) can both be
        real DYPOS ! Y distance to opposite corner ) negative
        real APSLEN ! Length of axis-parallel side
        integer ITYPE ! 1 : Parallelogram is Y-axis parallel
        ! = 2 : Parallelogram is X-axis parallel (default)
        ! Short-name : GPARLR
        ! Draws an axis-aligned parallelogram, from the current plotting position to a diagonally
        ! opposite co-ordinate (DXPOS,DYPOS) units away. Negative values may be specified
        ! for either distance. The co-ordinates are assumed to define the lower left and upper
        ! right corners of the parallelogram. It is drawn in the current graphics colour and
        ! plotting mode as selected by IGrColour/IGrColourN/IGrPlotMode and will
        ! be filled, if required, using the fill pattern selected by IGrFillPattern. The current
        ! plotting position remains unchanged.
        ! APSLEN and ITYPE define the precise shape and are as defined under
        ! IGrParallel.
        !e.g. CALL IGrColourN(48)
        !CALL IGrFillPattern(1,2,1)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !CALL IGrMoveTo(20.,10.)
        !CALL IGrParallelRel(20.0,30.0,10.,1)
        !Errors :
        !ErrBadSideLen(21) : Length of axis parallel side is <= zero. It must be positive.
        !ErrNoWidHgt (22) : Parallelogram does not have either height or width.
        !Portability notes :
        !See IGrFillPattern.
    end subroutine

    subroutine IGrPoint(XPOS,YPOS)
        real XPOS ! X co-ordinate
        real YPOS ! Y co-ordinate
        ! Short-name : GPOINA
        ! Sets the current plotting position to the absolute position (XPOS,YPOS) and plots a
        ! point at that position.
        !e.g. CALL IGrUnits(100.,0.,300.,400.)
        !CALL IGrPoint(150.,200.)
!        type(Fields), pointer :: this
!        this => this_
!        this%x = XPOS
!        this%y = YPOS
        !call ensureDrawing(this)
        !call drawPoint(this%canvas, this%x, this%y)
    end subroutine

    subroutine IGrPointRel(DXPOS,DYPOS)
        real DXPOS ! Distance to move X co-ordinate by
        real DYPOS ! Distance to move Y co-ordinate by
        ! Short-name : GPOINR
        ! Sets the current plotting position to the relative position (DXPOS,DYPOS) and plots a
        ! point at that position. i.e. Moves to the position which is (DXPOS,DYPOS) away from
        ! the current position before plotting a point.
        !e.g. CALL IGrUnits(100.,0.,300.,400.)
        !CALL IGrMoveTo(150.,200.)
        !CALL IGrPointRel(-20.0,0.0)
        !INTERACTER Subroutine Reference Graphics Primitives
        !1-43
!        type(Fields), pointer :: this
!        this => this_
!        this%x = this%x + DXPOS
!        this%y = this%x + DYPOS
        !call ensureDrawing(this)
        !call drawPoint(this%canvas, this%x, this%y)
    end subroutine

    subroutine IGrPolygonComplex(X,Y,NVERT)
        integer NVERT ! Number of vertices in X/Y arrays (<=4095)
        real X(NVERT) ! Array of X co-ordinates
        real Y(NVERT) ! Array of Y co-ordinates
        ! Short-name : GPOLIA
        ! Draws an irregular polygon defined by the specified absolute plotting positions, with
        ! possibly intersecting borders. The polygon is drawn in the current graphics colour and
        ! plotting mode as selected by IGrColour/IGrColourN/IGrPlotMode. The
        ! polygon will be filled, if required, using the pattern set by IGrFillPattern. The
        ! polygon will be closed, i.e. the last point will be joined to the first. Up to 4095 vertices
        ! are allowed.
        ! IGrPolygonComplex uses a device-specific primitive for solid and mixed-colour
        ! fills, where available (see Portability notes). Where such a primitive is not available or
        ! is known to be unreliable, a generic (i.e. device independent) scan-line search method
        ! is used. The generic method is also used for hatch filling on all devices.
        ! Whichever fill method is used (device-specific or generic), it will usually be faster than
        ! the triangle-based algorithm employed by IGrPolygonSimple. However,IGrPolygonComplex has a data overhead of about 20k as it can perform more
        ! complex fills than IGrPolygonSimple. In very rare cases, a polygon may be too
        ! complex for IGrPolygonComplex's generic algorithm, in which case the routine
        ! will exit with error code 49. This is only likely to occur in very extreme cases.
        ! If no fill is specified, IGrPolygonComplex simply draws a poly-line, i.e. it joins the
        ! points specified in X and Y regardless of whether the borders cross. Whether filled or
        ! not, the current plotting position becomes (X(1),Y(1)).
        !e.g. REAL X(4095),Y(4095)
        !:
        !READ(20,*) N
        !DO 100 I = 1,MIN(N,4095)
        !READ(20,*) X(I),Y(I)
        !100 CONTINUE
        !CALL IGrPolygonComplex(X,Y,N)
        !Errors :
        !ErrFillComplex (49) : Fill too complex. Unable to fill polygon.
        !Portability notes :
        !DOS :
        !IGrPolygonComplex's generic algorithm is used under DOS. Stippled fills are
        !supported.
        !MS Windows :
        !The Windows API polygon fill function is used. Stippled fills are supported.
        !Xlib :
        !The Xlib polygon fill call is used. Stippled fills are supported.
        !Tektronix :
        !Device polygon fill primitives are used on all Tek 4100/4200 compatible terminals and
        !emulators. Stippled fills are supported. The generic algorithm is used on Tek
        !4010/4014 compatible displays.
        !Graphics Primitives INTERACTER Subroutine Reference
        !1-44
        !ReGIS :
        !Device polygon fills are used on DEC VT terminals, DECterm and ZSTEM.
        !IGrPolygonComplex's generic fill is used under Reflection and Smarterm 340, due
        !to unreliable ReGIS polygon fill algorithms in these emulators. When mixed fills are
        !selected, fill lines are drawn in alternating colours.
!        type(Points), pointer :: pts
!        integer(INT32) i
!        type(Fields), pointer :: this
!        this => this_
!        pts => this%pts
!        call flushLine(this)
!        call ensureCapacityPoints(pts, NVERT)
!        pts%size = NVERT
!        do i = 0,  NVERT - 1
!            pts%xs(i) = X(i + 1)
!            pts%ys(i) = Y(i + 1)    
!        end do
!        
!        call ensureDrawing(this)
!        call drawPolygon(this%canvas, pts%size, pts%xs, pts%ys)
!        pts%size = 0
!        this%x = pts%xs(0)
!        this%y = pts%ys(0)
    end subroutine

    subroutine IGrPolygonGrad(X,Y,NVERT,IDIR)
        integer NVERT ! Number of vertices in supplied X/Y arrays (<=4095)
        real X(NVERT) ! Array of X co-ordinates
        real Y(NVERT) ! Array of Y co-ordinates
        integer IDIR ! Direction (1=bottom-to-top, 2=left-to-right)
        ! (3=top-to-bottom, 4=right-to-left)
        ! Draws an irregular polygon using a graduated colour fill. The polygon is defined by the
        ! specified absolute plotting positions, with possibly intersecting borders. The fill is
        ! graduated between start and end colours as defined by the previous and current colours
        ! respectively. These are normally selected via IGrColourN. The polygon will be
        ! closed, i.e. the last point will be joined to the first. Up to 4095 vertices are allowed.
        ! IGrPolygonComplex uses a generic (i.e. device independent) scan-line search
        ! algorithm, which involves drawing many adjacent lines in gradually varying colours.
        ! The efficiency of this technique varies depending on output device and/or output
        ! format. This will probably be most noticeable when using vector oriented output
        !formats (e.g. CGM, WMF, PostScript, HP-GL/2) where output size is likely to be
        !considerably greater than for single-colour polygon fills. A graduated fill should
        !therefore only be used when specifically required. IGrPolygonComplex should be
        !used instead for normal fills, since it can take advantage of device/format specific
        !primitives, where available. (Note : IGrPolygonGrad uses the same polygon search
        !algorithm as that used by IGrPolygonComplex when a device specific primitive is
        !not available).
        !The colour of the polygon is graduated across the extent of the polygon according to
        !the IDIR argument, starting at the previous colour and ending at the current colour.
        !Internally, this routine uses the 24 bit colour model (see IGrColourModel) and will
        !therefore normally only give good results on a display or in an output format which
        !takes advantage of 24-bit colour specification. Note that the 24-bit colour model does
        !not necessarily need to have been selected at the calling level to use this routine.
        !In very rare cases, a polygon may be too complex (as for IGrPolygonComplex)
        !This will generate error code 49. This is only likely to occur in very extreme cases.
        !Unlike most fill routines, IGrPolygonGrad does not use the pattern set by
        !IGrFillPattern.
        !On exit, the current plotting position becomes (X(1),Y(1)).
        !e.g. REAL X(4095),Y(4095)
        !:
        !READ(20,*) N
        !DO 100 I = 1,MIN(N,4095)
        !READ(20,*) X(I),Y(I)
        !100 CONTINUE
        !CALL IGrColourN(IStartColour)
        !CALL IGrColourN(IEndColour)
        !CALL IGrPolygonGrad(X,Y,N,1)
        !INTERACTER Subroutine Reference Graphics Primitives
        !1-45
        !Errors :
        !ErrFillComplex (49) : Fill too complex. Unable to fill polygon
        !Portability notes :
        !See IGrColourModel.
    end subroutine

    subroutine IGrPolygonSimple(X,Y,NVERT)
        integer NVERT ! Number of vertices in X/Y arrays (<=8190)
        real X(NVERT) ! Array of X co-ordinates
        real Y(NVERT) ! Array of Y co-ordinates
        ! Short-name : GPOLYA
        ! Draws an irregular polygon, defined by the specified absolute plotting positions. The
        ! polygon must enclose a single area, i.e. borders must not cross. The polygon is drawn
        ! in the current graphics colour and plotting mode as selected by
        ! IGrColour/IGrColourN/IGrPlotMode. The polygon will be closed, i.e. the
        ! last point will be joined to the first. Up to 8190 vertices are allowed.
        ! The polygon will be filled, if required, using the fill pattern selected by
        ! IGrFillPattern. The fill algorithm uses a series of triangle fills. This is very
        ! economic on data space. The alternative routine IGrPolygonComplex provides a
        ! more powerful algorithm and access to device-dependent polygon fills where available,but that routine requires more memory and supports a smaller maximum number of
        ! points.
        ! The use of a triangle-based algorithm means that solid and stippled fills are supported
        ! on all displays which support a solid/stippled triangle fill. Hatched fills are supported
        ! on all displays and output devices, including plotters. Since the polygon must enclose a
        ! single area, crossing borders cause the fill to fail with error 28.
        ! If no fill is specified, IGrPolygonSimple simply draws a poly-line, i.e. it joins the
        ! points specified in X and Y regardless of whether the borders cross. Whether filled or
        ! not, the current plotting position becomes (X(1),Y(1)).
        !e.g. DIMENSION X(1000),Y(1000)
        !READ(20,*) N
        !N = MIN(N,1000)
        !DO 100 I = 1,N
        !READ(20,*) X(I),Y(I)
        !100 CONTINUE
        !CALL IGrPolygonSimple(X,Y,N)
        !Errors :
        !ErrBordersCross (28) : Borders cross. Unable to fill polygon.
        !Portability notes :
        !See IGrFillPattern notes on triangle fills.
        !Graphics Primitives INTERACTER Subroutine Reference
        !1-46
        call IGrPolygonComplex(X,Y,NVERT)
    end subroutine

    subroutine IGrPolyLine(X,Y,NVERT)
        integer NVERT ! Number of vertices in X/Y arrays (<=4095)
        real X(NVERT) ! Array of X co-ordinates
        real Y(NVERT) ! Array of Y co-ordinates
        ! Draws a poly-line through a series of absolute (x,y) co-ordinates. The poly-line is
        ! drawn in the current colour, line style and plot mode as specified by the routines in the
        ! GS group. The poly-line is clipped to the graphics area as set by the most recent call to
        ! IGrArea or IGrViewport.
        ! Typically this routine has the same effect as a call to IGrMoveTo followed by a series
        ! of IGrLineTo calls. However, some screen/hardcopy drivers can take advantage of
        ! poly-line primitives to give a cleaner effect when drawing broken or exclusive-or lines.
        ! Some drivers will also draw poly-lines more efficiently through this routine. The
        ! precise benefit of using IGrPolyLine varies between devices and may not always be
        ! noticeable. On the other hand calling IGrPolyLine will always be at least as good as
        ! repeated calls to single line drawing routines, when drawing multiple connected lines.
        ! On exit the current plotting position becomes (X(NVERT),Y(NVERT)). The routine
        ! has no effect if NVERT<=1.
        !e.g. DIMENSION X(4095),Y(4095)
        !READ(20,*) N
        !DO 100 I = 1,N
        !READ(20,*) X(I),Y(I)
        !100 CONTINUE
        !CALL IGrPolyLine(X,Y,N)
    end subroutine

    subroutine IGrRectangle(XPOS1,YPOS1,XPOS2,YPOS2)
        real XPOS1 ! )
        real YPOS1 ! ) Any two diagonally opposite corner
        real XPOS2 ! ) co-ordinates of rectangle to be drawn
        real YPOS2 ! )
        ! Short-name : GRECTA
        ! Draws an axis-aligned rectangle at the specified absolute position, in the current
        ! graphics colour and plotting mode as selected by IGrColour, IGrColourN and
        ! IGrPlotMode. The rectangle will be filled, if required, using the fill pattern selected
        ! by IGrFillPattern. The current plotting position becomes (XPOS1,YPOS1).
        !e.g. CALL IGrColourN(48)
        !CALL IGrFillPattern(1,2,1)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !CALL IGrRectangle(30.0,30.0,60.0,80.0)
        !Errors :
        !ErrNoWidHgt (22) : Rectangle has neither height or width. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern
        !INTERACTER Subroutine Reference Graphics Primitives
        !1-47

!        double precision x1
!        double precision x2
!        double precision y1
!        double precision y2
!        integer(INT32) px1
!        integer(INT32) px2
!        integer(INT32) py1
!        integer(INT32) py2
!        
!        integer(INT32) width
!        integer(INT32) height
!        double precision left
!        double precision top
!        
!        type(CanvasHandle) c
!        type(Fields), pointer :: this
!        this => this_
!        
!        c = this%canvas
!        x1 = XPOS1
!        x2 = XPOS2
!        y1 = YPOS1
!        y2 = YPOS2
!
!        px1 = getPixelXFromXY(c, x1, y1)
!        px2 = getPixelXFromXY(c, x2, y2)
!        py1 = getPixelYFromXY(c, x1, y1)
!        py2 = getPixelYFromXY(c, x2, y2)
!
!        width = abs(px2 - px1)
!        height = abs(py2 - py1)
!
!        if (px1 < px2) then 
!            left = x1
!        else
!            left = x2
!        end if
!
!        if (py1 < py2) then 
!            top = y1
!        else
!            top = y2
!        end if
!
!
!        call drawRectangle(c, left, top, width, height) 
!        this%x = x1
!        this%y = y1
    end subroutine

    subroutine IGrRectangleRel(WIDTH,HEIGHT)
        real WIDTH ! Width of rectangle ) can both be
        real HEIGHT ! Height of rectangle ) negative
        ! Short-name : GRECTR
        ! Draws an axis-aligned rectangle of the specified width and height at the current plotting
        ! position. If both are positive, the current plotting position will be at the bottom left
        ! corner of the rectangle, but negative values for the width and height may be specified to
        ! plot to the left and/or below the current position. The rectangle is drawn in the current
        ! graphics colour and plotting mode as selected by IGrColour, IGrColourN and
        ! IGrPlotMode. The rectangle will be filled, if required, using the fill pattern selected
        ! by IGrFillPattern. The current plotting position remains unchanged.
        !e.g. CALL IGrColourN(48)
        !CALL IGrFillPattern(1,2,1)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !CALL IGrMoveTo(20.,10.)
        !CALL IGrRectangleRel(30.0,60.0)
        !Errors :
        !ErrNoWidHgt (22) : Rectangle has neither height or width. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern
    end subroutine

    subroutine IGrTrapezium(XPOS1,YPOS1,XPOS2,YPOS2,ALEN1,ALEN2,ITYPE)
        real XPOS1 ! X co-ordinate of lower-left corner
        real YPOS1 ! Y co-ordinate of lower-left corner
        real XPOS2 ! X co-ordinate of upper-right corner
        real YPOS2 ! Y co-ordinate of upper-right corner
        real ALEN1 ! Length of axis-parallel side starting at (XPOS1,YPOS1)
        real ALEN2 ! Length of axis-parallel side ending at (XPOS2,YPOS2)
        integer ITYPE ! 1 : Trapezium is Y-axis parallel
        ! = 2 : Trapezium is X-axis parallel (default)
        ! Short-name : GTRAPA
        ! Draws an axis-aligned trapezium at the specified absolute plotting positions, in the
        ! current graphics colour and plotting mode as selected by IGrColour, IGrColourN
        ! and IGrPlotMode. The specified co-ordinates are assumed to define the lower left
        ! and upper right corners of the trapezium. It will be filled, if required, using the fill
        ! pattern selected by IGrFillPattern. The current plotting position becomes
        ! (XPOS1,YPOS1).
        ! A trapezium drawn with this routine has one pair of sides which are parallel with either
        ! the Y or X axis. This is determined using ITYPE. The lengths of the axis-parallel sides
        ! are specified in ALEN1 and ALEN2, as shown in the diagram.
        ! Graphics Primitives INTERACTER Subroutine Reference
        ! 1-48
        !e.g. CALL IGrColourN(48)
        !CALL IGrFillPattern(1,2,1)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !CALL IGrTrapezium(0.0,30.0,50.0,50.0,10.0,5.0,2)
        !Errors :
        !ErrBadSidelen (21) : Length of axis parallel side is <= zero. It must be positive.
        !ErrNoWidHgt (22) : Trapezium does not have either height or width.
        !Portability notes :
        !See IGrFillPattern
    end subroutine

    subroutine IGrTrapeziumRel(DXPOS,DYPOS,ALEN1,ALEN2,ITYPE)
        real DXPOS ! X distance to opposite corner ) can both be
        real DYPOS ! Y distance to opposite corner ) negative
        real ALEN1 ! Length of axis-parallel side starting at current plotting pos.
        real ALEN2 ! Length of axis-parallel side ending at plotting position
        ! specified by DXPOS,DYPOS
        integer ITYPE ! 1 : Trapezium is Y-axis parallel
        ! = 2 : Trapezium is X-axis parallel (default)
        ! Short-name : GTRAPR
        ! Draws an axis-aligned trapezium, from the current plotting position to a diagonally
        ! opposite co-ordinate (DXPOS,DYPOS) units away. Either distance may be negative.
        ! The resulting pair of co-ordinates are assumed to define the lower left and upper right
        ! corners of the trapezium. It is drawn in the current graphics colour and plotting mode
        ! and will be filled, if required, using the fill pattern selected by IGrFillPattern.
        ! The current plotting position remains unchanged.
        ! ALEN1, ALEN2 and ITYPE define the precise shape as for IGrTrapezium.
        !e.g. CALL IGrColourN(48)
        !CALL IGrFillPattern(1,2,1)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !CALL IGrMoveTo(20.,10.)
        !CALL IGrTrapeziumRel(20.0,30.0,10.,5.,1)
        !INTERACTER Subroutine Reference Graphics Primitives
        !1-49
        !Errors :
        !ErrBadSideLen(21) : Length of axis parallel side is <= zero. It must be positive.
        !ErrNoWidHgt (22) : Trapezium does not have either height or width.
        !Portability notes :
        !See IGrFillPattern
    end subroutine

    subroutine IGrTriangle(XPOS1,YPOS1,XPOS2,YPOS2,XPOS3,YPOS3)
        real XPOS1 ! ) Co-ordinates of first
        real YPOS1 ! ) corner of triangle.
        real XPOS2 ! ) Co-ordinates of second
        real YPOS2 ! ) corner of triangle.
        real XPOS3 ! ) Co-ordinates of third
        real YPOS3 ! ) corner of triangle.
        ! Short-name : GTRNGA
        ! Draws a triangle at the specified absolute plotting positions, in the current graphics
        ! colour and plotting mode as selected by IGrColour, IGrColourN and
        ! IGrPlotMode. The triangle will be filled, if required, using the fill pattern selected
        ! by IGrFillPattern. The current plotting position becomes (XPOS1,YPOS1).
        !e.g. CALL IGrColourN(48)
        !CALL IGrFillPattern(2,2,4)
        !CALL IGrUnits(0.0,0.0,10.0,10.0)
        !CALL IGrTriangle(3.,3.,6.,8.,9.,1.)
        !Errors :
        !ErrNoWidHgt (22) : Triangle does not have either height or width.
        !i.e. All three points lie on a line. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern
    end subroutine

    subroutine IGrTriangleRel(DXPOS2,DYPOS2,DXPOS3,DYPOS3)
        real DXPOS2 ! X Distance to move to 2nd corner co-ordinate
        real DYPOS2 ! Y Distance to move to 2nd corner co-ordinate
        real DXPOS3 ! X Distance to move to 3rd corner co-ordinate
        real DYPOS3 ! Y Distance to move to 3rd corner co-ordinate
        ! Short-name : GTRNGR
        ! Draws a triangle, relative to the current plotting position. The four arguments specify
        ! the relative co-ordinates of the other two corners of the triangle, i.e. how far they are
        ! from the current plotting position. These distances can of course be negative, if
        ! required.
        ! Graphics Primitives INTERACTER Subroutine Reference
        ! 1-50
        ! The triangle is drawn in the current graphics colour and plotting mode as selected by
        ! IGrColour/IGrColourN/IGrPlotMode. The triangle will be filled, if required,using the fill pattern selected by IGrFillPattern. The current plotting position
        ! remains unchanged.
        !e.g. CALL IGrColourN(48)
        !CALL IGrFillPattern(1,2,3)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !CALL IGrMoveTo(20.,10.)
        !CALL IGrTriangleRel(10.,-5.,50.,0.)
        !Errors :
        !ErrNoWidHgt (22) : Triangle does not have either height or width.
        !i.e. All three points lie on a line. Nothing will be drawn.
        !Portability notes :
        !See IGrFillPattern
        !INTERACTER Subroutine Reference Graphics text
        !1-51
        !1.5 Group GC : Graphics Character Output
        !This group provides a number of routines to control graphics text output. The routines
        !which actually write graphics text strings are IGrCharOut and IGrCharOutRel.
        !Graphics text attributes are controlled using routines such as IGrCharUnderline
        !and IGrCharSlant.
        !The primary advantage of the GC routines is that they are able to use software defined
        !device-independent character sets (outline or vector fonts) which are loaded from disk
        !using IGrCharSet, in addition to hardware-dependent character sets. When the latter
        !are selected, INTERACTER will automatically substitute an equivalent software font,where a hardware-specific font is unavailable or unsuitable. When hardware-dependent
        !text is enabled, the actual font selected is controlled by IGrCharFont.
        !The direction, justification and angle of rotation of graphics mode text can be
        !controlled using IGrCharDirection, IGrCharJustify and IGrCharRotate.
        !The size of text is set using IGrCharSize.
        !By default text is monospaced, but proportional spacing is selectable via
        !IGrCharSpacing. If proportional spacing is enabled, the actual space occupied by
        !individual characters is redefinable via IGrCharSpace. The relative length of a
        !graphics text string (taking account of proportional spacing if enabled) is returned by
        !the IGrCharLength function.
        !Two overall strategies are available for font selection :
        !(1) Always use INTERACTER's software character sets, by calling IGrCharSet to
        !load font files from the charsets directory. This has the benefit of total device
        !independence. However, it does not take advantage of the font handling capabilities
        !of Windows, PostScript, HP-GL/2, etc.
        !(2) Leave the character set selection as 'hardware dependent'. This is the initial default.
        !This will utilise device/format specific font handling capabilities where appropriate
        !(e.g. Windows, PostScript) but will automatically substitute an INTERACTERequivalent
        !outline font where format-specific capabilities are not up to the required
        !standard. This solution requires no use of IGrCharSet. Instead, all font selection
        !is determined by a combination of IGrCharFont and IGrCharSpacing.
        !Both of the above strategies require that fonts from the charsets directory be
        !distributed with your application. Strategy (2) only requires the character set files for
        !the 'swiss', 'roman' and 'fixed' outline fonts.
        !Note : At version 4, symbol set handling was merged with INTERACTER graphics text
        !handling, with the creation of an 'ISS Symbols' character set. This combines all the old
        !25-piece symbol sets into an 8-bit character set. Users of the old IGrSymbXXX
        !routines are encouraged to convert to the IGrCharXXX routines. See Appendix A in
        !Volume 1.
        !Graphics text INTERACTER Subroutine Reference
        !1-52
    end subroutine

    subroutine IGrCharConvert(INFIL,OUTFIL)
        character(len=*) INFIL ! Input file name
        character(len=*) OUTFIL ! Output file name
        ! Short-name : GCHCNV
        ! Converts an ASCII source file defining an outline or vector based character set (as
        ! described in chapter 15 of the User Guide) to a binary format suitable to be read by
        ! IGrCharSet. Any character sets which you generate will need to be converted using
        ! this routine. A utility program called 'convsets' is supplied which simplifies the calling
        ! of this routine. Calling this routine is a 'one-off' task. There should be no need to use it
        ! in applications.
        ! Filename extensions of .dat and .chr are recommended for the input and output
        ! filenames respectively.
        !e.g. CALL IGrCharConvert('mychars.dat','mychars.chr')
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error reading from file or unexpected end-of-file
        !ErrFileClose (3) : Error closing file
        !ErrChrSymSetSize (25) : Too many bytes in definition. The internal limits (as
        !defined in chapter 15 of the User Guide) exceeded
    end subroutine

    subroutine IGrCharDirection(HORVER)
        character(len=*) HORVER ! Direction in which graphics text is to be output :
        ! = H : Horizontal (default) ) can be upper
        ! = V : Vertical ) or lower case
        ! Short-name : GCHDIR
        ! Sets the direction in which text is to be output in graphics mode, using IGrCharOut.
        ! The default is horizontal. If a string is supplied which starts with a letter other than H or
        ! V, the default direction is also horizontal. The specified direction applies to both
        ! software and hardware character set text output.
        ! Note that the graphics text direction specified here is relative to the angle of rotation
        ! specified by IGrCharRotate. i.e. Vertical text is printed one character above the
        ! next, perpendicular to the base line defined by the current rotation angle.
        !e.g. CALL IGrCharDirection('horiz')
        !CALL IGrCharOut(100.,100.'Horizontal text')
        !CALL IGrCharDirection('V')
        !CALL IGrCharOut(10.,200.,'Vertical !')
        !INTERACTER Subroutine Reference Graphics text
        !1-53
    end subroutine

    subroutine IGrCharFont(IFONT)
        integer IFONT ! Font number (1-8) :
        ! Proportional Fixed
        ! Helvetica (1) Helvetica or equivalent Courier
        ! HelveticaIt (2) Helvetica Italic Courier Italic
        ! HelveticaBd (3) Helvectia Bold Courier Bold
        ! HelveticaBdIt (4) Helvetica Bold/Italic Courier Bold/Italic
        ! TimesRoman (5) Times Roman or equivalent Courier
        ! TimesRomanIt (6) Times Roman Italic Courier Italic
        ! TimesRomanBd (7) Times Roman Bold Courier Bold
        ! TimesRomanBdIt (8) Times Roman Bold/Italic Courier Bold/Italic
        ! Fonts 1-4 can also be referenced using the alternative symbolic names :
        ! Courier (1), CourierIt (2), CourierBd (3) and CourierBdIt (4)
        ! Short-name : GCHFNT
        ! Include : intergc.inc
        ! Selects the device-dependent font/style to be used when hardware text is enabled.
        ! Fixed-spaced hardware text is enabled by default, using font number 1. Hardware text
        ! is also enabled by calling IGrCharSet('H'). IGrCharFont has no effect while
        ! software characters are enabled, other than to select the font which will be used next
        ! time hardware text is enabled.
        ! The meaning of IFONT depends on whether proportional or fixed spacing is currently
        ! selected (see IGrCharSpacing) :
        ! Proportional spacing :
        ! INTERACTER will always try to select the specified Helvetica or Times Roman font,provided it is supported by the target hardware or output format. Where such a font is
        ! not available, a device independent software font ('swiss' or 'roman') will be substituted.
        ! If the character set file for the equivalent software font cannot be located, the
        ! corresponding fixed space font is selected, but with characters placed at proportional
        ! spacing (typically the latter behaviour is far from ideal, but is necessary as a 'last resort'
        ! option where no hardware or software proportional font is available).
        ! Fixed spacing :
        ! When fixed spacing is selected IFONT selects a Courier-type font or a hardwaredependent
        ! equivalent. Under certain conditions, a device independent software font
        ! ('fixed') will be substituted if :
        ! (a) A given device or output format does not support a fixed-space hardware font at
        ! the currently requested size.
        ! or
        ! (b) A substituted software font is likely to give a significantly better appearance
        ! than the hardware equivalent, at the currently requested size.
        ! Most fonts provide 8-bit ISO Latin-1 character sets (i.e. character codes 32-126 and
        ! 161-255), but some are limited to 7-bit ASCII characters (i.e. 32-126). See the
        ! following Portability Notes and chapter 17 in the User Guide for device-specific
        ! information.
        ! Graphics text INTERACTER Subroutine Reference
        ! 1-54
        ! A demonstration program called showfont is supplied which displays the fonts
        ! available on the current device.
        !e.g. CALL IGrCharSet('H')
        !C select font 5 (Times Roman or Courier)
        !CALL IGrCharFont(5)
        !CALL IGrHardCopy(' ')
        !C Proportional spacing
        !CALL IGrCharSpacing('P')
        !CALL IGrCharOut(0.5,0.7,'Times Roman or equivalent')
        !C Fixed spacing
        !CALL IGrCharSpacing('F')
        !CALL IGrCharOut(0.5,0.3,'Courier or equivalent')
        !Portability notes :
        !DOS screen and Raster hardcopy/image-file drivers :
        !Hardware proportional fonts are not available, so software (outline) fonts will be
        !substituted. Eight different fixed space fonts are selectable. Each font is defined in data
        !within the library using 8x8 bitmap character definitions. These fonts are rescalable in
        !steps of 8 pixels or printer dots. The fonts are mainly intended for use at small-tomedium
        !text sizes. INTERACTER will try to substitute the 'fixed' software character set
        !if the required character size would be greater than 16x16 pixels.
        !All eight bitmap fonts in the DOS-screen and raster drivers contain 8-bit character sets.
        !Font numbers are assigned as follows :
        !IFONT = 1 : Plain 5 : Serif
        !2 : Plain italic 6 : Serif italic
        !3 : Plain bold 7 : Serif bold
        !4 : Plain bold/italic 8 : Serif bold/italic
        !MS Windows, WMF, Print Manager, PostScript :
        !The Helvetica, Times Roman and Courier fonts are all fully supported. All of these
        !fonts support 8-bit Latin-1 characters and are fully rescalable.
        !Xlib :
        !The Helvetica, Times Roman and Courier fonts are all supported under X Windows.
        !Under X11R4 they are only available at a limited number of font sizes (specifically, 6
        !font sizes ranging from 5 to 15 pixels wide). Under X11R5 or later, rescaleable X fonts
        !are used. Whilst this does not guarantee to give exactly the font size requested, it does
        !support a wider range of font sizes. Whichever X11 release is used, when a font of the
        !requested size (or a near equivalent) is not available a software outline font is
        !substituted. All of the supported Xlib fonts are 8-bit ISO Latin-1 fonts.
        !Tektronix :
        !Two 7-bit fixed space text styles are supported on Tek 4100/4200 terminals. Odd
        !IFONT values select upright text, even values select italics. Hardware text is always
        !used for fixed space text. Software substitution is used for proportional text.
        !Only one fixed space 7-bit font is available on Tek 401x terminals/printers and 4105
        !terminals and only at certain character sizes. Software substitution is normally used,except where a suitably sized hardware font exists.
        !INTERACTER Subroutine Reference Graphics text
        !1-55
        !ReGIS :
        !Two 8-bit fixed space text styles are supported on ReGIS terminals. Odd IFONT values
        !select upright text, even values select italics. Hardware text is always used for fixed
        !space text. Software substitution is used for proportional text.
        !HP-GL :
        !Two 7-bit fixed space text styles are supported on HP-GL plotters. Odd IFONT values
        !select upright text, even values select italics. Hardware text is always used for fixed
        !space text. Software substitution is used for proportional text.
        !HP-GL/2 :
        !When a LaserJet III (HP-GL/2 device type 1) is selected, the HP-GL/2 driver uses the
        !Stick font instead of Courier. While the LJ III Stick, Helvetica and Times Roman fonts
        !do not use the Latin-1 encoding, they support 90% of the same 8-bit characters.
        !INTERACTER therefore maps between the requested 8-bit Latin-1 characters and the
        !equivalent LaserJet III characters when device type 1 is selected.
        !When other device types are selected, the HP-GL/2 driver supports the required set of
        !Helvetica, Times Roman and Courier 8-bit ISO Latin-1 fonts.
        !All HP-GL/2 fonts are fully rescalable.
        !Lotus PIC :
        !Software text substitution is always used in PIC output due to the very limited font
        !selection capabilities of the Lotus graphic file format.
        !DXF :
        !Hardware font selection is not available, so software substitution is used for all fixed
        !space text over a certain size and for all proportional text.
        !CGM :
        !A font table is written in the CGM header which lists all the Courier, Helvetica and
        !Times Roman fonts, using the names specified in MIL-STD-2301. IGrCharFont
        !selects fonts as appropriate from this font table. In practice, many CGM importers fail
        !to handle font selection correctly, however. Hardware text in CGM output is therefore
        !highly dependent on the quality of the importer.
    end subroutine

    subroutine IGrCharJustify(JUSTIF)
        character(len=*) JUSTIF ! Justification mode for graphics text output :
        ! = C : Centred (default) ) can be
        ! = L : Left justified ) upper or
        ! = R : Right justified ) lower case
        ! Short-name : GCHJUS
        ! Sets the justification to be used when outputting text in graphics mode using
        ! IGrCharOut. The default is centred. If a string is supplied which starts with a letter
        ! other than C, L or R the default is also centred. The specified justification applies to
        ! both software and hardware character set text output.
        ! Justification always takes place relative to a plotting position. So left justified text is
        ! printed starting from a given position, right justified text finishes at that position and
        ! centred text appears either side of it. This is true of both horizontal and vertical text and
        ! is independent of the current angle of rotation. In all cases 'left' and 'right' refer to
        ! which end of the string is actually at the specified plotting position.
        ! Graphics text INTERACTER Subroutine Reference
        ! 1-56
        !e.g. CALL IGrCharJustify('Left')
        !CALL IGrCharOut(100.,100.'This starts at (100,100)')
        !CALL IGrCharDirection('V')
        !CALL IGrCharJustify('r')
        !CALL IGrCharOut(100.,150.,'This finishes at (100,150)')

!        type(Fields), pointer :: this
!        this => this_
!
!        this%alignment = JUSTIF
        
    end subroutine

    REAL function IGrCharLength(STRING) result(res)
        character(len=*) STRING ! String or character to measure
        ! When proportional spacing is enabled, this function returns the relative length of the
        ! specified string in the same units as would be specified to IGrCharSpace. So,
        ! IGrCharSpace('I') would return 0.56 by default. IGrCharSpace('IM')
        ! would return 0.56+1.42=1.98, and so on. In addition to providing a mechanism for
        ! interrogating the current spacing table, this function also allows a proportionally spaced
        ! string to be measured in user units simply by multiplying the result by
        ! InfoGraphics(3) (the width of a fixed space character expressed in user units).
        ! When fixed spacing is enabled, IGrCharLength(STRING) always returns
        ! REAL(LEN(STRING)). Hence the result of IGrCharLength multiplied by
        ! InfoGraphics(3) always returns the width the string in user-units, regardless of
        ! what type of spacing is enabled.
        ! This function must be explicitly declared as REAL in the calling program.
        !e.g. REAL InfoGraphics,IGrCharLength
        !C write a blue proportionally spaced string on a white background
        !CALL IGrCharSpacing('P')
        !WIDTH = IGrCharLength(STRING)*InfoGraphics(3)
        !HEIGHT = InfoGraphics(4)
        !CALL IGrColour('W')
        !CALL IGrFillPattern(4,0,0)
        !CALL IGrRectangle(X,Y,X+WIDTH,Y+HEIGHT)
        !CALL IGrCharJustify('L')
        !CALL IGrColour('BLU')
        !CALL IGrCharOut(X,Y+HEIGHT/2.0,STRING)
    
!        type(Fields), pointer :: this
!        real iLength
!        this => this_
!        iLength = real(getTextWidth(this%canvas, "IIIIII")) / 6
!        res = getTextWidth(this%canvas, STRING) / iLength  * 0.56
        res = 0.0
    end function


    subroutine IGrCharOut(XPOS,YPOS,STRING)
        real XPOS ! X co-ordinate
        real YPOS ! Y co-ordinate
        character(len=*) STRING ! String to write
        ! Short-name : GCHOUA
        ! Outputs STRING at the graphics co-ordinate (XPOS,YPOS). The plotting mode and
        ! colour are as previously defined by IGrPlotMode and IGrColour/IGrColourN.
        ! If a vector-based software character set has been selected, characters are drawn using a
        ! solid line style. Outline software characters are drawn in a solid fill style.
        ! The position of the text relative to (XPOS,YPOS) is determined by the most recent call
        ! to IGrCharJustify, and can be centred or left/right justified. The default is centred.
        ! The direction of the text (horizontal or vertical) is determined by
        ! IGrCharDirection, whilst the angle at which it is written is determined by
        ! IGrCharRotate. By default, text is horizontal.
        ! When text is output horizontally, YPOS specifies a position half-way up a character.
        ! When vertical output has been selected, XPOS specifies a position halfway across a
        ! character. In left/right justification mode the other co-ordinate specifies an extreme end
        ! of the string. These rules apply regardless of the angle of rotation.
        ! INTERACTER Subroutine Reference Graphics text
        ! 1-57
        ! On exit the current plotting position is updated to a point within the next character cell
        ! after the string which has been written. The exact position within the cell will depend
        ! on the current text direction and justification mode. In the diagram which follows, 'x'
        ! represents the new plotting position relative to the character cell. (For the purposes of
        ! calculating this plotting position, the final character cell after the output string is
        ! assumed to be a fixed width cell, regardless of whether fixed or proportional spacing is
        ! currently selected.)
        ! The font/character set used by IGrCharOut is determined by IGrCharSet,IGrCharSpacing and IGrCharFont. The default is set to fixed spaced hardware
        ! character set number 1.
        ! Text size is governed by IGrCharSize, though this is dependent on which character
        ! set and output device is selected. Software text size control is available on all devices.
        ! Hardware text size control is device dependent. See IGrCharSize.
        ! Whichever justification, direction or character set is used, text which would extend
        ! beyond the limits of the graphics area (as defined by IGrArea) is clipped at the edge
        ! of that area. Text which would be completely outside the graphics area is not printed.
        ! Normal 'over-write' plot mode is recommended for vector-based software characters. If
        ! text needs to be plotted in exclusive-or mode (to allow it to be 'unplotted' later), use
        ! either hardware text or an outline software character set.
        ! Text written by this routine can contain both 7-bit and 8-bit characters, as defined in the
        ! ISO Latin-1 standard (i.e. character codes in the range 32-126 and 161-255). However,whilst widely supported, Latin-1 8-bit characters are not universally available on all
        ! devices or in all fonts. See the character set illustrations in chapter 15 of the User Guide
        ! for details of which software character sets support 8-bit characters. The Portability
        ! Notes for IGrCharFont describe the availability of hardware-dependent 8-bit
        ! character sets. See also InfoGrScreen and InfoGrHardcopy, both of which can
        ! report 7-bit/8-bit character set availability.
        !e.g. CALL IGrCharOut(100.0,200.0,'This is centred at (100,200)')
        !CALL IGrCharJustify('L')
        !CALL IGrCharOut(300.0,200.0,'This starts at (300,200)')
        !Graphics text INTERACTER Subroutine Reference
        !1-58
        !Errors :
        !ErrNoSoftFont (53) : Unable to find a software (outline) font to substitute for an
        !unavailable hardware font size/style
!        type(Fields), pointer :: this
!        integer(INT32) width
!        integer(INT32) height
!        integer(INT32) pixelX
!        integer(INT32) pixelY
!        integer(INT32) dX
!        integer(INT32) dY
!        double precision x
!        double precision y
!
!        double precision charWidth
!        this => this_
!        call ensureDrawing(this)
!        call setFontPointSize(this%canvas, 6)
!
!        width = getTextWidth(this%canvas, STRING)
!        height = getTextHeight(this%canvas, STRING)
!
!        x = XPOS 
!        y = YPOS
!
!        
!        select case (this%alignment)
!            case ('C') 
!                dX = -width / 2
!            case ('R')
!                dX = -width
!            Case ('L')
!                dX = 0
!        end select
!
!        dY = -height / 2
!
!        pixelX = getPixelXFromXY(this%canvas, x, y) + dX
!        pixelY = getPixelYFromXY(this%canvas, x, y) + dY
!
!        x = getXFromPixel(this%canvas, pixelX, pixelY)
!        y = getYFromPixel(this%canvas, pixelX, pixelY)
!
!        call drawText(this%canvas, x, y, width, height, STRING)
!
!        
!        charWidth = real(getTextWidth(this%canvas, "xxxxxxxxxx")) / 10
!        width = charWidth * len(STRING)
!
!        select case (this%alignment)
!            case ('C') 
!                dX = width / 2
!            case ('L')
!                dX = width
!            case ('R')
!                dX = 0
!        end select
!
!        dY = 0
!
!        x = XPOS 
!        y = YPOS
!        pixelX = getPixelXFromXY(this%canvas, x, y) + dX
!        pixelY = getPixelYFromXY(this%canvas, x, y) + dY
!        
!        this%x = getXFromPixel(this%canvas, pixelX, pixelY)
!        this%y = getYFromPixel(this%canvas, pixelX, pixelY)
!        
    end subroutine

    subroutine IGrCharOutRel(STRING)
        character(len=*) STRING ! String to write
        ! Short-name : GCHOUR
        ! Outputs a string at the current plotting position. This is exactly equivalent to calling
        ! IGrCharOut, except that no (x,y) co-ordinate need be specified.
        ! The main use for this routine is where you simply wish to push out text immediately
        ! following text written with a previous call to IGrCharOut. When used in this way,left justification is the most appropriate mode, in which case IGrCharOut and
        ! IGrCharOutRel operate in a very similar manner to IOutStringXY and
        ! IOutString, the text mode string output routines. Right justified or centred text can
        ! of course still be used if this is more appropriate.
        ! Refer to IGrCharOut for more details of the effect of calling this routine.
        !e.g. CALL IGrCharJustify('L')
        !CALL IGrCharOut(10.,20.,'Here is some text ')
        !CALL IGrCharOutRel('followed by some more !')
!        type(Fields), pointer :: this
!        this => this_
!
!
!        call IGrCharOut(real(this%x), real(this%y), STRING)
    end subroutine

    subroutine IGrCharRotate(ANGLE)
        real ANGLE ! Angle of rotation at which strings are to be written, in degrees
        ! Short-name : GCHROT
        ! Defines the angle at which graphics text strings are to be written by IGrCharOut.
        ! The angle is measured in degrees counter clockwise from the horizontal, which is
        ! treated as zero. Hence, an angle of 90 degrees would give sideways text which runs
        ! vertically from the bottom of the graphics area toward the top. The default is zero.
        ! IGrCharRotate should not be confused with IGrCharDirection which sets the
        ! relative position of each character in a string from the last. In fact IGrCharRotate
        ! and IGrCharDirection can be used in combination to give rotated and vertical
        ! text. Similarly, IGrCharRotate and IGrCharSlant are also apparently similar
        ! routines with quite different purposes. IGrCharSlant sets the slant of each character
        ! within a string, enabling italics to be drawn. Again, IGrCharRotate and
        ! IGrCharSlant can be combined to give rotated italic text. See the ROTCHAR
        ! program in the demos directory for examples of some of these combinations.
        ! Graphics text rotation is most reliable when applied to software text, which supports all
        ! possible angles. The ability of a particular screen or hardcopy driver to rotate hardware
        ! text varies considerably depending on the target device or format. Some drivers support
        ! full rotation. Others only support 4 or 8 rotation angles or do not support hardware text
        ! rotation at all. Where all rotation angles are not supported, the nearest available angle is
        ! used. The functions InfoGrScreen(40) and InfoGrHardcopy(40) return
        ! hardware rotation text capability information. See also the following Portability notes
        ! and chapter 17 in the User Guide.
        ! INTERACTER Subroutine Reference Graphics text
        ! 1-59
        !e.g. CALL IGrCharJustify('C')
        !CALL IGrCharRotate(180.)
        !CALL IGrCharOut(0.5,0.5,'Upside down text !')
        !CALL IGrCharRotate(90.)
        !CALL IGrCharSlant(40.)
        !CALL IGrCharOut(0.1,0.5,'Bottom to top italics')
        !Portability notes :
        !DOS :
        !Hardware text can be rotated at four angles (0, 90, 180 and 270 degrees).
        !Windows :
        !Text can be rotated at any angle.
        !Xlib :
        !Hardware text rotation is not supported under X Windows.
        !Tektronix :
        !A Tek 4107/420x display can rotate text at any angle. Tek 4105 compatible devices
        !only support 4 angles (0, 90, 180 and 270). Tek 401x devices do not support rotation.
        !ReGIS :
        !Eight rotation angles are supported (0, 45, 90, 135, 180, etc.)
    end subroutine

    subroutine IGrCharSet(FILNAM)
        character(len=*) FILNAM ! Filename or string describing character set to use
        ! = 'H' or 'h' : select hardware-dependent text
        ! (text font/style set by IGrCharFont)
        ! = ' ' : load/select default software character set
        ! = 'filename' : load software character set from 'filename'
        ! Short-name : GCHSET
        ! Selects the character set to be used by future calls to IGrCharOut to output text in
        ! graphics mode.
        ! By default hardware-dependent text is enabled. This is re-selectable here by specifying
        ! 'H'. Both the size and appearance of hardware text is device dependent. When hardware
        ! text is selected, IGrCharFont determines the actual text font/style selected. Where a
        ! font of the required type/size/quality is not available on the current device or in the
        ! current output format, an equivalent software outline font is automatically substituted.
        ! It is therefore possible to perform all font selection via IGrCharFont, leaving
        ! INTERACTER to substitute software fonts where necessary. If this strategy is adopted,there is no need to call IGrCharSet directly. See IGrCharFont for more details.
        ! Calling IGrCharSet with an argument other than 'H' loads a software character set
        ! from a file, makes it the current font and disables hardware-text (and hardware text
        ! substitution). There are two ways to load a software character set :
        ! 1) By specifying a blank FILNAM, a default character set filename is used. The default
        ! name, standard.chr, is assigned by IScreenOpen. An alternative default
        ! name can be specified in the initialisation file using the CHARSET keyword.
        ! 2) By specifying the name of a file containing an INTERACTER-compatible character
        ! set. A suffix of .chr is recommended for software character set filenames.
        ! Graphics text INTERACTER Subroutine Reference
        ! 1-60
        ! Each character in a software font is formed by filling a polygon (outline fonts) or by
        ! drawing a series of lines (vector fonts). Whilst somewhat slower to plot, software
        ! characters can always be scaled to any size (using IGrCharSize) and have a
        ! consistent appearance on all displays and in all screen modes.
        ! A software graphics character set file contains a set of definitions of the shape of the
        ! standard ASCII characters in the range 33 to 126 and (optionally) the ISO Latin-1 8-bit
        ! characters in the range 161 to 255.
        ! If a software character set has already been loaded, a subsequent request to load it
        ! reselects that as the current character set without actually reading the character set file
        ! again. Up to 20 character sets are cached in this way. It is therefore possible to switch
        ! between hardware and software character sets, without repeated disk access. This check
        ! for a previously loaded filename is case sensitive.
        ! A selection of 8-bit and 7-bit character sets are supplied, some of which are based on
        ! the well known Hershey fonts. The default software character set is 'Standard'.
        ! The supplied 8-bit outline font character sets are as follows. They all implement ISO
        ! Latin-1 characters 33-126 and 161-255 :
        ! Generic Character Description
        ! Filename Set Name
        ! roman.chr Roman Equivalent to PostScript Times Roman
        ! romanbld.chr Roman Bold Bold version of Roman
        ! swiss.chr Swiss Equivalent to PostScript Helvetica
        ! swissbld.chr Swiss Bold Bold version of Swiss
        ! fixed.chr Fixed Equivalent to PostScript Courier
        ! fixedbld.chr Fixed Bold Bold version of Fixed
        ! The supplied 8-bit vector font character sets are as follows. They all implement ISO
        ! Latin-1 characters 33-126 and 161-255 :
        ! Generic Character Description
        ! Filename Set Name
        ! standard.chr Standard Simple general purpose character set,suitable for any device.
        ! simplexr.chr Simplex Roman Similar to the Standard character set,but with slightly more detail
        ! duplexr.chr Duplex Roman More detailed font, using roughly
        ! twice as many strokes as Simplex
        ! triplexr.chr Triplex Roman Heavier variant of the Duplex font
        ! complexr.chr Complex Roman Similar to Triplex
        ! INTERACTER Subroutine Reference Graphics text
        ! 1-61
        ! The supplied 7-bit vector font character sets are as follows. They implement ASCII
        ! characters 33 to 126 :
        ! Generic Character Description
        ! Filename Set Name
        ! complexi.chr Complex Italic Italic version of Complex Roman
        ! triplexi.chr Triplex Italic Italic version of Triplex Roman
        ! simplexs.chr Simplex Script Based on a hand-written style
        ! complexs.chr Complex Script More detailed variant of Simplex Script
        ! simplexg.chr Simplex Greek As for Simplex Roman except A-X/a-x
        ! replaced by Greek characters
        ! complexg.chr Complex Greek More detailed variant of Simplex Greek
        ! complexc.chr Complex Cyrillic Cyrillic version of Complex Roman
        ! gothicen.chr Gothic English Very detailed 'Old English' style
        ! gothicit.chr Gothic Italian Variant on the Gothic English style
        ! Two symbol sets are also supplied, in the form of 8-bit character sets :
        ! Generic Character Description
        ! Filename Set Name
        ! dingo.chr Dingo Symbols Dingbats-compatible outline symbol set
        ! symbols.chr ISS Symbols General purpose vector-based symbol set
        ! partly derived from the Hershey fonts
        ! The 'ISS Symbols' character set incorporates the five symbol sets which were supplied
        ! with v3.xx and earlier as individual 25-symbol files. Previously these were loaded via a
        ! separate routine (see IGrSymbolSet in the "Obsolete Routines" group).
        ! The following 7-bit variants of the 'Standard' character set are also supplied for
        ! backwards compatibility. They were implemented before the Standard character set was
        ! extended to include 8-bit Latin-1 characters. They all include national characters which
        ! replace certain 7-bit US ASCII characters. Their use is discouraged in new software.
        ! Generic Character Description
        ! Filename Set Name
        ! standden.chr Standard/Denmark Danish 7-bit variant of 'Standard'
        ! standfra.chr Standard/France French 7-bit variant of 'Standard'
        ! standger.chr Standard/Germany German 7-bit variant of 'Standard'
        ! standita.chr Standard/Italy Italian 7-bit variant of 'Standard'
        ! standnor.chr Standard/Norway Norwegian 7-bit variant of 'Standard'
        ! standswe.chr Standard/Sweden Swedish 7-bit variant of 'Standard'
        ! standuk.chr Standard/UK UK 7-bit variant of 'Standard'
        ! Graphics text INTERACTER Subroutine Reference
        ! 1-62
        ! All of these character sets (both 7-bit and 8-bit) should be stored in the same directory,the name of which can be defined in an operating system variable called INTCHDIR.
        ! This name can also be specified via the CHARDIR initialisation file keyword. By
        ! default, INTERACTER will attempt to open the character set file exactly as specified by
        ! FILNAM. If this fails, it will try to open the same file in the directory named in
        ! INTCHDIR/CHARDIR. This enables system independent code to be written. By
        ! specifying the generic filename, with no directory specification, you can leave
        ! INTERACTER to pick up the name of the character sets directory externally.
        ! Chapter 15 of the User Guide describes how to design your own outline or vectorbased
        ! character sets and illustrates the supplied character sets.
        !e.g. CALL IGrCharSet('H')
        !CALL IGrCharOut(100.,200.,'Hardware character set')
        !CALL IGrCharSet(' ')
        !IERROR = InfoError(1)
        !IF (IERROR.EQ.1.OR.IERROR.EQ.2) THEN
        !CALL IGrCharOut(100.,100.,'Cannot open/read char set file')
        !ELSE
        !CALL IGrCharOut(100.,100.,'Default Software character set')
        !ENDIF
        !CALL IGrCharSet('roman.chr')
        !IERROR = InfoError(1)
        !IF (IERROR.EQ.1.OR.IERROR.EQ.2) THEN
        !CALL IGrCharOut(100.,100.,'Cannot open/read char set file')
        !ELSE
        !CALL IGrCharOut(100.,100.,'Outline Roman')
        !ENDIF
        !Errors :
        !ErrFileOpen (1) : Error opening file. The current character set selection remains
        !in force.
        !ErrFileIO (2) : Error reading from file or unexpected end-of-file.
        !Hardware-dependent text is selected.
        !ErrFileClose (3) : Error closing file. Since by this stage the required character
        !set data has been read from the file, that set is selected
        !regardless of the error.
    end subroutine

    subroutine IGrCharSize(XSIZE,YSIZE)
        real XSIZE ! Character width
        ! (1.0 = base character width is equivalent to 75 per line)
        real YSIZE ! Character height
        ! (1.0 = base character height is equivalent to 25 per column)
        ! Short-name : GCHSIZ
        ! Sets the size of characters printed by IGrCharOut and IGrCharOutRel.
        ! Width/height values of 1.0 give standard size text, corresponding to 75 columns by 25
        ! rows, at fixed character spacing. This character size is completely independent of
        ! screen mode, ensuring a consistent character size, regardless of the resolution of the
        ! display. Character sizes of 2.0, for example, would give text which is twice as wide and
        ! high as the default, but the X and Y sizes need not be the same.
        ! INTERACTER Subroutine Reference Graphics text
        ! 1-63
        ! Text size is dependent on the size of the main graphics area as set by IGrArea. If
        ! IGrArea is called to rescale the size of this area, the size of graphics text is rescaled
        ! automatically. Hence, setting the width of the main graphics area to say 0.25 - 0.75,would give text which by default was half as wide, i.e. equivalent to 150 characters per
        ! line. This ensures that the size of text relative to other graphics in the main graphics
        ! area remains consistent regardless of the size of that area. However, text can quickly
        ! become unreadable in this situation, so it may be appropriate to call IGrCharSize to
        ! increase the character size when changing the main graphics area in this way.
        ! Hardware text size control is supported on most devices. A few output formats only
        ! support discrete font sizes. InfoGrScreen(19) reports the availability of hardware
        ! text size control on the current display. Where a hardware font of the current size (or a
        ! near equivalent) is not available, INTERACTER will attempt to substitute a software
        ! font, to ensure consistent behaviour across all output formats.
        ! The default character size is 1.0 for both height and width. Attempting to select a size
        ! which is less than or equal to zero resets that size to 1.0.
        ! Text is written using fixed spacing by default, but proportionally spaced text is
        ! selectable via IGrCharSpacing('P'). When proportional spacing is enabled the
        ! exact number of characters which will fit in a given screen width will vary according to
        ! what characters are actually printed. All proportional spacing is measured in terms of
        ! the equivalent fixed character spacing, so the size factor specified here is equally
        ! applicable to both fixed and proportionally spaced text.
        !e.g. CALL IGrCharSet(' ')
        !CALL IGrCharSize(1.0,1.0)
        !CALL IGrCharOut(100.,200.,'Standard Size Text')
        !CALL IGrCharSize(1.0,3.0)
        !CALL IGrCharOut(100.,100.,'Treble Height Text')
        !Portability notes :
        !DOS screen and raster hardcopy/image file drivers :
        !A degree of hardware text size control is supported. Various bit mapped fonts are
        !supported all of which are based on a minimum text size of 8x8 pixels or printer dots.
        !Text sizes are multiples of 8 pixels, i.e. 8x8, 8x16, 16x8, 16x16, etc. The nearest
        !appropriate size is selected according to the IGrCharSize parameters.
        !MS Windows :
        !Hardware text size control is fully supported.
        !Xlib :
        !Changing character size under X Windows, may require a new font file to be loaded.
        !Frequent character size changes should therefore be avoided where possible. For each
        !supported font style, various fixed sizes are available. Under X11R4 these range from 5
        !to 15 pixels wide. Under X11R5 or later, a wider range of font sizes are supported,improving the likelihood of finding a matching font size. A specific font file is selected
        !based on the requested character width. If the required font is not found for some
        !reason then an attempt will be made to substitute an alternative X font of a similar size.
        !If the required size is not available, a software font will be substituted, provided the
        !supplied INTERACTER outline fonts are accessible to the program.
        !If the X fonts which INTERACTER expects to be available in all X installations are not
        !found, programs will terminate with fatal error 12. This is unusual, since INTERACTER
        !sticks to a near universal set of Courier, Times Roman and Helvetica fonts.
        !Graphics text INTERACTER Subroutine Reference
        !1-64
        !Tektronix :
        !On a Tek 4107/4208 compatible display, full hardware text size control is supported
        !using the hardware generated stroke (vector) font. A series of discrete text sizes are
        !available on a Tek 4105-compatible. A smaller number of fixed character sizes are
        !available on a Tek 4014 or VT240/VT330/VT340. On displays which offer a limited
        !choice of text sizes, INTERACTER will select the nearest size, based on the supplied
        !XSIZE value. Standard 4014 displays support 4 character sizes. VT240, VT330 and
        !VT340 terminals (including ZSTEM240) support 8 sizes. Four sizes are available on
        !Falco Inifinity terminals but only one on the Falco 5000 series. Tek 4010 displays offer
        !no text size control.
        !ReGIS :
        !A reasonably high degree of hardware text size control is supported. Text size control is
        !similar to DOS in that text sizes increase in multiples of a basic text cell size.
    end subroutine

    subroutine IGrCharSlant(ANGLE)
        real ANGLE ! Angle at which software characters are to be drawn, in degrees
        ! ( -60.0 =< ANGLE =< 60.0 )
        ! Short-name : GCHSLA
        ! Sets the slant of characters printed by IGrCharOut when using a software character
        ! set. This enables italic text to be written, with the added flexibility of having it slope
        ! forwards or backwards. ANGLE values which are out of range are set to the maximum
        ! or minimum limits of +/- 60 degrees, as appropriate. The default character slant is 0.0,giving normal upright characters.
        ! To print slanting hardware text, use the IGrCharFont routine. Hardware fonts 2, 4, 6
        ! or 8 all select italic fonts, where supported.
        !e.g. CALL IGrCharSet(' ')
        !CALL IGrCharSlant(0.0)
        !CALL IGrCharOut(100.,200.,'Upright Characters')
        !CALL IGrCharSlant(45.0)
        !CALL IGrCharOut(100.,100.,'Italics !!')
    end subroutine

    subroutine IGrCharSpace(ICHR,SPACE)
        integer ICHR ! Character code (32-126 or 161-255)
        ! or 0 : reset entire spacing table to default values
        ! or -ve code to reset default spacing for char ABS(ICHR)
        real SPACE ! Character space (if ICHR>0)
        ! Sets or resets values in the proportional character spacing table. A default spacing table
        ! is stored in the library for all the characters in the range 32-126 and 161-255. This
        ! spacing table is expressed in terms of the space occupied by a proportionally spaced
        ! character relative to the space it would occupy when fixed spacing is selected. For
        ! example, the space value for the letter 'I' is set to .56 (i.e. 56% of the width it would
        ! occupy when fixed spacing is enabled). Similarly, the space value for 'M' is 1.42 (42%
        ! bigger than fixed spacing). The same table is used for all fonts/character sets, but it can
        ! be modified by calling this routine.
        ! The spacing table can be reset to its default values by specifying ICHR=0. Individual
        ! spacing values can be reset to their default value by passing a negative ICHR value.
        ! SPACE is only used when a valid positive ICHR value is specified.
        ! INTERACTER Subroutine Reference Graphics text
        ! 1-65
        ! Fixed or proportional spacing can be selected by calling IGrCharSpacing.
        ! IGrCharSpace can be called at any time, but the effect of calling it will only be
        ! visible whilst proportional spacing is enabled. To interrogate the character spacing
        ! table or measure the length of a proportionally spaced string, use the function
        ! IGrCharLength.
        !e.g. CALL IGrCharSpacing('P')
        !C Increase the spacing value for the letter I to 65%
        !ICHR = ICHAR('I')
        !CALL IGrCharSpace(ICHR,0.65)
    end subroutine

    subroutine IGrCharSpacing(FIXPROP)
        character(len=*) FIXPROP ! Required character spacing :
        ! = F : Fixed (default) ) can be upper
        ! = P : Proportional ) or lower case
        ! Selects fixed or proportional character spacing. By default, fixed spacing is selected
        ! which causes all characters to occupy equally sized character cells. This makes text
        ! string lengths and individual character positions easy to calculate. When proportional
        !spacing is selected, characters are spaced according to the width of a character (e.g. a W
        !occupies nearly 3 times the width of an I).
        !A common spacing table is maintained for all fonts, but this can be modified by calling
        !IGrCharSpace. The length of a proportionally spaced string can be measured using
        !IGrCharLength.
        !All software character sets support proportional spacing. When hardware text is
        !selected the effect of selecting fixed or proportional spacing is as follows :
        !Proportional spacing : A hardware-specific Helvetica or Times Roman style of font
        !will be selected, if available. If this is not available (e.g. DOS graphics mode) an
        !equivalent software outline font will be substituted automatically (provided the
        !character set file can be found).
        !Fixed spacing : A Courier font or equivalent hardware font will be selected. An
        !equivalent software outline font ('fixed') may be substituted automatically if a suitable
        !hardware font is not available. Resizeable fixed-space fonts are available on most
        !devices.
        !See also IGrCharFont, which determines the actual fixed or proprtionally spaced
        !font to be used.
        !e.g. CALL IGrCharSet('swiss.chr')
        !CALL IGrCharSpacing('F')
        !CALL IGrCharOut(100.,100.,'Fixed spacing')
        !CALL IGrCharSpacing('P')
        !CALL IGrCharOut(100.,200.,'Proportional Spacing')
    end subroutine

    subroutine IGrCharUnderline(ONOFF)
        character(len=*) ONOFF ! 'ON' : switch underlining on (upper or lower case)
        ! = any other value to switch underlining off
        ! Short-name : GCHUND
        ! Enables or disables underlining of graphics text. Once underlining is enabled, all
        ! horizontal text is underlined regardless of which character set is in use. Vertical text is
        ! not underlined, since this is not very useful. By default, underlining is off.
        ! Graphics text INTERACTER Subroutine Reference
        ! 1-66
        !e.g. CALL IGrCharUnderline('ON')
        !CALL IGrCharOut(100.,200.,'This is underlined')
        !CALL IGrCharUnderline('OFF')
        !CALL IGrCharOut(100.,100.,'And this is not')
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-67
        !1.6 Group GH : Graphics Hardcopy/Export
        !All of INTERACTER's graphics output routines can be made to generate hardcopy by
        !calling the IGrHardCopy routine, before the graphics image is drawn. (Note The
        !term .hardcopy. is used here to cover output to printers/plotters and graphics files.)
        !Graphics commands will thereafter generate both screen and hardcopy output, or just
        !hardcopy output if 'H' was specified to IScreenOpen, IScreenMode or
        !IGrInit. Such hardcopy output will normally be independent of the screen display
        !and of a relatively high quality.
        !By default, hardcopy is generated in HP-GL/2 format, but other drivers can be selected
        !using IGrHardCopySelect. Various hardcopy options are available to control the
        !behaviour of the selected driver, via IGrHardCopyOptions. These options can be
        !saved to or loaded from a disk file via IGrHardCopyOptSave and
        !IGrHardCopyOptLoad. Driver and option selection can be combined using
        !IGrHardCopySelFile.
        !If multiple pages are to be output to the same device or file, IGrEndPage can be used
        !to mark the end of each page of output.
        !The mappings between INTERACTER colour numbers and HP-GL pen numbers or
        !Lotus PIC file colour numbers can be controlled by IGrHardColourToPen.
        !ASCII text files can be printed via the graphics hardcopy drivers, by means of
        !IGrHardCopyTextFile.
        !For further information on the supplied drivers see the Graphics Hardcopy/Export
        !Drivers chapter of the User Guide.
        !As an alternative to using IGrHardCopy, IGrPrintImage can be called after the
        !display has been generated to dump the graphics area to a printer. This reduces
        !processing during graph plotting, but the quality of the dump will usually be limited by
        !the resolution of the screen. Similarly, the graphics area can be saved to a bit image file,by calling IGrSaveImage. Bit image files can also be generated directly from
        !program data via IGrSaveImageData8 and IGrSaveImageData24.
    end subroutine

    subroutine IGrEndPage(ACTION)
        character(len=*) ACTION ! String describing required action
        ! = 'P' : Preserve contents of graphics screen
        ! Short-name : GPAGE
        ! Ends a page of graphical output. An end-of-page command is sent to the hardcopy
        ! driver, if one is active, dependent on the selected driver:
        ! HP-GL An 'SP 0' command is generated. A 'PG' command is inserted in
        ! HP7550 output.
        ! PostScript A 'showpage' command will be issued, along with other end-of-page
        ! information such as the number of copies to be printed.
        ! Raster The internal raster image is dumped to the output device or file and
        ! the internal image buffer is cleared.
        ! Lotus PIC An 'end-of-picture' opcode is inserted in the output file.
        ! Graphics Hardcopy/Export INTERACTER Subroutine Reference
        ! 1-68
        ! DXF No end-of-page command available.
        ! CGM An "END PICTURE" element code is inserted in the output file.
        ! Windows The Print Manager driver calls the API function EndPage.
        ! WMF No end-of-page command available.
        ! HP-GL/2 The printer is temporarily switched to PCL mode. A number-of-copies
        ! instruction is issued followed by a page-throw. The printer is then
        ! returned to HP-GL/2 mode.
        ! The screen is cleared unless ACTION contains a 'P' to preserve the screen contents. The
        ! 'P' argument has no effect if hardcopy-only graphics are enabled.
        ! See also IGrPause.
    end subroutine

    subroutine IGrHardColourToPen(NCOLOR,IPEN)
        integer NCOLOR ! INTERACTER colour number, as for IGrColourN (0-255)
        integer IPEN ! Pen/colour number
        ! (HP-GL : 1 to 9 )
        ! (Lotus : 1 to 16 )
        ! (-1 to return to default mapping )
        ! Short-name : GHCPEN
        ! Defines the mapping between an INTERACTER 8-bit colour number and a pen/colour
        ! number in HP-GL or Lotus PIC output, i.e. Whenever a routine such as IGrColourN
        ! or IPgStyle is used to select an INTERACTER 8-bit colour number NCOLOR, the
        ! HP-GL or Lotus PIC driver will select pen/colour number IPEN. This mechanism
        ! operates in both 8-bit and 24-bit colour models, since neither of these drivers support
        ! 24-bit colour. (Internally IGrColourN will convert 24-bit RGB values to the nearest
        ! colour number in its 8-bit palette. The resulting colour number corresponds to
        ! NCOLOR.)
        ! By default, an automatic mapping is used, as described in the Portability notes.
        ! IGrHardColourToPen allows this default mapping to be overridden on a colourby-
        ! colour basis. The pen/colour numbers for each of the 256 INTERACTER colour
        ! numbers are separately redefinable. Each INTERACTER colour number uses the default
        ! mapping, unless redefined. So, changing the mapping for colour 200 will not affect
        ! settings for colours 199 or 201, for example.
        ! If for some reason the default mapping behaviour for a given INTERACTER colour
        ! number needs to be restored, simply specify a negative IPEN value. Alternatively, all
        ! colour/pen mappings are restored to their default each time a driver is initialised. This
        ! occurs when IGrInit or IGrHardCopySelect is called.
        ! Calls which specify an NCOLOR value outside the range 0-255 are ignored.
        !e.g. CALL IGrColourN(200)
        !C Draw a border round graphics area using pen number 1
        !CALL IGrHardColourToPen(200,1)
        !CALL IGrBorder
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-69
        !Portability notes :
        !HP-GL:
        !The value of IPEN should normally be in the range 1 to the number-of-available-pens,(InfoHardware(7)). Larger pen numbers are permitted up to a limit of 9, since this
        !allows additional pens to be used (where fitted) on plotters which are not otherwise
        !specifically supported. The default mapping between INTERACTER colour numbers
        !and HP-GL pen numbers is described in the following table :
        !INTERACTER
        !Colour #
        !4-pen
        !plotter
        !6-pen
        !plotter
        !8-pen
        !plotter
        !0-15, 240-255 1 1 1
        !16-47 3 3 3
        !48-79 1 5 5
        !80-111 2 2 2
        !112-143 2 6 6
        !144-175 4 4 4
        !176-207 3 1 7
        !208-239 4 2 8
        !Lotus PIC :
        !Lotus graphic files allow for up to 16 different colours, so IPEN must be in the range 1
        !to 16. Interpretation of colour numbers in PIC files varies considerably depending on
        !which WP/DTP package is used to import the file, so it is quite possible that the default
        !mapping may need to be modified for best results. The default mapping is as follows:
        !INTERACTER
        !Colour #
        !Lotus PIC
        !Colour
        !INTERACTER
        !Colour #
        !Lotus PIC
        !Colour
        !0-15 1 128-143 12
        !16-31 5 144-159 2
        !32-47 13 160-175 10
        !48-63 7 176-191 6
        !64-79 15 192-207 14
        !80-95 3 108-223 8
        !96-111 11 224-239 16
        !112-127 4 240-255 9
        !Graphics Hardcopy/Export INTERACTER Subroutine Reference
        !1-70
    end subroutine

    subroutine IGrHardCopy(DESTIN)
        character(len=*) DESTIN ! Destination name :
        ! = ' ' : default hardcopy output device/file/command
        ! = filename: named file or device
        ! = command: print command (@ specifies filename position)
        ! = 'S': Stop hardcopy output
        ! Short-name : GHCOPY or GDEVIC
        ! Enables or disables graphics hardcopy output. The hardcopy driver to be used can be
        ! selected using IGrHardCopySelect. By default, this will be the HP-GL/2 driver.
        ! Other drivers include HP-GL, PostScript, PCL, DXF, CGM, etc. Each of the available
        ! drivers is described in more detail in chapter 17 of the User Guide.
        ! If you wish to produce hardcopy, IGrHardCopy should be called with a suitable
        ! destination name, before calling the INTERACTER graphics routines which actually
        ! generate your graphics output. Thereafter, each call to a graphics routine will cause
        ! hardcopy instructions to be sent to the selected driver. If screen output has been
        ! enabled, the same graphics will also appear on screen. When no more hardcopy is
        ! required, just call IGrHardCopy again with an 'S' argument, to stop output and close
        ! the graphics hardcopy output channel. IScreenClose does this automatically.
        ! DESTIN specifies the output file name. If, no destination file name is specified, the
        ! graphics hardcopy driver will then write to the following default destination :
        !   Windows Print Manager : Output will be sent to the default Windows printer.
        !   WMF : Output will be sent to the Windows clipboard. Other applications will be
        ! able to import the file via a 'paste' operation.
        !   Other drivers : Output will be written to the file specified on the PLNAME record
        ! in the initialisation file. If this has also not been specified, output is written to
        ! interact.plt.
        ! Writing output to a file overwrites that file. Calling this routine twice, even with the
        ! default destination, will cause the previous file contents to be overwritten, unless
        ! different destination names are specified.
        ! Alternatively, DESTIN can specify an operating system command when generating HPGL,PostScript, raster (HP/Epson/IBM) or HP-GL/2 output (i.e. drivers 1, 2, 4 or 12). If
        ! DESTIN contains a space delimited @ character, when any of these drivers are
        ! selected, IGrHardCopy takes the following action:
        !   Output is written to a temporary file. The location and name of this file are
        ! determined automatically.
        !   When IGrHardCopy('s') or IScreenClose are called, the temporary file is
        ! closed and printed using the supplied operating system command. The @ character
        ! is replaced by the temporary print file name.
        !   The temporary print file is deleted.
        ! Examples of typical print commands are provided in the Portability notes. The
        ! PLNAME initialisation file record can also specify such a command.
        ! INTERACTER Subroutine Reference Graphics Hardcopy/Export
        ! 1-71
        ! The type of hardcopy commands generated by calling IGrHardCopy depends on the
        ! drivers which are linked into your program and on the current driver selection. Only
        ! one hardcopy driver can be active at any one time, though several may be linked into
        ! the same program, if required. By default, commands are generated in HP-GL/2 format.
        ! Other output formats can be selected by calling IGrHardCopySelect or by linking
        ! a customised version of IGrHardCopySelect as described in chapter 17 of the
        ! User Guide. If you wish to be able to replay hardcopy files at a later time using
        ! IGrReplay, be sure to use one of the HP-GL, HP-GL/2, CGM, PIC or WMF drivers.
        ! When the HP-GL/2, HP-GL or raster hardcopy drivers are used, the target device type
        ! can be selected using IPrinter2, IPlotter or IPrinter. Alternatively, the
        ! HPGL2 , PLOTTER or PRINTER keywords can be specified in the initialisation file.
        ! IdPrinter2, IdPlotter or IdPrinter can be used to select printer/plotter
        ! interactively.
        ! HP-GL, HP-GL/2, PostScript and DXF output files are plain ASCII. All others are
        ! binary formats. All files are transferable between different systems/platforms. Binary
        ! files must not undergo any type of format conversion when transferred between
        ! operating systems.
        ! The calling order for IGrHardCopy in combination with IGrHardCopyOptions,IGrHardCopySelect and the graphics output routines is crucial to ensure correct
        ! hardcopy output. If an alternative driver is to be selected, call IGrHardCopySelect
        ! first. IGrHardCopyOptions should then be called to modify any hardcopy options,before calling IGrHardCopy to open the graphics hardcopy output channel. Graph
        ! plotting may then proceed in the normal manner. Calling IGrPause or IGrEndPage
        ! will end a logical 'page' within the output file. A call to IGrHardCopy('S') or
        ! IScreenClose will close the hardcopy output channel.
        !e.g. LOGICAL DEFAUL
        !CHARACTER*12 DESTIN
        !:
        !C Select alternative driver if required
        !CALL IGrHardCopySelect(1,IDRIVR)
        !C Set hardcopy options if required
        !CALL IGrHardCopyOptions(1,IWIDTH)
        !CALL IGrHardCopyOptions(2,IHEIGHT)
        !C Call IGrHardCopy before your graphics processing
        !C - print graphs both to screen and default hardcopy file
        !IF (DEFAUL) THEN
        !DESTIN = ' '
        !ELSE
        !DESTIN = 'myfile.plt'
        !ENDIF
        !CALL IGrHardCopy(DESTIN)
        !CALL MYGRAF
        !C Stop generating hardcopy
        !CALL IGrHardCopy('S')
        !Errors :
        !ErrFileOpen (1): Error opening hardcopy device/file
        !ErrFileIO (2): Error writing initialisation codes to hardcopy device/file
        !ErrFileClose (3): Error closing hardcopy device/file if already open after a
        !previous call to IGrHardCopy
        !ErrPageSize (34): Requested page size too large for raster image buffer
        !(generated by raster driver)
        !Graphics Hardcopy/Export INTERACTER Subroutine Reference
        !1-72
        !Portability notes :
        !DOS :
        !Output can be sent direct to a device (e.g. PRN or LPT1). When output is sent to a file,instead of a device, you can send the file to a device later using a standard DOS COPY
        !or PRINT command, e.g.
        !COPY INTERACT.PLT LPT2
        !If the file is in binary format, as in the case of output from the raster driver, the /B
        !option should be specified, e.g.
        !COPY INTERACT.PLT PRN/B
        !Alternatively equivalent commands can be specified in the DESTIN argument,replacing the file name with an @ character. e.g.
        !COPY @ PRN/B
        !Typically, it is only worth using this mechanism in the DOS version if a file needs to be
        !printed in an unusual manner (e.g. via a batch file). For direct output to a device, just
        !specify the device name.
        !If output is sent direct to a serial (COMn) port it is advisable to specify P for the retry
        !parameter on the DOS MODE command which sets the baud rate etc. for that port. This
        !forces DOS to keep retrying when the serial device is busy rather than generating an
        !"Abort, Retry" message.
        !Windows :
        !When using one of INTERACTER's own (format-specific) drivers, direct output to a
        !device is typically not recommended (though it may well work, particularly when using
        !an ASCII output format such as PostScript or HP-GL/2). A better solution is to specify
        !a print command in this case, e.g.
        !COPY @ PRN/B
        !When the Windows printer driver is selected (i.e. output via Print Manager, using
        !driver #10) DESTIN is ignored. The destination is determined independently by Print
        !Manager in this case.
        !VMS :
        !Output can be sent direct to a device. Check with your local system manager on the
        !exact device name you should use in this case. If output is sent to a file, instead of
        !direct to a device, it can be printed later with a standard VMS PRINT or COPY
        !command. Alternatively, a suitable printing command can be specified in DESTIN, e.g.
        !PRINT/PASSALL @
        !Unix :
        !Output can be sent direct to a device. Check with your local system manager on the
        !exact device name you should use in this case. If output is sent to a file, instead of
        !direct to a device, it can be printed later with a Unix lp, lpr or cp command,depending on your local set up. Alternatively, a print command can be specified in
        !DESTIN. For example, if the PostScript driver is currently selected and the default
        !print queue is set up for PostScript output, specify the following command in DESTIN:
        !lpr @
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-73
    end subroutine

    subroutine IGrHardCopyOptions(NOPTN,IVALUE)
        integer NOPTN ! Option number (1-27, 101-107)
        integer IVALUE ! Option value (see following table)
        ! Short-name : GHCOPT
        ! Include : intergh.inc, intergen.inc
        ! Defines graphics hardcopy output options as defined in the following table. The drivers
        ! referred to in the Used by section are :
        ! 1 = HP-GL 8 = AutoCAD DXF format
        ! 2 = PostScript 9 = CGM format
        ! 4 = Raster hardcopy A = Windows Print Manager
        ! 6 = Raster Image file (PCX or BMP) B = Windows Metafile
        ! 7 = Lotus PIC format C = HP-GL/2
        ! The following symbolic names are defined in intergh.inc and the INTERACTER
        ! module to specify NOPTN:
        ! ImageWidth (1) LineJoin (10) ResetStartEnd (19)
        ! ImageHeight (2) LineCap (11) Transparency (20)
        ! HorizPos (3) FillDensity (12) HPGLLabelTerm (21)
        ! VerticPos (4) PrintDensity (13) EPSfile (22)
        ! Orientation (5) HardwareText (14) ColourPlanes (23)
        ! InvertColours (6) ControlD (15) DriverFill (25)
        ! UseColour (7) MaxStroke (16) ImageFormat (26)
        ! NumCopies (8) CarriageCtrl (17) WMFFormat (27)
        ! LineWidth (9) HPGLReplayInfo (18)
        ! TextPrintCols (101) TextPrintFont (105)
        ! TextPrintRows (102) TextPrintWrap (106)
        ! TextPrintPage1(103) TextPrintCC (107)
        ! TextPrintPage4(104)
        ! Graphics Hardcopy/Export INTERACTER Subroutine Reference
        ! 1-74
        ! Used by drivers *
        ! Opt IVALUE 1 2 4 6 7 8 9 A B C
        ! 1 Image width in points (1/72 inch)   
        ! 2 Image height in points   
        ! 3 Horizontal image adjustment in points   
        ! 4 Vertical image adjustment in points   
        ! 5 Orientation
        ! IntPortrait (0) portrait
        ! IntLandscape (1) landscape
        ! IntPortraitWH (2) portrait (set w/h)
        ! IntLandscapeWH (3) landscape ( -.- )
        !   
        ! 6 Invert colour numbers
        ! IntNo (0) : no
        ! IntYes (1) : yes
        ! BwOnly (2) : black/white only
        !  
        ! 7 Only use colour for fills
        ! IntNo (0) : no
        ! IntYes (1) : yes
        !  
        ! 8 Number of copies (>=1)   
        ! 9 Line thickness in tenths of a point  
        ! 10 Line join style
        ! MitreJoin (0) : mitred
        ! RoundJoin (1) : round
        ! BevelledJoin (2) : bevelled
        !  
        ! 11 Line cap
        ! ButtCap (0) : butt
        ! RoundCap (1) : round
        ! SquareCap (2) : projecting square
        !  
        ! 12 Fill line density  
        ! 13 Print density (1-4, 1 is highest) 
        ! 14 Force hardware text (0=no 0<font #)  
        ! 15 Add Ctrl/D to PostScript files
        ! IntNo (0) : no
        ! IntYes (1) : yes
        ! 
        ! 16 Max PostScript stroke frequency
        ! (10-255)
        ! 
        ! 17 Include carriage control
        ! IntNo (0) : no
        ! IntYes (1) : yes
        !  
        ! 18 Include HP-GL replay info
        ! IntNo (0) : no
        ! IntYes (1) : yes
        ! 
        ! INTERACTER Subroutine Reference Graphics Hardcopy/Export
        ! 1-75
        ! Used by drivers *
        ! Opt IVALUE 1 2 4 6 7 8 9 A B C
        ! 19 Reset/form feed at start/end (0-3)  
        ! 20 Transparency mode
        ! IntNo (0) : no
        ! IntYes (1) : yes
        ! 
        ! 21 HP-GL Label terminator (ASCII code)  
        ! 22 Generate EPS output
        ! IntNo (0) : no
        ! IntYes (1) : yes
        ! 
        ! 23 Number of colour planes
        ! (BMP/PCX file : 1, 4, 8 or 24)
        ! (DXF file : 3, 4 or 8)
        !  
        ! 25 Use driver-specific fill method
        ! IntNo (0) : no
        ! IntYes (1) : yes
        !  
        ! 26 Raster image file format
        ! PCXfile (0):PCX
        ! BMPuncompr (1):BMP uncompressed
        ! BMPrle (2):BMP compressed
        ! 
        ! 27 WMF file format
        ! StandardWMF (0) : Win3.1 standard
        ! AldusWMF (1) : Aldus placeable
        ! EnhancedWMF(2) : Win32 enhanced
        ! 
        ! The following options apply specifically to ASCII text file printing and are generic to
        ! all hardcopy drivers :
        ! 101 Columns per page in text print 
        ! 102 Rows per page in text print 
        ! 103 Start page in text print 
        ! 104 End Page in text print 
        ! 105 Courier font number in text print 
        ! 106 Wrap at end of line in text print (0/1) 
        ! 107 Act on Fortran carriage control (0/1) 
        ! If any hardcopy options are to be modified, this routine should normally be called
        ! before the call to IGrHardCopy which initiates hardcopy output (exceptions to this
        ! rule for individual options are noted below). Similarly, a call to
        ! IGrHardCopySelect to select an alternative graphics driver should precede any
        ! calls to IGrHardCopyOptions to modify hardcopy driver options.
        ! Graphics Hardcopy/Export INTERACTER Subroutine Reference
        ! 1-76
        ! All graphics hardcopy drivers are controllable by IGrHardCopyOptions though
        ! not all combinations of options and driver are supported (see table). The current values
        ! of any of the hardcopy options can be interrogated using InfoGrHardcopy. See also
        ! IGrHardCopyOptLoad and IGrHardCopyOptSave.
        ! Options 1 and 2 control the size of the image on the printed page, as opposed to the
        ! size of the paper on which the image is to be printed. It is the responsibility of the
        ! calling program and/or the user to ensure that the requested image size does not exceed
        ! the paper size being used. (Under the raster image file driver, these options define the
        ! image size in pixels rather than points.)
        ! Options 3 and 4 allow fine adjustment of the position of the image on the page.
        ! Positive horizontal adjustment values move to the right, negative values move to the
        ! left. The direction of vertical adjustment depends on the driver being used. The origin
        ! is at the bottom left in HP-GL, HP-GL/2 and PostScript output. Hence positive vertical
        ! adjustments move the image up relative to the bottom of the page when using these
        ! drivers. Under the raster graphics and Windows Print Manager drivers, positive vertical
        ! adjustments move the image down, relative to the top of the page.
        ! Option 5 allows the image to be printed in Portrait or Landscape orientation. When
        ! IVALUE is specified as 0 or 1, image width and height are treated as being independent
        ! of the requested orientation. i.e. they define the size of the printed image independently
        ! of whether it has been rotated on the output page. Alternatively, specify 2 or 3 to select
        ! portrait/landscape orientation and force the selected width/height values to match, as
        ! appropriate. For instance, specifying an orientation value of 2 (portrait) when the image
        ! width (option 1) exceeds the image height (option 2) will force
        ! IGrHardCopyOptions to exchange the width/height values.
        ! Option 6 controls how colour is to be interpreted :
        ! IVALUE = 0 reproduces all graphics colours as closely as possible, using appropriate
        ! grey scales on monochrome devices. This means that colours such as yellow or cyan are
        ! represented by lighter grey scales than colours such as red or blue. Since white graphics
        ! are also reproduced as white in the hardcopy output, this setting only makes sense
        ! where exact reproduction of the graphic image is required. This is mainly intended for
        !use with colour output devices (e.g. colour PostScript printers, HP PaintJet, colour
        !DeskJets, Epson JX, etc.). This is the default setting if black/white reversal is enabled
        !via IScreenOpen.
        !IVALUE = 1 inverts all graphics colours. Output from this option is best suited to
        !monochrome printers. In fact this option forces grey scaled mono output when using a
        !colour printer with the raster hardcopy driver. Under the PostScript and CGM drivers,output still contains colour information but colour values are inverted to give darker
        !grey scales for light colours (e.g. yellow/cyan) and vice versa.
        !IVALUE = 2 is a general purpose compromise between settings 0 and 1 which is
        !suitable for both monochrome and colour output devices. As such, it is the default
        !setting for option number 6, when the default white-on-black screen palette is used. It
        !generates output which matches the original colour selections except for black and
        !white which are inverted.
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-77
        !When a white-on-black colour scheme is selected (the default) and 24-bit colour
        !specification is requested (via IGrColourModel(24)), it is may be preferable to set
        !option 6 to zero, otherwise explicit requests for 'black' or 'white' will give the opposite
        !colours.
        !Option 7 controls how coloured lines are to be treated when generating colour output
        !which may be printed on a monochrome device. The use of colour can be limited to
        !area fills giving grey scaled fills on monochrome devices, but leaving lines solid. If
        !colour (and hence grey scaling) is also applied to lines, a somewhat inferior result may
        !be obtained on monochrome devices.
        !Option 8 selects the number of copies. Amongst the currently supported devices,PostScript, HP LaserJet and DeskJet 1200C/1600C printers support this feature. The
        !Windows Print Manager also supports this feature, though this is dependent on the
        !target printer driver. This setting can be changed at any time in the PostScript and raster
        !drivers, prior to an end-of-page call (e.g. IGrEndPage, IGrPause, etc.)
        !Option 9 controls line thickness. When plotting at high print resolutions the default
        !line thickness gives lines which are slightly thicker than the minimum device
        !resolution. The ideal thickness depends largely on output device and personal taste.
        !Unlike some other hardcopy options, line thickness can be redefined after
        !IGrHardCopy has been called, allowing various hardcopy line widths to be used in a
        !single plot. See chapter 17 of the User Guide for driver-specific comments regarding
        !line thickness. Hardcopy line thickness can also be set via IGrLineWidth (this has
        !exactly the same effect as calling IGrHardCopyOptions(9,n) directly).
        !Options 10 and 11 control the manner in which line joins and ends are rendered on the
        !output device. Typically these parameters will need to be varied if unexpected long
        !lines appear where lines join at acute angles.
        !Option 12 controls the density of hatch lines used to perform solid and mixed-colour
        !fills using the HP-GL or Lotus PIC drivers. In some circumstances this is also used by
        !the DXF driver. Increasing this value reduces plotting time and output file size, but may
        !not give a completely solid fill as a result. Unlike some other
        !IGrHardCopyOptions options, hatch line density can be redefined after
        !IGrHardCopy has been called. Driver-specific notes are as follows :
        !HP-GL : Density is measured in hundredths of a point. The ideal value depends
        !heavily on the pens being used. Typical values will be in the range 50-200. Where
        !HP-GL output is not actually destined for a plotter, but is to be replayed by
        !IGrReplay or post-processed by Toolkit programs (INTPRINT or INTVIEW), this
        !parameter can be set to an arbitrarily large value. The replay facility will still reproduce
        !solid or mixed fills as required, but the size of output file may be substantially reduced,since the hatch fill lines are not used by the replay routine.
        !Lotus PIC : Density is measured in 1/100000th of the picture height. The ideal
        !value depends heavily on the resolution of the ultimate target output device.
        !DXF : Some fill types use multiple adjacent lines in the DXF driver (mixedcolour
        !fills, circles/ellipses/arcs and complex polygons), in which case fill density is
        !measured in hundredths of a point.
        !Graphics Hardcopy/Export INTERACTER Subroutine Reference
        !1-78
        !Option 13 controls print density, since most dot-matrix/laser/inkjet printers support
        !more than one setting. This is only used by the raster graphics driver. Rather than
        !specifying the print density directly, a density number of 1-4 is used. For each known
        !output device INTERACTER supports up to 4 densities. The number of supported
        !densities is returned by InfoHardware(2). Actual densities available are returned
        !by InfoHardware(3-6). For example, an HP PaintJet supports two print densities,180 dpi and 90 dpi, so InfoHardware(2) would return 2. Printer density 1 is the
        !highest (e.g. 180 dpi on a PaintJet). By default, INTERACTER selects the 2nd highest
        !available density (e.g. 90 dpi on a PaintJet).
        !Option 14 can be used to force a hardware character set to be used in hardcopy output
        !regardless of the on-screen character set. IVALUE should be set to the number of the
        !font which is to be used for hardcopy hardware characters, using the same numbering
        !system as IGrCharFont in the GC group. By default, screen and hardcopy character
        !sets are the same (i.e. as IVALUE = 0). Unlike most other hardcopy options, this setting
        !can be changed after IGrHardCopy has been called. (In general, use of option 14 is
        !no longer recommended. It pre-dates the more general outline font substitution method
        !introduced at versions 3.15/4.0.)
        !Option 15 determines whether a Ctrl/D terminator is added at the end of PostScript
        !printer output. Some, but not all, PostScript printers require this. Those which do not,usually still accept it without causing an error, so the Ctrl/D terminator is enabled by
        !default. This option is not used by the PostScript driver when generating EPS
        !(Encapsulated PostScript), where the Ctrl/D terminator is always omitted.
        !Option 16 can be used to control the maximum frequency of 'stroke' commands in a
        !PostScript output file. In this case IVALUE specifies the maximum number of 'lineto'
        !commands which can be generated before a 'stroke' command is issued to close a
        !PostScript path. Older PostScript interpreters or printers may require a lower value than
        !the default of 255. Reducing the maximum stroke frequency increases output file sizes
        !but reduces the likelihood of interpreter overflow errors. The appropriate value depends
        !heavily on the particular interpreter or printer being used.
        !Option 17 determines whether a space carriage control character should be inserted at
        !the start of each line in HP-GL, HP-GL/2 and PostScript output files. By default,INTERACTER does not include carriage control characters at the start of such output
        !records. Some Fortran oriented print spoolers may require carriage control to be
        !included, but most systems do not. Output file size will be increased if carriage control
        !is included.
        !Option 18 controls the inclusion of 'replay' information in HP-GL output files.
        !Normally, INTERACTER embeds extra information in HP-GL files, allowing them to
        !be accurately replayed using IGrReplay. This information is also used by Toolkit
        !programs which can replay HP-GL (e.g. INTPRINT). If an HP-GL output file is not to
        !be processed by IGrReplay or a Toolkit program, then this replay information can be
        !safely omitted, to reduce file size. Some poorly written HP-GL importers will need this
        !information to be switched off too.
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-79
        !Option 19 controls the output of reset/form feed codes on HP-GL plotters, HP PCL
        !printers and Epson type printers as follows :
        !HP-GL : IVALUE = 0 = don't switch plotter on/off at start/end
        !1-3 = switch plotter on/off at start/end
        !HP PCL : IVALUE = 0 = don't reset printer at all
        !1 = reset printer at end only
        !2 = reset printer at start only
        !3 = reset printer at start and end
        !Epson : IVALUE = 0/2 = No form feed at end of print
        !1/3 = form feed at end of print
        !HP-GL plotters : Setting IVALUE to a non-zero value causes ESC.Y and ESC.Z
        !codes to be added at the start and end of HP-GL output files, to switch the plotter
        !on/off. This will be necessary if the device has been configured to be inactive until
        !explicitly enabled by a 'plotter on' sequence. By default, plotter on/off codes are not
        !generated since the more common configuration is for plotters to be active at all times.
        !HP PCL printers : By default each image dumped to an HP PCL printer begins and
        !ends with a printer reset command (ESC E). This resets the printer to its default state
        !and prints all data in the printer. Similarly, each image sent to an Epson-type printer is
        !terminated by a form-feed by default. Option number 19 can be used to modify this
        !behaviour. In the case of HP PCL printers, it can be used to print more than one image
        !on the same page. Typically, this would be achieved by setting IVALUE to 2 before
        !dumping the first image, then to 0 for intermediate images and to 1 for the last image.
        !Epson printers : IVALUE can be set to 0 or 2 to suppress the final form feed, thus
        !allowing additional printout to be added immediately below the printed image.
        !Option 20 allows 'transparency mode' to be enabled when using the raster driver to
        !generate output on an HP PaintJet. This causes the PaintJet to use double pass printing
        !for higher quality when printing on transparency film. This option should not be used
        !for paper hardcopy and is disabled by default.
        !Option 21 specifies the ASCII character to be used to mark the end of hardware text
        !strings generated by the HP-GL or HP-GL/2 drivers (the 'label terminator' in HP-GL
        !terminology). This should be an ASCII code in the range 1-127. The default is 4
        !(EOT).
        !Option 22 determines whether the PostScript driver generates files in EPS
        !(Encapsulated PostScript) format. By default printer output is generated. If EPS is
        !selected, output files are generated in a slightly modified format which is suitable for
        !inclusion in WP/DTP documents which will be printed on PostScript printers. Enabling
        !this option causes option 15 to have no effect.
        !Option 23 specifies the number of colour planes in a BMP/PCX file (generated by the
        !raster image file driver) or a DXF file. For a BMP/PCX file, IVALUE should be 1, 4, 8
        !or 24, which gives 2, 16, 256 or 16 million colours respectively. 256 colour images are
        !generated by default. 24-bit colour files are only likely to be useful when the 24-bit
        !colour model has been selected via IGrColourModel. For a DXF file, IVALUE
        !should be one of 3, 4 or 8, giving 7, 14 or 255 colours. DXF files are generated using
        !the full AutoCAD 255 colour palette by default.
        !Graphics Hardcopy/Export INTERACTER Subroutine Reference
        !1-80
        !Option 24 is reserved and should not be modified.
        !Option 25 determines the area fill method to be used by drivers which provide a fill
        !primitive capability, but which are likely to be subject to some form of driver-specific
        !limitations (see chapter 17 of the User Guide). IVALUE=0 selects the generic method,which draws many adjacent horizontal lines. Typically this increases output file size
        !and relies heavily on the setting of option 12. IVALUE=1 enables driver specific fills to
        !be used where appropriate, though still falling back on the generic fill method where
        !necessary. Driver-specific fills typically give better results, where available. Unlike
        !some other IGrHardCopyOptions options, the preferred fill method can be
        !redefined after IGrHardCopy has been called, allowing selective use of device fills
        !for certain types of fill and not for others.
        !Option 26 determines the format of files generated by the raster image file driver
        !(hardcopy number 6). By default, PCX files are generated, but uncompressed or
        !compressed Windows bitmap (BMP) files can also be selected. Compressed BMP files
        !typically require significantly less disk space, but cannot be loaded by a small minority
        !of Windows packages. Only 16/256 BMP files can be compressed, so monochrome and
        !24-bit colour BMP files are always saved uncompressed.
        !Option 27 determines the format in which WMF files are generated. Certain Microsoft
        !products (e.g. Word & Excel) will not read Standard Windows WMF files. Instead they
        !require WMF files to be in Aldus placeable metafile format. Aldus format is therefore
        !enabled by default when generating WMF files. Most other packages can read WMF
        !files in both Standard Windows 3.1 format and Aldus placeable format. The Win32
        !API introduced the Enhanced metafile format, which generates larger files and is not
        !supported by many packages. The Enhanced format is therefore supported mainly for
        !completeness and is only available in Win32 implementations.
        !Finally, options 101-107 apply specifically to ASCII text file prints as generated by
        !IGrHardCopyTextFile :
        !Options 101 and 102 determine the number of text columns/rows which will be fitted
        !into the page area as set by options 1 and 2.
        !Options 103 and 104 determine the start/end pages within the document. The default
        !values ensure that the whole of the document is printed.
        !Option 105 determines which variant of the Courier font is used to print the text file,using the same numbering scheme (1-4) as IGrCharFont. INTERACTER's nearest
        !equivalent software font may be used, where a particular output format provides poor
        !Courier text support. Best results will be achieved with formats which use rescalable
        !hardware fonts (e.g. Print Manager, PostScript, HP-GL/2).
        !Option 106 controls end-of-line wrap. By default this is disabled, causing long lines to
        !be truncated.
        !Option 107 controls Fortran carriage control recognition. By default this option is
        !disabled and a standard plain ASCII text file is assumed. Enabling this option causes
        !the first character of each line in the file to be interpreted as follows:
        !1 : New page + : Stay on current line
        !0 : Skip a line Other : New line
        !NOPTN values outside the specified range are ignored.
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-81
        !See also IdGrHardcopyOptions which allows graphics hardcopy options to be
        !selected interactively using pre-defined forms.
        !The following tables list the default option values for each option number (note that
        !some default values for the raster graphics hardcopy driver depend on whether an
        !Epson/IBM or HP PCL printer has been selected) :
        !Default IVALUE for drivers 1-4
        !NOPTN HP-GL
        !Plotter
        !PostScript Raster
        !(Epson)
        !Raster
        !(HP PCL)
        !1 Varies * 756 576 576
        !2 Varies * 540 432 432
        !3 Varies * 42 0 100
        !4 0 -20 0 70
        !5 Land Land Port Land
        !6 - 2V 2V 2V
        !7 - Fills only - -
        !8 - 1 - 1
        !9 5 5 5 5
        !10 - mitred - -
        !11 - butt - -
        !12 80 - - -
        !13 - - 2 2
        !14 No No No No
        !15 - Yes - -
        !16 - 255 - -
        !17 No No - -
        !18 Yes - - -
        !19 0 - 3 3
        !20 - - - No
        !21 4 - - -
        !22 - No - -
        !23 - - - -
        !25 Generic - - -
        !26 - - - -
        !27 - - - -
        !* = Default HP-GL page dimensions/position are plotter dependent
        !V = Option 6 defaults to 0 when black/white reversal is requested
        !via IScreenOpen or the REVERSE initialisation file keyword
        !Graphics Hardcopy/Export INTERACTER Subroutine Reference
        !1-82
        !Default IVALUE for drivers 5-9
        !NOPTN Raster
        !Image
        !Lotus
        !PIC
        !AutoCAD
        !DXF
        !CGM
        !1 640 - 756 -
        !2 480 - 540 -
        !3 - - - -
        !4 - - - -
        !5 - - - -
        !6 - - - 2V
        !7 - - - -
        !8 - - - -
        !9 5 - 5 5
        !10 - - - -
        !11 - - - -
        !12 - 150 80 -
        !13 - - - -
        !14 No No No No
        !15 - - - -
        !16 - - - -
        !17 - - - -
        !18 - - - -
        !19 - - - -
        !20 - - - -
        !21 - - - -
        !22 - - - -
        !23 8 - 8 -
        !25 - Generic - -
        !26 PCX - - -
        !27 - - - -
        !V = Option 6 defaults to 0 when black/white reversal is requested
        !via IScreenOpen or the REVERSE initialisation file keyword
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-83
        !Default IVALUE for drivers 10-12
        !NOPTN Windows Print
        !Manager
        !WMF HP-GL/2
        !1 Varies 756 769
        !2 Varies 540 541
        !3 72 - 0
        !4 72 - 0
        !5 1 - Land
        !6 2V 2V 2V
        !7 Varies - -
        !8 1 - 1
        !9 5 5 5
        !10 - - mitred
        !11 - - butt
        !12 - - -
        !13 - - -
        !14 No No No
        !15 - - -
        !16 - - -
        !17 - - No
        !18 - - -
        !19 - - -
        !20 - - -
        !21 - - 4
        !22 - - -
        !23 - - -
        !25 - - -
        !26 - - -
        !27 - Aldus -
        !V = Option 6 defaults to 0 when black/white reversal is requested
        !via IScreenOpen or the REVERSE initialisation file keyword
        !Default IVALUE for Text File Printing Options
        !NOPTN All Drivers
        !101 80
        !102 60
        !103 1
        !104 999999
        !105 1
        !106 No
        !107 No
        !Graphics Hardcopy/Export INTERACTER Subroutine Reference
        !1-84
        !e.g.
        !C select raster hardcopy driver
        !CALL IGrHardCopySelect(1,4)
        !C select Portrait and move image up by 40 points
        !CALL IGrHardCopyOptions(5,0)
        !CALL IGrHardCopyOptions(4,40)
        !C select highest available printer density
        !CALL IGrHardCopyOptions(13,1)
        !C now enable graphics hardcopy output
        !CALL IGrHardCopy(' ')
    end subroutine

    subroutine IGrHardCopyOptLoad(FILNAM)
        character(len=*) FILNAM ! Graphics hardcopy options file name
        ! Loads a complete set of graphics hardcopy options from a file saved by
        ! IGrHardCopyOptSave (or a file prepared manually to the same format). The driver
        ! number and plotter/printer types are also read from the file. If they do not match the
        ! currently selected driver/device, loading is abandoned and graphics hardcopy options
        ! are not updated (the device types need only match where the selected driver generates
        !device-dependent output, e.g. HP-GL/2). This ensures that the loaded options correctly
        !match the currently selected driver. To force the hardcopy file to select the driver in
        !addition to setting hardcopy options, call IGrHardCopySelFile instead.
        !e.g. CALL IGrHardCopySelect(1,PostScript)
        !CALL IGrHardCopyOptLoad('psoption.dat')
        !CALL IGrHardCopy('myfile.ps')
        !CALL MYGRAF
        !CALL IGrHardCopy('S')
        !Errors :
        !ErrFileOpen (1) : Error opening hardcopy options file
        !ErrFileIO (2) : Error reading file or unexpected end of file
        !ErrDrivDevNum (54) : Mismatch between file driver/device numbers and
        !current selections
    end subroutine

    subroutine IGrHardCopyOptSave(FILNAM)
        character(len=*) FILNAM ! Graphics hardcopy options file name
        ! Saves a complete set of graphics hardcopy options to the named file. The file also
        ! contains the currently selected hardcopy driver number and the current printer/plotter
        ! types. The resulting file can be reloaded by IGrHardCopyOptLoad or
        ! IGrHardCopySelFile.
        ! The file is saved as plain ASCII text allowing the file to be viewed, edited or
        ! transferred to other operating systems/compilers. The first record consists of the current
        ! driver number (as would be specified to IGrHardCopySelect) followed by the
        ! current plotter and printer numbers (as described in chapter 13 of the User Guide).
        ! Subsequent records contain the hardcopy options as would be set via
        ! IGrHardCopyOptions, one per line. The corresponding symbolic name (as defined
        ! in intergh.inc) for each option is also written at the end of each line as a comment,though this is not used when reloading the file.
        !e.g. CALL IGrHardCopySelect(1,PostScript)
        !CALL IGrHardCopyOptions(Orientation,IntPortrait)
        !CALL IGrHardCopyOptions(LineWidth,10)
        !CALL IGrHardCopyOptSave('psoption.dat')
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-85
        !Errors :
        !ErrFileOpen (1) : Error opening hardcopy options file
        !ErrFileIO (2) : Error writing to file
    end subroutine

    subroutine IGrHardCopySelect(IACTN,IDRIVR)
        integer IACTN ! Action code (must always be 1 to select driver)
        integer IDRIVR ! Graphics hardcopy driver number :
        ! HPGLplotter (1) : HP-GL
        ! PostScript (2) : PostScript/EPS
        ! RasterPrinter (4) : Raster printer
        ! (dot-matrix/laser/inkjet printers)
        ! RasterImage (6) : Raster image file (PCX/BMP)
        ! LotusPIC (7) : Lotus PIC format
        ! AutoCadDXF (8) : AutoCAD DXF format
        ! CGMetafile (9) : CGM format
        ! WinPrintMgr (10) : Windows Print Manager
        ! WinMetafile (11) : Windows Metafile (WMF)
        ! HPGL2 (12) : HP-GL/2
        ! Short-name : GHCSEL
        ! Include : intergh.inc
        ! Selects and reinitialises the specified graphics hardcopy driver. The source for
        ! IGrHardCopySelect is also supplied, allowing customisation of the combination
        ! of hardcopy drivers to be linked. Note : Non-Windows versions only link a subset of
        ! the listed drivers. See below.
        ! The default hardcopy driver is always HP-GL/2. Using this driver requires no special
        ! action. IGrHardCopySelect allows the calling program to change the driver which
        ! will be invoked by IGrHardCopy, if required. Call IGrHardCopySelect before
        ! IGrHardCopy, specifying the number of the driver to be used. More than one driver
        ! can be used in the same program run so long as IGrHardCopy('S') or
        ! IScreenClose is called to close down one set of hardcopy output before invoking a
        ! new driver with calls to IGrHardCopySelect and IGrHardCopy.
        ! In addition to selecting the graphics driver to be used, IGrHardCopySelect also
        ! 'binds' the top level graphics routines to INTERACTER's low level hardcopy drivers, i.e.
        ! all calls to the low level drivers pass through this routine. Since this is the only place
        ! where these low level drivers are called, it is possible to customise the combination of
        ! drivers which are loaded at link time by selective commenting of driver subroutine calls
        ! in the supplied IGrHardCopySelect source code. This is described in chapter 17 of
        ! the User Guide. The same chapter also describes which drivers are linked by default.
        ! See also IdGrHardcopyDriver which allows the graphics hardcopy driver to be
        ! selected interactively using a menu.
        ! Fixed format Fortran 77 source code for this routine is supplied in ghcsel.f (Unix)
        ! or ghcsel.for (other operating systems). Equivalent free format Fortran 90 source
        ! code is also supplied in ghcsel.f90.
        ! Graphics Hardcopy/Export INTERACTER Subroutine Reference
        ! 1-86
        !e.g. CHARACTER*10 DRVER(3)
        !INTEGER IDRV(3)
        !DATA DRVER/'PostScript',1 'Windows ',
        !2 'HP-GL/2 '/
        !DATA IDRV/2,10,12/
        !:
        !C select driver using a menu
        !IDRIVR = IMenuVertic(DRVER,MAXDRV,IX,IY,'Driver',0,1,1)
        !C select driver
        !CALL IGrHardCopySelect(1,IDRV(IDRIVR))
        !C open default output file/device
        !CALL IGrHardCopy(' ')
        !C now generate some graphics
        !CALL MYGRAF
        !Portability notes :
        !Windows :
        !The Print Manager and WMF drivers are only available in the Windows version.
    end subroutine

    subroutine IGrHardCopySelFile(FILNAM)
        character(len=*) FILNAM ! Hardcopy options file name
        ! Selects the required graphics device, hardcopy driver and associated hardcopy options
        ! by reading the appropriate information from the named file. This combines the
        ! functions of IPrinter/IPlotter/IPrinter2 (where appropriate),IGrHardCopySelect and IGrHardCopyOptLoad into a single routine.
        ! The named file is assumed to have been saved by a call to IGrHardCopyOptSave
        ! (or to have been manually prepared to the same format). This means that the driver
        ! number, as would otherwise be specified to IGrHardCopySelect, should be the
        ! first value on the first record, followed by plotter, printer and HP-GL/2 device types on
        ! the same record. The remainder of the file specifies the default hardcopy options to be
        ! used with that driver/device, one per record.
        ! No special processing is performed on the filename. INTERACTER will attempt to open
        ! the file exactly as specified.
        !e.g. CHARACTER*12 FILNAM
        !:
        !C Select hardcopy options file
        !CALL IdFilename(FILNAM)
        !CALL IGrHardCopySelFile(FILNAM)
        !CALL IGrHardCopy('myfile.plt')
        !CALL MYGRAF
        !CALL IGrHardCopy('S')
        !Errors :
        !ErrFileOpen (1) : Error opening hardcopy options file
        !ErrFileIO (2) : Error reading file or unexpected end of file
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-87
    end subroutine

    subroutine IGrHardCopyTextFile(INFILE,OUTFILE)
        character(len=*) INFILE ! ASCII text file to print
        character(len=*) OUTFILE ! Output file/device name
        ! Prints the named ASCII text file via the current graphics hardcopy driver as selected by
        ! IGrHardCopySelect. Internally, IGrHardCopyTextFile calls
        ! IGrHardCopy to open and close the hardcopy output channel. It reads the file using
        ! standard Fortran i/o and writes the contents of the file using IGrCharOut.
        ! The output file/device name OUTFILE is passed to IGrHardCopy. It can therefore be
        ! left blank to specify the default graphics hardcopy output destination. In Fortran 90
        ! implementations when the USE INTERACTER statement has been included,OUTFILE is an optional argument and can therefore be omitted, thereby selecting the
        ! default destination name.
        ! Hardware dependent Courier text is selected to generate the printed version of the text
        ! file. Certain drivers may substitute a software font, where format-specific hardware text
        ! handling facilities are inadequate.
        ! Since this routine uses standard graphics hardcopy and graphics text handling routines
        ! to generate the print file, all of the supported hardcopy drivers and hardcopy options
        ! are available. For example, the size of the printable page area used to print text is
        ! controllable via options 1 and 2 of IGrHardCopyOptions. It may be desirable to
        ! change hardcopy option 5 (orientation) from its default of landscape to portrait. Setting
        ! option 5 to 2 (portrait with width/height set appropriately) may be the most appropriate
        ! option.
        ! In addition to the standard graphics hardcopy options, IGrHardCopyOptions also
        ! supports 7 additional options which apply specifically to text file printing such as
        ! number of columns/rows per page, start/end page number, text font and wrap mode. See
        ! IGrHardCopyOptions for details.
        ! On colour printers text is written in the current colour as set by IGrColourN.
        ! Pagination is controlled via hardcopy option 107. When this is disabled (the default), a
        ! new page is forced if a form feed character (ASCII 12) is found in column one of an
        ! input record. When Fortran carriage control is enabled (option 107=1) then a 1 in the
        ! first column has this effect instead.
        !e.g. CHARACTER*80 FILNAM
        !:
        !C Select text file to print
        !CALL IdFilename(FILNAM)
        !CALL IGrHardCopyOptions(Orientation,IntPortraitWH)
        !CALL IGrHardCopyTextFile(FILNAM,' ')
        !Errors :
        !ErrFileOpen (1) : Error opening text file or output file
        !ErrFileIO (2) : Error reading file from text file
    end subroutine

    subroutine IGrPrintImage(PNAME)
        character(len=*) PNAME ! Name of printer device or print file
        ! (uses default for current operating system if blank)
        ! Dumps the contents of the graphics area to the printer in the same manner as
        ! IScreenDump. The only differences from IScreenDump are :
        ! Graphics Hardcopy/Export INTERACTER Subroutine Reference
        ! 1-88
        !   Calling this routine has no effect in text mode. It only performs graphics dumps.
        !   Only the current graphics area (as set by IGrArea) is printed rather than the whole
        ! screen/window.
        ! As for IScreenDump, the behaviour of this routine can be controlled by
        ! IScreenDumpOptions. See IScreenDump for further information.
        ! Portability notes :
        ! Tektronix & ReGIS terminals :
        ! The built in terminal dump is used which will normally invoke a full screen dump.
        ! Hence there is no functional difference between IGrPrintImage and
        ! IScreenDump on a graphics terminal.
        ! Errors :
        ! ErrFileOpen (1) : Error opening printer device/file
        ! ErrFileIO (2) : Error writing to print device/file
        ! ErrFileClose (3) : Error closing print device/file
        ! ErrPrintGfx (5) : Graphics not supported on requested printer
    end subroutine

    subroutine IGrSaveImage(FNAME)
        character(len=*) FNAME ! Filename to save
        ! Short-name : GSAVE
        ! Saves the current graphics area, as defined by IGrArea, to the named bit image file, in
        ! PCX (PC Paintbrush) or BMP (Windows bitmap) format. The target format is
        ! determined by the file extension which should be .pcx or .bmp (case is not
        ! significant). The default is PCX if the extension does not match either of these. This
        ! routine is equivalent to IScreenSaveImage, which operates on the full screen area.
        !e.g. CALL IGrCharOut(0.5,0.05,'Mark area to save')
        !CALL IGrInputBox(X1,Y1,WID,HGT,3)
        !CALL IGrArea(X1,Y1,X1+WID,Y1+HGT)
        !CALL IGrSaveImage('cutout.pcx')
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error writing to file
        !ErrFileClose (3) : Error closing file
        !ErrScreenLoadSave (6) : Screen mode not supported
        !Portability notes :
        !DOS :
        !The bit image file is saved at the same colour depth as the current graphics mode. By
        !default, BMP files are saved uncompressed, but compressed files can be saved by
        !enabling screen mode option 13. See IScreenModeOptions.
        !MS Windows :
        !BMP files are saved in uncompressed format, using the same colour depth as the
        !current Windows video driver. PCX files are saved in 8-bit format (256 colours) on a
        !display with 256 colours or 24-bit format (16M colours) on a 16/24/32-bit colour
        !display. Saving as BMP is somewhat quicker, but PCX files are smaller.
        !INTERACTER Subroutine Reference Graphics Hardcopy/Export
        !1-89
        !Xlib :
        !Both PCX and BMP files are saved in 256 colour format on X servers which use 256
        !colours or less. On X servers with more than 256 colours, BMP/PCX files are saved in
        !24-bit colour format. The latter files are larger, but ensure full colour reproduction.
        !Terminals :
        !Screen image files cannot be saved on serial terminals. Error code 6 will be generated.
    end subroutine

    subroutine IGrSaveImageData8(FNAME,BMPDATA,IWID,IHGT)
        character(len=*) FNAME ! Filename to save to
        character(1) BMPDATA(*) ! 8-bit colour bitmap data
        integer IWID ! Bitmap width
        integer IHGT ! Bitmap height
        ! Saves the supplied raw bitmap data as an 8-bit (256-colour) BMP or PCX file. Files
        ! saved by this routine can be displayed by IGrLoadImage or IScreenLoadImage.
        ! The save format is determined by the file extension (.bmp or .pcx). BMP files are
        ! saved uncompressed. PCX is the default if the extension does not identify the format.
        ! BMPDATA is a character array containing IWID*IHGT bytes of bitmap data. Each byte
        ! defines a colour index corresponding to INTERACTER's 256 device independent colour
        ! numbering scheme. The bitmap data should be organised in BMPDATA as follows:
        ! First IWID bytes contain top row of bitmap
        ! Next IWID bytes contain second row but one,....
        ! Last IWID bytes contain bottom row of bitmap
        ! Palette information is included in the file according to the currently selected
        ! INTERACTER palette. This can be defined before calling IGrSaveImageData8 by
        ! calling IGrPalettteRGB.
        ! Note that users of the Fortran 90 INTERACTER module can also call this routine via
        ! the generic interface of IGrSaveImageData, which is shared with the
        ! IGrSaveImageData24 routine.
        ! See also IGrLoadImageData.
        !e.g. PARAMETER (IW = 640 )
        !PARAMETER (IH = 480 )
        !PARAMETER (LENBMP = IW*IH)
        !CHARACTER*1 BMPDATA(LENBMP)
        !:
        !CALL IGrSaveImageData8('bitmap.bmp',BMPDATA,IW,IH)
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error writing to file
        !ErrFileClose (3) : Error closing file
        !Graphics Hardcopy/Export INTERACTER Subroutine Reference
        !1-90
    end subroutine

    subroutine IGrSaveImageData24(FNAME,BMPDATA,IWID,IHGT)
        character(len=*) FNAME ! Filename to save to
        integer BMPDATA(*) ! 24-bit colour bitmap data
        integer IWID ! Bitmap width
        integer IHGT ! Bitmap height
        ! Saves the supplied raw bitmap data as a 24-bit colour BMP or PCX file.
        ! The save format is determined by the file extension (.bmp or .pcx). BMP files are
        ! saved uncompressed. PCX is the default if the extension does not identify the format.
        ! BMPDATA is an integer array containing IWID*IHGT bitmap data values. Each value
        ! defines an RGB value using the 24-bit formula:
        ! red + 256*green + 256*256*blue
        ! The bitmap data should be organised in BMPDATA as follows:
        ! First IWID values contain top row of bitmap
        ! Next IWID values contain second row but one,....
        ! Last IWID values contain bottom row of bitmap
        ! Note that users of the Fortran 90 INTERACTER module can also call this routine via
        ! the generic interface of IGrSaveImageData, which is shared with the
        ! IGrSaveImageData8 routine.
        !e.g. PARAMETER (IW = 640 )
        !PARAMETER (IH = 480 )
        !PARAMETER (LENBMP = IW*IH)
        !INTEGER BMPDATA(LENBMP)
        !:
        !CALL IGrSaveImageData24('bitmap.bmp',BMPDATA,IW,IH)
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error writing to file
        !ErrFileClose (3) : Error closing file
        !INTERACTER Subroutine Reference Graphics Import
        !1-91
        !1.7 Group GF : Graphics File Import
        !Graphics files can be read back into INTERACTER-based applications.
        !The type and contents of a graphics file can be interrogated via IGrFileInfo.
        !Various types of vector graphics metafiles can be imported via IGrReplay. The
        !behaviour of this routine is controlled by IGrReplayOptions. A zoom facility is
        !provided by IGrReplayArea.
        !Bit image files can be displayed in the graphics area by IGrLoadImage or can be
        !read into a 24-bit RGB array by IGrLoadImageData.
    end subroutine

    subroutine IGrFileInfo(FNAME,INFO,MAXITEM)
        character(len=*) FNAME ! Filename to return information about
        integer INFO ! Array to return information about file :
        ! INFO(1) : File Type
        ! INFO(2) : Image Width
        ! INFO(3) : Image Height
        ! INFO(4-6) : Format dependent
        integer MAXITEM ! Maximum number of items to return in INFO (>=1)
        ! Include : intergf.inc
        ! Returns information about the named graphics file. The INFO array receives the
        ! returned information and MAXITEM indicates the maximum number of items to be
        ! returned in that array.
        ! INFO(1) will return a code indicating the file format :
        ! NotFound (-1) : File does not exist
        ! TypeUnknown (0) : Unable to determine file type
        ! TypeBMP (1) : Windows .BMP format bitmap
        ! TypePCX (2) : PCX format bitmap
        ! TypeWMF (3) : Windows metafile
        ! TypeHPGL (4) : HP-GL plotter file
        ! TypeHPGL2 (5) : HP-GL/2 plotter file
        ! TypeCGM (6) : Computer Graphics Metafile (CGM)
        ! TypeLotusPIC (7) : Lotus PIC
        ! TypeAcornDraw (8) : Acorn Draw
        ! TypeTek4014 (9) : DEC LN 03+ Tektronix 4014
        ! TypePostScript (10) : PostScript or EPS
        ! TypeHPPCL (11) : HP PCL
        ! TypeESCP2 (12) : Epson ESC/P2
        ! TypeESCP (13) : Epson ESC/P
        ! TypeDXF (14) : AutoCAD DXF
        ! Note that identification of some of the listed file types is only guaranteed for files
        ! generated by the INTERACTER graphics hardcopy/export drivers. Files from third party
        ! sources may be identified too, but this cannot be generally relied upon.
        ! Graphics Import INTERACTER Subroutine Reference
        ! 1-92
        ! If a known file type is identified, the following information is returned :
        ! BMP files:
        ! INFO(2) : Image width in pixels
        ! INFO(3) : Image height in pixels
        ! INFO(4) : Number of colours
        ! INFO(5) : Is file compressed? (0=no , 1=yes)
        ! PCX files :
        ! INFO(2) : Image width in pixels
        ! INFO(3) : Image height in pixels
        ! INFO(4) : Number of colours (2/16/256)
        ! INFO(5) : File format version number (0-5)
        ! The file format version is a value which is unique to PCX format files and reflects
        ! which version of the PCX format the file conforms to. Nearly all PCX files will now be
        ! version 5 files.
        ! WMF files :
        ! INFO(2) : Image width in points
        ! INFO(3) : Image height in points
        ! INFO(4) : Sub format : StandardWMF (0) : Standard metafile.
        ! AldusWMF (1) : Aldus placeable metafile.
        ! EnhancedWMF (2) : Enhanced metafile.
        ! The availability of size information is dependant on the sub-format. Standard metafiles
        ! contain no size information, INFO(2)/(3) will return -1 in this case. Aldus placeable
        ! metafiles contain reliable information, in the form of an extra 22-byte header. This is
        ! present in files generated using INTERACTER. Enhanced metafiles contain size
        ! information. However the values returned from INTERACTER generated files do not
        ! correspond to the original hardcopy options used to generate the file.
        ! HP-GL and HP-GL/2 files :
        ! INFO(2) : Image width in points
        ! INFO(3) : Image height in points
        ! INFO(4) : Number of pens/colours
        ! INFO(5) : Device number used when generating file.
        ! INFO(6) : Number of images in file.
        ! Information is only available for HP-GL and HP-GL/2 files which were generated by
        ! INTERACTER and which also include replay information (see hardcopy option18). The
        ! device number (INFO(5)) corresponds to the INTERACTER plotter or HP-GL/2
        ! device type which was currently selected when the file was created (see the PLOTTER
        ! and HPGL2 initialisation file keywords and the list of device types in the Supported
        ! Hardware chapter in the User Guide). If MAXITEM>=6, the whole file will be
        ! scanned to count the number of pages. If this information is not required, specify a
        ! smaller MAXITEM value to reduce processing time.
        ! Computer Graphics Metafiles (CGM) :
        ! INFO(4) : Number of images in file.
        ! If MAXITEM>=4, the whole file will be scanned to count the number of pages. If this
        ! information is not required, specify MAXITEM=1 to reduce processing time.
        ! INTERACTER Subroutine Reference Graphics Import
        ! 1-93
        ! Lotus PIC files :
        ! INFO(2) : 3201 (standard horizontal resolution of all PIC files)
        ! INFO(3) : 2311(standard vertical resolution of all PIC files)
        ! INFO(4) : Number of images in file.
        ! If MAXITEM>=4, the whole file will be scanned to count the number of pages. If this
        ! information is not required, specify a smaller MAXITEM value to reduce processing
        ! time.
        ! Acorn Draw :
        ! INFO(2) : Image width in points
        ! INFO(3) : Image height in points
        ! DEC LN03+ :
        ! No additional information
        ! PostScript :
        ! INFO(2) : Image width in points ) EPS files
        ! INFO(3) : Image height in points ) only
        ! INFO(4) : 0 = Printer file, 1 = EPS file
        ! HP PCL :
        ! INFO(4) : Number of colours (2 or 8)
        ! INFO(5) : Print density in dots per inch
        ! ESC/P2 :
        ! INFO(4) : Number of colours (2 or 8)
        ! INFO(5) : Print density in dots per inch
        ! ESC/P :
        ! INFO(4) : Number of colours (2 or 8)
        ! DXF :
        ! INFO(2) : Image width in points
        ! INFO(3) : Image height in points
        ! In the unlikely event that one of the format-specific INFO(n) values cannot be
        ! identified, a value of -1 is returned.
        !e.g. INTEGER INFO(5)
        !CALL IGrFileInfo('picture.bmp',INFO,5)
        !IF (INFO(1).EQ.TypeBMP) COMPRESSED = INFO(5).NE.0
        !CALL IGrFileInfo('picture.plt',INFO,4)
        !IF (INFO(1).EQ.TypeHPGL) NPENS = INFO(4)
    end subroutine

    subroutine IGrLoadImage(FILNAM)
        character(len=*) FILNAM ! Name of bit image file to load
        ! Short-name : GLOAD
        ! Loads a PCX (PC Paintbrush) or BMP (Window bitmap) format bit image file into the
        ! current graphics area. The file type is determined automatically. Unlike the equivalent
        ! IScreenLoadImage routine (which loads an entire screen), the screen mode is not
        ! reset and the screen contents outside the graphics area normally remain unchanged (see
        ! Portability notes).
        ! Graphics Import INTERACTER Subroutine Reference
        ! 1-94
        ! The image is loaded to the screen only. Hardcopy output enabled via IGrHardCopy
        ! is not affected. To print a bitmap loaded via this routine, use IGrPrintImage.
        !e.g. CALL IGrCharOut(0.5,0.9,'This text will remain on screen')
        !CALL IGrArea(0.0,0.0,1.0,0.5)
        !CALL IGrLoadImage('file1.pcx')
        !CALL InKeyEvent(KEY)
        !CALL IGrLoadImage('file2.pcx')
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error reading from file
        !ErrFileClose (3) : Error closing file
        !ErrScreenLoadSave (6) : Screen mode not supported
        !ErrBadScreenFile (27) : Incompatible or unsupported screen image file
        !Portability notes :
        !DOS :
        !PCX or uncompressed BMP bit image files can be reloaded into any graphics screen
        !mode which has the same colour depth. If the image file contains palette information,the screen palette is updated to match that used by the file.
        !The image is not rescaled, so it may be clipped or may not fill the graphics area,depending on the respective pixel dimensions of the graphics area and the bit image
        !file. The image is written starting from the bottom left corner of the graphics area.
        !Since image files are saved at a screen-byte rather than a pixel level, some overlap may
        !be observed at the left and/or right edges of the graphics area when reloading a 2-colour
        !or 16-colour image file.
        !MS Windows :
        !BMP or PCX files of any colour depth can be loaded. This includes 16/256 colour
        !compressed BMP files. The image is stretched to fit the graphics area.
        !Xlib :
        !The Xlib driver can load 1/4/8/24/32-bit colour image files in uncompressed BMP
        !format or 8/24 bit colour PCX files. The image is stretched to fit the graphics area.
        !Terminals :
        !Screen image files are not supported on serial terminals or terminal emulators.
    end subroutine

    subroutine IGrLoadImageData(FILNAM,IBMPDATA)
        character(len=*) FILNAM ! Name of bit image file to load
        integer IBMPDATA(*) ! Array to receive RGB data
        ! Loads a BMP or PCX bit image from the named file and returns the 24-bit RGB values
        ! corresponding to each pixel in the bitmap. The file type is determined automatically. If
        ! the file format is unknown or unsupported, error code 27 is generated.
        ! The supported BMP and PCX file formats are:
        !   BMP : 4/8/16/24/32 bit colour, compressed and uncompressed
        !   PCX : 4/8/24 bit colour (all PCX files are compressed)
        ! Monochrome files are not supported.
        ! INTERACTER Subroutine Reference Graphics Import
        ! 1-95
        ! The data is returned in the usual 24-bit RGB format, namely:
        ! Red + 256*Green + 256*256*Blue
        ! Image data is returned row-by-row in IBMPDATA, top row first. The organisation of the
        ! returned array is identical to that used by IGrSaveImageData. Data saved by
        ! IGrSaveImageData24 can be reloaded by IGrLoadImageData and vice versa.
        ! Files saved by IGrSaveImage and the raster hardcopy driver can also be reloaded by
        ! this routine, as can many third party BMP/PCX files.
        ! IBMPDATA must be large enough to receive the whole of the image. This can be
        ! determined by IGrFileInfo. i.e. IBMPDATA must be at least INFO(2)*INFO(3)
        ! elements long, where INFO(2) and INFO(3) are the image width and height
        ! returned by IGrFileInfo.
        !e.g. CHARACTER*10 FILENAME
        !PARAMETER (MAXBMP = 100000)
        !INTEGER IBMPDATA(MAXBMP)
        !INTEGER INFO(3)
        !:
        !FILENAME = 'bitmap.bmp'
        !CALL IGrFileInfo(FILENAME,INFO,3)
        !IF (INFO(1).EQ.1.OR.INFO(1).EQ.2) THEN
        !IF (INFO(2)*INFO(3).LE.MAXBMP) THEN
        !CALL IGrLoadImageData(FILENAME,IBMPDATA)
        !Errors :
        !ErrFileOpen (1) : Error opening file
        !ErrFileIO (2) : Error reading from file
        !ErrFileClose (3) : Error closing file
        !ErrBadScreenFile (27) : Incompatible or unsupported image file
    end subroutine

    subroutine IGrReplay(FILNAM)
        character(len=*) FILNAM ! Name of vector graphics file to be replayed
        ! Short-name : GRPLAY
        ! Replays an HP-GL, HP-GL/2, CGM or Lotus PIC graphics file. Such files should
        ! normally have been created by INTERACTER originally, using IGrHardCopy. CGM
        ! files from some third party sources can also be replayed as can most PIC files. The
        ! Windows implementation can also replay WMF files from any source. The input file
        ! type is sensed automatically.
        ! While IGrReplay is a very simple routine to call, it performs quite a complex task.
        ! Certain features of its operation are therefore worth understanding :
        !   The currently selected graphics units, area, colour, etc. are all unaffected by the call
        ! to IGrReplay. All graphics parameters are restored on exit from the routine.
        !   The graphics file is replayed into the current graphics area as defined by IGrArea.
        !   By default, the whole of the image in the graphics file is replayed in the graphics
        ! area. Optionally, a sub-area of the image can be displayed by calling
        ! IGrReplayArea. Effectively, this provides a 'zoom' facility.
        !   Calls to IGrAreaClear are not logged to the graphics output file, so they are not
        ! reproduced by IGrReplay.
        ! Graphics Import INTERACTER Subroutine Reference
        ! 1-96
        !   INTERACTER generated files are designed to be portable between different types of
        ! screen display and even different operating systems. Hence a graphics image can be
        ! generated on one system then replayed on another. [Note : Using the hardware
        ! character set when generating the output file may give poor results if replayed on a
        ! display or in a mode which has different size hardware characters. For full
        ! portability always generate your graphics images using the device-independent
        ! software character sets.]
        !   Colours are reproduced as accurately as possible, subject to the capabilities of the
        ! current output device. Whichever black/white reversal option was selected by
        ! IScreenOpen or the REVERSE keyword, when the input file was generated,ensure that the same option is in use when replaying the file. Otherwise, odd results
        ! may be observed for black or white graphics.
        ! When replaying HP-GL, HP-GL/2, CGM or Lotus PIC files it is possible to generate
        ! hardcopy output at the same time. It is therefore possible to convert files to PostScript,WMF, etc, by calling IGrHardCopy and IGrReplay in the same program and
        ! selecting a suitable hardcopy driver via IGrHardCopySelect. The same mechanism
        ! can be used to print an HP-GL, HP-GL/2 or CGM file via Windows Print Manager.
        ! Under Windows, an API function is used to replay a WMF file. Consequently replaying
        ! WMF files is a screen-only facility. Simultaneous hardcopy output is not available in
        ! this case.
        ! See IGrReplayOptions which controls certain aspects of IGrReplay behaviour.
        !e.g. CHARACTER*20 PLTFIL
        !:
        !CALL IOutStringXY(10,10,'Enter name of file to replay : ')
        !CALL InString(PLTFIL,LENGTH)
        !CALL IGrAreaClear
        !CALL IGrReplay(PLTFIL(:LENGTH))
        !Errors :
        !ErrFileOpen (1) : Error opening file.
        !ErrFileIO (2) : Error reading from file.
        !(This error terminates the replay operation)
        !ErrFileClose (3) : Error closing file.
    end subroutine

    subroutine IGrReplayArea(XLEFT,YLOWER,XRIGHT,YUPPER)
        real XLEFT ! Left limit of replay area (0.0=<XLEFT <1.0)
        real YLOWER ! Lower limit of replay area (0.0=<YLOWER <1.0)
        real XRIGHT ! Right limit of replay area (0.0 <XRIGHT=<1.0)
        real YUPPER ! Upper limit of replay area (0.0 <YUPPER=<1.0)
        ! Defines the area of an image to be replayed by IGrReplay. By default, the whole
        ! image is replayed (i.e. the replay area dimensions are 0.0 - 1.0 in both dimensions).
        ! Remember that this routine specifies the area of the image in the file. That part of the
        ! image will then be scaled to fit the current graphics area as set by IGrArea.
        !e.g. CALL IGrArea(0.0,0.0,0.5,0.5)
        !CALL IGrReplayArea(0.5,0.5,1.0,1.0)
        !CALL IGrReaplay('picture.cgm')
        !INTERACTER Subroutine Reference Graphics Import
        !1-97
        !Errors :
        !ErrBadArea (44) : Invalid X and/or Y range. Range reset to 0.0-1.0
        !Portability notes :
        !WMF :
        !Currently, this facility does not have any affect when replaying Windows metafiles.
    end subroutine

    subroutine IGrReplayOptions(NOPTN,IVALUE)
        integer NOPTN ! Option number (1-4)
        integer IVALUE ! Option value (see below)
        ! NOPTN IVALUE Default
        ! ReplayPause 1 Pause at end of intermediate plots (0=no 1=yes) Yes
        ! ReplayClear 2 Clear graphics area at end of intermediate plots
        ! (0=no 1=yes)
        ! Yes
        ! ReplayStart 3 First picture in file to replay 1
        ! ReplayEnd 4 Last picture in file to display 1
        ! Include : intergf.inc
        ! Sets options which determine the behaviour of IGrReplay when replaying graphics
        ! files.
        ! ITEM's 1 and 2 determine the action at the end of an intermediate plot. This is a plot
        ! prior to the picture specified by ITEM=4. These options therefore determine whether a
        ! keystroke/mouse-click is required between screens and whether the screen is cleared at
        ! the end of each picture. By default both options are enabled. The screen is not cleared
        ! and there is no pause after the screen specified by ITEM=4. This ensures that the last
        ! picture to be replayed remains visible on exit.
        ! ITEM's 3 and 4 allow the plot range to be specified in multi-picture files. By default,just the first picture in a file is displayed. The number of pages in an input file can be
        ! determined via IGrFileInfo.
        ! Due to the use of a Windows API routine, replaying WMF files is not affected by this
        ! routine. Effectively WMF replay defaults to no intermediate pause or screen clear. All
        ! pictures are replayed.
        !e.g. CALL IGrReplayOptions(3,2)
        !CALL IGrReplayOptions(4,2)
        !C display second picture in file
        !CALL IGrReplay('pictures.cgm')
        !
        !INTERACTER Subroutine Reference Graphics Positional Input
        !1-99
        !1.8 Group GI : Graphics Input
        !In addition to the various graphics output facilities already described, points, lines and
        !rectangular areas can be input using routines in this group. The graphics input device
        !(usually keyboard or mouse) can be selected using IGrInputDevice. The basic
        !single point input routine is IGrInputXY, but IGrInputLine and IGrInputBox
        !are also available. The graphics input area can be restricted using IGrInputLimits.
        !Where a mouse is available, access is provided to lower level mouse features via the
        !separate MC (Mouse Cursor Control) and KM (Keyboard/Mouse Event Handling)
        !subroutine groups. These replace the GINMOU routine which was provided in earlier
        !releases and has now been moved to the OR (Obsolete Routines) group.
        !While most graphics displays support GIN mode, InfoGrScreen can be called to
        !test whether GIN mode is in fact available.
    end subroutine

    subroutine IGrInputBox(XPOS,YPOS,WIDTH,HEIGHT,IACTN)
        real XPOS ! on entry : Initial X position
        ! on exit : Returned X position (IACTN >1)
        real YPOS ! on entry : Initial Y position
        ! on exit : Returned Y position (IACTN >1)
        real WIDTH ! on entry : Initial width of box
        ! on exit : Returned width of box (IACTN<>2)
        real HEIGHT ! on entry : Initial height of box
        ! on exit : Returned height of box (IACTN<>2)
        integer IACTN ! Input action required :
        ! = 1 : Stretch box out from a fixed position
        ! = 2 : Place a box of fixed size
        ! = 3 : Mark both corners of a box
        ! Short-name :GINBOX
        ! Uses graphics input (GIN) mode to enable the user to mark a rectangular area of the
        ! graphics screen using the current graphics input device (see IGrInputDevice). The
        ! final position and/or size of the area are returned. The area can be marked in one of
        ! three ways, depending on the specified action.
        ! From the point of view of the calling program, the effect of calling this routine is the
        ! same regardless of operating system or display. However, the precise nature of the user
        ! interface varies, depending on both the input device and the display. In general, what
        ! happens is as follows :
        ! Action 1 : The corner of the rectangle, specified by (XPOS,YPOS), remains fixed
        ! and graphics input (GIN) mode is used to specify the second corner of the rectangle. On
        ! suitable displays, a rectangle is 'rubber-banded' as the user moves the GIN cursor to the
        ! required position.
        ! Graphics Positional Input INTERACTER Subroutine Reference
        ! 1-100
        ! Action 2 : The size of the rectangle remains fixed, with its initial position
        ! determined by the values of (XPOS,YPOS) and WIDTH/HEIGHT on entry to
        ! IGrInputBox. The graphics input device is used to 'place' this box at the required
        ! position. On suitable displays, this box is 'dragged' to its new position. The corner
        ! which is diagonally opposite to (XPOS,YPOS) is treated as the GIN cursor position,and it is this corner which is restricted to the graphics input area defined by
        ! IGrInputLimits. Hence, on exit, it will lie within the graphics input area, but
        ! (XPOS,YPOS) may not.
        ! Action 3 : In this case two points must be marked. IGrInputXY is called to
        ! mark the first point, which is initially (XPOS,YPOS). Once that position has been
        ! selected, the opposite corner of the rectangle is selected in the same way as Action type
        ! 1. The distance of the second point from the first is returned in WIDTH/HEIGHT.
        ! Pressing an exit key other than 'confirm' when marking the first point causes
        ! IGrInputBox to exit immediately without attempting to mark the second corner of
        ! the box.
        ! In all cases, points are marked in the same way as for IGrInputXY, i.e. using the
        ! confirm/quit/help keys or the mouse buttons. The 'exit' key or button can be
        ! interrogated using InfoInput.
        ! Termination of GIN mode need not be restricted to pressing one of the 'exit keys' or
        ! mouse buttons, though this is the default. An alternative 'any key to exit' option can be
        ! activated using IGrInputOptions(4,N). See IGrInputOptions for more
        ! details.
        ! In a windowing environment it is possible for a graphics window expose/resize event to
        ! occur during a call to IGrInputBox. in which case InfoInput(55) will return
        ! 259. Similarly, a close-window request will also cause immediate termination,returning InfoInput(55) as 260.
        ! Note that the rubber-banded rectangle is drawn in the style currently selected by
        ! IGrLineType, enabling a dotted or dashed box to be used if preferred.
        ! By default a box of any relative shape can be marked, when action 1 or 3 is specified.
        ! However, if GIN option 10 (see IGrInputOptions) has been enabled, the shape of
        ! the marked rectangle will be forced to maintain the aspect ratio determined by the
        ! relative values of WIDTH/HEIGHT on entry.
        ! IGrInputBox does not update the current plotting position, since this may not be
        ! required. Use IGrInputDevice to select the graphics input device.
        !e.g. XPOS = 0.0
        !YPOS = 0.0
        !WID = 0.5
        !HGT = 0.5
        !CALL IGrInputBox(XPOS,YPOS,WID,HGT,3)
        !KEXIT = InfoInput(55)
        !INTERACTER Subroutine Reference Graphics Positional Input
        !1-101
        !Portability notes :
        !DOS, Xlib and Windows :
        !Operation on these displays is the same. Graphics input is controlled as for
        !IGrInputXY. When action type 3 is selected the first corner is selected using a cross
        !hair cursor (for keyboard input) or an arrow (for mouse input). When marking the
        !second corner or dragging the rectangle, the size/position of the rectangle follows the
        !movement of the cursor keys or mouse.
        !Tektronix :
        !On a Tektronix terminal, using GIN mode, movement of the GIN cursor is entirely
        !under the local control of the terminal until a terminating key or button is pressed.
        !Consequently, it is not possible to 'drag' or stretch a rectangle in the way that other
        !implementations can, except on a 4207/4208 which supports rubber-banding (action
        !codes 1 and 3). On terminals which support exclusive-or plotting, the currently selected
        !area can be checked by pressing a non-exit key (e.g. space bar). When an exit key is
        !pressed this rectangle is removed. Alternatively, normal keyboard input can be selected
        !(again, on terminals which support exclusive-or plotting), though with the considerable
        !limitation that cursor keys cannot be detected in Tektronix mode on most terminals.
        !Aspect ratio maintenance is not supported when rubber banding a box using GIN mode
        !on a Tek terminal.
        !Refer to the IGrInputXY Portability notes for more information on Tek GIN mode.
        !ReGIS :
        !In ReGIS Locator mode, movement of the GIN cursor is under the local control of the
        !terminal until a terminating key is pressed. Rubber banding (action codes 1 and 3) is
        !supported on VT340 compatible displays. Normal keyboard input under the control of
        !the host can also be selected if required since ReGIS supports both Exclusive-or mode
        !and cursor key detection.
        !Aspect ratio maintenance is not supported when rubber banding a box using Locator
        !mode on a ReGIS terminal.
    end subroutine

    subroutine IGrInputDevice(DEVIC)
        character(len=*) DEVIC ! Graphics input device (upper or lower case)
        ! = K : Keyboard only
        ! = M : Mouse/pointing device (default, if available)
        ! = D : Digitising tablet
        ! Short-name : GINDEV
        ! Selects the input device to be used by the GIN (graphics input) routines. By default a
        ! mouse or equivalent pointing device is used, where available, but keyboard input is
        ! selected otherwise. Where a mouse or pointing device is fitted, keyboard input can still
        ! be selected for operations where the fine control of the keyboard is preferable, using a
        ! 'K' parameter. Input from a digitising tablet can be selected using a 'D' parameter under
        ! DOS.
        ! Graphics Positional Input INTERACTER Subroutine Reference
        ! 1-102
        ! Where a mouse/pointing device is selected and is under the direct control of
        ! INTERACTER (as under DOS, Xlib or Windows), input is actually accepted from both
        ! mouse and keyboard for maximum user convenience. The 'K' option for keyboard-only
        !input can still be used to suppress the use of the mouse (e.g. to test how a program will
        !behave when a mouse is not available).
        !In general, when keyboard input is selected, the graphics cursor used by the GIN
        !routines appears as a small cross hair. If a mouse is selected the GIN cursor is an arrow
        !pointer. When using a digitising tablet, no cursor is displayed. This is a useful visual
        !reminder of which input device is currently selected.
        !The default GIN device is a mouse/pointing device. Note that only the first character of
        !the supplied argument is used.
        !e.g. IF (InfoHardware(23).GT.1) CALL IGrInputDevice('Mouse')
        !CALL IGrInputXY(XPOS,YPOS)
        !Portability notes :
        !DOS :
        !A serial or bus mouse with a Microsoft compatible driver is required. MOUSE.COM or
        !the equivalent driver program supplied with the mouse, must have been loaded before
        !running your program. Microsoft compatible mice have two buttons, Mouse Systems
        !compatible mice have three. Where three are fitted, the extra (middle) button can be
        !detected by the GIN routines. The presence of the MOUSE.COM driver is sensed
        !automatically at start up by IScreenOpen.
        !No driver is required when using a digitising tablet, though some tablets can also be
        !used to emulate a mouse. In the latter case, a Microsoft compatible driver must be
        !loaded and the tablet should be identified to INTERACTER as a though it were a
        !mouse, not a digitiser.
        !Xlib and MS Windows :
        !Both mouse and keyboard input are supported. Simultaneous mouse/keyboard input is
        !supported. Three mouse buttons are assumed, if not specified. The mouse is the default
        !GIN device unless suppressed using IGrInputDevice('K') or a MOUSE=1 record
        !in the initialisation file.
        !Tektronix :
        !Tektronix compatible terminals support locally controlled GIN mode. In other words,the default GIN cursor is moved around the screen under the control of the terminal
        !itself, not INTERACTER. Different terminals support various GIN cursor control
        !devices, e.g. mouse, joystick, or just the keyboard. In INTERACTER terms, this mode is
        !equivalent to 'mouse/pointing device' mode even if the user actually controls the GIN
        !cursor using the keyboard. Selecting keyboard mode requires that :
        !1) The terminal must support exclusive-or plotting
        !2) Suitable input control keys must have been set up for cursor movement, using
        !InControlKey, since Tektronix cursor keys do not generate any control codes.
        !Calling IGrInputDevice on a Tektronix thus defaults to a mouse/pointing device
        !unless keyboard input is requested and exclusive-or plotting is supported.
        !INTERACTER Subroutine Reference Graphics Positional Input
        !1-103
        !ReGIS :
        !As on a Tektronix, the GIN cursor is moved under the control of the terminal not the
        !host INTERACTER program. Whatever the physical device used to move the GIN
        !cursor (mouse, keyboard, etc.) this is treated by INTERACTER as a 'mouse/pointing
        !device'. Selecting 'keyboard input' mode means that GIN mode is entirely controlled by
        !the host program using exclusive-or plotting. This will typically be slower than using
        !local GIN mode but provides greater control. A mouse/pointing device (i.e. locally
        !controlled GIN mode) is selected by default.
    end subroutine

    subroutine IGrInputLimits(XLEFT,YLOWER,XRIGHT,YUPPER)
        real XLEFT ! Left limit of graphics input area (0.0 =<XLEFT < 1.0)
        real YLOWER ! Lower limit of graphics input area (0.0 =<YLOWER < 1.0)
        real XRIGHT ! Right limit of graphics input area (0.0 <XRIGHT=< 1.0)
        real YUPPER ! Upper limit of graphics input area (0.0 <YUPPER=< 1.0)
        ! Short-name : GINLIM
        ! Defines the area of the screen in which graphics input is allowed. Logically (and
        ! possibly physically) the GIN cursor will be restricted to the area specified. By default,the graphics input area is set to the whole screen. Where initial positions are specified
        ! to GIN routines such as IGrInputBox and IGrInputXY which lie outside the
        ! limits set by IGrInputLimits, the GIN cursor is forced to the nearest point which
        ! lies within the specified graphics input area.
        ! Note that calls to IGrArea automatically reset the graphics input limits to match the
        ! current graphics area, but these limits can be over-ridden with a later call to
        ! IGrInputLimits.
        ! When using a digitiser, the graphics input area limits are mapped onto the equivalent
        ! area on the digitising tablet. Any attempts to input a point outside that area on the tablet
        ! using the confirm button will be rejected. Other buttons may be pressed at any position.
        ! IGrInputXY, IGrInputBox and IGrInputLine reset mouse input limits to full
        ! screen on exit. Mouse input as performed via InKeyEvent and the fixedfield/
        ! menu/form routines is unaffected by these limit settings.
        !e.g. CALL IGrInputLimits(0.0,0.5,1.0,1.0)
        !C graphics input restricted to the top half of the screen ...
        !CALL IGrInputXY(X,Y)
        !Portability notes :
        !Xlib and MS Windows :
        !The mouse cursor is not physically restricted to the specified GIN limits since this
        !would prevent normal user interaction with other windows/programs. Instead, 'confirm'
        !is ignored outside the GIN limits and rubber banding is restricted to the GIN limits. The
        !help and quit keys/buttons may be pressed at any position within either of the graphics
        !or text windows.
        !Graphics Positional Input INTERACTER Subroutine Reference
        !1-104
        !Tektronix :
        !It is not possible to physically restrict the GIN cursor to the specified input area on the
        !currently supported 4010/4014/4105 type displays. Instead, the graphics input routines
        !will reject any attempts to select a point outside that area using the confirm key. The
        !help and quit keys may be pressed at any position on the screen. When a
        !4107/4207/4208 type device is used, the GIN cursor is restricted to the GIN area, as
        !required.
        !ReGIS :
        !It is not possible to physically restrict the GIN cursor to the specified input area under
        !ReGIS. Instead, the graphics input routines will reject any attempts to select a point
        !outside that area using the confirm key. The help and quit keys may be pressed at any
        !position on the screen.
    end subroutine

    subroutine IGrInputLine(XPOS,YPOS,XLEN,YLEN,IACTN)
        real XPOS ! on entry: Initial X position
        ! on exit : Returned X position (IACTN >1)
        real YPOS ! on entry: Initial Y position
        ! on exit : Returned Y position (IACTN >1)
        real XLEN ! entry : Initial X distance of line end from XPOS
        ! on exit : Returned X distance (IACTN<>2)
        real YLEN ! on entry: Initial Y distance of line end from YPOS
        ! on exit : Returned Y distance (IACTN<>2)
        integer IACTN ! Input action required :
        ! = 1 : Stretch line out from a fixed position
        ! = 2 : Place a line of fixed length
        ! = 3 : Mark both ends of a line
        ! Short-name : GINLIN
        ! Uses graphics input (GIN) mode to enable the user to mark a line using the current
        ! graphics input device (see IGrInputDevice). The final position and/or length of the
        ! line are returned. The line can be marked in one of three ways, depending on the
        ! specified action.
        ! This routine is functionally identical to IGrInputBox, except that a line is marked
        ! instead of a rectangle. XLEN and YLEN mark the relative distance of the 2nd point of
        ! the line from the first, instead of the width and height of the box. Refer to
        ! IGrInputBox for more information.
        !e.g. XPOS = 0.5
        !YPOS = 0.5
        !CALL IGrInputLine(XPOS,YPOS,DXPOS,DYPOS,1)
        !KEXIT = InfoInput(55)
        !Portability notes :
        !See IGrInputBox
        !Tektronix :
        !Rubber-banding, as used by action codes 1 and 3, is supported in GIN mode on a
        !Tektronix 4107 or 4207/4208 terminal.
        !INTERACTER Subroutine Reference Graphics Positional Input
        !1-105
    end subroutine

    subroutine IGrInputOptions(NOPTN,IVALUE)
        integer NOPTN ! Option number (1-10)
        integer IVALUE ! Option value (see below)
        ! NOPTN IVALUE
        ! DigXRange (1) Digitiser x range
        ! DigYRange (2) Digitiser y range
        ! DigSerialPort (3) Digitiser serial port (1-4)
        ! GINTerminate (4) GIN mode termination condition :
        ! GINExitKey (0) : Only allow standard exit keys
        ! GINAnyKey (1) : Allow any non-movement key
        ! GINCursorSize (5) Size of program generated GIN cross hair cursor
        ! DigButtons (6) Number of digitiser stylus buttons (2/3/4/16)
        ! GINCursor (7) Type of pointing device GIN mode cursor
        ! CrossHair (0) : Cross hair
        ! HardwarePointer (1) : Hardware/mouse-driver
        ! generated pointer (default)
        ! GINExitOutside (8) Allow exit on key/button press outside GIN menu
        ! IntNo (0) : Disable (default)
        ! IntYes (1) : Enable
        ! GINMenuHighlight (9) Highlight for selected GIN menu item
        ! GINNone (-2) : None
        ! GINBorder (-1) : Border drawn round symbol
        ! 0 =< : Redraw symbol in colour
        ! IVALUE
        ! GINBoxRatio (10) Maintain aspect ratio when rubber-banding a box
        ! IntNo (0) : Disable (default)
        ! IntYes (1) : Enable
        ! Short-name : GINOPT
        ! Include : intergi.inc, intergen.inc
        ! Defines graphics input mode options. Invalid NOPTN values are ignored.
        ! Options 1 and 2 allow the range of values generated by a particular digitising tablet to
        ! be specified. The default ranges for each of the supported tablet types are described in
        ! section 14.5 of the User Guide. Modifications may be required to these values to suit
        ! 'compatible' devices or tablets of different sizes. Multiply the tablet length or width by
        ! the currently selected resolution to determine the required range value. For example, on
        ! a tablet measuring 36"x48" operating at 1000lpi, the x & y ranges would be 36000 &
        ! 48000 respectively.
        ! Under DOS, the serial port to which a digitiser is attached may need to be defined.
        ! Usually this would be done by means of an initialisation file keyword (see chapter 14 in
        ! the User Guide) but can be specified here using NOPTN=3. The default is port 1.
        ! Graphics Positional Input INTERACTER Subroutine Reference
        ! 1-106
        ! Option 4 controls the manner in which key strokes are treated in GIN mode. By default,only confirm, help and quit keys (or mouse buttons) and resize/expose events terminate
        ! GIN mode. However, by specifying a non-zero IVALUE, any non-movement key
        ! terminates GIN mode. In this case, InfoInput(55) still returns its usual values of
        ! 21-23 if an exit key is pressed, 259 for a resize/expose event or 260 for a close-window
        ! request. However, if a non-exit and non-movement key is pressed, InfoInput(55)
        ! returns -1 and the actual InKeyEvent code of the key which was pressed is returned
        ! by InfoInput(57). Conversely, InfoInput(57) will return -1 when
        ! InfoInput(55) returns 21-23/259/260.
        ! Option 5 sets the size of the GIN mode cross hair cursor. IVALUE defines the cross
        ! hair size as a proportion of the screen width and has a default initial value of 25, i.e. the
        ! cross hair size is one 25th of the screen width. Hence, the larger the value of IVALUE,the smaller the cross hair cursor.
        ! Option 6 allows the number of digitiser stylus buttons to be specified. Normally this
        ! need only be specified where a 16-button stylus is fitted.
        ! Option 7 specifies the preferred GIN cursor type to be used by IGrInputXY,IGrInputBox, IGrInputLine and IGrInputMenu when a pointing device has
        ! been selected. By default, a device specific GIN cursor is maintained by the display
        ! hardware or a memory resident mouse driver (redefinable separately by
        ! IMouseCursorShape on some displays). By setting IVALUE to zero a cross hair
        ! can be selected instead. On some displays (see Portability notes) this forces
        ! INTERACTER to maintain its own cross hair cursor instead. In the latter case, this is the
        ! same cross hair cursor as is generated by INTERACTER when keyboard input is
        ! selected so its size is controllable via option 5. Note that option 7 does not affect the
        ! mouse cursor used outside the GIN routines (see IMouseCursorShape).
        ! Option 8 specifies whether IGrInputMenu should terminate when an exit key/button
        ! is pressed outside the area of the GIN menu. By default they are ignored.
        ! Option 9 determines how IGrInputMenu highlights the selected symbol on exit. By
        ! default, the symbol is not highlighted. Alternatively a box can be drawn round it by
        ! specifying IVALUE=-1, or it can be redrawn in a colour specified by IVALUE.
        ! Option 10 determines whether the aspect ratio of a rubber banded box should be
        ! maintained in IGrInputBox, when action code 1 or 3 is specified.
        !e.g.
        !C select 5850x5850 for the X and Y digitiser ranges
        !CALL IGrInputOptions(1,5850)
        !CALL IGrInputOptions(2,5850)
        !Portability notes :
        !DOS :
        !Nominally, COM ports 1-4 can be selected using option 3. Only ports 1 and 2 have
        !standard port addresses however (3F8h and 2F8h). No standards exist for these
        !addresses for COM3 and COM4, but 3E8h and 2E8h are commonly supported. These
        !are the addresses used by INTERACTER. If in doubt check the documentation supplied
        !with a PC or serial card for compatibility.
        !Selecting a cross hair cursor, using option 7, causes a program-maintained cross hair to
        !be drawn, the size of which is determined by option 5.
        !INTERACTER Subroutine Reference Graphics Positional Input
        !1-107
        !MS Windows :
        !Option 7 selects between a small cross hair cursor and the currently selected graphics
        !window mouse cursor. Use of the cross-hair cursor requires that the supplied
        !xhair.cur resource file be built into the executable using a resource compiler. The
        !supplied MAKEINT and LINKINT batch files do this automatically. This is necessary
        !because of the inadequate nature of the standard Windows cross-hair cursor.
        !Xlib :
        !Option 7 selects between a small cross hair cursor and the currently selected graphics
        !window mouse cursor.
        !Tektronix and ReGIS terminals :
        !Option 5 only affects the size of a cross hair generated by the host program when the
        !keyboard is selected as the input device. When Tektronix GIN mode or ReGIS Locator
        !mode is selected the GIN cursor size is under the control of the terminal. Option 7 has
        !no effect.
        !Option 10 has no visible effect since rubber banding is under terminal control, where
        !supported. However the returned result will be forced to match the required aspect
        !ratio, if this option is enabled.
    end subroutine

    subroutine IGrInputXY(XPOS,YPOS)
        real XPOS ! on entry : Initial x position of graphics cursor
        ! on exit : Returned x cursor position
        real YPOS ! on entry : Initial y position of graphics cursor
        ! on exit : Returned y cursor position
        ! Short-name : GINXY
        ! Presents a graphics input (GIN) cursor which the user can move using the current
        ! graphics input device (see IGrInputDevice) and returns the position at which an
        ! 'exit' key or mouse button was pressed. The cursor reverts to its previous state on exit.
        ! This routine has numerous applications.
        ! By default, the GIN cursor can be moved to any position on the screen, both inside and
        ! outside the current graphics area, though this can be modified by calling
        ! IGrInputLimits.
        ! Logically, the effect of calling this routine is the same regardless of operating system or
        ! display. However, the precise nature of the user interface varies, depending on both the
        ! input device and the display. In general, what happens is as follows :
        ! a) The input limits as set by IGrInputLimits are enabled
        ! b) A GIN cursor of some sort is displayed (see IGrInputOptions(7,n))
        ! c) The cursor is moved, using the available input device (mouse, keyboard, etc.)
        ! d) An 'exit' key or equivalent mouse button is pressed to mark a point. All other keys
        ! are ignored. If keyboard input is selected, the three allowable 'exit' keys are
        ! confirm/quit/help, as defined by InControlKey or the KEY initialisation file
        ! keyword. The exit key which was used can be interrogated, as usual, by calling
        ! InfoInput(55). If a mouse is used the buttons are treated like exit keys :
        ! left button = confirm (exit 'key' 21)
        ! middle button = help (exit 'key' 22 : 3-button mice only)
        ! right button = quit (exit 'key' 23)
        ! Graphics Positional Input INTERACTER Subroutine Reference
        ! 1-108
        ! In a windowing environment, it is possible for a graphics window expose/resize
        ! event to occur during the call, in which case InfoInput(55) will return 259.
        ! Similarly, a close-window request will return InfoInput(55) set to 260.
        ! a) Pointing device input limits are reset to the full screen.
        ! The calling program can thus check for exit keys 21-23 (confirm/help/quit) without
        ! being concerned with what type of input device is in use. Similarly, if one of the
        ! alternative GIN mode exit keys has been pressed (control keys 31-33), InfoInput
        ! still returns values of 21-23 as described (i.e. pressing either control key 21 or 31
        ! returns 21 and so on.)
        ! Termination of GIN mode need not be restricted to pressing one of the 'exit keys' or
        ! mouse buttons, though this is the default. An alternative 'any key to exit' option can be
        ! activated. See IGrInputOptions(4,N).
        ! [Notes for digitiser users : When a digitiser is selected as the current graphics input
        ! device, rather than a keyboard or mouse, no on-screen cursor is displayed. The value of
        ! XPOS and YPOS on entry to IGrInputXY are ignored. The buttons on the digitiser
        ! stylus/cursor are identified in the same manner as mouse buttons or keyboard exit keys :
        ! confirm (exit 'key' 21) = button 1 (also buttons 3 and 5-16)
        ! quit (exit 'key' 23) = button 2
        ! help (exit 'key' 22) = button 4 (3rd button on a 3-button stylus)
        ! The actual number of the button which was pressed is available via InfoInput(59).
        ! From the point of view of the calling program, using IGrInputXY to receive input
        ! from a digitiser is no different to using it to input from the mouse/keyboard.]
        ! IGrInputXY does not update the current plotting position, since this may not be
        ! required. Use IGrInputDevice to select the graphics input device.
        !e.g. XPOS = 50.0
        !YPOS = 100.0
        !100 CALL IGrInputXY(XPOS,YPOS)
        !KEXIT = InfoInput(55)
        !IF (KEXIT.EQ.21) THEN
        !CALL IGrLineTo(XPOS,YPOS)
        !ELSE IF (KEXIT.EQ.23) THEN
        !CALL IGrMoveTo(XPOS,YPOS)
        !ELSE
        !CALL HELP
        !ENDIF
        !IF (KEXIT.NE.21) GOTO 100
        !Portability notes :
        !DOS :
        !The GIN cursor is displayed at the specified plotting position. This will be a cross hair
        !if keyboard-only input has been selected or if IGrInputOptions(7,0) has been
        !called. Otherwise, the currently selected mouse cursor is displayed.
        !INTERACTER Subroutine Reference Graphics Positional Input
        !1-109
        !If keyboard input is selected, the GIN cursor is displayed in a colour determined by
        !IGrColour/IGrColourN. The cursor can then be moved, pixel-by-pixel using the
        !cursor keys. To move the cursor in bigger steps or to the edges of the graphics input
        !area, use the extended/extreme cursor movement keys. (See InControlKey and
        !InKeyEvent for details of these keys). The same 'exit' keys as would be used in text
        !mode are also available for graphics input. The keyboard control keys are also available
        !when a mouse is selected
        !MS Windows :
        !If keyboard input is selected, the GIN cursor is displayed at the specified plotting
        !position as a cross hair in a colour determined by IGrColour/IGrColourN. The
        !cursor can then be moved, pixel-by-pixel using the cursor keys. To move the cursor in
        !bigger steps or to the edges of the graphics input area, use shift or ctrl with the cursor
        !keys. The same 'exit' keys which are used in text mode are also available for graphics
        !input. If mouse input is selected (the default) the mouse cursor is moved to the
        !specified position. Keyboard control keys remain available even if a mouse is selected.
        !Xlib :
        !If keyboard input is selected, the GIN cursor is displayed at the specified plotting
        !position as a cross hair in a colour determined by IGrColour/IGrColourN. The
        !cursor can then be moved, pixel-by-pixel using the cursor keys. To move the cursor in
        !bigger steps or to the edges of the graphics input area, use shift or ctrl with the cursor
        !keys. The same 'exit' keys which are used in text mode are also available for graphics
        !input.
        !If mouse input is selected (the default) the workstation mouse cursor is moved to the
        !specified position. Keyboard control keys remain available even if a mouse is selected.
        !If a help or quit mouse button is pressed when the pointer is in the text window or a
        !help/quit key is pressed when the text window has the focus, IGrInputXY will exit
        !with (XPOS,YPOS) set to a position just outside the X Windows graphics window.
        !Tektronix :
        !On a Tektronix terminal, 'GIN mode' is normally selected (though see below). This
        !usually invokes a cross-hair cursor which can be moved using the local pointing device.
        !Movement of the GIN cursor is entirely under the local control of the terminal until a
        !terminating key or button is pressed. To mark a position the user should press one of
        !the 'exit' keys as defined using InControlKey or a KEYnn initialisation file
        !keyword. If any other key is pressed or the current cursor position is outside the
        !graphics input area, the terminal bell rings and the GIN cursor remains on screen.
        !Remember though, that function and keypad keys are not normally detectable in
        !Tektronix mode, so the exit keys should be selected accordingly. The alternative GIN
        !control keys (31-33) are provided to overcome this problem without having to redefine
        !the text mode control keys (21-23).
        !On some devices (mainly 4010/4014 compatible) the initial position of the GIN cursor
        !is not under program control. Instead, it normally reappears wherever it was last
        !displayed. On most 4100/4200 compatible displays the initial position of the GIN
        !cursor can be controlled.
        !Graphics Positional Input INTERACTER Subroutine Reference
        !1-110
        !Logically, INTERACTER treats Tektronix GIN mode as if it were a mouse or pointing
        !device. However, if keyboard input has been selected using IGrInputDevice,IGrInputXY behaves exactly like the other implementations except the cursor control
        !keys will not work. You will need to define the movement control keys to some
        !combination on the main keyboard, using InControlKey. In practice this can be
        !rather awkward, which is why GIN mode is used by default even though it is less
        !flexible than direct keyboard control.
        !Certain terminals (mainly PC based emulators) may not support GIN mode. Refer to
        !chapter 18 in the User Guide or call InfoGrScreen(21) to check this feature.
        ![Technical note : When using Tektronix GIN mode, a 'GIN terminator' of carriage
        !return is assumed. This is the default state on most Tektronix compatible terminals, but
        !may need to be set explicitly by means of a terminal set-up option. Alternatively, the
        !GIN terminator can be defined to INTERACTER by means of the GINTERM
        !initialisation file keyword. See chapter 14 in the User Guide for more information.]
        !xterm :
        !Using the X Windows Tek4014 emulator, INTERACTER programs the alternative GIN
        !exit keys (control keys 31-33) to respond to the 3 mouse buttons. Hence, graphics input
        !can be confirmed simultaneously from either the mouse or the keyboard.
        !ReGIS :
        !Under ReGIS, 'Locator mode' is normally selected (though see below). This usually
        !invokes a cross hair cursor which can be moved using the local pointing device.
        !Movement of the GIN cursor is entirely under the local control of the terminal until a
        !terminating key or button is pressed. To mark a position the user should press one of
        !the 'exit' keys as defined using InControlKey or a KEYnn initialisation file
        !keyword. If any other key is pressed or the current cursor position is outside the
        !graphics input area, the terminal bell rings and the GIN cursor remains on screen.
        !Whilst Function/keypad keys remain available in ReGIS mode, they should not be
        !selected as GIN exit keys if ReGIS Locator mode is being used.
        !Logically, INTERACTER treats ReGIS Locator mode as if it were a mouse or pointing
        !device. If keyboard input has been selected using IGrInputDevice, IGrInputXY
        !behaves in much the same way as the DOS version, controlling all cross hair movement
        !from the host. In this case, function/keypad keys can be selected as GIN mode exit keys
        !if required.
        !DECterm :
        !When using DECterm under DECwindows, the notes above for ReGIS apply. The
        !DECterm mouse is used as the Locator mode input device with the left, middle and
        !right buttons being automatically identified as confirm, help and quit keys.
        !INTERACTER Subroutine Reference Graphics Proximity Checks
        !1-111
        !1.9 Group GP : Graphics Proximity Checks
        !This group provides a set of utility routines which simplify co-ordinate checking in
        !relation to lines, circles/ellipses and polygons. IGrInsideCircle,IGrInsideEllipse and IGrInsidePolygon are all logical functions which
        !determine whether a given point lies within a given type of shape.
        !IGrDistanceLine determines the distance of a given point from a given line.
        !IGrIntersectLine determines where (or if) two lines intersect.
        !In all cases, these routines accept arguments with the same meaning as the equivalent
        !graphics primitives elsewhere, with the addition of the co-ordinate pair of interest. For
        !examples of how to use these routines see the proxchek demo program.
    end subroutine

    REAL function IGrDistanceLine(X1,Y1,X2,Y2,XCHECK,YCHECK,METHOD) result(res)
        real X1 ! X co-ordinate of start of line
        real Y1 ! Y co-ordinate of start of line
        real X2 ! X co-ordinate of end of line
        real Y2 ! Y co-ordinate of end of line
        real XCHECK ! X co-ordinate of point to check
        real YCHECK ! Y co-ordinate of point to check
        integer METHOD ! Calculation method for points not on a perpendicular line:
        ! DistanceDirect (0) : Give direct distance to nearest end of line
        ! DistanceExtended (1) : Give perpendicular distance to extended line
        ! Include : intergi.inc
        ! Measures the distance from the point (XCHECK,YCHECK) to the line which lies
        ! between (X1,Y1) and (X2,Y2). Specifically, it measures the length of a line drawn
        ! perpendicular to the given line which connects with the specified point. If no such line
        ! exists (because the point lies 'beyond' the line ends) METHOD determines how the
        ! distance should be calculated :
        ! Graphics Proximity Checks INTERACTER Subroutine Reference
        ! 1-112
    
        res = 0
    end function

    LOGICAL function IGrInsideCircle(XPOS,YPOS,RADIUS,XCHECK,YCHECK) result(res)
        real XPOS ! X co-ordinate of circle centre
        real YPOS ! Y co-ordinate of circle centre
        real RADIUS ! Radius of circle in current X plotting units
        real XCHECK ! X co-ordinate of point to check
        real YCHECK ! Y co-ordinate of point to check
        ! Determines whether the point (XCHECK,YCHECK) lies within the given circle. The
        ! physical dimensions of the circle are calculated in the same manner as IGrCircle.
        ! The function returns .TRUE. if the point lies inside the circle.
    
        res = .true.
    end function

    LOGICAL function IGrInsideEllipse(XPOS,YPOS,RADIUS,RATIO,XCHECK,YCHECK) result(res)
        real XPOS ! X co-ordinate of ellipse centre
        real YPOS ! Y co-ordinate of ellipse centre
        real RADIUS ! Radius of ellipse in current X plotting units
        real RATIO ! Ratio of the height of the ellipse to the width
        real XCHECK ! X co-ordinate of point to check
        real YCHECK ! Y co-ordinate of point to check
        ! Determines whether the point (XCHECK,YCHECK) lies within the given ellipse. The
        ! physical dimensions of the ellipse are calculated in the same manner as IGrEllipse.
        ! The function returns .TRUE. if the point lies inside the ellipse.
    
        res = .true.
    end function

    LOGICAL function IGrInsidePolygon(X,Y,NVERT,XCHECK,YCHECK) result(res)
        integer NVERT ! Number of vertices in X/Y arrays (<=4095)
        real X(NVERT) ! Array of X co-ordinates
        real Y(NVERT) ! Array of Y co-ordinates
        real XCHECK ! X co-ordinate of point to check
        real YCHECK ! Y co-ordinate of point to check
        ! Determines whether the point (XCHECK,YCHECK) lies within the given polygon. The
        ! physical dimensions of the polygon are calculated in the same manner as
        ! IGrPolygonComplex. The function returns .TRUE. if the point lies inside the
        ! polygon. The same limits on polygon size apply as for IGrPolygonComplex.
        ! INTERACTER Subroutine Reference Graphics Proximity Checks
        ! 1-113
    
        res = .true.
    end function

    subroutine IGrIntersectLine(X1,Y1,X2,Y2,X3,Y3,X4,Y4,XINTER,YINTER,ISTATUS)
        real X1 ! First X co-ordinate of first line
        real Y1 ! First Y co-ordinate of first line
        real X2 ! Second X co-ordinate of first line
        real Y2 ! Second Y co-ordinate of first line
        real X3 ! First X co-ordinate of second line
        real Y3 ! First Y co-ordinate of second line
        real X4 ! Second X co-ordinate of second line
        real Y4 ! Second Y co-ordinate of second line
        real XINTER ! X co-ordinate of intersection point ) zero if lines
        real YINTER ! Y co-ordinate of intersection point ) are parallel
        integer ISTATUS ! How lines intersect (if at all) :
        ! ParaCollinear (0) : Lines are parallel and collinear
        ! ParallelLines (1) : Lines are parallel but not collinear
        ! IntersectBeyond (2) : Lines intersect but not within either segment
        ! IntersectOn1 (3) : Lines intersect on segment 1 only
        ! IntersectOn2 (4) : Lines intersect on segment 2 only
        ! IntersectOnBoth (5) : Lines intersect on both line segments
        ! Include : intergi.inc
        ! Calculates the intersection point (XINTER,YINTER) of the two specified lines. If the
        ! lines are parallel, ISTATUS will be returned as 0 or 1. It is therefore important to check
        ! ISTATUS before using the resulting co-ordinate pair. ISTATUS provides further
        ! information about precisely how the lines intersect (if at all), which is best illustrated by
        ! way of the following diagrams :
        ! 
        ! INTERACTER Subroutine Reference PG Housekeeping/Options
        ! 2-1
        ! 2. Presentation Graphics : Subroutine Descriptions
        ! The Presentation Graphics routines are designed to perform many of the most common
        ! graphical data display operations in a semi-automatic way, while offering maximum
        ! flexibility in the style and layout of that display. All of the routines described in this
        ! chapter are built on the lower level graphics facilities provided by the routines
        ! described in chapter 1. This means that routines from all these groups can be freely
        ! mixed, enabling customisation of the Presentation Graphics displays to meet specialised
        ! requirements. A particular implication of this flexibility is that hardcopy facilities
        ! provided by the GH subroutine group are fully available when using the PG routines.
        ! A visual graph designer is supplied with the Windows versions of INTERACTER,called GraphEd. This allows any of the supported graph types to be designed
        ! interactively, with control over all of the available layout and style options. GraphEd
        ! generates Fortran source code which calls the routines in the various PG groups to draw
        ! the required graph. This code can then be incorporated into applications for any
        ! platform (not just Windows) in the same manner as any other piece of source. It can
        ! also be manually modified if required.
        ! (Given the close association between the routines in the PG and GG/GA/etc. groups, it
        ! would be a good idea to refer to the introductory sections on those groups at this point,if you have not already done so. A basic grasp of how they work will save you a great
        ! deal of time in using the PG routines. You don't need to read the whole of chapter 1,just the introductions.)
        ! In general, it is quite possible to plot a set of data complete with axes, scale and labels
        ! in less than 20 lines of code. To take advantage of these easy to use routines though,you should follow certain logical steps.
        ! a) Initialise INTERACTER as normal, by calling IScreenOpen and optionally reset
        ! the main graphics area and plotting units by calling IGrArea and IGrUnits.
        !e.g. CALL IScreenOpen(' ','G',NX,NY,NCOLORS)
        !CALL IGrArea(0.1,0.1,0.9,0.9)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !b) You're now ready to use the PG (Presentation Graphics) routines. In fact, as soon as
        !IScreenOpen has been called they are available, i.e. the IGrArea and
        !IGrUnits calls above are entirely optional. The PG routines operate on an area
        !which will be referred to as the Presentation Graphics area (or PG area for short).
        !This is an area within the main graphics area and is defined by the routine
        !IPgArea. So, in the same way that IGrArea defines which part of the
        !screen/page to use for general graphics operations, so IPgArea defines the part of
        !the main graphics area which is to be used for Presentation Graphics operations.
        !This enables a border to be left around the PG area in which other objects such as
        !labels, keys, etc. can still be plotted without lying outside the main graphics area.
        !By default the PG area occupies a range 0.1 to 0.9 in the main graphics area in both
        !the X and Y directions. Let's suppose we wanted to leave ourselves a bigger border.
        !IPgArea could be called like so :
        !e.g. CALL IPgArea(0.2,0.2,0.8,0.8)
        !PG Housekeeping/Options INTERACTER Subroutine Reference
        !2-2
        !c) Having told the PG routines where to put our display, we need to define what sort
        !of plot to produce. Various types are available, including histograms, line graphs
        !and so on. These are selected by calling IPgNewPlot which also defines how
        !much data is to be plotted and the required layout. Take for example a 3
        !dimensional stacked histogram, with 3 data sets each containing 6 data values :
        !e.g. CALL IPgNewPlot(PgHistogram,3,6,PgLay3D+PgLayStacked,0)
        !d) If we wish, we could plot some data immediately using IPgHistogram (the
        !histogram plotting routine) and use all the default styles, units, etc. However, the
        !default units are always 0.0 to 1.0 in both the X and Y dimensions, so we will
        !probably want to modify these. It's important to understand at this point that the
        !units we shall be using when plotting data using the PG routines will be as defined
        !by IPgUnits, not by IGrUnits. IPgUnits defines the units for the PG area in
        !just the same way that IGrUnits does for the main graphics area. Think of
        !IGrArea + IGrUnits as one pair of routines operating on the full graphics area
        !and then IPgArea + IPgUnits as an analogous pair of routines which operate
        !on the PG area. Having got that straight, what sort of units do we want for our
        !histogram ? Let's assume we have values to plot in the range 0 to 100. A typical call
        !to IPgUnits would be :
        !e.g. CALL IPgUnits(1.0,0.0,6.0,100.0)
        !(Note that in practice it will be more convenient to use the max/min functions in
        !Group MM to calculate either or both of the unit ranges. Scalar values are used here
        !to simplify the example.)
        !e) Again, we could easily plot some data at this point, but it probably isn't going to be
        !very useful without some axes. In general, it is best to draw these before plotting
        !your data values. To add a set of axes is very simple :
        !e.g. CALL IPgAxes
        !f) Now we are ready to plot some data. Assuming we already have some data in 3
        !arrays called VAL1, VAL2 and VAL3, we can simply plot them on our histogram by
        !calling IPgHistogram :
        !e.g. CALL IPgHistogram(VAL1)
        !CALL IPgHistogram(VAL2)
        !CALL IPgHistogram(VAL3)
        !and if our data had been in a 2 dimensional array (e.g. VAL(6,3)) we could have
        !used :
        !e.g. DO 100 ISET = 1,3
        !CALL IPgHistogram(VAL(1,ISET))
        !100 CONTINUE
        !And so, our total coding effort to produce a 3D stacked histogram has been just :
        !CALL IScreenOpen(' ','G',NX,NY,NCOLORS)
        !CALL IGrArea(0.1,0.1,0.9,0.9)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !CALL IPgNew Plot(PgHistogram,3,6,PgLay3D+PgLayStacked,0)
        !CALL IPgArea(0.2,0.2,0.8,0.8)
        !CALL IPgUnits(1.0,0.0,6.0,100.0)
        !CALL IPgAxes
        !DO 100 ISET = 1,3
        !CALL IPgHistogram(VAL(1,ISET))
        !100 CONTINUE
        !INTERACTER Subroutine Reference PG Housekeeping/Options
        !2-3
        !Obviously, we haven't added a title, labels or a scale (all of which are available in other
        !PG routines), but a useful display has already been generated with minimum effort.
        !Additionally we could have defined the histogram fill styles using IPgStyle, drawn a
        !border round the graphics area using IGrBorder, made the user press Return by
        !calling IGrPause and so on. Other useful routines are IGrCharSet which selects
        !software characters, IGrHardCopy which enables hardcopy and IPgKeyAll which
        !adds a key. In general you should not need to resort to the very low level 'move and
        !draw' type routines, but these are all available to use if you wish. Remember though
        !that these routines work in main graphics area units not PG area units. Use
        !IPgUnitsToGrUnits/IPgUnitsFromGrUnits to convert PG units to/from
        !main graphics area units. Alternatively, a set of PG line/fill .primitives. are provided in
        !the PG(5) group.
        !Once you've plotted one graph you can define a fresh display (of either the same or a
        !new type) by another call to IPgNewPlot. Any previous settings resulting from calls
        !to IPgArea, IPgUnits, IPgStyle can remain in force for the next plot, if
        !required, reducing coding even further. The current display is not automatically wiped
        !from the PG area when IPgNewPlot is next called, allowing plots of different types
        !to be superimposed on top of one another. A line graph can easily be drawn on top of a
        !histogram, for example.
        !For more detailed examples of how to generate various types of Presentation Graphics
        !plots using many of the supported options see the pgdemo2 demonstration program.
        !PG Housekeeping/Options INTERACTER Subroutine Reference
        !2-4
        !2.1 Group PG(1) : Housekeeping/Option Selection
        !Routines in this group control the behaviour of the routines in the other PG groups.
        !These include IPgNewPlot and IPgStyle which define the overall graph type and
        !individual data set presentation styles respectively. IPgArea and IPgUnits are the
        !PG equivalents of IGrArea and IGrUnits, defining the area in which plots will be
        !placed and the plotting units to be used. IPgUnitsZ is a logical extension of
        !IPgUnits which defines the Z scale units for 3D surface/scatter/volume plots.
        !Likewise IPgUnitsPolar defines the units to use for the radius of a polar plot.
        !Various other option/parameter selection routines are also provided.
        !IPgClipRectangle determines the area to which plots are clipped. Log or linear
        !scaling is selectable via IPgScaling. Elevation and rotation angles of 3D
        !surface/scatter/volume plots are controlled by IPgElevation and IPgRotation.
        !The colour/existence of grid lines on 3D surface/volume plots is determined by
        !IPgGridLines. Grid line direction on 3D surface plots is set by
        !IPgGridDirection. The granularity of 2D fill-based contour plots can be specified
        !via IPgConFill2Granul.
        !The relative vertical position of X or Y scale annotation is controlled by
        !IPgXScalePos and IPgYScalePos. Similarly the relative position of X and Y
        !axis labels can be controlled by IPgXLabelPos and IPgYLabelPos respectively.
        !X and Y axis tick mark positions can be specified via IPgXTickPos and
        !IPgYTickPos. Tick length control is provided via IPgXTickLength,IPgYTickLength and IPgZTickLength. The relative vertical position of an Xaxis
        !key (an optional feature of IPgKeyAll) is controlled by IPgXKeyPos.
        !By default, scaling is calculated automatically, but user defined scales can be specified
        !for each of the X/Y/Z axes using IPgXUserScale, IPgYUserScale and
        !IPgZUserScale. The same functionality is provided on histogram X axes and barchart
        !Y axes by IPgXUserScaleHist and IPgYUserScaleBar. The number of
        !decimal places in scale values can be controlled by IPgDecimalPlaces.
        !Tick marks and scale values can be rotated by calling IPgXScaleAngle,IPgYScaleAngle and IPgZScaleAngle.
        !Nearly all of the settings which can be specified via this group can be interrogated via
        !the InfoPgInteger, InfoPgReal and InfoPgStyle function in the IF group.
    end subroutine

    subroutine IPgArea(XLEFT,YLOWER,XRIGHT,YUPPER)
        real XLEFT ! Left limit of PG area (0.0= < XLEFT < 1.0)
        real YLOWER ! Lower limit of PG area (0.0= < YLOWER < 1.0)
        real XRIGHT ! Right limit of PG area (0.0 < XRIGHT =< 1.0)
        real YUPPER ! Upper limit of PG area (0.0 < YUPPER =< 1.0)
        ! Short-name : PGAREA
        ! Defines the Presentation Graphics area relative to the main graphics area (which is
        ! itself defined by IGrArea). Each parameter is expressed as a proportion of the main
        ! graphics area. Hence, arguments of (0.25,0.25,0.75,0.75) would give a centred PG area
        ! occupying half the width and half the height of the main graphics area. This enables
        ! space to be left around the Presentation Graphics plotting area where labels, titles, scale
        ! values and keys can be plotted.
        ! INTERACTER Subroutine Reference PG Housekeeping/Options
        ! 2-5
        !e.g. CALL IGrArea(0.1,0.1,0.9,0.9)
        !CALL IPgArea(0.2,0.1,0.8,0.7)
        !CALL IPgTitle('PG Area occupies 60% of Main Area','C')
    end subroutine

    subroutine IPgClipRectangle(AREA)
        character(len=*) AREA ! Area to which PG plots are to be clipped
        ! = G : Main graphics area defined by IGrArea (default)
        ! = P : Presentation Graphics area defined by IPgArea
        ! Short-name : PGCLIP
        ! Specifies the area to which PG plots are to be clipped. By default, plots generated by
        ! the routines in the PG(3)/(4) groups are clipped to the main graphics area, like all other
        ! graphics. However, parts of the plot may therefore extend into the border between the
        ! edges of the main and presentation graphics areas (as set by IGrArea and IPgArea
        ! respectively). To force the routines in the PG(3)/(4) groups to clip their output at the
        ! edge of the area set by IPgArea, call IPgClipRectangle with a 'P' argument.
        !e.g. CALL IPgNewPlot(PgHistogram,1,NVALUE,0,0)
        !CALL IPgClipRectangle('P')
        !CALL IPgHistogram(YDATA)
    end subroutine

    subroutine IPgConFill2Granul(IGRAN)
        integer IGRAN ! 2D fill-based contour plot granularity (>=1)
        ! Specifies the 'granularity' of 2D fill-based contour plots generated by
        ! IPgConFill2Irreg and IPgConFill2Reg. These routines will sub-divide each
        ! grid cell into IGRAN x IGRAN equally sized sub-cells and estimate the height within
        ! each sub-cell, thereby reducing the amount of data which needs to be supplied to define
        ! the grid. Setting granularity to 1 causes no sub-division to take place.
        !e.g. DIMENSION ZDATA(NXDIM,NYDIM)
        !CALL IPgConFill2Granul(4)
        !CALL IPgConFill2Reg(ZDATA,NXDIM,NYDIM,ZCONTR)
    end subroutine

    subroutine IPgContourLabel(ISET,LABEL)
        integer ISET ! Contour number
        character(len=*) LABEL ! Contour label (<=10 characters)
        ! Specifies a label to be plotted on a 2D line-based contour plot by IPgContour2Reg.
        ! when the marker type has been set to 6 (user defined contour label) for contour ISET.
        ! A maximum of 10 characters per label are stored. Longer strings are truncated.
        !e.g. PARAMETER (NCONTOUR = 3)
        !CHARACTER*6 LABELS(NCONTOUR)
        !DATA LABELS/'Low','Middle','High'/
        !CALL IPgNewPlot(PgZarrayPlot,NCONTOUR,NVALUE,0,1)
        !DO 100 ICONT = 1,NCONTOUR
        !CALL IPgStyle(ICONT,0,6,0,223,31)
        !CALL IPgContourLabel(ICONT,LABEL(ICONT))
        !100 CONTINUE
        !CALL IPgContour2Reg(ZDATA,NXDIM,NYDIM,ZCONTR)
    end subroutine

    subroutine IPgDecimalPlaces(NDEC)
        integer NDEC ! Number of decimal places in scale values (<0 : auto-select)
        ! Specifies the number of decimal places to use in scale values displayed by
        ! IPgXScale, IPgXScaleTop, IPgYScaleLeft, IPgYScaleRight and
        ! IPgZScale. By default, this is determined automatically for each scale value, but this
        ! routine can be used to override this auto-selection. NDEC<0 restores auto-selection.
        ! PG Housekeeping/Options INTERACTER Subroutine Reference
        ! 2-6
        !e.g.
        !C force 2 decimal places on X axis
        !CALL IPgDecimalPlaces(2)
        !CALL IPgXScale('tn')
        !C use default annotation on Y axis
        !CALL IPgDecimalPlaces(-1)
        !CALL IPgYScaleLeft('tn')
    end subroutine

    subroutine IPgElevation(ANGLE)
        real ANGLE ! Angle of elevation for 3D contour plot view in degrees
        ! ( 0.0 =< ANGLE =< 45.0 )
        ! Short-name : PGELEV
        ! Specifies the elevation angle for 3D surface/scatter/volume plot views. The angle must
        ! be 0-45 degrees. An angle of zero gives a head-on view. The default angle is 22.5
        ! degrees, which gives a view which just fits within the Presentation Graphics area.
        ! Smaller values will not use the full PG area and larger ones may cause some parts of the
        ! plot to extend outside the PG area. See also IPgRotation.
        !e.g. CALL IPgNewPlot(PgFuncPlot,1,NVALUE,PgLay3D,0)
        !CALL IPgElevation(40.)
        !CALL IPgSurf3Func(MYFUNC)
    end subroutine

    subroutine IPgGridDirection(IGRID)
        integer IGRID ! Direction of grid lines on 3D contour plots
        ! 3 : Both X and Y (default)
        ! 2 : Perpendicular to Y axis only
        ! 1 : Perpendicular to X axis only
        ! 0 : No grid
        ! Specifies the direction of grid lines on a 3D surface plot. By default, a conventional
        ! X/Y grid is drawn (IGRID=3). If grid lines are only required in a single direction, set
        ! IGRID to 1 or 2. The grid can be suppressed completely by setting IGRID=0 (this has
        ! the same effect as specifying an out of range colour number to IPgGridLines).
        !e.g. CALL IPgNewPlot(PgFuncPlot,1,NVALUE,PgLay3D,0)
        !C display grids lines in one direction only
        !CALL IPgGridDirection(1)
        !CALL IPgSurf3FuncCont(MYFUNC,ZCONTR)
    end subroutine

    subroutine IPgGridLines(IGRID)
        integer IGRID ! Colour of grid lines on 3D contour plots, or :
        ! -1 : height dependent grid line colours
        ! -2 : no grid lines
        ! -3 : grid lines drawn in background colour
        ! Selects the colour or existence of grid lines on a 3D surface/volume plot. By default,this is set to the background colour (IGRID=-3) to ensure that grid lines are visible on
        ! monochrome devices. However, grid line colour may benefit from being changed on
        ! colour devices. The colour number is specified as for IGrColourN.
        ! When using IPgSurf3DataCont or IPgSurf3FuncCont to generate 3D surface
        ! plots with height dependent contour colours, two further options may prove useful :
        ! 1) IGRID = -1 : The colours specified to IPgStyle set the grid line colour rather
        ! than the grid cell fill colour. In this case, each cell is filled using the background
        ! colour giving the effect of a line-only colour-coded surface plot. This option has no
        ! effect when grid lines are disabled by IPgGridDirection.
        ! INTERACTER Subroutine Reference PG Housekeeping/Options
        ! 2-7
        ! 2) IGRID= -2 : Suppresses grid lines. See also IPgGridDirection.
        ! Note : IGRID=-2 also suppresses grid lines on 3D volume plots.
        !e.g. CALL IPgNewPlot(PgFuncPlot,1,NVALUE,PgLay3D,0)
        !C suppress grid lines on a contoured 3D function plot
        !CALL IPgGridLines(-1)
        !CALL IPgSurf3FuncCont(MYFUNC,ZCONTR)
    end subroutine

    subroutine IPgMarker(ISET,MARKER)
        integer ISET ! Data set number
        integer MARKER ! Marker number (0-9, 1-52, 1-20 or 33-126/161-255)
        ! Specifies the marker number to be used when ISTYL2 is specified to IPgStyle with
        ! a value of 1-4 for a scatter plot, line plot, X/Y plot or line-based 2D contour plot. The
        ! marker number to be displayed can be set as follows :
        ! IPgStyle ISTYL2 Marker Type MARKER
        ! 1 Digits 0 to 9
        ! 2 Letters 1-26 (A-Z) or 27-52 (a-z)
        ! 3 Markers 1-20 as drawn by IGrMarker
        ! 4 Symbols 33-126 or 161-255. See symbols.chr
        ! When marker type 2 (letters) is selected, the currently loaded character set is used. This
        ! would allow a user-created software character set to be used or possibly the 'dingo'
        ! character set. Marker type 4 plots symbols from symbols.chr, regardless of the
        ! currently selected character set.
        ! If IPgMarker is not called to specify the marker number for a given data set, a marker
        ! number is selected in a plot-type dependent manner, which provides backwards
        ! compatibility with v3.xx and earlier (which did not implement IPgMarker) :
        ! 2D scatter plots : The marker number set via IPgStyle argument ISTYL1 is used
        ! 2D contour plots : The marker number set via IPgStyle argument ISTYL3 is used
        ! Line, 3D scatter and X/Y plots : The data set number is used
        !e.g. INTEGER MARKER(5)
        !DATA MARKER/228, 230, 231, 62, 58/
        !CALL IPgNewPlot(PgLinePlot,5,NVALUE,0,0)
        !DO 100 ISET = 1,5
        !CALL IPgStyle(ISET,0,4,0,ICOLR(ISET),MCOLR(ISET))
        !CALL IPgMarker(ISET,MARKER(ISET)
        !100 CONTINUE
    end subroutine

    subroutine IPgMarkerFrequency(ISTART,IEVERY)
        integer ISTART ! Plot first marker at this point
        integer IEVERY ! Plot subsequent markers at this frequency
        ! Specifies the frequency at which markers will be plotted, when requested on line plots
        ! (IPgLinePlot) and X-Y pair plots (IPgXYPairs). Markers are plotted at every
        ! point if ISTART=1 and IEVERY=1.
        !e.g. CALL IPgNewPlot(PgLinePlot,1,NVALUE,0,1)
        !CALL IPgStyle(ISET,0,2,0,LINECOL,MARKCOL)
        !C Plot marker every 5 points
        !CALL IPgMarkerFrequency(5,5)
        !PG Housekeeping/Options INTERACTER Subroutine Reference
        !2-8
    end subroutine

    subroutine IPgNewPlot(ITYPE,NSETS,NVALUE,LAYOUT,IRESET)
        integer ITYPE ! Graph type. One of:
        ! PgHistogram (1) Histogram
        ! PgBarChart (2) Bar chart
        ! PgPieChart (3) Pie Chart
        !PgLinePlot (4) Line plot (e.g. a time series)
        !PgFuncPlot (5) Function plot
        !PgPolyline (6) Joined XY pairs or XYZ triplets
        !PgScatterPlot (7) Scatter Plot
        !PgZarrayPlot (8) Z(x,y) array contour/surface plot
        !PgTable (9) Table of numeric data
        !PgVolumePlot (10) Volume plot
        INTEGER NSETS ! Number of data sets, pie wedges, contours or columns
        INTEGER NVALUE ! Number of values to plot
        !(2 element grid-size array for contour/surface plots)
        !(3 element grid-size array for volume plots)
        INTEGER LAYOUT ! Layout. Sum of:
        !PgLay3D (1) 3 dimensional
        !PgLayAdjacent (2) Adjacent bars in histograms/bar-charts
        !PgLayAntiClock (2) Anti-clockwise pie chart wedges
        !PgLayCol (4) Point-dependent colours on 3D scatter and Z(x,y) plots
        !PgLayFill (8) Filled label cells (tables) or grid cells (2D contour plots)
        !PgLayOverlap (8) Overlapping bars on histograms and bar charts
        !PgLayContGrad (16) Height-dependent 3D surface contours (graduated colour)
        !PgLayCont (32) Height-dependent 3D surface contours
        !PgLayHighLow (32) High/low histogram
        !PgLayPolar (64) Polar co-ordinates
        !PgLaySpider (128) Spider tags on pie charts
        !PgLaySpline (128) Fit spline on line plots and 2D XY pair plots
        !PgLayStepped (128) Stepped 3D surface
        !PgLayColTile (256) Tile-dependent colours on 3D contour plots
        !PgLayVariable (512) Variable 3D surface grid size or spider tag length
        !PgLayValueLab (512) Value labels on histograms and bar charts
        !PgLayStacked (1024) Stacked line plot, histogram or bar chart
        INTEGER IRESET ! Reset style/layout settings (0=no 1=yes)
        !Include : interpg1.inc
        !Introduces a new Presentation Graphics plot. It specifies the dimensions and layout of
        !the plot. It should be called before adding axes, scale and data to the PG area.
        !ITYPE identifies the type of PG plot to be generated. You will still need to call the
        !appropriate data plotting routines following the call to IPgNewPlot. For example if
        !ITYPE=PgBarChart, you will need to call IPgBarChart to actually plot the barchart
        !values. Calls to any other data plotting routines such as IPgFunctionLine,IPgHistogram, etc. will have no effect until a new plot type is selected by another
        !call to IPgNewPlot.
        !INTERACTER Subroutine Reference PG Housekeeping/Options
        !2-9
        !NSETS specifies the number of data sets, pie-wedges, contours or columns. The
        !maximum number which can be displayed simultaneously is 256. However, on certain
        !types of plot (e.g. line plots, scatter plots) more data sets can be plotted by repeating the
        !call to IPgNewPlot after plotting the first data sets. The main limitation to this is that
        !stacked values will not be carried forward from one plot to another. If an invalid
        !number of data sets is specified, a default of one is assumed.
        !NVALUES sets the number of values to be plotted. This is normally only limited if a
        !stacked plot or a spline curve is requested. Stacked plots are limited to 1024 values per
        !data set and splines are limited to 4095 points. Non-stacked histograms, bar-charts and
        !high-low plots are limited to 1986 points. Otherwise, any number of points can be
        !plotted, subject to the resolution of the output device. Again, if an invalid number of
        !values is specified, a default of one is used.
        !When a Z(x,y) plot or a 3D function plot is requested (i.e. ITYPE=PgZarrayPlot
        !or ITYPE=PgFuncPlot/LAYOUT=PgLay3D), NSETS and NVALUES are
        !interpreted slightly differently. NSETS specifies the number of contours to be plotted
        !(set this to 1 if IPgSurf3Data, IPgSurf3Func or IPgSurf3Step are to be
        !called, since these surface plotting routines do not use contour-dependent colouring).
        !NVALUE should be passed as a two element array containing the number of x and y grid
        !points.
        !When a 3D volume plot is requested, (ITYPE=PgVolumePlot and
        !LAYOUT=PgLay3D), NVALUE should be passed as a three element array containing
        !the number of x, y and z grid points. NSETS is only used if a contoured 3D volume plot
        !is requested (LAYOUT=PgLay3D+PgLayCont).
        !If a pie chart is selected, NSETS specifies the number of wedges to be plotted and
        !NVALUE is not used.
        !LAYOUT allows various layout options to be modified. Set this to zero if the default
        !layout is acceptable. Otherwise, it should be the sum of the required layout
        !modification flags:
        !PgLay3D : Selects three dimensional histograms, bar-charts, function plots, Z(x,y)
        !plots, x/y/z polyline plots, scatter plots and volume plots. For other plots, the default of
        !a 2 dimensional display is always assumed.
        !PgLayAdjacent : The bars on 2D histograms and bar-charts are drawn with spaces
        !between each data set, by default. Bars will be drawn immediately adjacent to one
        !another if this option is specified.
        !PgLayAntiClock : Displays pie chart wedges anti-clockwise. Wedges are plotted
        !clockwise by default.
        !PgLayCol : The colour of each point can be set separately on 3D scatter, Z(x,y) and
        !volume plots. This option should be specified when IPgScatterPlot3DCol,IPgSurf3DataCol, IPgSurf3StepCol or IPgVolume3Col are to be used.
        !PgLayFill : Specify this option if a filled 2D contour plot is to be generated using
        !IPgConFill2Reg or IPgConFill2Irreg. By default, a line-based plot is
        !assumed. This option can also be used to request filled row/column label backgrounds
        !when using IPgTableInteger and/or IPgTableReal.
        !PG Housekeeping/Options INTERACTER Subroutine Reference
        !2-10
        !PgLayOverlap : Bars can be overlapped on 2D non-stacked histograms or barcharts.
        !By default, they are plotted side-by-side.
        !PgLayContGrad : On a 3D surface to be generated using IPgSurf3Data,IPgSurf3Step or IPgSurf3Func, this will select graduated colouring, i.e. the
        !colour of each tile or column wil be related to its height relative to min/max Z colours
        !set via IPgStyle(1/2,..).
        !PgLayCont : Specify this option if a contoured 3D plot is to be generated using any
        !of IPgSurf3DataCont, IPgSurf3StepCont, IPgSurf3FuncCont or
        !IPgVolume3Cont.
        !PgLayHighLow : When a 2D histogram is requested, this option specifies that a
        !'high/low' plot is to be drawn using IPgHighLow (instead of a conventional histogram
        !via IPgHistogram).
        !PgLayPolar : Specifies a polar, rather than Cartesian, co-ordinate system for a 2D
        !scatter plot, XY pair plot or line plot. Radius units are determined by
        !IPgUnitsPolar. Angles are in degrees anti-clockwise from the 3-o'clock position.
        !When this option is selected, Angle replaces the X co-ordinate and Radius replaces the
        !Y co-ordinate. Hence routines which affect the X axis of Cartesian plots affect the
        !angle axis of polar plots. Similarly routines which affect the Y axis of Cartesian plots
        !affect the radius axis of polar plots.
        !PgLaySpline : Draws lines on Line plots and 2D XY pair plots as splines (smooth
        !curves).
        !PgLaySpider : Adds spider tags to pie charts when IPgKeyAll is called. These
        !tags connect the wedge to a descriptive string.
        !PgLayStepped : Include this option if a stepped 3D surface plot is to be generated,using IPgSurfStep, IPgSurfStepCont or IPgSurfStepCol.
        !PgLayColTile : The colour of each tile can be set separately on 3D surface plots
        !when IPgSurf3DataCol is to be used. This is an alternative to the PgLayCol
        !option which indicates that vertex-specific colours will be supplied. The tile-specific
        !colours option allows transparent tiles to be specified but represents a less direct
        !association between vertex heights and colour values.
        !PgLayVariable : Specifies variable grid size or spider tag lengths. On 3D contour,function and volume plots, this selects a grid whose relative size varies according to the
        !number of x and y grid points. By default, the grid is fixed in size and the grid point
        !density varies. On pie charts, if spider tags have been selected, these will vary in length
        !if this option is selected. This forces descriptions to be aligned vertically to the left and
        !right of the pie. By default, spider tags are of a fixed length and descriptions are placed
        !around the edge of the pie.
        !PgLayValueLab : When this option is specified on non-stacked 2D bar-charts and
        !histograms, a label will be plotted at the end of each bar indicating the exact value
        !represented by that bar.
        !PgStacked : Keep a running total of the data values plotted and display the results
        !accordingly. Such plots are available on histograms, bar-charts and line plots.
        !INTERACTER Subroutine Reference PG Housekeeping/Options
        !2-11
        !IRESET allows various style/layout settings for the next plot (such as those set via
        !IPgStyle) to be reset to plot-type dependent default values. When this argument is
        !set to 1, a set of defaults are selected which are appropriate to the chosen plot type.
        !While the various PG(1) routines (e.g. IPgStyle) can still be called to amend the
        !appearance of the plot, fewer calls are typically necessary. Alternatively, if IRESET is
        !zero, all the style/layout settings remain unchanged. This allows a common set of styles
        !to be carried forward from one plot to the next.
        !Under Fortran 9x compilers, LAYOUT and ISTYLE can be omitted provided the calling
        !program unit contains a USE INTERACTER statement. They are treated as being set to
        !zero in this case.
        !e.g.
        !C select a 50 point 2D scatter plot
        !CALL IPgNewPlot(PgScatterPlot,1,50,0)
        !CALL IPgScatterPlot(X,Y)
        !C select a 3D stacked histogram,C with 5 data sets and 10 data values
        !CALL IPgNewPlot(PgHistogram,5,10,PgLay3D+PgLayStacked)
        !CALL IPgHistogram(1,DAT1)
        !CALL IPgHistogram(2,DAT2)
    end subroutine

    subroutine IPgRotation(ANGLE)
        real ANGLE ! Angle of rotation in degrees
        ! Specifies the angle of rotation for 3D surface/scatter/volume plot views. The angle can
        ! be in the range -360 to +360. The default value of ANGLE is 0 degrees. See also
        ! IPgElevation.
        !e.g. CALL IPgNewPlot(PgFuncPlot,1,NVALUE,PgLay3D,0)
        !CALL IPgElevation(40.)
        !CALL IPgRotation(75.)
        !CALL IPgSurf3Func(MYFUNC)
    end subroutine

    subroutine IPgScaling(XSCAL,YSCAL)
        character(len=*) XSCAL ! X scaling ) 'LIN' = Linear scaling (default)
        character(len=*) YSCAL ! Y scaling ) 'LOG' = Logarithmic scaling (base 10)
        ! Short-name : PGSCAL
        ! Selects the type of scaling required on each of the X and Y axes on Presentation
        ! Graphics plots. Linear scaling is selected by default initially and will also be selected
        ! by default if 'LOG' is not selected as the appropriate scale type.
        ! Logarithmic scaling can be selected on any of the line, histogram, bar-chart, 2D scatter,x/y pair and function plots, though all 3D plots use linear scaling regardless of the
        ! current selection made using IPgScaling. Similarly the X axis on histograms and
        ! the Y axis on bar-charts are always linear. For polar plots only the radius (Y) axis can
        ! use logarithmic scaling.
        !e.g. EXTERNAL FUNC
        !C select linear X scaling and logarithmic Y scaling
        !CALL IPgScaling('LIN','LOG')
        !CALL IPgNewPlot(PgFuncPlot,1,10,0,0)
        !CALL IPgUnits(0.0,1.0,10.0,1.E10)
        !CALL IPgAxes
        !CALL IPgYGraticules(0)
        !CALL IPgYScaleLeft(' ')
        !CALL IPgFunctionLine(FUNC)
        !CALL IPgTitle('Log/Linear scaling',' ')
        !PG Housekeeping/Options INTERACTER Subroutine Reference
        !2-12
    end subroutine

    
    subroutine IPgStyle3DAxes(ISTYLE,ICOL1,ICOL2)
        integer ISTYLE ! Axes fill style :
        ! Outline (0) : Outline only
        ! MixedColour (3) : Mixed colour fill
        ! Solid (4) : Solid fill
        integer ICOL1(3) ! Array of primary fill colours
        integer ICOL2(3) ! Array of secondary fill colours
        ! (only used if mixed-colour fill selected)
        ! Include : intergs.inc
        ! Defines the fill style and colour of the axes panels drawn by IPgAxes for a 3D plot. If
        ! ISTYLE is zero, 3D axes are drawn by IPgAxes as a wire frame, in the currently
        ! selected graphics colour.
        ! If ISTYLE is set to 3 or 4, each panel of the 3D axes is filled in the selected style. If a
        ! solid fill is requested, each panel is drawn in the colours specified in ICOL1. A mixed
        ! colour fill uses the pairs of colours specified in ICOL1 and ICOL2. The panel numbers
        ! are illustrated in the following diagrams :
        ! X Axis
        ! Y Axis
        ! 1
        ! 2
        ! 3
        ! X Axis
        ! X Axis
        ! Y Axis
        ! Y Axis
        ! Z Axis
        ! Z Axis
        ! 1
        ! 2
        ! 3
        ! 3D bar-chart/histogram 3D surface/scatter plot
        !e.g. INTEGER ICOL1(3),ICOL2(3)
        !:
        !CALL IPgNewPlot(PgFuncPlot,NC,NVALUE,PgLay3D,0)
        !ICOL1(1) = 240
        !ICOL1(2) = 223
        !ICOL1(3) = 223
        !CALL IPgStyle3DAxes(4,ICOL1,ICOL2)
        !CALL IPgAxes
        !CALL IGrColour('Blue')
        !CALL IPgZGraticules(1)
    end subroutine

    subroutine IPgStyleOutline(ICOL)
        integer ICOL ! Outline colour
        ! Defines the outline colour for bars and wedges on 2D histograms (IPgHistogram),2D bar-charts (IPgBarChart) and pie-charts (IPgPieChart).
        !e.g. DIMENSION YEAR(12)
        !CALL IPgNewPlot(PgHistogram,1,12,0,0)
        !CALL IPgAxes
        !CALL IPgYScaleLeft(' ')
        !CALL IPgXScale('TN')
        !CALL IPgStyleOutline(60)
        !CALL IPgHistogram(YEAR)
        !INTERACTER Subroutine Reference PG Housekeeping/Options
        !2-21
    end subroutine

    subroutine IPgUnits(XLEFT,YLOWER,XRIGHT,YUPPER)
        real XLEFT ! Lower limit of PG area X units
        real YLOWER ! Lower limit of PG area Y units
        real XRIGHT ! Upper limit of PG area X units
        real YUPPER ! Upper limit of PG area Y units
        ! Short-name : PGUNIT
        ! IPgUnits defines the plotting units (the 'user co-ordinate system') to be used when
        ! drawing in the Presentation Graphics area defined by IPgArea. These units are
        ! completely independent of those set by IGrUnits for the main graphics area. In the
        ! same way that IGrUnits defines the units for the IGrArea screen area, so
        ! IPgUnits defines the units for the area defined by IPgArea.
        ! The initial ranges are 0.0 to 1.0 on both axes. The values should be selected to
        !accommodate the minimum and maximum data values to be plotted. Some plots (e.g.
        !histograms) may not have an obvious unit for one of the axes, since the NVALUE
        !parameter supplied to IPgNewPlot is all that is required. However, if IPgXScale
        !or IPgYScaleLeft is called to add ticks, graticules or numeric values to that scale,the scaling will be based on the values supplied to this routine so choose your units
        !accordingly. For instance, if a histogram of 12 monthly values is to be plotted, a
        !sensible X range would be 1.0 to 12.0, as in the example below.
        !Obviously the X and/or Y ranges will depend heavily on the data to be plotted. The
        !functions in Group MM are therefore provided to assist in calculation of minimum and
        !maximum values for all types of PG plots.
        !Unlike the co-ordinate range for the main graphics area, the PG co-ordinate system can
        !be inverted. i.e. XLEFT can be greater than XRIGHT and YLOWER can be greater than
        !YUPPER. (Note that this does not apply to 3D surface/scatter plots which must have a
        !positive range). If a zero X or Y range is specified, an error is set and the limits for that
        !axis are reset to 0-1.
        !The units set by this routine have no effect on polar plots.
        !e.g. DIMENSION YEAR(12)
        !CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !YMAX = IRealMaxFunc1(YEAR,12,12)
        !CALL IPgUnits(1.,0.,12.,YMAX)
        !CALL IPgAxes
        !CALL IPgYScaleLeft('n')
        !CALL IPgXScale('TN')
        !CALL IPgHistogram(YEAR)
        !Errors :
        !ErrBadUnits (16) : X or Y range is zero
    end subroutine

    subroutine IPgUnitsPolar(RMAX)
        real RMAX ! Maximum radius value to plot
        ! Specifies the radius units for polar scatter/line/polyline plots. This routine has no effect
        ! on the units used by Cartesian plots.
        ! Selecting a maximum radius of zero or less resets this value to the default of 1.
        !e.g. CALL IPgNewPlot(PgScatterPlot,1,10,PgLayPolar,0)
        !CALL IPgUnitsPolar(RMAX)
        !PG Housekeeping/Options INTERACTER Subroutine Reference
        !2-22
        !Errors :
        !ErrBadUnits (16) : Maximum radius is less than or equal to 0.
    end subroutine

    subroutine IPgUnitsZ(ZMIN,ZMAX)
        real ZMIN ! Minimum Z value to plot
        real ZMAX ! Maximum Z value to plot
        ! Short-name : PGUNIZ
        ! Specifies the Z units for 3D surface/scatter/volume plots. This routine complements
        ! IPgUnits which specifies the X and Y ranges. ZMIN and ZMAX are used by
        ! IPgZScale, IPgSurf3Data, IPgSurf3Func, IPgScatterPlot3D, etc.
        ! Selecting an invalid Z range resets the limits to the default of 0-1.
        !e.g. CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !CALL IPgUnitsZ(ZMIN,ZMAX)
        !Errors :
        !ErrBadUnits (16) : Lower Z value is greater than or equal to upper Z
    end subroutine

    subroutine IPgXKeyPos(RELPOS)
        real RELPOS ! Relative position of an X-axis key (0.0 <= RELPOS <= 1.0)
        ! Sets the position of an X-axis key plotted by IPgKeyAll when the LAYOUT argument
        ! to that routine contains an 'X'. RELPOS describes the position of the key strings labels
        ! as a proportion of the distance from the edge of the PG area to the edge of the main
        ! graphics area. Reducing RELPOS places the X label closer to the PG area.
        ! If both an X axis key and an X axis label are required, the position of one or both will
        ! need to be modified (see IPgXLabelPos).
        !e.g. CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !CALL IPgArea(0.2,0.2,0.8,0.8)
        !CALL IPgBorder
        !CALL IPgXKeyPos(0.85)
        !DESCRIP(1) = 'Sunshine'
        !DESCRIP(2) = 'Cloudy'
        !CALL IPgKeyAll(DESCRIP,'X')
        !CALL IPgXLabelPos(0.6)
        !CALL IPgXLabel('Months','c')
    end subroutine

    subroutine IPgXLabelPos(RELPOS)
        real RELPOS ! Relative position of X-axis labels (0.0 <= RELPOS <= 1.0)
        ! Sets the position of X-axis labels output by IPgXLabel/IPgXLabelTop. RELPOS
        ! describes the position of X labels as a proportion of the distance from the edge of the
        ! PG area to the edge of the main graphics area. This may need to be reduced if the
        ! YLOWER or YUPPER arguments to IPgArea are increased to give a larger border
        ! between the PG plot and the edge of the main graphics area. Reducing RELPOS has the
        ! effect of placing the X label closer to the PG area.
        ! On a 3D surface/scatter/volume plot, RELPOS still controls the X label position, but
        ! the value is interpreted slightly differently because the label is rotated to match the
        ! orientation of the 3D axes. Reducing RELPOS still moves the X label closer to the 3D
        ! plot in this case.
        ! INTERACTER Subroutine Reference PG Housekeeping/Options
        ! 2-23
        !e.g. CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !CALL IPgArea(0.2,0.2,0.8,0.8)
        !CALL IPgBorder
        !CALL IPgXLabelPos(0.6)
        !CALL IPgXLabel('Months','c')
    end subroutine

    subroutine IPgXScaleAngle(TANGLE,SANGLE)
        real TANGLE ! X axis tick-mark angle
        ! (Degrees counter clockwise from horizontal on 3D surfaces/volume plots)
        ! (Degrees counter clockwise from vertical otherwise)
        real SANGLE ! X axis scale value string angle
        ! (Degrees counter clockwise from horizontal)
        ! Specifies the rotation angle for tick marks and value strings plotted by IPgXScale,IPgXText, IPgXScaleTop and IPgXTextTop. By default both are zero.
        ! TANGLE only affects the angle of tick marks on Cartesian plots. On polar plots tick
        ! marks are always radial.
        ! SANGLE is always used when a software character set is selected. If a hardware
        ! character set is selected, the ability of the individual screen or hardcopy driver to rotate
        ! value strings will be device/format dependent (see IGrCharRotate).
        !e.g. CALL IPgNewPlot(PgLinePlot,1,12,0,0)
        !CALL IPgXScaleAngle(30.,-60.)
        !CALL IPgXScale(' ')
    end subroutine

    subroutine IPgXScalePos(RELPOS)
        real RELPOS ! Relative position of the X scale (0.0 <= RELPOS <= 1.0)
        ! Short-name : PGXSCP
        ! Sets the position of X scale values/descriptions output by IPgXScale/IPgXText
        ! and IPgXScaleTop/IPgXTextTop. RELPOS describes the position of the X scale
        ! numbers or descriptions as a proportion of the distance from the edge of the PG area to
        ! the edge of the main graphics area. The default value is 0.38, but this may need to be
        ! reduced if the YLOWER or YUPPER arguments to IPgArea are increased to give a
        ! larger border between the PG plot and the edge of the main graphics area. Reducing
        ! RELPOS has the effect of placing the X scale closer to the PG area.
        ! Note:
        !   The logic of the RELPOS value is different to that used by IPgYScalePos.
        !   This routine affects 2D plots and 3D bar-charts/histograms.
        !e.g. CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !CALL IPgArea(0.2,0.2,0.8,0.8)
        !CALL IPgAxes
        !CALL IPgXScalePos(0.26)
        !CALL IPgXScale(' ')
    end subroutine

    subroutine IPgXTickLength(RELLEN)
        real RELLEN ! Relative length of X axis tick marks (default=1.0)
        ! Sets the length of X axis tick marks drawn by IPgXScale and IPgXScaleTop.
        ! Lengths are measured relative to the default length, so a value of 2.0 would give double
        ! length ticks, for example.
        !e.g. CALL IPgXTickLength(2.0)
        !CALL IPgXScale(' ')
        !PG Housekeeping/Options INTERACTER Subroutine Reference
        !2-24
    end subroutine

    subroutine IPgXTickPos(YBOTTOM,YTOP)
        real YBOTTOM ! Y position of bottom X-axis tick marks
        real YTOP ! Y position of top X-axis tick marks
        ! Sets the vertical position of X axis tick marks plotted by IPgXScale and
        ! IPgXScaleTop. By default, tick marks are plotted at 0.0 if this lies within the PG
        ! area, or at the bottom/top of the PG area otherwise. Call IPgXTickPos to override
        ! the default logic. This routine will normally be used in combination with IPgAxesXY
        ! or IPgBorder.
        ! YBOTTOM and YTOP are both expressed in terms of PG area units as set by
        ! IPgUnits. To restore the default X axis tick mark logic, specify YTOP<YBOTTOM.
        ! This routine has no effect when a polar layout is selected.
        !e.g. CALL IPgNewPlot(PgLinePlot,2,12,0,0)
        !CALL IPgUnits(0.0,0.0,1000.0,400.0)
        !CALL IPgAxesXY(500.,200.)
        !CALL IPgXTickPos(500.,500.)
        !CALL IPgXScale(' ')
    end subroutine

    subroutine IPgXUserScale(SPOINT,NPOINT)
        real SPOINT(:) ! Array of X axis scale points
        integer NPOINT ! Number of scale points in SPOINT()
        ! (<=0 to disable user scaling on this axis)
        ! Defines a user scale for the X axis, over-riding automatic scale generation. SPOINT
        ! defines the positions at which tick marks, graticules and annotation will be plotted by
        ! IPgXScale, IPgXGraticules and IPgXText. Values in SPOINT are defined in
        ! the same units as specified to IPgUnits for Cartesian plots or degrees for polar plots.
        ! NPOINT defines the number of values in the SPOINT array. If NPOINT is less than or
        ! equal to zero, user defined scaling is disabled on the X axis. This is the default. The
        ! maximum value of NPOINT is 100.
        ! Note that user defined scales are not used on logarithmic scales. For user scales on
        ! histogram X axes see IPgXUserScaleHist.
        !e.g. PARAMETER (NPOINT = 8)
        !REAL XSCALE(NPOINT)
        !DO 100 I = 1,NPOINT
        !XSCALE(I) = 2.5*FLOAT(I)
        !100 CONTINUE
        !CALL IPgUnits(0.0,0.0,20.0,1.0)
        !CALL IPgXUserScale(XSCALE,NPOINT)
        !CALL IPgXScale(' ')
    end subroutine

    subroutine IPgXUserScaleHist(IBARS,NPOINT)
        integer IBARS(:) ! Array of histogram X axis bar numbers
        integer NPOINT ! Number of scale points in IBARS()
        ! (<=0 to disable user scaling on histogram X axes)
        ! Defines a user scale for histogram X axes, over-riding automatic scale generation.
        ! IBARS defines the bar numbers at which tick marks and annotation will be plotted by
        ! IPgXScale and IPgXText. Values in IBARS are in the range 1 to NVALUE, as
        ! specified to IPgNewPlot. User defined scaling on other X axes can be selected
        ! independently via IPgXUserScale.
        ! INTERACTER Subroutine Reference PG Housekeeping/Options
        ! 2-25
        ! NPOINT defines the number of values in the IBARS array. If NPOINT is less than or
        ! equal to zero, user defined scaling is disabled on histogram X axes. This is the default.
        ! The maximum value of NPOINT is 100.
        !e.g. PARAMETER (NPOINT = 8)
        !INTEGER IBARS(NPOINT)
        !C label every third bar
        !DO 100 I = 1,NPOINT
        !IBARS(I) = I*3
        !100 CONTINUE
        !CALL IPgNewPlot(PgHistogram,1,25,0,0)
        !CALL IPgAxes()
        !CALL IPgXUserScaleHist(IBARS,NPOINT)
        !CALL IPgXScale(' ')
    end subroutine

    subroutine IPgYLabelPos(RELPOS)
        real RELPOS ! Relative position of Y-axis labels (0.0 <= RELPOS <= 1.0)
        ! Sets the position of Y-axis labels output by IPgYLabelLeft/IPgYLabelRight.
        ! RELPOS describes the position of Y labels as a proportion of the distance from the
        ! edge of the PG area to the edge of the main graphics area. This may need to be reduced
        ! if the XLEFT or XRIGHT arguments to IPgArea are increased to give a larger border
        ! between the PG plot and the edge of the main graphics area. Reducing RELPOS has the
        ! effect of placing the Y label closer to the PG area.
        ! On a 3D surface/scatter/volume plot, the RELPOS parameter still controls the Y label
        ! position, but the value is interpreted slightly differently because the label is rotated to
        ! match the orientation of the 3D axes. Reducing RELPOS still moves the Y label closer
        ! to the 3D plot in this case.
        !e.g. CALL IPgNewPlot(PgLinePlot,2,12,0,0)
        !CALL IPgArea(0.2,0.2,0.8,0.8)
        !CALL IPgAxes
        !CALL IPgYLabelPos(0.7)
        !CALL IPgYLabel('Y axis','9c')
    end subroutine

    subroutine IPgYScalePos(RELPOS)
        real RELPOS ! Relative position of the Y scale, as a multiple of the length of
        ! a Y axis tick mark (default = 1.5)
        ! Sets the position of Y scale values/descriptions output by IPgYScaleLeft,IPgYTextLeft, IPgYScaleRight and IPgYTextright. RELPOS describes
        ! the position of the Y scale numbers or descriptions as a multiple of the length of a
        ! normal (i.e. non-log scale) Y-axis tick mark. The default value is 1.5. Increasing this
        ! value will move Y scale values away from the Y axis.
        ! Note:
        !   The logic of the RELPOS value is different to that used by IPgXScalePos.
        !   This routine affects 2D plots and 3D bar-charts/histograms.
        !e.g. CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !CALL IPgAxes
        !C Move Y axis values further away
        !CALL IPgYScalePos(2.0)
        !CALL IPgYScale(' ')
        !PG Housekeeping/Options INTERACTER Subroutine Reference
        !2-26
    end subroutine

    subroutine IPgYScaleAngle(TANGLE,SANGLE)
        real TANGLE ! Y axis tick-mark angle ) Degrees counter-clockwise
        real SANGLE ! Y axis scale value string angle ) from horizontal
        ! Specifies the rotation angle for tick marks and value strings plotted by
        ! IPgYScaleLeft/IPgYTextLeft and IPgYScaleRight/IPgYTextRight.
        ! By default both angles are zero.
        ! SANGLE is always used when a software character set is selected. If a hardware
        ! character set is selected, the ability of the individual screen or hardcopy driver to rotate
        ! value strings will be device/format dependent (see IGrCharRotate).
        !e.g. CALL IPgNewPlot(PgLinePlot,1,12,0,0)
        !CALL IPgYScaleAngle(0.,90.)
        !CALL IPgYScaleLeft(' ')
    end subroutine

    subroutine IPgYTickLength(RELLEN)
        real RELLEN ! Relative length of Y axis tick marks (default=1.0)
        ! Sets the length of Y axis tick marks drawn by IPgYScaleLeft and
        ! IPgYScaleRight. Lengths are measured relative to the default length, so a value of
        ! 2.0 would give double length ticks, for example.
        !e.g. CALL IPgYTickLength(2.0)
        !CALL IPgYScaleLeft(' ')
    end subroutine

    subroutine IPgYTickPos(XLEFT,XRIGHT)
        real XLEFT ! X position of left Y-axis tick marks
        real XRIGHT ! X position of right Y-axis tick marks
        ! Sets the horizontal position of Y axis tick marks plotted by IPgYScaleLeft and
        ! IPgYScaleRight. By default, tick marks are plotted at 0.0 if this lies within the PG
        ! area, or at the left/right of the PG area otherwise. Call IPgYTickPos to override the
        ! default logic. This routine will normally be used with IPgAxesXY or IPgBorder.
        ! XLEFT and XRIGHT are both expressed in terms of PG area units as set by
        ! IPgUnits. To restore the default Y axis tick mark logic, specify XRIGHT<XLEFT.
        ! This routine has no effect when a polar layout is selected.
        !e.g. CALL IPgNewPlot(PgLinePlot,2,12,0,0)
        !CALL IPgUnits(0.0,0.0,1000.0,400.0)
        !CALL IPgAxesXY(500.,200.)
        !CALL IPgYTickPos(200.,200.)
        !CALL IPgYScaleLeft(' ')
    end subroutine

    subroutine IPgYUserScale(SPOINT,NPOINT)
        real SPOINT(:) ! Array of Y axis scale points
        integer NPOINT ! Number of scale points in SPOINT()
        ! (<=0 to disable user scaling on this axis)
        ! Defines a user scale for the Y axis, over-riding automatic scale generation. SPOINT
        ! defines the positions at which tick marks, graticules and annotation will be plotted by
        ! IPgYScaleLeft, IPgYScaleRight, IPgYGraticules, IPgYTextLeft and
        ! IPgYTextRight. Values in SPOINT are defined in the same units as specified to
        ! IPgUnits or IPgUnitsPolar.
        ! INTERACTER Subroutine Reference PG Housekeeping/Options
        ! 2-27
        ! NPOINT defines the number of values in SPOINT(). If NPOINT<=0, user defined
        ! scaling is disabled on the Y axis. This is the default. NPOINT must be <=100.
        ! Note that user defined scales are not used on logarithmic scales. For user scales on barchart
        ! Y axes see IPgYUserScaleBar.
        !e.g. PARAMETER (NPOINT = 8)
        !REAL YSCALE(NPOINT)
        !DO 100 i = 1,NPOINT
        !YSCALE(i) = 2.5*FLOAT(i)
        !100 CONTINUE
        !CALL IPgUnits(0.0,0.0,XMAX,20.0)
        !CALL IPgYUserScale(YSCALE,NPOINT)
        !CALL IPgYScaleLeft(' ')
        !CALL IPgYGraticules(1)
    end subroutine

    subroutine IPgYUserScaleBar(IBARS,NPOINT)
        integer IBARS(:) ! Array of bar-chart Y axis bar numbers
        integer NPOINT ! Number of scale points in IBARS()
        ! (<=0 to disable user scaling on bar-chart Y axes)
        ! Defines a user scale for bar-chart Y axes, over-riding automatic scale generation.
        ! IBARS defines the bar numbers at which tick marks and annotation will be plotted by
        ! IPgYScaleLeft and IPgYTextLeft. Values in IBARS are in the range 1 to
        ! NVALUE, as specified to IPgNewPlot. User defined scaling on other Y axes can be
        ! selected independently via IPgYUserScale.
        ! NPOINT defines the number of values in the IBARS array. If NPOINT is less than or
        ! equal to zero, user defined scaling is disabled on bar-chart Y axes. This is the default.
        ! The maximum value of NPOINT is 100.
        !e.g. PARAMETER (NPOINT = 8)
        !INTEGER IBARS(NPOINT)
        !C label every third bar
        !DO 100 I = 1,NPOINT
        !IBARS(I) = I*3
        !100 CONTINUE
        !CALL IPgNewPlot(PgBarChart,1,25,0,0)
        !CALL IPgAxes()
        !CALL IPgYUserScaleBar(IBARS,NPOINT)
        !CALL IPgYScaleLeft(' ')
    end subroutine

    subroutine IPgZLabelPos(RELPOS)
        real RELPOS ! Relative position of Z-axis labels (0.0 <= RELPOS <= 1.0)
        ! Sets the position of Z-axis labels output by IPgZLabelLeft/IPgZLabelRight
        ! on a 3D surface/scatter/volume plot. RELPOS describes the position of Z labels as a
        ! proportion of the distance from the edge of the PG area to the edge of the main graphics
        ! area. The default value is 0.8, but this may need to be reduced if the XLEFT or
        ! XRIGHT arguments to IPgArea are increased to give a larger border between the PG
        ! plot and the edge of the main graphics area. Reducing RELPOS has the effect of placing
        ! the Z label closer to the PG area.
    end subroutine

    subroutine IPgZScaleAngle(TANGLE,SANGLE)
        real TANGLE ! Z axis tick-mark angle ) Degrees counter-clockwise
        real SANGLE ! Z axis scale value string angle ) from horizontal
        ! Specifies the rotation angle for tick marks and value strings plotted by IPgZScale
        ! and IPgZText.By default both angles are zero.
        ! PG Housekeeping/Options INTERACTER Subroutine Reference
        ! 2-28
        ! SANGLE is always used when a software character set is selected. If a hardware
        ! character set is selected, the ability of the individual screen or hardcopy driver to rotate
        ! value strings will be device/format dependent (see IGrCharRotate).
        !e.g. CALL IPgNewPlot(PgZarrayPlot,NC,NVALUE,PgLay3D,0)
        !CALL IPgZScaleAngle(0.,30.)
        !CALL IPgZScale(' ')
    end subroutine

    subroutine IPgZTickLength(RELLEN)
        real RELLEN ! Relative length of Z axis tick marks (default=1.0)
        ! Sets the length of Z axis tick marks drawn by IPgZScale. Lengths are measured
        ! relative to the default length, so a value of 2.0 would give double length ticks.
        !e.g. CALL IPgZTickLength(2.0)
        !CALL IPgZScale(' ')
    end subroutine

    subroutine IPgZUserScale(SPOINT,NPOINT)
        real SPOINT(*) ! Array of Z axis scale points
        integer NPOINT ! Number of scale points in SPOINT()
        ! (<=0 to disable user scaling on this axis)
        ! Defines a user scale for the Z axis, over-riding automatic scale generation. SPOINT
        ! defines the positions at which tick marks and annotation will be plotted by
        ! IPgZScale. Values in SPOINT are defined in the same units as specified to
        ! IPgUnitsZ.
        ! NPOINT defines the number of values in the SPOINT array. If NPOINT is less than or
        ! equal to zero, user defined scaling is disabled on the Z axis. This is the default. The
        ! maximum value of NPOINT is 100.
        !e.g. PARAMETER (NPOINT = 5)
        !REAL ZSCALE(NPOINT)
        !DO 100 I = 1,NPOINT
        !ZSCALE(I) = 4.0*FLOAT(I)
        !100 CONTINUE
        !CALL IPgUnitsZ(0.0,20.0)
        !CALL IPgZUserScale(ZSCALE,NPOINT)
        !CALL IPgZScale(' ')
        !INTERACTER Subroutine Reference PG Axes/Annotations
        !2-29
        !2.2 Group PG(2) : Axes Plotting/Annotation
        !All of the routines in this group are concerned with drawing and annotating PG plot
        !axes. These are general purpose routines designed to be used with all of the various plot
        !types available in the PG(3) and PG(4) groups. Calling any routine in this group will
        !cause some sort of output to the selected graphics device.
        !IPgAxes will normally be called before drawing a graph and simply draws axis lines.
        !IPgAxesXY does the same job, but allowing the origin to be specified. IPgBorder
        !may be used as an alternative and draws a border round the PG area.
        !IPgXGraticules and IPgYGraticules generate X/Y graticules (scale lines).
        !IPgZGraticules does the same for the Z axis, on 3D surface/scatter/volume plots.
        !IPgKeyAll and IPgKeySingle can be used to generate a key. IPgKeyAll is a
        !'quick and simple' routine, whereas IPgKeySingle provides positional control over
        !key placement.
        !IPgTitle, IPgXLabel, IPgXLabelTop, IPgYLabelLeft and
        !IPgYLabelRight all perform the same basic task of adding titles or labels above,below or beside a PG plot. IPgZLabelLeft and IPgZLabelRight add labels to
        !3D surface/scatter/volume plot Z axes.
        !IPgXScale, IPgXScaleTop, IPgYScaleLeft, IPgYScaleRight and
        !IPgZScale add numeric scales to the X, Y and Z axes. Alternatively, scales can be
        !annotated with user-supplied text via the equivalent routines IPgXText,IPgXTextTop, IPgYTextLeft, IPgYTextRight and IPgZText. User defined
        !scales can be set up for these routines by calling IPgXUserScale,IPgYUserScale or IPgZUserScale in the PG(1) group.
    end subroutine

    subroutine IPgAxes
        ! Short-name : PGAXES
        ! Draws a set of axes in the current Presentation Graphics area. The axes are drawn in the
        ! currently selected graphics colour. The precise action depends on whether
        ! IPgNewPlot specified a 2D Cartesian, 2D polar or 3D layout.
        ! If a 2D layout is required, X and Y axis lines are drawn. The PG area units, as defined
        ! by IPgUnits, are used to determine where to place these axis lines. If the origin (0,0)
        ! occurs within the PG area, the lines are drawn through this point. Otherwise, the axis
        ! lines are drawn at the extreme left or bottom of the PG area.
        ! If a 2D polar layout is required the largest circle which will fit within the PG area is
        ! drawn. Crossed horizontal and vertical lines through the centre of the circle are also
        ! drawn.
        ! If a 3D layout is required, a cut-away 'box' is drawn to represent the X, Y and Z axes.
        ! For a bar-chart or histogram, the resulting axes frame is drawn so as to occupy the
        ! whole of the PG area. For a 3D surface/scatter/volume plot the axes will depend on the
        ! elevation and rotation angles set by IPgElevation and IPgRotation. In the
        ! latter case, the shape of the axes will also depend on whether a variable grid size has
        ! been selected in the call to IPgNewPlot. 3D axes are drawn in the style defined by
        ! IPgStyle3DAxes.
        ! See also IPgAxesXY which allows the origin to be specified on 2D Cartesian plots.
        ! PG Axis/Annotation INTERACTER Subroutine Reference
        ! 2-30
        ! Note that IPgAxes does not mark the axes with a scale. Call IPgXScale,IPgXScaleTop, IPgYScaleLeft, IPgYScaleRight and IPgZScale to do
        ! this, as required.
        !e.g. CALL IPgNewPlot(PgFuncPlot,1,50,0,0)
        !CALL IPgUnits(0.0,-1.0,10.0,1.0)
        !CALL IGrColour('W')
        !CALL IPgAxes
        !CALL IPgYScaleLeft(' ')
        !CALL IPgXScale(' ')
        !CALL IPgTitle('Sine Wave',' ')
        !CALL IPgFunctionLine(SIN)
    end subroutine

    subroutine IPgAxesXY(XORIGIN,YORIGIN)
        real XORIGIN ! X origin ) In same units as
        real YORIGIN ! Y origin ) specified to IPgUnits
        ! Draws a set of axes in the current Presentation Graphics area in exactly the same
        ! manner as IPgAxes, except that the origin can be specified on 2D Cartesian plots.
        ! Hence calling IPgAxes is directly equivalent to calling IPgAxesXY(0.0,0.0).
        !e.g. CALL IPgNewPlot(PgLinePlot,1,50,0,0)
        !XMIN = -1.0
        !YMIN = -1.0
        !CALL IPgUnits(XMIN,YMIN,10.0,1.0)
        !C place axes at bottom/left of plot
        !CALL IPgAxesXY(XMIN,YMIN)
    end subroutine

    subroutine IPgBorder
        ! Short-name : PGBORD
        ! Draws a border around the edge of the current PG area in the same way that
        ! IGrBorder draws a border round the main graphics area. IPgBorder can also be
        ! used as an alternative to IPgAxes where the x and y axes lie at the bottom and left
        ! limits of the PG area, or where dual scale graphs are to be drawn.
        !e.g. CALL IPgNewPlot(PgFuncPlot,1,50,0,0)
        !CALL IPgUnits(0.0,0.0,10.0,1.0)
        !CALL IPgBorder
        !INTERACTER Subroutine Reference PG Axes/Annotations
        !2-31
    end subroutine

    subroutine IPgKeyAll(DESCR,LAYOUT)
        character(len=*) DESCR(*) ! Array containing descriptions of each data set
        character(len=*) LAYOUT ! Required layout :
        ! For non-pie charts, one of:
        ! V : Vertical, to right of plot
        ! 9 : Rotated through 90 to right of plot
        ! X : Single line below X axis
        ! And any of :
        ! B : Border around key
        ! R : Reverse order
        ! (default is top-to-bottom or left-to-right)
        ! For line plots & polyline plots only :
        ! E : Add descriptions at end of lines
        ! For pie charts :
        ! P : Add integer percentage values to descriptions
        ! R : Add real percentage values to descriptions
        ! (default is descriptions only)
        ! Short-name : PGKEY
        ! Adds a key to the current PG display describing all the data sets. Pie chart keys are
        ! treated as a special case and are therefore documented separately.
        ! DESCR should be declared as an array of character strings in your calling program,describing each of the data sets on the current PG display.
        ! Whatever colours or line styles are used for each key, the current selections will remain
        ! unchanged on exit. See also IPgKeySingle which draws a key for a single data set.
        ! The exact action taken by IPgKeyAll depends on the currently selected plot type:
        ! Pie Charts :
        ! Descriptions are plotted either at the edge of the corresponding wedge or at the end of a
        ! 'spider tag', depending on the LAYOUT parameter specified to IPgNewPlot. A spider
        ! tag is a line which joins the centre of a wedge to the corresponding description,allowing those descriptions to be moved further from the pie itself. If
        ! PgLayVariable was also specified to IPgNewPlot in the LAYOUT argument, then
        ! spider tags will vary in length with the result that descriptions will be vertically aligned
        ! to the left and right of the pie.
        ! If the LAYOUT argument to IPgKeyAll contains 'P' or 'R', each description will end
        ! or begin with a percentage value showing the size of each wedge. Descriptions to the
        ! left of the centre of the pie have the percentage at the end of the description and those
        ! to the right have it at the beginning. Percentages are shown as an integer if 'P' is
        ! specified or as a real (with one decimal place) if 'R' is specified.
        ! Pie chart description strings are plotted in the currently selected size and colour. If
        ! selected, spider tags are drawn in the current line style and the last but one colour. i.e.
        ! Two consecutive calls to IGrColourN before IPgKeyAll would set the colours for
        ! spider tags and then descriptions.
        ! PG Axis/Annotation INTERACTER Subroutine Reference
        ! 2-32
        ! Graduated Surfaces Plots :
        ! When a graduated colour surface plot is requested, a graduated colour bar is plotted
        ! beside or below the PG area. The bar is graduated in the same colours as the surface.
        ! DESCR should contain two strings corresponding to the minimum and maximum Z
        ! heights. These will be plotted at either end of the string.
        ! By default, the descriptions are plotted below/above the graduated bar, to the right of
        ! the PG area. A 'V' or a '9' in the LAYOUT argument causes the strings to be plotted
        ! beside the bar, either vertically or rotated through 90 degrees. An X moves the key
        ! below the PG area. By default the graduated bar is plotted with the minimum Z
        ! colour/description at the bottom or left of the graduated bar. An 'R' in LAYOUT reverses
        ! this logic. A 'B' adds a border, regardless of key location.
        ! Other Plot Types :
        ! The style of presentation, as specified to IPgStyle, is used to draw a key for each
        ! data set. This will be a small rectangle for a bar chart or histogram, filled appropriately.
        ! For scatter plots and line/x-y plots which use markers, a marker is plotted. For function
        ! plots or line/x-y plots without markers, a short line is drawn. In all cases, the colour
        ! specified to IPgStyle is used.
        ! By default, the key is plotted as a list to the right of the PG area, with the description of
        ! each data set plotted horizontally to the right of the key. LAYOUT can be used to
        ! modify the layout/position in 3 mutually exclusive ways
        !   A 'V' plots the keys side-by-side to the right of the PG area with the description
        ! strings printed vertically below.
        !   A '9' also plots the keys side-by-side to the right of the PG area, but with the
        ! description strings rotated through 90. This is more appropriate for relatively long
        ! descriptive strings.
        !   An 'X' plots the description strings horizontally on a single line below the X axis, at
        ! the bottom of the plot. The relative position of this key can be set by
        ! IPgXKeyPos.
        ! Two other options can also be specified in LAYOUT, if required:
        !   A 'B' requests a border around the complete key + descriptions.
        !   An 'R' reverses the display order. By default, descriptions will be displayed with the
        ! lowest numbered element of the DESCR array at the top or left of the key. Reverse
        ! key ordering is most appropriate for stacked histograms/line-plots.
        ! The actual size of each key item depends on the current character size, since it will be
        ! drawn to be in keeping with the appearance of the descriptive text. This will depend on
        ! whether hardware or software text is in use (as selected by IGrCharSet).
        ! If dual scales are being used, IPgYScaleRight and IPgYLabelRight will write
        ! to the same screen area as would be used by IPgKeyAll, to the right of the PG area.
        ! In this case, IPgKeySingle should be used to draw keys at an alternative location or
        ! an X-axis key should be selected.
        ! On line plots and X/Y polyline plots an alternative option is available which overrides
        ! the other LAYOUT settings:
        ! INTERACTER Subroutine Reference PG Axes/Annotations
        ! 2-33
        !   An 'E' indicates that the descriptions should be plotted at the end of each line. The
        ! strings are displayed left justified and horizontally, using the current rotation, font
        ! and colour.
        !e.g. DIMENSION YEAR1(12),YEAR2(12)
        !CHARACTER*10 DESCRP(2)
        !DATA DESCRP/'1998 Sales','1999 Sales'/
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !C only use 60% of width of main graphics area but 80% of height
        !CALL IPgArea(0.1,0.1,0.7,0.9)
        !C plot 2 sets of monthly data,on a line graph with a key
        !CALL IPgNewPlot(PgLinePlot,2,12,0,0)
        !CALL IPgUnits(1.0,0.,12.0,10000.)
        !C select numeric line markers in different colours
        !CALL IPgStyle(1,0,1,0,3,2)
        !CALL IPgStyle(2,0,1,0,2,1)
        !CALL IPgAxes
        !CALL IPgLinePlot(YEAR1)
        !CALL IPgLinePlot(YEAR2)
        !CALL IPgTitle('Sales 98/99',' ')
        !C display a rotated key at the right with a border
        !CALL IPgKeyAll(DESCRP,'9B')
    end subroutine

    subroutine IPgKeySingle(ISET,XPOS,YPOS,DESCR)
        integer ISET ! Data set number
        real XPOS ! X position in units specified by IGrUnits
        real YPOS ! Y position in units specified by IGrUnits
        character(len=*) DESCR ! Description of data in data set ISET
        ! Short-name : PGKEY1
        ! Draws a key at the specified position for a single data set and prints the supplied
        ! description beside or below it. The data set number is a value in the range 1 to the
        ! number of data sets specified to IPgNewPlot. The style of presentation of this data
        ! set, as specified to IPgStyle, is then used to draw a key. This will be a small
        ! rectangle for a bar chart, histogram or table, filled appropriately. For scatter plots and
        ! line/x-y plots which use markers, a marker is plotted. For function plots or line/x-y
        ! plots without markers, a short line is drawn. In all cases, the colour specified to
        ! IPgStyle is used.
        ! The position of the key item is specified as (XPOS,YPOS). This co-ordinate pair is
        ! specified in terms of the main graphics area rather than the PG area, allowing a key to
        ! be placed with complete freedom. Consequently XPOS and YPOS must be specified in
        ! terms of the units supplied to IGrUnits rather than IPgUnits.
        ! The actual size of the key item depends on the current character size, since it will be
        ! drawn to be in keeping with the appearance of the descriptive text. This will depend on
        ! whether hardware or software text is in use (as selected by IGrCharSet).
        ! The description of the data set is either placed horizontally, to the right of the key or
        ! vertically below it. This depends on the currently selected text direction, as set by
        ! IGrCharDirection. The string will also be rotated in the appropriate direction as
        ! set by IGrCharRotate, provided this is set to one of the 4 main compass points (i.e.
        ! one of 0, 90, 180 or 270).
        ! Whatever colours and/or line styles are used for this key, the current selections will
        ! remain unchanged on exit. See also IPgKeyAll which draws keys for all the data sets
        ! on the current display in one call, with automatic position selection.
        ! PG Axis/Annotation INTERACTER Subroutine Reference
        ! 2-34
        !e.g. DIMENSION YEAR1(12),YEAR2(12)
        !CALL IGrUnits(0.0,0.0,100.0,100.0)
        !C only use 60% of width of main graphics area but 80% of height
        !CALL IPgArea(0.1,0.1,0.7,0.9)
        !C plot 2 sets of monthly data,on a line graph with a key
        !CALL IPgNewPlot(PgLinePlot,2,12,0,0)
        !CALL IPgUnits(1.0,0.,12.0,10000.)
        !C select numeric line markers in different colours
        !CALL IPgStyle(1,0,1,0,3,2)
        !CALL IPgStyle(2,0,1,0,2,1)
        !CALL IPgAxes
        !CALL IPgLinePlot(YEAR1)
        !CALL IPgLinePlot(YEAR2)
        !CALL IPgTitle('Sales 98/99',' ')
        !C set text direction to vertical and add a key at the right
        !CALL IGrCharDirection('V')
        !CALL IPgKeySingle(1,80.,80.,'1998 Sales')
        !CALL IPgKeySingle(2,90.,80.,'1999 Sales')
    end subroutine

    subroutine IPgTitle(TITLE,JUSTIF)
        character(len=*) TITLE ! Title string for current PG display
        character(len=*) JUSTIF ! Text justification
        ! = L : Starting at left edge above PG area
        ! = C : Centred above PG area (default)
        ! = R : Ending at right edge above PG area
        ! Short-name : PGTITL
        ! Prints a title above the Presentation Graphics area. The horizontal position of the title is
        ! determined by the justification parameter. The currently selected graphics character set
        ! and size (as set by IGrCharSet and IGrCharSize) are used to display the title
        ! string. The vertical position is exactly half-way between the top of the PG and main
        ! graphics areas.
        ! If more than one heading is required, IPgTitle could be called with 'L' then 'R'
        ! justification parameters to place strings at both the left and right limits of the area above
        ! the PG area. To add similar text to the X and Y axes see the corresponding routines
        ! IPgXLabel, IPgXLabelTop, IPgYLabelLeft and IPgYLabelRight. Note
        ! that IPgXLabelTop is almost identical to IPgTitle, except that it places the
        ! descriptive string slightly higher (i.e. nearer to the edge of the main graphics area)
        ! leaving more room for a scale to be plotted by IPgXScaleTop or IPgXTextTop.
        ! If the supplied title is too wide to fit above the PG area, the character width will be
        ! adjusted accordingly. The currently selected graphics character size and justification
        ! mode are restored on exit.
        !e.g. CALL IPgTitle('ISS Ltd.','L')
        !CALL IPgTitle('1999 Sales','R')
        !CALL IPgLinePlot(SALES)
        !INTERACTER Subroutine Reference PG Axes/Annotations
        !2-35
    end subroutine

    subroutine IPgXGraticules(LTYPE)
        integer LTYPE ! 0 : Solid lines (default) )
        ! = 1 : Dotted lines ) As for
        ! = 2 : Dashed lines ) IGrLineType
        ! = 3 : Dot/dashed lines )
        ! = 4 : Dot-dot/dashed lines )
        ! = 5 : Long/short dashes )
        ! = 6 : Short dashes )
        ! Short-name : PGXGRA
        ! Include : intergs.inc
        ! Draws graticules (background scale lines) vertically across the PG area, using lines of
        ! the specified type. On polar plots radial lines are drawn. Dotted lines are recommended
        ! since they are least likely to obscure the data being plotted.
        ! Graticules are drawn at regular intervals along the X axis, at the same positions as the
        ! ticks which are plotted by the IPgXScale scale routine. In fact, graticules are directly
        ! equivalent to ticks except they extend across the full height of the PG area. Optionally,graticules can be drawn at user defined positions specified via IPgXUserScale.
        ! Obviously, IPgXGraticules should be called before plotting any data, otherwise
        ! the graticules will be drawn over the top of the plotted data.
        ! On displays which do not support dotted lines, graticules will be drawn as solid lines.
        ! See IGrLineType or call the IF group function InfoGrScreen to check for
        ! broken line support.
        !e.g. CALL IPgNewPlot(PgBarChart,2,12,0,0)
        !CALL IPgUnits(0.,1.,10000.,12.)
        !CALL IPgAxes
        !CALL IPgXGraticules(1)
        !CALL IPgXScale('TN')
    end subroutine

    subroutine IPgXLabel(XLABEL,JUSTIF)
        character(len=*) XLABEL ! X axis label string
        character(len=*) JUSTIF ! Text justification
        ! = L : Starting at left edge below PG area
        ! = C : Centred below PG area (default)
        ! = R : Ending at right edge below PG area
        ! Short-name : PGXLBL
        ! Prints a label for the bottom X axis, below the Presentation Graphics area. The
        ! horizontal position of the label is determined by the justification parameter. The
        ! currently selected graphics character set and size (as set by IGrCharSet and
        ! IGrCharSize) are used to display the label string. The vertical position can be
        ! changed by IPgXLabelPos. A scale can be plotted separately using IPgXScale
        ! and/or IPgXText.
        ! If more than one X axis label is required, IPgXLabel could be called with 'L' then 'R'
        ! justification parameters to place strings at both the left and right limits of the area
        ! below the PG area. To add similar text to the Y axes see the corresponding routines
        ! IPgYLabelLeft and IPgYLabelRight. To place a label above the PG area use
        ! IPgXLabelTop.
        ! PG Axis/Annotation INTERACTER Subroutine Reference
        ! 2-36
        ! If the supplied label is too wide to fit below the PG area, the character width will be
        ! adjusted accordingly. The currently selected graphics character size and justification
        ! mode are restored on exit.
        ! On a 3D surface/scatter/volume plot, the label is plotted parallel to the lower X axis.
        ! The label will therefore be rotated to match the orientation of the 3D axes. In this case
        ! the JUSTIF argument determines which end of the X axis the label is plotted relative
        ! to.
        !e.g. CALL IPgXLabel('Age','R')
        !CALL IPgYLabelLeft('Average Height','T')
        !CALL IPgHistogram(HEIGHT)
    end subroutine

    subroutine IPgXLabelTop(XLABEL,JUSTIF)
        character(len=*) XLABEL ! X axis label string
        character(len=*) JUSTIF ! Text justification
        ! = L : Starting at left edge above PG area
        ! = C : Centred above PG area (default)
        ! = R : Ending at right edge above PG area
        ! Prints a label for the top X axis, above the Presentation Graphics area. A scale can be
        ! plotted separately using IPgXScaleTop and/or IPgXTextTop. On a 3D surface,scatter or volume plot, the label is plotted parallel to the upper X axis. In all other
        ! respects, this routine is identical to IPgXLabel which places the label below the PG
        ! area.
    end subroutine

    subroutine IPgXScale(SCALE)
        character(len=*) SCALE ! Type of scale required (combination of T/I/N)
        ! = T : Ticks outside the axes
        ! = I : Ticks inside the axes
        ! = N : Numbering
        ! = blank : Ticks outside and numbering
        ! Short-name : PGXSCL
        ! Adds a scale to the bottom X axis of a Presentation Graphics display, with the option of
        ! selecting ticks and/or numeric values. This routine will normally be used in
        ! combination with the IPgAxes or IPgBorder routines though none are obligatory.
        ! Ticks can be placed inside (above) the axis if required, but will be placed outside
        ! (below) by default.
        ! By default, scaling intervals are calculated automatically and will normally be a
        ! multiple of 2, 5 or 10. Slightly different rules are applied on 3D surface/volume plots.
        ! The default interval for polar plots is 30 degrees. Alternatively scale points can be
        ! specified via IPgXUserScale.
        ! Ticks and/or numeric labels are added at the automatically generated or user-defined
        ! intervals on the X axis, according to the SCALE parameter. Note that SCALE can be
        ! any string you like. IPgXScale simply checks to see whether any of the key letters
        ! T/N/I (upper or lower case as usual) occur in that string. If the string is completely
        ! blank, ticks outside the axis and numeric labels are assumed. The vertical position of
        ! the scale is calculated automatically, but can be adjusted using IPgXScalePos.
        ! By default, ticks are drawn vertically and value strings are plotted horizontally. The
        ! angle of both can be changed independently, by calling IPgXScaleAngle.
        ! INTERACTER Subroutine Reference PG Axes/Annotations
        ! 2-37
        ! By default, on Cartesian plots, ticks are drawn at a vertical position (in PG units) of 0.0,if this lies within the PG area, or at the bottom of the PG area otherwise. This default
        ! logic can be overridden by calling IPgXTickPos. On polar plots tick marks are
        ! drawn radially and placed at the maximum radius. Tick mark length can be set by
        ! IPgXTickLength.
        ! Numeric labels are plotted using the current character set and character size. However,if the labels would overlap as a result, character size is adjusted accordingly. The
        ! currently selected graphics character size is restored on exit. The number of decimal
        ! places in E/F format values is determined automatically or can be defined explicitly by
        ! calling IPgDecimalPlaces.
        ! To label the X scale with text rather than numbers, see the alternative routine
        ! IPgXText.
        ! Calling IPgXScale has no effect if the current graph type is a table.
        !e.g. CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !CALL IPgUnits(1.,0.,12.,10000.)
        !CALL IPgAxes
        !C add ticks only to inside of X axis
        !CALL IPgXScale('I')
    end subroutine

    subroutine IPgXScaleTop(SCALE)
        character(len=*) SCALE ! Type of scale required (T/I/N, as for IPgXScale)
        ! Adds a scale to the top X axis of a Presentation Graphics display, displaying scale
        ! values above the PG area. It is equivalent to the IPgXScale routine which places the
        ! scale below the PG area. This routine will normally be used in combination with the
        ! IPgAxesXY or IPgBorder routines, though none are obligatory. Ticks can be
        ! placed inside (below) the axis if required, but will be placed outside (above) by default.
        ! By default, ticks are drawn at a vertical position (in PG units) of 0.0, if this lies within
        ! the PG area, or at the top of the PG area otherwise. This default logic can be overridden
        ! by calling IPgXTickPos.
        ! To label the top X scale with text rather than numbers, see the alternative routine
        ! IPgXTextTop. To specify a user-defined scale for the X axis, see
        ! IPgXUserScale.
        ! This routine has the same effect as IPgXScale for polar plots.
        ! Calling IPgXScaleTop has no effect if the current graph type is a table.
    end subroutine

    subroutine IPgXText(DESCR,NDESC)
        integer NDESC ! Number of supplied descriptions
        character(len=*) DESCR(NDESC) ! Descriptions of scale points
        ! Short-name : PGXTXT
        ! All plot types except tables:
        ! Labels the bottom X axis scale using the supplied text descriptions, instead of numeric
        ! values as would otherwise be added by the alternative IPgXScale routine. Trailing
        ! spaces are not stripped. This routine might be used when plotting monthly data to
        ! annotate the X scale with the actual month names instead of the numbers 1 to 12.
        ! PG Axis/Annotation INTERACTER Subroutine Reference
        ! 2-38
        ! Scaling intervals are calculated automatically by default, using the same algorithm as
        ! IPgXScale. Alternatively, scale points are user definable via IPgXUserScale.
        ! The supplied descriptions are placed at each of the scale points which would otherwise
        ! have been labelled numerically by IPgXScale. In fact, the two routines can be called
        ! in combination, if ticks are also required, as in the example below. The vertical position
        ! of the scale point descriptions is calculated automatically, but can be adjusted on
        ! Cartesian plots using IPgXScalePos.
        ! By default, value strings are plotted horizontally, but this can be changed by calling
        ! IPgXScaleAngle.
        ! Scale point labels are plotted using the current character set and character size.
        ! However, if the labels would overlap as a result, character size is adjusted accordingly.
        ! The currently selected graphics character size is restored on exit.
        ! Tables:
        ! Adds column labels to the bottom of the table using the supplied text descriptions. A
        ! box is drawn around each label using the currently selected graphics colour. If
        ! PgLayFill was specified in the LAYOUT argument to IPgNewPlot then this box is
        ! filled using a solid fill in the previously selected colour.
        ! The size of box around each label is calculated from the number of columns specified
        ! to IPgNewPlot and the current character size. A border of 1/4 of a character above
        ! and below the labels is allowed to avoid a cramped appearance. If the current character
        ! size would cause labels to extend outside the main graphics area then the character size
        ! is reduced accordingly. The character size is also reduced if the labels would be too
        ! long to fit within a column. A border of 1/2 a character is allowed when calculating the
        ! maximum character width.
        ! Labels are output centred within each column, using unrotated, horizontal text.
        ! The currently selected graphics character size and justification are restored on exit.
        !e.g. CHARACTER*3 MONTH(12)
        !DATA MONTH/'Jan','Feb','Mar','Apr','May','Jun',1 'Jul','Aug','Sep','Oct','Nov','Dec'/
        !CALL IPgNewPlot(PgHistogram,1,12,0,0)
        !CALL IPgUnits(1.,0.,12.,10000.)
        !CALL IPgAxes
        !C add ticks only to inside of X axis
        !CALL IPgXScale('T')
        !C and descriptions ..
        !CALL IPgXText(MONTH,12)
        !CALL IPgHistogram(SALES)
    end subroutine

    subroutine IPgXTextTop(DESCR,NDESC)
        integer NDESC ! Number of supplied descriptions
        character(len=*) DESCR(NDESC) ! Descriptions of scale points
        ! Labels the top X axis scale using the supplied text descriptions, in the same manner as
        ! IPgXText. The exception is a polar plot or 3D surface/scatter/volume plot, where
        ! IPgXText and IPgXTextTop are synonymous.
        ! INTERACTER Subroutine Reference PG Axes/Annotations
        ! 2-39
    end subroutine

    subroutine IPgYGraticules(LTYPE)
        integer LTYPE ! 0 : Solid lines (default) )
        ! = 1 : Dotted lines ) As for
        ! = 2 : Dashed lines ) IGrLineType
        ! = 3 : Dot/dashed lines )
        ! = 4 : Dot-dot/dashed lines)
        ! = 5 : Long/short dashes )
        ! = 6 : Short dashes )
        ! Short-name : PGYGRA
        ! Include : intergs.inc
        ! Draws graticules (background scale lines) horizontally across the PG area, using lines
        ! of the specified type. On polar plots graticules are drawn as concentric circles. Dotted
        ! lines are recommended since they are least likely to obscure the data being plotted.
        ! Graticules are drawn at regular intervals along the Y axis, at the same positions as the
        ! ticks which are plotted by the IPgYScaleLeft scale routine. In fact, graticules are
        ! directly equivalent to ticks except they extend across the full width of the PG area.
        ! Optionally, graticules can be drawn at user defined positions specified via
        ! IPgYUserScale.
        ! Obviously, IPgYGraticules should be called before plotting any data, otherwise
        ! the graticules will be drawn over the top of the plotted data.
        ! On displays which do not support dotted lines, graticules will be drawn as solid lines.
        ! See IGrLineType or call the IF group function InfoGrScreen to check for
        ! broken line support.
        !e.g. CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !CALL IPgUnits(1.,0.,12.,10000.)
        !CALL IPgAxes
        !CALL IPgYGraticules(1)
        !CALL IPgYScaleLeft('TN')
        !PG Axis/Annotation INTERACTER Subroutine Reference
        !2-40
    end subroutine

    subroutine IPgYLabelLeft(YLABEL,JUSTIF)
        character(len=*) YLABEL ! Left Y axis label string
        character(len=*) JUSTIF ! Text justification (one of) :
        ! T : Starting at top edge, to the left of PG area
        ! C : Centred, to the left of PG area (default)
        ! B : Ending at the bottom edge, to the left of PG area
        ! and orientation (one of) :
        ! V : Vertical (default)
        ! R : Rotated by 270 degrees
        ! 9 : Rotated by 90 degrees
        ! Or, on a 3D surface/scatter/volume plot, justification only :
        ! L/C/R : Left/centre/right justify the label
        ! Short-name : PGYLBL
        ! Prints a label for the Y axis to the left of the Presentation Graphics area. The vertical
        ! position of the label is determined by the justification parameter. The currently selected
        ! graphics character set and size (as set by IGrCharSet and IGrCharSize) are used
        ! to display the label string. The horizontal position can be changed by
        ! IPgYLabelPos. A scale can be plotted separately using IPgYScaleLeft and/or
        ! IPgYTextLeft.
        ! If more than one Y axis label is required, IPgYLabelLeft could be called with 'T'
        ! then 'B' justification parameters to place strings at both the top and bottom limits of the
        ! area beside the PG area. To add similar text to the X axes see the corresponding
        ! routines IPgXLabel and IPgXlabelTop. To place a label to the right of the PG
        ! area use IPgYLabelRight.
        ! The string can either be displayed vertically or rotated. Add a V to JUSTIF, for
        ! vertical text (this is the default if the orientation character is omitted). Specifying an R
        ! or 9 rotates the label by 270 or 90 degrees counter-clockwise. If hardware text is
        ! selected, some screen/hardcopy drivers do not support label rotation, in which case
        ! vertical text is used instead. See IGrCharRotate for further information.
        ! If the supplied label is too long to fit beside the PG area, the character size will be
        ! adjusted accordingly. The currently selected graphics character size and justification
        ! mode are restored on exit. The number of decimal places in E/F format values is
        ! determined automatically or can be defined explicitly by calling
        ! IPgDecimalPlaces.
        ! On a 3D surface/scatter/volume plot, the label is plotted parallel to the lower Y axis.
        ! The label will therefore be rotated to match the orientation of the 3D axes. In this case
        ! the JUSTIF argument should simply be L, C or R to indicate which end of the Y axis
        ! the label should be plotted relative to.
        !e.g. CALL IPgXLabel('Age','R')
        !C add a Rotated label at the Top edge
        !CALL IPgYLabelLeft('Average Height','TR')
        !CALL IPgHistogram(HEIGHT)
        !INTERACTER Subroutine Reference PG Axes/Annotations
        !2-41
    end subroutine

    subroutine IPgYLabelRight(YLABEL,JUSTIF)
        character(len=*) YLABEL ! Right Y axis label string
        character(len=*) JUSTIF ! Text justification (one of) :
        ! T : Starting at top edge, to the right of PG area
        ! C : Centred, to the right of PG area (default)
        ! B : Ending at the bottom edge, to the right of PG area
        ! and orientation (one of) :
        ! V : Vertical (default)
        ! R : Rotated by 270 degrees
        ! 9 : Rotated by 90 degrees
        ! Or, on a 3D surface/scatter/volume plot, justification only :
        ! L/C/R : Left/centre/right justify the label
        ! Short-name : PGYLBR
        ! Prints a label for the Y axis to the right of the Presentation Graphics area. A scale can
        ! be plotted separately using IPgYScaleRight and/or IPgYTextRight. On a 3D
        ! surface/scatter/volume plot, the label is plotted parallel to the upper Y axis. In all other
        ! respects, this routine is identical to IPgYLabelLeft which places the label to the left
        ! of the PG area (or below the Y axis on a 3D surface/scatter/volume plot).
        ! This routine is of most use on dual scale displays, i.e Histograms or Line plots where
        ! two scales are being used, as in the example below.
        !e.g.
        !C use IPgBorder in preference to IPgAxes
        !CALL IPgBorder
        !C draw 2 sets of monthly data on a line plot
        !CALL IPgNewPlot(PgLinePlot,2,12,0,0)
        !C data set 1
        !CALL IPgUnits(1.0,0.0,12.0,10.0)
        !CALL IPgYLabelLeft('First data set',' ')
        !CALL IPgLinePlot(DATA1)
        !C data set 2
        !CALL IPgUnits(1.0,0.0,12.0,50.0)
        !CALL IPgYLabelRight('Second data set',' ')
        !CALL IPgLinePlot(DATA2)
    end subroutine

    subroutine IPgYScaleLeft(SCALE)
        character(len=*) SCALE ! Type of scale required (T/I/N, as for IPgXScale)
        ! Short-name : PGYSCL
        ! Adds a scale to the left hand Y axis of a Presentation Graphics display, with the option
        ! of selecting ticks and/or numeric values. This routine will normally be used in
        ! combination with IPgAxes though neither is obligatory. Ticks can be placed inside
        ! (to the right of) the axis if required, but will be placed outside (to the left) by default.
        ! On polar plots ticks and values are placed along the horizontal line through the centre
        ! of the plot. By default ticks are placed below the line. Inside places them above the
        ! line.
        ! By default, scaling intervals are calculated automatically and will normally be some
        ! multiple of 2, 5 or 10. Slightly different rules are applied on 3D surface/volume plots.
        ! Alternatively scale points can be specified via IPgYUserScale.
        ! PG Axis/Annotation INTERACTER Subroutine Reference
        ! 2-42
        ! Ticks and/or numeric labels are added at the automatically generated or user-defined
        ! intervals on the Y axis, according to the SCALE parameter. Note that SCALE can be
        ! any string you like. IPgYScaleLeft simply checks to see whether either of the key
        ! letters T or N (upper or lower case as usual) occur in that string. If the string is
        ! completely blank, ticks outside the axis and numeric labels are assumed.
        ! By default, ticks and value strings are plotted horizontally. The angle of both can be
        ! changed independently, by calling IPgYScaleAngle.
        ! By default, ticks are drawn at a horizontal position (in PG units) of 0.0, if this lies
        ! within the PG area, or at the left of the PG area otherwise. This default logic can be
        ! overridden by calling IPgYTickPos. Tick mark length can be set by
        ! IPgYTickLength. On polar plots ticks are always placed on the horizontal line
        ! through the centre of the plot. Tick mark length can be set by IPgYTickLength.
        ! Numeric labels are plotted using the current character set and character size. However,if the labels would overlap as a result, character size is adjusted accordingly. The
        ! currently selected graphics character size is restored on exit.
        ! To label the left-hand Y scale with text rather than numbers, see the alternative routine
        ! IPgYTextLeft.
        ! Calling IPgYScaleLeft has no effect if the current graph type is a table.
        !e.g. CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !CALL IPgUnits(1.,0.,12.,10000.)
        !CALL IPgAxes
        !C label Y axis with numbers but not ticks
        !CALL IPgYScaleLeft('N')
    end subroutine

    subroutine IPgYScaleRight(SCALE)
        character(len=*) SCALE ! Type of scale required (T/I/N, as for IPgXScale)
        ! Short-name : PGYSCR
        ! Adds a scale to the Y axis of a Presentation Graphics display, displaying scale values to
        ! the right of the PG area. It is equivalent to the IPgYScaleLeft routine which places
        ! the scale at the left. This routine will normally be used in combination with the
        ! IPgAxesXY or IPgBorder routines, though none are obligatory. Ticks can be
        ! placed inside (to the left of) the axis if required, but will be placed outside (to the right)
        ! by default.
        ! This routine is of most use on dual scale displays, i.e. Histograms or Line plots where
        ! two scales are required, as in the following example. It is also useful with polar plots
        ! since the scale values are then displayed in the natural order, increasing left to right.
        ! By default, ticks are drawn at a horizontal position (in PG units) of 0.0, if this lies
        ! within the PG area, or at the right of the PG area otherwise. This default logic can be
        ! overridden by calling IPgYTickPos. On polar plots ticks are always placed on the
        ! horizontal line through the centre of the plot.
        ! To label the right hand Y scale with text rather than numbers, see the alternative routine
        ! IPgYTextRight. To specify a user-defined scale for the Y axis, see
        ! IPgYUserScale.
        ! Calling IPgYScaleRight has no effect if the current graph type is a table.
        ! INTERACTER Subroutine Reference PG Axes/Annotations
        ! 2-43
        !e.g.
        !C use IPgBorder in preference to IPgAxes
        !CALL IPgBorder
        !C draw 2 sets of monthly data on a line plot
        !CALL IPgNewPlot(PgLinePlot,2,12,0,0)
        !C data set 1 : Y units are 0-10
        !CALL IPgUnits(1.0,0.0,12.0,10.0)
        !CALL IPgYScaleLeft(' ')
        !CALL IPgLinePlot(DATA1)
        !C data set 2 : Y units are 0-50
        !CALL IPgUnits(1.0,0.0,12.0,50.0)
        !CALL IPgYScaleRight('n')
        !CALL IPgLinePlot(DATA2)
    end subroutine

    subroutine IPgYTextLeft(DESCR,NDESC)
        integer NDESC ! Number of supplied descriptions
        character(len=*) DESCR(NDESC) ! Descriptions of scale points
        ! Short-name : PGYTXL
        ! All plot types except tables:
        ! Labels the left hand Y axis scale using the supplied text descriptions, instead of
        ! numeric values as would otherwise be added by the alternative IPgYScaleLeft
        ! routine. Trailing spaces are not stripped. On a 3D surface/scatter/volume plot the lower
        ! Y axis is labelled.
        ! Scaling intervals are calculated automatically, using the same algorithm as
        ! IPgYScaleLeft. Alternatively, scale points are user definable via
        ! IPgYUserScale. The supplied descriptions are placed at each of the scale points
        ! which would otherwise have been labelled numerically by IPgYScaleLeft. In fact,the two routines can be called in combination, if ticks are also required. See also
        ! IPgYTextRight, IPgXText and IPgXTextTop.
        ! By default, value strings are plotted horizontally, but this can be changed by calling
        ! IPgYScaleAngle.
        ! Scale point labels are plotted using the current character set and character size.
        ! However, if the labels would overlap as a result, character size is adjusted accordingly.
        ! The currently selected graphics character size is restored on exit.
        ! Tables:
        ! Adds row labels to the left of the table using the supplied text descriptions. A box is
        ! drawn around each label using the currently selected graphics colour. If PgLayFill
        ! was specified in the LAYOUT argument to IPgNewPlot then this box is filled using a
        ! solid fill in the previously selected colour.
        ! The size of box around each label is calculated from the number of rows specified to
        ! IPgNewPlot and the current character size. A border of 1/2 of a character to the left
        ! and right of the labels is allowed to avoid a cramped appearance. If the current
        ! character size would cause labels to extend outside the main graphics area then the
        ! character size is reduced accordingly. The character size is also reduced if the labels
        ! would be too tall to fit within a row. A border of 1/4 of a character is allowed when
        ! calculating the maximum character height.
        ! Labels are output left justified, using unrotated, horizontal text.
        ! The currently selected graphics character size and justification are restored on exit.
        ! PG Axis/Annotation INTERACTER Subroutine Reference
        ! 2-44
    end subroutine

    subroutine IPgYTextRight(DESCR,NDESC)
        integer NDESC ! Number of supplied descriptions
        character(len=*) DESCR(NDESC) ! Descriptions of scale points
        ! Short-name : PGYTXR
        ! Labels the right hand Y axis scale using the supplied text descriptions, in the same
        ! manner as IPgYTextLeft. The exception is a 3D surface/scatter/volume plot, where
        ! IPgYTextLeft and IPgYTextRight are synonymous.
    end subroutine

    subroutine IPgZGraticules(LTYPE)
        integer LTYPE ! 0 : Solid lines (default) )
        ! = 1 : Dotted lines ) As for
        ! = 2 : Dashed lines ) IGrLineType
        ! = 3 : Dot/dashed lines )
        ! = 4 : Dot-dot/dashed lines)
        ! = 5 : Long/short dashes )
        ! = 6 : Short dashes )
        ! Include : intergs.inc
        ! Draws graticules (background scale lines) on the Z axis of a 3D surface/scatter/volume
        ! plot. A call to this routine will be ignored on any other type of plot.
        ! Graticules are drawn at regular intervals along the Z axis, at the same positions as the
        ! ticks which are plotted by IPgZScale. Optionally, graticules can be drawn at user
        ! defined positions specified via IPgZUserScale.
        ! Obviously, IPgZGraticules should be called before plotting any data, otherwise
        ! the graticules will be drawn over the top of the plotted data.
        ! On displays which do not support dotted lines, graticules will be drawn as solid lines.
        ! See IGrLineType or call the IF group function InfoGrScreen to check for
        ! broken line support.
        !e.g. CALL IPgNewPlot(PgFuncPlot,NC,NVALUE,PgLay3D,0)
        !CALL IPgStyle3DAxes(4,223,0,0)
        !CALL IPgAxes
        !CALL IPgZGraticules(1)
    end subroutine

    subroutine IPgZLabelLeft(ZLABEL,JUSTIF)
        character(len=*) ZLABEL ! Left Z axis label string
        character(len=*) JUSTIF ! Text justification (one of) :
        ! T : Starting at top edge of Z axis, to the left of PG area
        ! C : Centred, to the left of PG area (default)
        ! B : Ending at the bottom edge, to the left of PG area
        ! And orientation (one of) :
        ! V : Vertical (default)
        ! R : Rotated by 270 degrees
        ! 9 : Rotated by 90 degrees
        ! Prints a label for the Z axis of a 3D surface/scatter/volume plot, to the left of the
        ! Presentation Graphics area. The vertical position of the label is determined by the
        ! justification parameter.
        ! INTERACTER Subroutine Reference PG Axes/Annotations
        ! 2-45
        ! The currently selected graphics character set and size (as set by IGrCharSet and
        ! IGrCharSize) are used to display the label string. The default horizontal position is
        ! 80% of the distance between the edge of the PG and main graphics areas, measured
        ! from the edge of the PG area, but this can be changed by IPgZLabelPos. A scale can
        ! be plotted separately using IPgZScale.
        ! To place a label to the right of a 3D surface/scatter/volume plot, use
        ! IPgZLabelRight.
        ! The string can either be displayed vertically or rotated. Add a V to the justification
        ! letter specified in JUSTIF, for vertical text (this is the default if the orientation
        ! character is omitted). Specifying an R or 9 rotates the label by 270 or 90 degrees
        ! counter-clockwise. If hardware text is selected, some screen/hardcopy drivers do not
        ! support label rotation, in which case vertical text is used instead. See
        ! IGrCharRotate for further information.
        ! If the supplied label is too long to fit beside the Z axis, the character size will be
        ! adjusted accordingly. The currently selected graphics character size and justification
        ! mode are restored on exit.
        !e.g. see IPgSurf3Func
    end subroutine

    subroutine IPgZLabelRight(ZLABEL,JUSTIF)
        character(len=*) ZLABEL ! Right Z axis label string
        character(len=*) JUSTIF ! Text justification (one of) :
        ! T : Starting at top edge of Z axis, to the right of PG area
        ! C : Centred, to the right of PG area (default)
        ! B : Ending at the bottom edge, to the right of PG area
        ! And orientation (one of) :
        ! V : Vertical (default)
        ! R : Rotated by 270 degrees
        ! 9 : Rotated by 90 degrees
        ! Prints a label for the Z axis of a 3D surface/scatter/volume plot to the right of the
        ! Presentation Graphics area. In all other respects, this routine is identical to
        ! IPgZLabelLeft which places the label to the left of the PG area.
    end subroutine

    subroutine IPgZScale(SCALE)
        character(len=*) SCALE ! Type of scale required (T/I/N, as for IPgXScale)
        ! Short-name : PGZSCL
        ! Adds a scale to the Z axis of a 3D surface/scatter/volume plot, with the option of
        ! selecting ticks and/or numeric values. This routine will normally be used in
        ! combination with the IPgAxes routine though neither is obligatory. Ticks can be
        ! placed inside the axis if required, but will be placed outside by default.
        ! Scaling intervals are calculated automatically. Alternatively scale points can be
        ! specified via IPgZUserScale.
        ! PG Axis/Annotation INTERACTER Subroutine Reference
        ! 2-46
        ! Ticks and/or numeric labels are added at the automatically generated or user-defined
        ! intervals on the Z axis, according to the SCALE parameter. Note that SCALE can be
        ! any string you like. IPgZScale simply checks to see whether any of the key letters
        ! T/N/I (upper or lower case as usual) occur in that string. If the string is completely
        ! blank, ticks outside the axis and numeric labels are assumed.
        ! Numeric labels are plotted using the current character set and character size. However,if the labels would overlap as a result, character size is adjusted accordingly. The
        ! currently selected graphics character size is restored on exit. The number of decimal
        ! places in E/F format values is determined automatically or can be defined explicitly by
        ! calling IPgDecimalPlaces.
        ! By default, ticks and value strings are plotted horizontally. The angle of both can be
        ! changed independently, by calling IPgZScaleAngle.
        ! Tick mark length can be set by IPgZTickLength.
        !e.g. CALL IPgNewPlot(PgFuncPlot,1,NVALUE,PgLay3D,0)
        !CALL IPgUnitsZ(0.0,10.0)
        !CALL IPgAxes
        !C add numbers only to Z axis
        !CALL IPgZScale('N')
    end subroutine

    subroutine IPgZText(DESCR,NDESC)
        integer NDESC ! Number of supplied descriptions
        character(len=*) DESCR(NDESC) ! Descriptions of scale points
        ! Labels the Z axis scale on a 3D surface/scatter/volume plot using the supplied text
        ! descriptions, instead of numeric values as would otherwise be added by the alternative
        ! IPgZScale routine. Trailing spaces are not stripped.
        ! Scaling intervals are calculated automatically by default, using the same algorithm as
        ! IPgZScale. Alternatively, scale points are user definable via IPgZUserScale.
        ! The supplied descriptions are placed at each of the scale points which would otherwise
        ! have been labelled numerically by IPgZScale. In fact, the two routines can be called
        ! in combination, if ticks are also required, as in the following example.
        ! By default, value strings are plotted horizontally, but this can be changed by calling
        ! IPgZScaleAngle.
        ! Scale point labels are plotted using the current character set and character size.
        ! However, if the labels would overlap as a result, character size is adjusted accordingly.
        ! The currently selected graphics character size is restored on exit.
        !e.g. REAL SPOINT(3)
        !CHARACTER*6 DESCR(3)
        !DATA SPOINT/0.0,0.5,1.0/
        !DATA DESCR/'Low','Medium','High'/
        !NVALUE(1) = NXGRID
        !NVALUE(2) = NYGRID
        !CALL IPgNewPlot(PgFuncPlot,1,NVALUE,PgLay3D,0)
        !CALL IPgAxes
        !C add ticks only to Z axis
        !CALL IPgZUserScale(SPOINT,3)
        !CALL IPgZScale('T')
        !C and descriptions ..
        !CALL IPgZText(DESCR,3)
        !CALL IPgSurf3Func(Z)
        !INTERACTER Subroutine Reference PG Chart/Graph Plotting
        !2-47
        !2.3 Group PG(3) : Chart/Graph Plotting
        !Data can be plotted using various chart/graph types, namely bar charts
        !(IPgBarChart), 2D function line plots (IPgFunctionLine), histograms
        !(IPgHistogram or IPgHighLow), line plots (IPgLinePlot), pie-charts
        !(IPgPieChart), scatter plots (IPgScatterPlot, IPgScatterPlot3D and
        !IPgScatterPlot3DCol), tables (IPgTableInteger and IPgTableReal)
        !and joined x-y pairs or x-y-z triplets (IPgXYPairs and IPgXYZTriplets). To add
        !error bars to a line plot call IPgErrorBars. A call to any one of these routines must
        !be preceded by a call to IPgNewPlot which defines the graph type to be generated.
    end subroutine

    subroutine IPgBarChart(XVALUE)
        real XVALUE(*) ! Array of values to be plotted on bar chart
        ! Short-name : PGBARC
        ! Plots the supplied values on a bar chart in the current PG area. The number of data
        ! values to plot and the layout are as defined in a previous call to IPgNewPlot. The
        ! plotting units are as defined to IPgUnits and the style of presentation of this data set
        ! should have been defined using IPgStyle. If the current graph type specified to
        ! IPgNewPlot is not a bar chart, then calling IPgBarChart will have no effect.
        ! This routine is very similar to IPgHistogram, except that data is presented
        ! horizontally rather than vertically. Consequently, the data supplied to this routine
        ! specifies values on the X rather than the Y axis.
        ! If a stacked plot has been requested, IPgBarChart will plot up to a maximum of
        ! 1024 data values in the array XVALUE. The values in XVALUE will be added to those
        ! already plotted, to calculate the lengths of the bars drawn. XVALUE is assumed to be a
        ! one dimensional array of data values, but can equally be one dimension of a multidimensional
        ! array.
        ! When plotting a 2D bar-chart, all filled bars are drawn with an outline by default. This
        ! can be suppressed via IPgStyle or redefined via IPgStyleOutline.
        ! On a 2D non-stacked bar chart, the value of each data item can be plotted at the end of
        ! each bar by specifying PgLayValueLab in the LAYOUT argument of IPgNewPlot.
        ! The labels are plotted in the current graphics colour, font and character size.
        ! On a 2D non-stacked bar chart, the bars are plotted side-by-side in clusters, by default.
        ! The bars in each cluster can be made to overlap by specifying PgLayOverlap in the
        ! LAYOUT argument of IPgNewPlot.
        ! Whatever colours have been specified to IPgStyle for this data set, the current
        ! graphics colour will remain unchanged on exit.
        !e.g. DIMENSION VALS(10,2)
        !:
        !C plot 2 sets of 10 values on a stacked 3D bar chart
        !CALL IPgNewPlot(PgBarChart,2,10,PgLay3D+PgLayStacked,0)
        !CALL IPgUnits(0.0,1.,50.0,10.)
        !CALL IPgAxes
        !CALL IPgXScale(' ')
        !CALL IPgBarChart(VALS(1,1))
        !CALL IPgBarChart(VALS(1,2))
        !CALL IPgTitle('3D Stacked Bar Chart','L')
        !PG Chart/Graph Plotting INTERACTER Subroutine Reference
        !2-48
    end subroutine

    subroutine IPgErrorBars(YLOW,YHIGH)
        real YLOW(*) ! Array of error bar minimum values
        real YHIGH(*) ! Array of error bar maximum values
        ! Adds error bars to a line plot. Each array should contain NVALUE values, as specified
        ! in an earlier call to IPgNewPlot. To omit a particular error bar, specify YLOW(N) to
        ! be greater than or equal to YHIGH(N). The error bars are plotted in a solid line style in
        ! the colour most recently selected via IGrColour/IGrColourN.
        !e.g. REAL VALS(10),VALMIN(10),VALMAX(10)
        !CALL IPgNewPlot(PgLinePlot,1,10,0,0)
        !CALL IPgAxes
        !CALL IPgXScale('T')
        !CALL IPgYScaleLeft('TN')
        !CALL IPgLinePlot(VALS)
        !CALL IGrColour('cyan')
        !CALL IPgErrorBars(VALMIN,VALMAX)
    end subroutine

    subroutine IPgFunctionLine(FUNC)
        EXTERNAL FUNC ! Name of external or intrinsic function to plot
        ! Short-name : PGFUNC
        ! Plots values of the supplied function in the current PG area. The number of data values
        ! to plot and the layout are as defined in a previous call to IPgNewPlot. The plotting
        ! units are as defined to IPgUnits and the style of presentation of this data set should
        ! have been defined using IPgStyle. If the current graph type specified to
        ! IPgNewPlot is not a function plot, calling IPgFunctionLine has no effect.
        ! The function is either plotted as a line graph, or by filling the area under the line,depending on the style selected by IPgStyle.
        ! The supplied function must be declared in the calling program as either EXTERNAL (if
        ! it is a user function) or INTRINSIC (for a standard Fortran function such as SIN).
        ! The function must take one and only one REAL argument and return a REAL result.
        ! Any number of points of the function can be plotted, this being defined by the previous
        ! call to IPgNewPlot. In general, the more points you specify, the better the resolution
        ! of the plot (though it will take longer to draw). Y values of the function are plotted at
        ! even X intervals between the minimum and maximum X values specified in the last call
        ! to IPgUnits.
        ! Whatever colours and/or line type have been specified to IPgStyle for this data set,the current selections will remain unchanged on exit.
        !e.g. INTRINSIC SIN
        !C plot a graph of the SIN function
        !CALL IPgNewPlot(PgFuncPlot,1,100,0,0)
        !CALL IPgUnits(0.0,-1.0,20.0,1.0)
        !CALL IPgAxes
        !CALL IPgYScaleLeft(' ')
        !CALL IPgFunctionLine(SIN)
        !CALL IPgTitle('SIN Wave','L')
        !INTERACTER Subroutine Reference PG Chart/Graph Plotting
        !2-49
    end subroutine

    subroutine IPgHighLow(YLOW,YHIGH)
        real YLOW(*) ! Array of minimum values for each histogram bar
        real YHIGH(*) ! Array of maximum values for each histogram bar
        ! Plots the supplied arrays of maximum and minimum values as a high/low histogram in
        ! the current PG area. The number of data values to plot and the layout are as defined in a
        ! previous call to IPgNewPlot. Specifically, the ITYPE and LAYOUT arguments to
        ! that routine should be PgHistogram and PgLayHighLow.
        ! The behaviour of this routine is identical to IPgHistogram except that :
        ! (a) Each bar is plotted between the specified low and high values.
        ! (b) Stacked and 3D plots are not supported since they are not appropriate.
        ! (c) If value labels have been requested (by specifying PgLayValueLab in the
        ! LAYOUT argument of IPgNewPlot) these are plotted at both ends of each bar.
        !e.g. REAL YMIN(12),YMAX(12)
        !:
        !c plot 12 months worth of max/min values as a high/low histogram
        !CALL IPgNewPlot(PgHistogram,2,12,PgLayHighLow,0)
        !CALL IPgUnits(1.,0.,12.,10000.)
        !CALL IPgAxes
        !CALL IPgYScaleLeft(' ')
        !CALL IPgXScale('TN')
        !CALL IPgHighLow(YMIN,YMAX)
        !CALL IPgTitle('Monthly Minima/Maxima for 1999',' ')
        !Errors :
        !ErrBadMaxMin (58) : A min value is larger than a max value.
        !A zero height bar will be drawn.
    end subroutine

    subroutine IPgHistogram(YVALUE)
        real YVALUE(*) ! Array of values to be plotted on histogram
        ! Short-name : PGHIST
        ! Plots the supplied values on a histogram in the current PG area. The number of data
        ! values to plot and the layout are as defined in a previous call to IPgNewPlot. The
        ! plotting units are as defined to IPgUnits and the style of presentation of this data set
        ! should have been defined using IPgStyle. If the current graph type specified to
        ! IPgNewPlot is not a histogram, then calling IPgHistogram will have no effect.
        ! If a stacked plot has been requested, IPgHistogram will plot up to a maximum of
        ! 1024 data values in the array YVALUE. The values in YVALUE will be added to those
        ! already plotted, to calculate the lengths of the bars drawn. YVALUE is assumed to be a
        ! one dimensional array of data values, but can equally be one dimension of a multidimensional
        ! array.
        ! When plotting a 2D histogram, all filled bars are drawn with an outline by default. This
        ! can be suppressed via IPgStyle or redefined via IPgStyleOutline.
        ! On a 2D non-stacked histogram, the value of each data item can be plotted at the end of
        ! each bar by specifying PgLayValueLab in the LAYOUT argument of
        ! IPgNewPlot. The labels are plotted in the current graphics colour, font and character
        ! size.
        ! PG Chart/Graph Plotting INTERACTER Subroutine Reference
        ! 2-50
        ! On a 2D non-stacked histogram, the bars are plotted side-by-side in clusters, by default.
        ! The bars in each cluster can be made to overlap by specifying PgLayOverlap in the
        ! LAYOUT argument of IPgNewPlot.
        ! Whatever colours have been specified to IPgStyle for this data set, the current
        ! graphics colour will remain unchanged on exit.
        !e.g. DIMENSION YEAR1(12),YEAR2(12)
        !C plot 2 sets of 12 values on a histogram
        !CALL IPgNewPlot(PgHistogram,2,12,0,0)
        !CALL IPgUnits(1.,0.,12.,10000.)
        !CALL IPgAxes
        !CALL IPgYScaleLeft(' ')
        !CALL IPgXScale('TN')
        !CALL IPgHistogram(YEAR1)
        !CALL IPgHistogram(YEAR2)
        !CALL IPgTitle('Sales for 1998 and 1999',' ')
    end subroutine

    subroutine IPgLinePlot(YVALUE)
        real YVALUE(*) ! Array of values to be plotted on graph
        ! Short-name : PGLINE
        ! Plots the supplied values as a line graph in the current PG area. The values should
        ! either be Y values for a Cartesian plot or radius values for a polar plot. The number of
        ! data values to plot and the layout are as defined in a previous call to IPgNewPlot.
        ! The plotting units are as defined to IPgUnits or IPgUnitsPolar and the style of
        ! presentation of this data set should have been defined using IPgStyle. If the current
        ! graph type specified to IPgNewPlot is not a line graph, calling IPgLinePlot will
        ! have no effect.
        ! The data is either plotted as a simple line graph, or by filling the area under the line,depending on the style selected by IPgStyle. On polar plots the values are plotted
        ! anti-clockwise and the last point is connected back to the first point. If a fill under the
        ! line is requested for a polar plot the area inside the polygon is filled.
        ! If splines have been selected in the call to IPgNewPlot, a smooth curve will be fitted
        ! through the data points. In this case the option to fill the area under the line is not
        ! available. The maximum number of points through which a spline may be fitted is
        ! 4095.
        ! This routine is particularly suited to the plotting of time dependent data. In this case the
        ! X units supplied to IPgUnits should reflect the time scale over which the data is
        ! being plotted. This will ensure meaningful labelling by the IPgXScale routine.
        ! If a stacked plot has been requested, IPgLinePlot will plot up to a maximum of
        ! 1024 data values in the array YVALUE. The values in YVALUE will be added to those
        ! already plotted, to calculate the Y positions to draw the next line to. YVALUE is
        ! assumed to be a one dimensional array of data values, but can equally be one dimension
        ! of a multi-dimensional array.
        ! If markers have been requested, via IPgStyle, these are plotted at every point by
        ! default. Marker frequency can be changed by calling IPgMarkerFrequency. The
        ! actual marker plotted is determined by a combination of IPgStyle's ISTYL2
        ! argument and the data set number. Alternatively, this can be set directly by calling
        ! IPgMarker.
        ! INTERACTER Subroutine Reference PG Chart/Graph Plotting
        ! 2-51
        ! To add error bars to a line plot, call the companion routine IPgErrorBars.
        ! Whatever colours and line styles have been specified to IPgStyle for this data set,the current selections will remain unchanged on exit.
        !e.g. DIMENSION VALS(10,2)
        !C plot 2 sets of 10 values on a stacked line graph
        !CALL IPgNewPlot(PgLinePlot,2,10,PgLayStacked,0)
        !CALL IPgUnits(0.0,0.0,1.0,1.0)
        !CALL IPgAxes
        !CALL IPgXScale('T')
        !CALL IPgYScaleLeft('TN')
        !CALL IPgLinePlot(VALS(1,1))
        !CALL IPgLinePlot(VALS(1,2))
        !CALL IPgTitle('Stacked Line Graph','R')
    end subroutine

    subroutine IPgPieChart(PIEVAL,SANGLE,EXPLOD)
        real PIEVAL(*) ! Array of values to be plotted on pie chart
        real SANGLE ! Start angle of first wedge of pie, in degrees
        ! counter-clockwise from 3 o'clock
        character(len=*) EXPLOD ! String of blanks or E's indicating which wedges
        ! (if any) to explode. Single blank for none.
        ! Short-name : PGPIEC
        ! Plots the supplied values in the form of a pie chart in the current PG area. The number
        ! of wedges to plot and the layout are as defined in a previous call to IPgNewPlot.
        ! The style of presentation of all wedges should have been defined using IPgStyle. If
        ! the current graph type specified to IPgNewPlot is not a pie chart, calling
        ! IPgPieChart has no effect. Plotting units as defined to IPgUnits are not relevant.
        ! All filled wedges are drawn with an outline by default. This can be suppressed via
        ! IPgStyle or redefined via IPgStyleOutline.
        ! The first wedge is plotted starting at the angle specified by SANGLE. Wedges are then
        ! plotted either clockwise from that point, unless PgLayAntiClock was specified in
        ! the LAYOUT argument to IPgNewPlot.
        ! Wedges can be 'exploded' (i.e. moved out from the centre of the pie) by setting the
        ! appropriate character of EXPLOD to 'E'. This allows more than one wedge to be
        ! exploded if required. EXPLOD can be any length; if it is shorter than the number of
        ! wedges it is treated as being blank extended. Hence if EXPLOD is a single blank, no
        ! wedges are exploded.
        ! The size of the pie chart is determined by various factors such as the size of the PG
        ! area, whether spider tags have been requested and which wedges have been exploded.
        ! Whatever colours have been specified to IPgStyle for each wedge, the current
        ! graphics colour will remain unchanged on exit.
        !e.g. PARAMETER (NWEDGE = 5)
        !DIMENSION PIEVAL(NWEDGE)
        !CHARACTER*10 DESCRP(NWEDGE)
        !C generate a pie chart with 5 wedges with the 2nd & 4th exploded
        !CALL IPgNewPlot(PgPieChart,NWEDGE,0,PgLaySpider,0)
        !CALL IPgPieChart(PIEVAL,90.,' E E')
        !CALL IGrColourN(ISTCOL)
        !CALL IGrColourN(IDECOL)
        !CALL IPgKeyAll(DESCRP,'P')
        !CALL IPgTitle('Pie Chart Title !','C')
        !PG Chart/Graph Plotting INTERACTER Subroutine Reference
        !2-52
    end subroutine

    subroutine IPgScatterPlot(XVALUE,YVALUE)
        real XVALUE(*) ! Array of X or Angle values to be plotted on scatter plot
        real YVALUE(*) ! Array of Y or Radius values to be plotted on scatter plot
        ! Short-name : PGSCAT
        ! Plots the supplied co-ordinate pairs on a 2D scatter plot in the current PG area.
        ! XVALUE should specify X values for a Cartesian plot or angles in degress anticlockwise
        ! from the 3-o'clock position for a polar plot. YVALUE should specify Y values
        ! for a Cartesian plot of radius values for a polar plot. The number of data values to plot
        ! and the layout are as defined in a previous call to IPgNewPlot. The plotting units are
        ! as defined to IPgUnits or IPgUnitsPolar and the style of presentation of this
        ! data set should have been defined using IPgStyle. If the current graph type specified
        ! to IPgNewPlot is not a 2D scatter plot, calling IPgScatterPlot has no effect.
        ! This routine is very similar to IPgXYPairs, except that points are not joined. Each
        ! point is plotted as a marker. The type of marker to be used can be defined in calls to
        ! IPgStyle and IPgMarker.
        ! Any number of co-ordinate pairs can be plotted, this being defined by the previous call
        ! to IPgNewPlot. XVALUE and YVALUE are assumed to be one dimensional arrays of
        ! data values, but can equally be single dimensions of multi-dimensional arrays.
        ! Whatever colours have been specified to IPgStyle for this data set, the current
        ! graphics colour will remain unchanged on exit.
        !e.g. DIMENSION X(50),Y(50)
        !C single scatter plot with 50 co-ordinate pairs
        !CALL IPgNewPlot(PgScatterPlot,1,50,0,0)
        !CALL IPgUnits(-100.0,-100.0,100.0,100.0)
        !CALL IPgAxes
        !CALL IPgXScale('T')
        !CALL IPgYScaleLeft('T')
        !CALL IPgScatterPlot(X,Y)
        !CALL IPgTitle('50 Point Scatter Plot',' ')
    end subroutine

    subroutine IPgScatterPlot3D(XVALUE,YVALUE,ZVALUE)
        real XVALUE(*) ! Array of X values to be plotted on scatter plot
        real YVALUE(*) ! Array of Y values to be plotted on scatter plot
        real ZVALUE(*) ! Array of Z values to be plotted on scatter plot
        ! Plots the supplied co-ordinate triplets on a 3D scatter plot in the current PG area. The
        ! number of data values to plot and the layout are as defined in a previous call to
        ! IPgNewPlot. The plotting units are as defined to IPgUnits and IPgUnitsZ. The
        ! viewing angle is controlled by IPgRotation and IPgElevation. The style of
        ! presentation of this data set should have been defined using IPgStyle. If the current
        ! graph type specified to IPgNewPlot is not a 3D scatter plot, calling
        ! IPgScatterPlot3D will have no effect.
        ! Each point is plotted as a marker. Optionally a connecting line can be drawn to one of
        ! the X, Y or Z axes. The type of marker and connecting line are defined by IPgStyle
        ! and IPgMarker.
        ! Any number of co-ordinate pairs can be plotted, this being defined by the previous call
        ! to IPgNewPlot. XVALUE, YVALUE and ZVALUE are assumed to be one dimensional
        ! arrays of data values, but can equally be single dimensions of multi-dimensional arrays.
        ! INTERACTER Subroutine Reference PG Chart/Graph Plotting
        ! 2-53
        ! Whatever colours have been specified to IPgStyle for this data set, the current
        ! graphics colour will remain unchanged on exit.
        ! See also IPgScatterPlot3DCol which allows the colour of each marker to be
        ! specified individually.
        !e.g. PARAMETER (NPTS = 50)
        !REAL X(NPTS),Y(NPTS),Z(NPTS)
        !:
        !! single scatter plot with 50 co-ordinate pairs
        !CALL IPgNewPlot(PgScatterPlot,1,NPTS,PgLay3D,0)
        !CALL IPgUnits(-100.0,-100.0,100.0,100.0)
        !CALL IPgUnitsZ(0.0,10.0)
        !CALL IPgAxes
        !CALL IPgXScale('T')
        !CALL IPgYScaleLeft('T')
        !CALL IPgZScale('T')
        !CALL IPgScatterPlot3D(X,Y,Z)
    end subroutine

    subroutine IPgScatterPlot3DCol(XVALUE,YVALUE,ZVALUE,ICOLR)
        real XVALUE(*) ! Array of X values to be plotted on scatter plot
        real YVALUE(*) ! Array of Y values to be plotted on scatter plot
        real ZVALUE(*) ! Array of Z values to be plotted on scatter plot
        integer ICOLR(*) ! Array of colour numbers corresponding to each (x,y,z)
        ! Plots the supplied co-ordinate triplets on a 3D scatter plot in the current PG area. This
        ! routine is identical to IPgScatterPlot3D except that the colour of each marker is
        ! specified individually, rather than on a per-data-set basis via IPgStyle.
        ! IPgNewPlot should be called with PgLayCol specified in the LAYOUT argument
        ! when this routine is to be used.
    end subroutine

    subroutine IPgTableInteger(IVALUE)
        integer IVALUE(*) ! Array of integer values to be plotted in a table
        ! Plots the supplied integer values as a column in a table. The number of data values to
        ! plot are as defined in a previous call to IPgNewPlot. The position and width of the
        ! column are calculated automatically from the number of data sets specified in a
        ! previous call to IPgNewPlot. The style of presentation of the column should have
        ! been defined using IPgStyle. If the current graph type specified to IPgNewPlot is
        ! not a table, calling IPgTableInteger will have no effect.
        ! Values are written using the current character set and size. However if the current
        ! character size is too large for the values to fit in the cells then the size is adjusted to the
        ! largest size which will fit. It is still advisable to choose an appropriate character size
        ! before calling IPgTableInteger since reliance on automatic character sizing can
        ! result in different character sizes being used in each column. When calculating the
        ! largest character size a border of 1/2 a character at the left and right and 1/4 of a
        ! character above and below is allowed to avoid a cramped appearance. A gap of 1/2 a
        ! character is also allowed when outputing left or right justified values. Values are output
        ! using un-rotated, horizontal text regardless of the currently requested angle and
        ! direction.
        ! Each cell in the column will have a border drawn using the currently selected graphics
        ! colour.
        ! PG Chart/Graph Plotting INTERACTER Subroutine Reference
        ! 2-54
        ! Column and row labels can be plotted by calling IPgXTextTop and
        ! IPgYTextLeft.
        ! Any number of values can be plotted, this being defined by the previous call to
        ! IPgNewPlot. IVALUE is assumed to be a one dimensional array of data values, but
        ! can equally be a single dimension of a multi-dimensional array.
        ! Whatever colours and justification have been specified to IPgStyle for this column,the current selections will remain unchanged on exit.
        !e.g. PARAMETER (NROWS = 10)
        !REAL RVALUE1(NROWS),RVALUE2(NROWS),IVALUE(NROWS)
        !! Plot table consisting of two real columns and 1 integer column
        !CALL IPgNewPlot(PgTable,3,NROWS,PgLayFill,0)
        !CALL IPgTableReal(RVALUE1,'(F6.2)')
        !CALL IPgTableReal(RVALUE2,'(F6.2)')
        !CALL IPgTableInteger(IVALUE)
    end subroutine

    subroutine IPgTableReal(RVALUE,FRMAT)
        real RVALUE(*) ! Array of real values to be plotted in a table
        character(len=*) FRMAT ! Fortran format to use for displaying values
        ! Plots the supplied real values as a column in a table, in the same manner as
        ! IPgTableInteger, except that the output format can be specified. FRMAT must be
        ! a valid Fortran format string enclosed in brackets.
        !e.g. see IPgTableInteger
    end subroutine

    subroutine IPgXYPairs(XVALUE,YVALUE)
        real XVALUE(*) ! Array of X or Angle values to be plotted
        real YVALUE(*) ! Array of Y or Radius values to be plotted
        ! Short-name : PGXYPR
        ! Plots the supplied values as a series of joined co-ordinate pairs (a 'poly-line') in the
        ! current PG area. XVALUE should specify X values for a Cartesian plot or angles in
        ! degrees anti-clockwise from the 3-o'clock position for a polar plot. YVALUE should
        ! specify Y values for a Cartesian plot or radius values for a polar plot. The number of
        ! data values to plot and the layout are as defined previously to IPgNewPlot. The
        ! plotting units are as defined to IPgUnits or IPgUnitsPolar and the style of
        ! presentation of this data set should have been set using IPgStyle. If the current plot
        ! type specified to IPgNewPlot is not a 2D polyline plot, calling IPgXYPairs has no
        ! effect.
        ! This routine is very similar to the scatter plot routine IPgScatterPlot, except that
        ! points are joined here. Points can still be plotted with a marker, in addition to the
        ! joining lines. The type of marker to be used can be defined in calls to IPgStyle and
        ! IPgMarker. Similarly, closed or open poly-lines are also selectable using
        ! IPgStyle. Marker frequency can be controlled by IPgMarkerFrequency.
        ! By default points are joined by straight lines. If splines have been selected in the call to
        ! IPgNewPlot, a smooth curve will be fitted through the data points. The maximum
        ! number of points through which a spline may be fitted is 4095.
        ! INTERACTER Subroutine Reference PG Chart/Graph Plotting
        ! 2-55
        ! Any number of co-ordinate pairs can be plotted (if splines have not been selected), this
        ! being defined by the previous call to IPgNewPlot. XVALUE and YVALUE are
        ! assumed to be one dimensional arrays of data values, but can equally be single
        ! dimensions of multi-dimensional arrays.
        ! Whatever colours and/or line style have been specified to IPgStyle for this data set,the current selections will remain unchanged on exit.
        !e.g. DIMENSION X(50),Y(50)
        !C single X-Y pairs plot with 50 points
        !CALL IPgNewPlot(PgPolyline,1,50,0,0)
        !CALL IPgUnits(-100.0,-100.0,100.0,100.0)
        !CALL IPgAxes
        !CALL IPgXScale('T')
        !CALL IPgYScaleLeft('T')
        !CALL IPgXYPairs(X,Y)
        !CALL IPgTitle('50 Point X/Y-pair Plot',' ')
    end subroutine

    subroutine IPgXYZTriplets(XVALUE,YVALUE,ZVALUE)
        real XVALUE(*) ! Array of X values to be plotted
        real YVALUE(*) ! Array of Y values to be plotted
        real ZVALUE(*) ! Array of Z values to be plotted
        ! Plots the supplied values as a series of joined co-ordinate triplets (a 'poly-line') in the
        ! current 3D PG plotting space. The number of data values to plot and the layout are as
        ! defined in a previous call to IPgNewPlot. The plotting units are as defined to
        ! IPgUnits and IPgUnitsZ. The style of presentation of this data set should have
        ! been defined using IPgStyle. If the current graph type specified to IPgNewPlot is
        ! not a 3D polyline plot, calling this routine has no effect.
        ! Points can still be plotted with a marker. The type of marker to be used can be defined
        ! in calls to IPgStyle or IPgMarker. Similarly, closed or open poly-lines are also
        ! selectable using IPgStyle. Marker frequency can be controlled by
        ! IPgMarkerFrequency.
        ! Points are joined by straight lines. The maximum number of points is 4094 (closed) or
        ! 4095 (closed). XVALUE, YVALUE and ZVALUE are assumed to be one dimensional
        ! arrays of data values, but can equally be single dimensions of multi-dimensional arrays.
        ! Whatever colours and/or line style have been specified to IPgStyle for this data set,the current selections will remain unchanged on exit.
        !e.g. REAL X(50),Y(50),Z(50)
        !C single X-Y-Z triplets plot with 50 points
        !CALL IPgNewPlot(PgPolyline,1,50,PgLay3D,0)
        !CALL IPgUnits(-100.0,-100.0,100.0,100.0)
        !CALL IPgUnitsZ(0.0,10.0)
        !CALL IPgAxes
        !CALL IPgXScale('T')
        !CALL IPgYScaleLeft('T')
        !CALL IPgZScale(.T.)
        !CALL IPgXYZTriplets(X,Y,Z)
        !CALL IPgTitle('50 Point X/Y/Z Triplets Plot',' ')
        !
        !INTERACTER Subroutine Reference PG Contour/Surface Plots
        !2-57
        !2.4 Group PG(4) : Contour/Surface Plotting
        !The routines in this group provide facilities to view three dimensional data in the form
        !of a 2D contour plot, a 3D surface or a 3D volume plot.
        !Line based 2D contour plots can be generated on a regular grid by
        !IPgContour2Reg, or on an irregular grid using IPgContour2Irreg. The two
        !routines use different algorithms, each of which has its particular advantages. Fill based
        !contour plots can also be generated using the same argument lists, via
        !IPgConFill2Reg or IPgConFill2Irreg, which share a common algorithm.
        !A 3D surface plotting routine is also provided which is accessible via five different
        !entry points. IPgSurf3Func and IPgSurf3FuncCont plot a user-supplied
        !function whilst IPgSurf3Data and IPgSurf3DataCont plot from a data array.
        !IPgSurf3Func and IPgSurf3Data plot the entire surface in a uniform or
        !graduated colour, whereas IPgSurf3FuncCont and IPgSurf3DataCont allow
        !contour levels to be specified for height dependent colour coding. A fifth routine,IPgSurf3DataCol, plots a surface in the same way as IPgSurf3Data, except
        !that the colour of each point on the surface can be specified, allowing (x,y,z,c) plotting.
        !Three further routines are provided which provide 'stepped' contour plots, namely
        !IPgSurf3Step, IPgSurf3StepCont and IPgSurf3StepCol. Logically these
        !are equivalent to IPgSurf3Data, IPgSurf3DataCont and
        !IPgSurf3DataCol, except that each data point is plotted as a rectangular column.
        !3D volume plots (i.e. representations of arrays of (x,y,z) data) can be drawn using
        !IPgVolume3Col (cell-specific colours) or IPgVolume3Cont (colour contours).
        !Since much 'real world' data does not exist in a regular gridded form, a data filter
        !routine called IPgXYZToGrid is provided which can convert random (x,y,z) data to a
        !2D gridded form which is suitable for routines such as IPgContour2Reg,IPgSurf3Data, etc. The complementary routine IPgXYZSearchBox controls the
        !behaviour of this filter.
    end subroutine

    subroutine IPgConFill2Irreg(ZVALUE,NXDIM,NYDIM,ZCONTR,XGRID,YGRID)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM) ! Array of values to plot
        real ZCONTR(:) ! Array of contour heights
        real XGRID(:) ! Array of X grid points
        REAL YGRID(:) ! Array of Y grid points
        ! Plots the supplied data in the form of a 2D fill-based contour plot on a user specified
        ! grid, which may be irregularly spaced. If the current graph type specified to
        ! IPgNewPlot is not a 2D Z array plot, calling IPgConFill2Reg has no effect.
        ! PG Contour/Surface Plots INTERACTER Subroutine Reference
        ! 2-58
        ! NXDIM and NYDIM specify the declared dimensions of ZVALUE in the calling
        ! program. However, the actual number of x and y grid points contained in ZVALUE,XGRID and YGRID which are to be plotted should be specified via the NVALUE
        ! argument to IPgNewPlot. The number of contours to be plotted should have also
        ! been specified in a preceding call to IPgNewPlot via the NSET argument. As far as
        ! the PG routines are concerned a contour is one 'data set'. This places an upper limit on
        ! the number of contours which can be plotted (see IPgNewPlot).
        ! ZCONTR defines the heights at which contours will be plotted. Colour and fill style for
        ! each contour can be defined via a call to IPgStyle, specifying the contour number.
        ! Areas of the plot can be left unfilled by setting the fill style for a given contour height
        ! to zero. The style of each cell is determined as follows :
        ! Style of cells below ZCONTR(1) are set by IPgStyle(1,...
        ! Style of cells below ZCONTR(2) are set by IPgStyle(2,...
        ! ...
        ! Style of cells below ZCONTR(NSET-1) are set by IPgStyle(NSET-1,...
        ! Style of cells above ZCONTR(NSET-1) are set by IPgStyle(NSET,...
        ! Hence the ZCONTR array should contain (NSET-1) monotonically increasing contour
        ! heights, otherwise IPgConFill2Irreg will set the error flag to 43 and exit.
        ! The algorithm used by IPgConFill2Irreg involves filling each cell of the grid
        ! with a rectangle of the appropriate style, based on the average height of the four grid
        ! intersections which define that cell. Optionally, a granularity factor can be specified via
        ! IPgConFill2Granul, which causes each grid cell to be sub-divided into NxN
        ! equally sized sub-cells. The height of each sub-cell is then estimated based on its
        ! proximity to each of the 4 main cell corners and the sub-cell is filled accordingly. This
        ! can substantially improve resolution without increasing the size of the ZVALUE array.
        ! If an irregularly spaced grid is not required, the alternative routine IPgConFill2Reg
        ! can be used instead, since it uses the same algorithm.
        ! There are no significant internal data overheads in using this routine, but best results
        ! will be obtained by experimenting with differing combinations of grid size and
        ! granularity. There is no specific limit on grid size other than device resolution.
        ! IPgConFill2Irreg allows the contour plot to be rescaled by changing the
        ! arguments to IPgUnits. i.e. It is possible to zoom in and out of the plot. This is
        ! because IPgConFill2Irreg knows the values of X and Y used to generate the
        ! ZVALUE array. IPgConFill2Reg on the other hand has to assume that the range of
        ! values specified to IPgUnits were also the range of values used to generate ZVALUE
        ! and therefore scales the resulting contour plot to fill the PG area.
        ! INTERACTER Subroutine Reference PG Contour/Surface Plots
        ! 2-59
        !e.g. PARAMETER (NXDIM=50,NYDIM=50,NC=10,NC1=NC-1)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM),ZCONTR(NC1)
        !REAL XGRID(NXDIM),YGRID(NYDIM)
        !C get data from some source
        !CALL MYDATA(ZVALUE,XGRID,YGRID,NXDIM,NYDIM,NX,NY)
        !C generate a 2 dimensional contour plot of data in ZVALUE
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,NC,NVALUE,PgLayFill,0)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !C generate a regular grid for sake of this example
        !DO 100 IX = 1,NX
        !XGRID(IX) = XMIN + FLOAT(IX-1)*(XMAX-XMIN)/FLOAT(NX-1)
        !100 CONTINUE
        !DO 200 IY = 1,NY
        !YGRID(IY) = YMIN + FLOAT(IY-1)*(YMAX-YMIN)/FLOAT(NY-1)
        !200 CONTINUE
        !C generate some arbitrary contour heights
        !CALL IRealMaxMin2(ZVALUE,NXDIM,NYDIM,NX,NY,ZMIN,ZMAX)
        !DO 300 IC = 1,NC1
        !ZCONTR(IC) = ZMIN + FLOAT(IC)*(ZMAX-ZMIN)/FLOAT(NC)
        !300 CONTINUE
        !CALL IPgConFill2Granul(4)
        !CALL IPgConFill2Irreg(ZVALUE,NXDIM,NYDIM,ZCONTR,XGRID,YGRID)
        !Errors :
        !ErrContHeights (43) : Contour heights do not increase monotonically
    end subroutine

    subroutine IPgConFill2Reg(ZVALUE,NXDIM,NYDIM,ZCONTR)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM)
        ! = Array of values to plot
        real ZCONTR(*) ! Array of contour heights
        ! Plots the supplied data in the form of a 2D fill-based contour plot on a regularly spaced
        ! grid. If the current graph type specified to IPgNewPlot is not a 2D contour plot,calling IPgConFill2Reg will have no effect.
        ! Operation of IPgConFill2Reg is the same as IPgConFill2Irreg, except that :
        ! (a) No grid point arrays are specified, so each cell is equally sized.
        ! (b) IPgConFill2Reg has to assume that the range of values specified to
        ! IPgUnits were also the range of values used to generate ZVALUE and therefore
        ! scales the resulting contour plot to fill the PG area. To rescale such a plot, use the
        ! alternative routine IPgConFill2Irreg.
        ! PG Contour/Surface Plots INTERACTER Subroutine Reference
        ! 2-60
        !e.g. PARAMETER (NXDIM=50,NYDIM=50,NC=10,NC1=NC-1)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM),ZCONTR(NC1)
        !:
        !C get data from some source
        !CALL MYDATA(ZVALUE,NXDIM,NYDIM,NX,NY)
        !C generate a 2 dimensional contour plot of data in ZVALUE
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,NC,NVALUE,PgLayFill,0)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !C generate some arbitrary contour heights
        !CALL IRealMaxMin2(ZVALUE,NXDIM,NYDIM,NX,NY,ZMIN,ZMAX)
        !DO 100 IC = 1,NC1
        !ZCONTR(IC) = ZMIN + FLOAT(IC)*(ZMAX-ZMIN)/FLOAT(NC)
        !100 CONTINUE
        !CALL IPgConFill2Granul(4)
        !CALL IPgConFill2Reg(ZVALUE,NXDIM,NYDIM,ZCONTR)
        !Errors :
        !ErrContHeights (43) : Contour heights do not increase monotonically
    end subroutine

    subroutine IPgContour2Irreg(ZVALUE,NXDIM,NYDIM,ZCONTR,XGRID,YGRID)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM)
        ! = Array of values to plot
        real ZCONTR(*) ! Array of contour heights
        real XGRID(*) ! Array of X grid points
        real YGRID(*) ! Array of Y grid points
        ! Short-name : PG2COI
        ! Plots the supplied data in the form of a 2D line-based contour plot on a user specified
        ! grid, which may be irregularly spaced. If the current graph type specified to
        ! IPgNewPlot is not a 2D Z array plot, calling IPgContour2Reg has no effect.
        ! NXDIM and NYDIM specify the declared dimensions of ZVALUE in the calling
        ! program. However, the actual number of x/y grid points contained in ZVALUE, XGRID
        ! and YGRID which are to be plotted should be specified via the NVALUE argument to
        ! IPgNewPlot. The number of contours to be plotted should have also been specified
        ! in a call to IPgNewPlot via the NSET argument. As far as the PG routines are
        ! concerned a contour is one data set. This places an upper limit on the number of
        ! contours which can be plotted (see IPgNewPlot).
        ! ZCONTR defines the heights at which contours will be plotted. This array must consist
        ! of monotonically increasing values, otherwise IPgContour2Irreg will set the error
        ! flag to 43 and exit.
        ! Colour and line style can be defined for each contour via a call to IPgStyle,specifying the contour number. However, due to the nature of the algorithm used by
        ! IPgContour2Irreg, line style selection may not operate satisfactorily. See the
        ! notes on IPgContour2Irreg versus IPgContour2Reg.
        ! INTERACTER Subroutine Reference PG Contour/Surface Plots
        ! 2-61
        ! The algorithm used by IPgContour2Irreg involves a search which scans each cell
        ! of the grid in a top-to-bottom, left-to-right manner, drawing contour segments within
        ! each cell as it finds them. Hence, IPgContour2Irreg has no concept of a
        ! continuous contour. As a result, it has minimal memory overheads but may not be
        ! suitable for all types of output device. Pen plotters in particular give poor results and
        ! non-solid line types may not reproduce well on monochrome devices.
        ! If an irregularly spaced grid is not required, the alternative routine IPgContour2Reg
        ! may prove more appropriate, since that uses a different algorithm. The respective merits
        ! of IPgContour2Irreg and IPgContour2Reg can be summarised as follows :
        !   IPgContour2Irreg is somewhat smaller than IPgContour2Reg in terms of
        ! code size and has no workspace requirements.
        !   The number of X and Y grid points is not limited by IPgContour2Irreg and
        ! the number of contours is only limited by the supported number of data sets (as
        ! described under IPgNewPlot). The same is only true of IPgContour2Reg
        ! under Fortran 90 compilers.
        !   IPgContour2Irreg allows the contour plot to be rescaled by changing the
        ! arguments to IPgUnits. i.e. It is possible to zoom in and out of the plot. This is
        ! because IPgContour2Irreg knows the values of X and Y used to generate the
        ! ZVALUE array. IPgContour2Reg on the other hand has to assume that the range
        ! of values specified to IPgUnits were also the range of values used to generate
        ! ZVALUE and therefore scales the resulting contour plot to fill the PG area.
        !   IPgContour2Reg can plot markers on each contour whereas
        ! IPgContour2Irreg cannot. This includes numeric or user-defined labels on the
        ! contour lines themselves.
        !   IPgContour2Reg is more suitable for use on vector oriented displays (such as
        ! plotters) since it follows the path of individual contours rather than drawing many
        ! separate line segments. For the same reason non-solid line types reproduce better
        ! when plotted by IPgContour2Reg because line patterns are not constantly
        ! reselected (and hence reinitialised).
        ! For a fill based contour plot, see the alternative routine IPgConFill2Irreg.
        ! PG Contour/Surface Plots INTERACTER Subroutine Reference
        ! 2-62
        !e.g. PARAMETER (NXDIM=50,NYDIM=50,NC=10)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM),ZCONTR(NC)
        !REAL XGRID(NXDIM),YGRID(NYDIM)
        !:
        !C get data from some source
        !CALL MYDATA(ZVALUE,XGRID,YGRID,NXDIM,NYDIM,NX,NY)
        !C generate a 2 dimensional contour plot of data in ZVALUE
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,NC,NVALUE,0,0)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !C generate a regular grid for sake of this example
        !DO 100 IX = 1,NX
        !XGRID(IX) = XMIN + FLOAT(IX-1)*(XMAX-XMIN)/FLOAT(NX-1)
        !100 CONTINUE
        !DO 200 IY = 1,NY
        !YGRID(IY) = YMIN + FLOAT(IY-1)*(YMAX-YMIN)/FLOAT(NY-1)
        !200 CONTINUE
        !C generate some arbitrary contour heights
        !CALL IRealMaxMin2(ZVALUE,NXDIM,NYDIM,NX,NY,ZMIN,ZMAX)
        !DO 300 IC = 1,NC
        !ZCONTR(IC) = ZMIN + FLOAT(IC)*(ZMAX-ZMIN)/FLOAT(NC+1)
        !300 CONTINUE
        !CALL IPgContour2Irreg(ZVALUE,NXDIM,NYDIM,ZCONTR,XGRID,YGRID)
        !Errors :
        !ErrContHeights (43) : Contour heights do not increase monotonically
    end subroutine

    subroutine IPgContour2Reg(ZVALUE,NXDIM,NYDIM,ZCONTR)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZCONTR(*) ! Array of contour heights
        real ZVALUE(NXDIM,NYDIM)
        ! = Array of values to plot
        ! Short-name : PG2CON
        ! Plots the supplied data in the form of a 2D line-based contour plot on a regularly
        ! spaced grid. If the current graph type, as specified to IPgNewPlot, is not a 2D Z
        ! array plot, then calling IPgContour2Reg will have no effect.
        ! NXDIM and NYDIM specify the declared dimensions of ZVALUE in the calling
        ! program. However, the actual number of x/y grid points contained in ZVALUE which
        ! are to be plotted should be specified via the NVALUE argument to IPgNewPlot. The
        ! number of contours to be plotted should have also been specified in a call to
        ! IPgNewPlot via the NSET argument. As far as the PG routines are concerned a
        ! contour is one 'data set'. This places an upper limit on the number of contours which
        ! can be plotted (see IPgNewPlot).
        ! ZCONTR defines the heights at which contours will be plotted. These must increase
        ! monotonically, otherwise IPgContour2Reg will set the error flag to 43 and exit.
        ! INTERACTER Subroutine Reference PG Contour/Surface Plots
        ! 2-63
        ! Colour, line style and an optional marker type can be defined for each contour via calls
        ! to IPgStyle and IPgMarker, specifying the contour number. In particular, label
        ! strings can be plotted within each contour line by setting ISTYL2 to 5 or 6 in earlier
        ! calls to IPgStyle. A style value of 5 causes the value in ZCONTR to be plotted as a
        ! numeric value string. Alternatively, a style setting of 6 causes a user-defined string to
        ! be plotted. This is set via IPgContourLabel.
        ! The algorithm used by IPgContour2Reg involves a search which traces each
        ! individual contour at each specified height. As such it is well suited to all types of
        ! output device, including pen plotters.
        ! An internal workspace array is used which is allocated dynamically in versions of the
        ! library built with a Fortran 90 compiler. Under Fortran 77 compilers, a static workspace
        ! of 100k bytes is used which imposes a limit on the total complexity of the plot which
        ! can be generated :
        ! NX * NY * NC =< 400,000
        ! Where : NX = Number of X grid points ) As defined in
        ! NY = Number of Y grid points ) previous call
        ! NC = Number of Contours ) to IPgNewPlot
        ! Hence, under a Fortran 77 compiler, there is a trade off between grid density and
        ! number of contours.
        ! In some situations, the alternative routine IPgContour2Irreg may prove more
        ! appropriate, since that uses a different algorithm. The respective merits of
        ! IPgContour2Reg and IPgContour2Irreg are discussed in the earlier section
        ! describing IPgContour2Irreg.
        ! For a fill based contour plot, see the alternative routine IPgConFill2Reg.
        !e.g. PARAMETER (NXDIM=50,NYDIM=50,NC=10)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM),ZCONTR(NC)
        !C get data from some source
        !CALL MYDATA(ZVALUE,NXDIM,NYDIM,NX,NY)
        !C generate a 2 dimensional contour plot of data in ZVALUE
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,NC,NVALUE,0,0)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !C generate some arbitrary contour heights
        !CALL IRealMaxMin2(ZVALUE,NXDIM,NYDIM,NX,NY,ZMIN,ZMAX)
        !DO 100 IC = 1,NC
        !ZCONTR(IC) = ZMIN + FLOAT(IC)*(ZMAX-ZMIN)/FLOAT(NC+1)
        !100 CONTINUE
        !CALL IPgContour2Reg(ZVALUE,NXDIM,NYDIM,ZCONTR)
        !Errors :
        !ErrContHeights (43) : Contour heights do not increase monotonically
        !PG Contour/Surface Plots INTERACTER Subroutine Reference
        !2-64
    end subroutine

    subroutine IPgSurf3Data(ZVALUE,NXDIM,NYDIM)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM)
        ! = Array of values to plot
        ! Short-name : PGCON3
        ! Draws a 3D contour plot using the same surface plotting routine as IPgSurf3Func,except that the plot is generated from data instead of using an EXTERNAL function.
        ! IPgSurf3Data should be preceded by a call to IPgNewPlot which sets the graph
        ! type to .Z array., the number of data sets to 1 and the layout to 3D (i.e. the ITYPE,NSET and LAYOUT arguments to IPgNewPlot must be PgZarrayPlot, 1 and
        ! PgLay3D respectively). The colour of the surface is determined in one of two ways:
        ! (1) By default, the surface is plotted in a uniform colour at all heights. The upper/lower
        ! surface colours can be specified separately via IPgStyle(1/2,..).
        ! (2) If PgLayContGrad is also specified in the LAYOUT argument to IPgNewPlot,graduated colouring is used. Each tile on the surface is plotted in a colour which is
        ! proportional to its Z height, within the start/end colour range set by
        ! IPgStyle(1/2,..). Internally, this option uses the 24-bit colour model, so the
        ! output device or format must support this model for best results. See
        ! IGrColourModel. Note : There is no need to explicitly select the 24-bit colour
        ! model or to specify start/end colours using this model.
        ! NXDIM and NYDIM must contain the declared size of ZVALUE in the calling program,though the actual size of the contour grid is specified in the NVALUE argument of the
        ! preceding call to IPgNewPlot. If NVALUE is passed as NX and NY for example, then
        ! the ZVALUE array should contain NX*NY values defining the Z values of the grid
        ! intersections. These values are equivalent to the real function results returned by the
        ! external function when using IPgSurf3Func.
        ! In all other respects, IPgSurf3Data is equivalent to IPgSurf3Func. Refer to the
        ! IPgSurf3Func documentation for further information.
        !e.g. PARAMETER (NXDIM=50,NYDIM=50)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM)
        !:
        !C get data from some source
        !CALL MYDATA(ZVALUE,NXDIM,NYDIM,NX,NY)
        !C plot a 3 dimensional contour plot of data in ZVALUE
        !C with a variable grid size
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,1,NVALUE,PgLay3D+PgLayVariable,0)
        !CALL IPgElevation(ANGLE)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !CALL IRealMaxMin2(ZVALUE,NXDIM,NYDIM,NX,NY,ZMIN,ZMAX)
        !CALL IPgUnitsZ(ZMIN,ZMAX)
        !CALL IPgSurf3Data(ZVALUE,NXDIM,NYDIM)
        !CALL IPgXLabel('X axis',' ')
        !CALL IPgYLabelLeft('Y axis',' ')
        !CALL IPgZLabelLeft('Z axis','T')
        !INTERACTER Subroutine Reference PG Contour/Surface Plots
        !2-65
    end subroutine

    subroutine IPgSurf3DataCol(ZVALUE,NXDIM,NYDIM,ICOL)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM) ! Array of values to plot
        integer ICOL(NXDIM,NYDIM) ! Array of colour values
        ! Draws a 3D contour plot using the same surface plotting routine as IPgSurf3Data,except that the colour of each point on the surface can be specified individually in the
        ! ICOL array. Specify PgLayCol or PgLayColTile in the LAYOUT argument to
        ! IPgNewPlot when using this routine.
        ! When PgLayCol is specified to IPgNewPlot, ICOL should contain
        ! (NXDIM,NYDIM) vertex-specific colour values. When PgLayColTile is specified
        ! to IPgNewPlot, ICOL should contain (NXDIM-1,NYDIM-1) tile-specific colour
        ! values. In either case, ICOL should still be dimensioned to (NXDIM,NYDIM).
        ! When tile-specific colours are selected, a tile colour of -1 can be specified to indicate
        ! that a tile should be transparent (unfilled). This facility is not available for vertexspecific
        ! colours, where the colour of each tile is based on the average RGB value of the
        ! four surrounding vertices.
        !e.g. PARAMETER (NXDIM=50,NYDIM=50)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM)
        !INTEGER ICOL(NXDIM,NYDIM)
        !CALL MYDATA(ZVALUE,NXDIM,NYDIM,NX,NY)
        !DO 100 IY = 1,NY
        !DO 100 IX = 1,NX
        !ICOL(IX,IY) = 255*IX*IY/(NX*NY)
        !100 CONTINUE
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNew Plot(PgZarrayPlot,1,nvalue,PgLay3D+PgLayCol)
        !CALL IPgSurf3DataCol(ZVALUE,NXDIM,NYDIM,ICOL)
    end subroutine

    subroutine IPgSurf3DataCont(ZVALUE,NXDIM,NYDIM,ZCONTR)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM)
        ! = Array of values to plot
        real ZCONTR(*) ! Array of contour heights
        ! Short-name : PG3CON
        ! Draws a 3D contour plot in the same manner as IPgSurf3Data except that contour
        ! heights are specified, allowing height dependent colouring of cells within the plot. The
        ! colour of each cell in the surface is determined as follows :
        ! Cells below ZCONTR(1) are plotted in colour set by IPgStyle(1,...
        ! Cells below ZCONTR(2) are plotted in colour set by IPgStyle(2,...
        ! ...
        ! Cells below ZCONTR(NSET-1)
        ! are plotted in colour set by IPgStyle(NSET-1,...
        ! Cells above ZCONTR(NSET-1)
        ! are plotted in colour set by IPgStyle(NSET,...
        ! PG Contour/Surface Plots INTERACTER Subroutine Reference
        ! 2-66
        ! where NSET is the number of contours specified in the preceding call to
        ! IPgNewPlot. Hence the ZCONTR array should contain (NSET-1) monotonically
        ! increasing contour heights. If NSET was specified as 1, IPgSurf3Data must be
        ! called rather than IPgSurf3DataCont, since a uniformly coloured surface plot will
        ! be assumed. If transparent cells are required at a given contour height, set the fill style
        ! for that height to zero ('no fill').
        ! If IPgGridLines(-1) has been called, each cell is drawn in the background colour
        ! using a solid fill. In this case, the grid lines around the cell are drawn in the appropriate
        ! colour instead, selected in the same manner as above.
        ! In all other respects this routine is the same as IPgSurf3Data. Refer to the
        ! IPgSurf3Data documentation for more information.
        !e.g. PARAMETER (NXDIM=50,NYDIM=50,NC=9)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM),ZCONTR(NC)
        !:
        !C get data from some source
        !CALL MYDATA(ZVALUE,NXDIM,NYDIM,NX,NY)
        !C plot a 3 dimensional contour plot of data in ZVALUE
        !C with a variable grid size
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,NC+1,NVALUE,1 PgLay3D+PgLayCont+PgLayVariable)
        !CALL IPgElevation(ANGLE)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !CALL IRealMaxMin2(ZVALUE,NXDIM,NYDIM,NX,NY,ZMIN,ZMAX)
        !CALL IPgUnitsZ(ZMIN,ZMAX)
        !C generate some arbitrary contour heights
        !DO 100 IC = 1,NC
        !ZCONTR(IC) = ZMIN + FLOAT(IC)*(ZMAX-ZMIN)/FLOAT(NC+1)
        !100 CONTINUE
        !CALL IPgSurf3DataCont(ZVALUE,NXDIM,NYDIM,ZCONTR)
        !CALL IPgXLabel('X axis',' ')
        !CALL IPgYLabelLeft('Y axis',' ')
        !CALL IPgZLabelLeft('Z axis','T')
        !Errors :
        !ErrContHeights (43) : Contour heights do not increase monotonically
    end subroutine

    subroutine IPgSurf3Func(ZFUNC)
        EXTERNAL ZFUNC ! Name of external function to plot
        ! Short-name : PGFUN3
        ! Plots values of the supplied function in the form of a 3D surface in the current PG area.
        ! The number of x and y data values to plot and the layout are as defined in a previous
        ! call to IPgNewPlot. The plotting units are as defined to IPgUnits/IPgUnitsZ
        ! and the style of presentation should have been defined using IPgStyle.
        ! IPgSurf3Func should be preceded by a call to IPgNewPlot which sets the plot
        ! type to .Function., the number of data sets to 1 and the layout to 3D (i.e. the ITYPE,NSET and LAYOUT arguments to IPgNewPlot must be PgFuncPlot, 1 and
        ! PgLay3D respectively). The colour of the surface is determined in one of two ways:
        ! (1) By default, the surface is plotted in a uniform colour at all heights. The upper/lower
        ! surface colours can be specified separately via IPgStyle(1/2,..).
        ! INTERACTER Subroutine Reference PG Contour/Surface Plots
        ! 2-67
        ! (2) If PgLayContGrad is specified in the LAYOUT argument to IPgNewPlot,graduated colouring is used. Each tile on the surface is plotted in a colour which is
        ! proportional to its Z height, within the start/end colour range set by
        ! IPgStyle(1/2,..). Internally, this option uses the 24-bit colour model, so the
        ! output device or format must support this model for best results. See
        ! IGrColourModel. Note : There is no need to explicitly select the 24-bit colour
        ! model or to specify start/end colours using this model.
        ! A number of points should be noted when plotting 3D surfaces using this and other
        ! routines in this group:
        !   The supplied function must take 2 real arguments (x,y) and return a real result (z).
        !   The contour plot is drawn using a back-to-front solid fill method, (also known as
        ! the Painter's method, for obvious reasons). This provides a fast method of hidden
        ! surface removal, with minimal memory requirements. Plots drawn on displays
        ! which do not support solid fill primitives will take significantly longer to draw, but
        ! will give the same result so long as at least two graphics colours are supported.
        !Hardcopy is best generated using something other than the HP-GL driver (e.g. HPGL/
        !2, PostScript, raster, CGM, etc.) or by saving and exporting a screen image.
        !HP-GL plotter output can be used if it is to be post-processed subsequently by
        !INTPRINT or IGrReplay, since fill information is included in the HP-GL file.
        !  The angle of rotation of the view can be specified using IPgRotation. The
        !default rotation angle is 0 degrees.
        !  The angle of elevation of the view can be specified using IPgElevation. The
        !default elevation is 22.5 degrees which gives the largest plot which is guaranteed to
        !fit within the 2 dimensional limits of the PG area. Greater elevation angles are
        !supported, but some Y values may be plotted outside the PG area as a result.
        !  IPgUnitsZ should be used to define the Z range.
        !  Z values returned by the supplied function are mapped onto half the height of the
        !PG area, regardless of the viewing angle. Z values which would go outside the Z
        !range are clipped and will appear as a flat area at the minimum or maximum limit of
        !the projected plot.
        !  The number of x and y grid points need not be equal, but by default the size of the
        !grid is fixed. Obviously the relative density of x and y grid lines varies in this case.
        !Alternatively the distance between grid points can be fixed, by specifying a variable
        !grid size to IPgNewPlot.
        !  The axes and scale routines IPgAxes, IPgXScale, IPgYScaleLeft and
        !IPgZScale can all be used for 3D function plots, but should be called before
        !IPgSurf3Func.
        !  If labels are required, the following routines are available :
        !Lower X axis : IPgXLabel
        !Upper X axis : IPgXLabelTop
        !Lower Y axis : IPgYLabelLeft
        !Upper Y axis : IPgYLabelRight
        !Left Z axis : IPgZLabelLeft
        !Right Z axis : IPgZLabelRight
        !PG Contour/Surface Plots INTERACTER Subroutine Reference
        !2-68
        !(Note : The advice in some earlier releases about using IPgXLabel to label both
        !the X and Y axes and using IPgYLabelLeft to label the Z axis, no longer
        !applies. The label plotting functions are now sensitive to the current graph type
        !being a 3D surface plot.)
        !  The style of the upper and lower surfaces can be defined separately using
        !IPgStyle with ISET values of 1 and 2 respectively. So, each 'side' of the surface
        !can be different colours.
        !  By default, grid lines are drawn in both X and Y directions. The colour and
        !direction of these grid lines can be set by IPgGridLines and
        !IPgGridDirection.
        !See also IPgSurf3FuncCont which can plot individual grid cells in height
        !dependent colours.
        !e.g. INTEGER NVALUE(2)
        !EXTERNAL ZFUNC
        !C plot a 3 dimensional function with a variable grid size
        !NVALUE(1) = NXGRID
        !NVALUE(2) = NYGRID
        !CALL IPgNewPlot(PgFuncPlot,1,NVALUE,PgLay3D+PgLayVariable,0)
        !CALL IPgElevation(ANGLE)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !CALL IRealMaxMinFunc2(ZFUNC,XMIN,YMIN,XMAX,YMAX,1 NXGRID,NYGRID,ZMIN,ZMAX)
        !CALL IPgUnitsZ(ZMIN,ZMAX)
        !CALL IPgSurf3Func(ZFUNC)
        !CALL IPgXLabel('X axis',' ')
        !CALL IPgYLabelLeft('Y axis',' ')
        !CALL IPgZLabelLeft('Z axis','T')
        !:
    end subroutine

    
    subroutine IPgSurf3FuncCont(ZFUNC,ZCONTR)
        EXTERNAL ZFUNC ! Name of external function to plot
        real ZCONTR(*) ! Array of contour heights
        ! Short-name : PG3FUN
        ! Plots values of the supplied function in the form of a 3D surface in the same manner as
        ! IPgSurf3Func except that contour heights are specified, allowing height dependent
        ! colouring of cells within the plot. The colour of each cell in the surface is determined as
        ! follows :
        ! Cells below ZCONTR(1) are plotted in colour set by IPgStyle(1,...
        ! Cells below ZCONTR(2) are plotted in colour set by IPgStyle(2,...
        ! ...
        ! Cells below ZCONTR(NSET-1)
        ! are plotted in colour set by IPgStyle(NSET-1,...
        ! Cells above ZCONTR(NSET-1)
        ! are plotted in colour set by IPgStyle(NSET,...
        ! INTERACTER Subroutine Reference PG Contour/Surface Plots
        ! 2-69
        ! where NSET is the number of contours specified in the preceding call to
        ! IPgNewPlot. Hence the ZCONTR array should contain (NSET-1) monotonically
        ! increasing contour heights. If NSET was specified as 1, IPgSurf3Func must be
        ! called rather than IPgSurf3FuncCont, since a uniformly coloured surface plot will
        ! be assumed. If transparent cells are required at a given contour height, set the fill style
        ! for that height to zero ('no fill').
        ! If IPgGridLines(-1) has been called, each cell is drawn in the background colour
        ! using a solid fill. In this case, the grid lines around the cell are drawn in the appropriate
        ! colour instead, selected in the same manner as above.
        ! In all other respects this routine is the same as IPgSurf3Func. Refer to the
        ! IPgSurf3Func documentation for more information.
        !e.g. PARAMTER (NC=9)
        !INTEGER NVALUE(2)
        !EXTERNAL ZFUNC
        !REAL ZCONTR(NC)
        !:
        !C plot a 3 dimensional function with a variable grid size
        !NVALUE(1) = NXGRID
        !NVALUE(2) = NYGRID
        !CALL IPgNewPlot(PgFuncPlot,NC+1,NVALUE,1 PgLay3D+PgLayCont+PgLayVariable,0)
        !CALL IPgElevation(ANGLE)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !CALL IRealMaxMinFunc2(ZFUNC,XMIN,YMIN,XMAX,YMAX,1 NXGRID,NYGRID,ZMIN,ZMAX)
        !CALL IPgUnitsZ(ZMIN,ZMAX)
        !C generate some arbitrary contour heights
        !DO 100 IC = 1,NC
        !ZCONTR(IC) = ZMIN + FLOAT(IC)*(ZMAX-ZMIN)/FLOAT(NC+1)
        !100 CONTINUE
        !CALL IPgSurf3FuncCont(ZFUNC,ZCONTR)
        !CALL IPgXLabel('X axis',' ')
        !CALL IPgYLabelLeft('Y axis',' ')
        !CALL IPgZLabelLeft('Z axis','T')
        !:
    end subroutine

    subroutine IPgSurf3Step(ZVALUE,NXDIM,NYDIM)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM)
        ! = Array of values to plot
        ! Draws a stepped 3D surface plot in a similar manner toIPgSurf3Data, except that
        ! each data point is displayed as a rectangular column of the specified height.
        ! IPgSurf3Step should be preceded by a call to IPgNewPlot which specifies the
        ! ITYPE=PgZarrayPlot, NSET=1 and LAYOUT=PgLay3D+PgLayStepped. The
        ! colour of the surface is determined in one of two ways:
        ! (1) By default, every column in the surface is plotted in a uniform colour/style, which
        ! can be specified separately via IPgStyle(1,..).
        ! PG Contour/Surface Plots INTERACTER Subroutine Reference
        ! 2-70
        ! (2) If PgLayContGrad is also specified in the LAYOUT argument to IPgNewPlot,graduated colouring is used. Each column on the surface is plotted using a
        ! graduated fill, where the bottom colour is set via IPgStyle(1,..) and the top
        ! colour is determined by its Z height, where IPgStyle(2,..) sets the colour for
        ! a maximum Z height. Internally, this option uses the 24-bit colour model, so the
        ! output device or format must support this model for best results. See
        ! IGrColourModel. Note : There is no need to explicitly select the 24-bit colour
        ! model or to specify start/end colours using this model.
        ! NXDIM and NYDIM must contain the declared size of ZVALUE in the calling program,though the actual number of columns to be plotted is specified in the NVALUE
        ! argument of the preceding call to IPgNewPlot. If NVALUE is passed as NX and NY
        ! for example, then the ZVALUE array should contain NX*NY values defining the Z
        ! heights of each column.
        ! Stepped surfaces are plotted in a very similar manner to the continuous (sometimes
        ! known as 'carpet') plots drawn by other routines in this group. In particular, they share
        ! the following features:
        !   The stepped surface is drawn using a back-to-front polygon fill method, ("the
        ! Painter's method"). It therefore requires a raster rather than a vector oriented output
        ! device or format.
        !   The angle of rotation and elevation of the view can be specified using
        ! IPgRotation and IPgElevation.
        !   IPgUnitsZ defines the Z range.
        !   Z values in the supplied array are mapped onto half the height of the PG area,regardless of the viewing angle. Z values which would go outside the Z range are
        ! clipped.
        !   The x and y grid sizes need not be equal, but by default the size of the grid is fixed.
        ! The relative density of x and y grid lines varies in this case. Alternatively the
        ! distance between grid points can be fixed, by specifying a variable grid size to
        ! IPgNewPlot.
        !   The axes and scale routines IPgAxes, IPgXScale, IPgYScaleLeft and
        ! IPgZScale are all available for use with stepped 3D surfaces.
        !   All the labelling routines (IPgXLabel, etc.) operate in the same way as on other
        ! 3D surfaces.
        ! The position of X/Y axis tick marks, scale values and graticules are determined slightly
        ! differently on stepped surface plots, however. Since grid cell centres represent the
        ! actual data points, the scale is adjusted to fit between the centres of the first and last
        ! cells on each of the X and Y axes.
        ! INTERACTER Subroutine Reference PG Contour/Surface Plots
        ! 2-71
        !e.g. PARAMETER (NXDIM=50,NYDIM=50)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM)
        !:
        !C get data from some source
        !CALL MYDATA(ZVALUE,NXDIM,NYDIM,NX,NY)
        !C plot a stepped 3D surface from data in ZVALUE
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,1,NVALUE,PgLay3D+PgLayStepped,0)
        !CALL IPgElevation(ANGLE)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !CALL IRealMaxMin2(ZVALUE,NXDIM,NYDIM,NX,NY,ZMIN,ZMAX)
        !CALL IPgUnitsZ(ZMIN,ZMAX)
        !CALL IPgStyle(1,4,0,0,32,0)
        !CALL IPgSurf3Step(ZVALUE,NXDIM,NYDIM)
        !CALL IPgXLabel('X axis',' ')
        !CALL IPgYLabelLeft('Y axis',' ')
        !CALL IPgZLabelLeft('Z axis','T')
    end subroutine

    subroutine IPgSurf3StepCol(ZVALUE,NXDIM,NYDIM,ICOL)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM) ! Array of values to plot
        integer ICOL(NXDIM,NYDIM) ! Array of colour values
        ! Draws a stepped 3D surface plot using the same surface plotting routine as
        ! IPgSurf3Step, except that the colour of each column is specified individually in the
        ! ICOL array. Add PgLayCol to the LAYOUT argument to IPgNewPlot.
        ! ZVALUE should contain NVALUE(1)*NVALUE(2) column heights and ICOL should
        ! contain the same number of corresponding colour values (where NVALUE is as defined
        ! to IPgNewPlot). Any columns for which a colour value of -1 is specified will not be
        ! drawn.
        !e.g. PARAMETER (NXDIM=50,NYDIM=50)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM)
        !INTEGER ICOL(NXDIM,NYDIM)
        !CALL MYDATA(ZVALUE,NXDIM,NYDIM,NX,NY)
        !DO 100 IY = 1,NY
        !DO 100 IX = 1,NX
        !ICOL(IX,IY) = 255*IX*IY/(NX*NY)
        !100 CONTINUE
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,1,NVALUE,1 PgLay3D+PgLayStepped+PgLayCol,0)
        !CALL IPgSurf3StepCol(ZVALUE,NXDIM,NYDIM,ICOL)
        !PG Contour/Surface Plots INTERACTER Subroutine Reference
        !2-72
    end subroutine

    subroutine IPgSurf3StepCont(ZVALUE,NXDIM,NYDIM,ZCONTR)
        integer NXDIM ! First declared dimension of ZVALUE
        integer NYDIM ! Second declared dimension of ZVALUE
        real ZVALUE(NXDIM,NYDIM)
        ! = Array of values to plot
        real ZCONTR(*) ! Array of contour heights
        ! Draws a stepped 3D contour plot in the same manner as IPgSurf3Step except that
        ! contour heights are specified, allowing height dependent colouring of each column
        ! within the plot. Add PgLayCont to the LAYOUT argument to IPgNewPlot when
        ! using this routine. The colour of each column is determined as follows :
        ! Columns below ZCONTR(1)are plotted in colour set by IPgStyle(1,...
        ! Columns below ZCONTR(2)are plotted in colour set by IPgStyle(2,...
        ! ...
        ! Columns below ZCONTR(NSET-1)
        ! are plotted in colour set by IPgStyle(NSET-1,...
        ! Columns above ZCONTR(NSET-1)
        ! are plotted in colour set by IPgStyle(NSET,...
        ! where NSET is the number of contours specified in the preceding call to
        ! IPgNewPlot. Hence the ZCONTR array should contain (NSET-1) monotonically
        ! increasing contour heights. If NSET was specified as 1, IPgSurf3Step should be
        ! called rather than IPgSurf3StepCont, since a uniformly coloured surface plot will
        ! be assumed. If columns are not to be plotted at a given contour height, set the fill style
        ! for that height to zero ('no fill').
        ! In all other respects this routine is the same as IPgSurf3Step. Refer to the
        ! IPgSurf3Step documentation for more information.
        !e.g. PARAMETER (NXDIM=50,NYDIM=50,NC=9)
        !INTEGER NVALUE(2)
        !REAL ZVALUE(NXDIM,NYDIM),ZCONTR(NC)
        !:
        !C get data from some source
        !CALL MYDATA(ZVALUE,NXDIM,NYDIM,NX,NY)
        !C plot a stepped 3 dimensional contour plot of data in ZVALUE
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !CALL IPgNewPlot(PgZarrayPlot,NC+1,NVALUE,1 PgLay3D+PgLayStepped+PgLayCont,0)
        !CALL IPgElevation(ANGLE)
        !CALL IPgUnits(XMIN,YMIN,XMAX,YMAX)
        !CALL IRealMaxMin2(ZVALUE,NXDIM,NYDIM,NX,NY,ZMIN,ZMAX)
        !CALL IPgUnitsZ(ZMIN,ZMAX)
        !C generate some arbitrary contour heights
        !DO 100 IC = 1,NC
        !ZCONTR(IC) = ZMIN + FLOAT(IC)*(ZMAX-ZMIN)/FLOAT(NC+1)
        !100 CONTINUE
        !CALL IPgSurf3StepCont(ZVALUE,NXDIM,NYDIM,ZCONTR)
        !CALL IPgXLabel('X axis',' ')
        !CALL IPgYLabelLeft('Y axis',' ')
        !CALL IPgZLabelLeft('Z axis','T')
        !Errors :
        !ErrContHeights (43) : Contour heights do not increase monotonically
        !INTERACTER Subroutine Reference PG Contour/Surface Plots
        !2-73
    end subroutine

    subroutine IPgVolume3Col(ICOLR,NXDIM,NYDIM,NZDIM)
        integer NXDIM ! First declared dimension of ICOLR
        integer NYDIM ! Second declared dimension of ICOLR
        integer NZDIM ! Third declared dimension of ICOLR
        integer ICOLR(NXDIM,NYDIM,NZDIM) ! Array of grid cell colours
        ! Draws a 3D volume plot, where the colour of every (x,y,z) grid cell in the 3D
        ! presentation graphics space is defined by the ICOLR array. ICOLR should contain
        ! NVALUE(1) * NVALUE(2) * NVALUE(3) values, as defined to IPgNewPlot.
        ! Any cells for which a colour value of -1 is specified will not be plotted. Otherwise,every cell which is visible from the current viewing angle will be plotted as a 3D
        ! rectangle (a 'cube') in the colour specified by ICOLR. Nearly all of the other cells
        ! which will be obscured in the final plot are also omitted, to minimise plotting time.
        ! Each cell is drawn with an outline by default. The colour of this outline is determined
        ! by IPgGridLines, which can also be used to suppress the grid outline. The latter
        ! feature works best at high grid densities and where there is a significant degree of
        ! colour variation across the visible surface of the object being plotted.
        ! Virtually all of the routines which control viewing, scaling and labelling of 3D surface
        !plots are equally applicable to this plot type (e.g.IPgRotation, IPgElevation,etc.). The notable exceptions are IPgStyle, IPgKeyAll, IPgKeySingle and
        !IPgGridDirection.
        !e.g. PARAMETER (NXDIM=50,NYDIM=50,NZDIM=50)
        !INTEGER NVALUE(3)
        !INTEGER ICOLR(NXDIM,NYDIM,NZDIM)
        !CALL MYDATA(ICOLR,NXDIM,NYDIM,NZDIM,NX,NY,NZ)
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !NVALUE(3) = NZ
        !CALL IPgNewPlot(PgVolumePlot,1,NVALUE,PgLay3D+PgLayCol,0)
        !CALL IPgAxes
        !CALL IPgRotation(ANGLE)
        !CALL IPgVolume3Col(ICOLR,NXDIM,NYDIM,NZDIM)
    end subroutine

    subroutine IPgVolume3Cont(VALUE,NXDIM,NYDIM,NZDIM,CONTR)
        integer NXDIM ! First declared dimension of ICOLR
        integer NYDIM ! Second declared dimension of ICOLR
        integer NZDIM ! Third declared dimension of ICOLR
        real VALUE(NXDIM,NYDIM,NZDIM) ! Array of grid cell values
        real CONTR(*) ! Array of contour values
        ! Draws a 3D volume plot, where the colour of each (x,y,z) grid cell in the 3D
        ! presentation graphics space is determined by which contour it lies in, as defined by the
        ! VALUE and CONTR arrays. The VALUE array should contain NVALUE(1) *
        ! NVALUE(2) * NVALUE(3) values, as defined to IPgNewPlot.
        ! The colour of each cell is determined as follows :
        ! PG Contour/Surface Plots INTERACTER Subroutine Reference
        ! 2-74
        ! VALUE(x,y,z)<CONTR(1) plotted in colour set by IPgStyle(1
        ! VALUE(x,y,z)<CONTR(2) plotted in colour set by IPgStyle(2
        ! ...
        ! VALUE(x,y,z)<CONTR(NSET-1) plotted in colour set by IPgStyle(NSET-1
        ! VALUE(x,y,z)>=CONTR(NSET-1) plotted in colour set by IPgStyle(NSET
        ! where NSET is the number of contours specified in the preceding call to
        ! IPgNewPlot. Hence the CONTR array should contain (NSET-1) monotonically
        ! increasing contour heights. If cells in a particular contour are not to be plotted, set the
        ! fill style for that contour to zero ('no fill'). Otherwise, every cell which is visible from
        ! the current viewing angle will be plotted as a 3D rectangle (a 'cube') in the colour
        ! specified by IPgStyle. Nearly all of the other cells which will be obscured in the
        ! final plot are also omitted, to minimise plotting time.
        ! Each cell is drawn with an outline by default. The colour of this outline is determined
        ! by IPgGridLines, which can also be used to suppress the grid outline. The latter
        ! feature works best at high grid densities and where there is a significant degreee of
        ! colour variation across the visible surface of the object being plotted.
        ! Virtually all of the routines which control viewing, scaling and labelling of 3D surface
        !plots are equally applicable to this plot type (e.g.IPgRotation, IPgElevation,etc.). The only notable exception is IPgGridDirection.
        !e.g. PARAMETER (NXDIM=50, NYDIM=50, NZDIM=50)
        !PARAMETER (NCONT=10, NC1 =NCONT-1)
        !INTEGER NVALUE(3)
        !REAL VALUE(NXDIM,NYDIM,NZDIM)
        !REAL CONTR(NC1)
        !CALL MYDATA(VALUE,NXDIM,NYDIM,NZDIM,NX,NY,NZ)
        !NVALUE(1) = NX
        !NVALUE(2) = NY
        !NVALUE(3) = NZ
        !DO 100 ICONT = 1,NC1
        !CONTR(ICONT) = 0.1*ICONT
        !100 CONTINUE
        !CALL IPgNewPlot(PgVolumePlot,1,NVALUE,PgLay3D+PgLayCont,0)
        !CALL IPgAxes
        !CALL IPgRotation(ANGLE)
        !CALL IPgVolume3Cont(VALUE,NXDIM,NYDIM,NZDIM,CONTR)
        !Errors :
        !ErrContHeights (43) : Contour heights do not increase monotonically
    end subroutine

    subroutine IPgXYZSearchBox(BOXWID,BOXHGT)
        real BOXWID ! Width of IPgXYZToGrid search box ) Same units as
        real BOXHGT ! Height of IPgXYZToGrid search box ) IPgUnits
        ! Defines the size of the box around each rectangular grid point in IPgXYZToGrid
        ! which will be searched to calculate the Z height for that point. Increasing the size of
        ! this box may increase the accuracy of the results generated by IPgXYZToGrid, at the
        ! expense of increased computation time.
        ! The box size is specified in the same units as IPgUnits. Its default size is (0.1,0.1).
        !e.g. see IPgXYZToGrid
        !INTERACTER Subroutine Reference PG Contour/Surface Plots
        !2-75
    end subroutine

    subroutine IPgXYZToGrid(X,Y,Z,NPOINT,ZRECT,NXRECT,NYRECT,NXDIM,NYDIM)
        real X(*) ! Array of X co-ordinates of input data
        real Y(*) ! Array of Y co-ordinates of input data
        real Z(*) ! Array of Z heights of input data
        integer NPOINT ! Number of points in X, Y, Z arrays
        integer NXRECT ! X size of returned grid in ZRECT
        integer NYRECT ! Y size of returned grid in ZRECT
        integer NXDIM ! First declared dimension of ZRECT
        integer NYDIM ! Second declared dimension of ZRECT
        real ZRECT(NXDIM,NYDIM)
        ! = Output array of gridded Z heights
        ! Converts a list of randomly located Z heights to a rectangular grid which can be
        ! supplied as input to 2D/3D Z array plotting routines such as IPgSurf3Data,IPgSurf3DataCont and IPgContour2Reg. The resulting data can also be used
        ! with IPgContour2Irreg if regularly spaced grid lines are specified to that routine.
        ! The routine works by calculating a weighted average of the Z heights of all the points
        ! which lie in a search box around each point to be returned in the ZRECT array. A Z
        ! height is calculated for NXRECT * NYRECT points spread evenly across the extent of
        ! the PG area. The (x,y) co-ordinates in the X and Y arrays are therefore assumed to be
        ! expressed in terms of PG area units as set by IPgUnits. By default, the size of the
        ! search box is 0.1 x 0.1 (again, in term of PG area units), but the size of this box can be
        ! changed via IPgXYZSearchBox.
        ! IPgXYZToGrid has an internal limit on the number of points it can consider around
        ! any one grid point (i.e. a maximum number of points which can lie in the search box
        ! specified by IPgXYZSearchBox). This limit is 4095, so this is only likely to be met
        ! when the search box is particularly large or a very large volume of data is being filtered.
        ! Rather than aborting if this limit is met, IPgXYZToGrid simply bases its weighted Z
        ! calculation on the first 4095 neighbouring points and ignores any subsequent input
        ! values which are local to that grid point. Error code 51 is set in this case.
        ! By its nature, this is a numerically intensive routine. Its speed therefore relies heavily
        ! on factors such as the amount of data supplied, the size of the output grid, the search
        ! box size, the quality of the compiler and the power of the hardware.
        ! PG Contour/Surface Plots INTERACTER Subroutine Reference
        ! 2-76
        !e.g. PARAMETER (NXDIM=100,NYDIM=100,NCDIM=9,NCDIM1=NCDIM-1)
        !PARAMETER (MAXPT = 10000)
        !DIMENSION ZDATA(NXDIM,NYDIM)
        !REAL ZCONT(NCDIM1)
        !REAL X(MAXPT),Y(MAXPT),Z(MAXPT)
        !INTEGER NVAL(2)
        !C
        !DATA ZCONT/2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0/
        !C
        !OPEN(20,FILE='CONTOUR.DAT',STATUS='OLD')
        !READ(20,*) NPTS
        !NPTS = MIN(NPTS,MAXPT)
        !DO 10 IPT = 1,NPTS
        !READ(20,*) X(IPT),Y(IPT),Z(IPT)
        !10 CONTINUE
        !CLOSE(20)
        !NGRIDX = 50
        !NGRIDY = 50
        !C
        !NVAL(1) = NGRIDX
        !NVAL(2) = NGRIDY
        !CALL IPgNewPlot(PgZarrayPlot,NCDIM,NVAL,PgLayFill,0)
        !CALL IPgUnits(-1.0,-1.0,1.0,1.0)
        !DO 100 IC = 1,NCDIM
        !CALL IPgStyle(IC,4,0,0,IC*25,0)
        !100 CONTINUE
        !CALL IPgXYZSearchBox(0.2,0.2)
        !CALL IPgXYZToGrid(X,Y,Z,NPTS,ZDATA,NGRIDX,NGRIDY,NXDIM,NYDIM)
        !CALL IPgConFill2Granul(5)
        !CALL IPgConFill2Reg(ZDATA,NXDIM,NYDIM,ZCONT)
        !Errors :
        !ErrSearchBox (51) : A search box contains too many points
        !INTERACTER Subroutine Reference PG Area Primitives
        !2-77
        !2.5 Group PG(5) : PG Area Primitives
        !This group provides a bridge between the lower level graphics primitives in the
        !GD/GC/GP/GI groups and the higher level Presentation Graphics routines. They allow
        !co-ordinate conversion between the two sets of routines and provide basic 2D/3D
        !line/polygon drawing primitives.
        !The IPgUnitsToGrUnits and IPgUnitsFromGrUnits routines convert
        !between PG and main graphics area 2D co-ordinates. IPgUnitsToGrUnits3
        !converts a 3D PG area co-ordinate triplet to a 2D main graphics area equivalent.
        !IPgJoin2, IPgPolyLine2 and IPgPolygonComplex2 can be used to draw
        !lines, polylines and polygons in the 2D PG area. IPgJoin3, IPgPolyLine3 and
        !IPgPolygonComplex3 perform the same tasks in the 3D PG area.
    end subroutine

    subroutine IPgJoin2(XPG1,YPG1,XPG2,YPG2)
        real XPG1 ! 2D PG area X co-ordinate/Angle to draw from
        real YPG1 ! 2D PG area Y co-ordinate/Radius to draw from
        real XPG2 ! 2D PG area X co-ordinate/Angle to draw to
        real YPG2 ! 2D PG area Y co-ordinate/Radius to draw to
        ! Draws a line between the two specified co-ordinates (XPG1,YPG1) and (XPG2,YPG2)
        ! in the 2D Presentation Graphics plotting area. This routine is functionally equivalent to
        ! IGrJoin, except that the co-ordinates are based on the units defined via IPgUnits
        ! for a Cartesian plot or IPgUnitsPolar for a polar plot. Angles for polar plots are
        ! measured in degrees, anti-clockwise from the 3-o'clock position. The style of the line is
        ! determined by the routines in the GS subroutine group (IGrColourN etc.)
        ! (XPG2,YPG2) becomes the current plotting position.
        !e.g.
        !C 2D graph type
        !CALL IPgNewPlot(PgLinePlot,1,NVALUE,0,0)
        !CALL IPgUnits(0.0,0.0,1000.0,500.0)
        !C draw a line horizontally across the centre of the PG area
        !CALL IPgJoin2(0.0,250.0,1000.0,250.0)
    end subroutine

    subroutine IPgJoin3(XPG1,YPG1,ZPG1,XPG2,YPG2,ZPG2)
        real XPG1 ! 3D PG area X co-ordinate to draw from
        real YPG1 ! 3D PG area Y co-ordinate to draw from
        real ZPG1 ! 3D PG area Z co-ordinate to draw from
        real XPG2 ! 3D PG area X co-ordinate to draw to
        real YPG2 ! 3D PG area Y co-ordinate to draw to
        real ZPG2 ! 3D PG area Z co-ordinate to draw to
        ! Draws a line between the two specified co-ordinates (XPG1,YPG1,ZPG1) and
        ! (XPG2,YPG2,ZPG2) in the 3D Presentation Graphics plotting area. This routine is
        ! functionally equivalent to IGrJoin, except that the co-ordinates are based on the (x,y)
        ! units defined via IPgUnits and the z units defined via IPgUnitsZ The style of the
        ! line is determined by the routines in the GS subroutine group (IGrColourN etc.) The
        ! 2D equivalent of (XPG2,YPG2,ZPG2) becomes the current plotting position.
        ! PG Area Primitives INTERACTER Subroutine Reference
        ! 2-78
        !e.g.
        !C 3D graph type
        !CALL IPgNewPlot(PgZarrayPlot,1,NVALUE,PgLay3D,0)
        !CALL IPgUnits(0.0,0.0,1000.0,500.0)
        !CALL IPgUnitsZ(0.0,10.0)
        !C draw line between dialognonally opposite corners of the PG area
        !CALL IPgJoin3(0.0,0.0,0.0,1000.0,500.0,10.0)
    end subroutine

    subroutine IPgPolygonComplex2(XPG,YPG,NVERT)
        integer NVERT ! Number of vertices in supplied arrays (<=4095)
        real XPG(NVERT) ! Array of 2D PG area X co-ordinates/Angles
        real YPG(NVERT) ! Array of 2D PG area Y co-ordinates/Radii
        ! Draws a polygon in the 2D PG area, defined by the supplied XPG and YPG arrays. This
        ! routine is functionally equivalent to IGrPolygonComplex, except that the coordinates
        ! are based on the units defined via IPgUnits for a Cartesian plot or
        ! IPgUnitsPolar for a polar plot. Angles for polar plots are measured in degrees,anti-clockwise from the 3-o'clock position. The style of the polygon is determined by
        ! the routines in the GS subroutine group (IGrFillPattern etc.)
        ! (XPG(1),YPG(1)) becomes the current plotting position.
        !e.g. REAL XPG(4095),YPG(4095)
        !READ(20,*) N
        !NVERT = MIN(N,4095)
        !DO 100 I = 1,NVERT
        !READ(20,*) XPG(I),YPG(I)
        !100 CONTINUE
        !C 2D graph type
        !CALL IPgNewPlot(PgPolyline,1,NVALUE,0,0)
        !CALL IPgPolygonComplex2(XPG,YPG,NVERT)
    end subroutine

    subroutine IPgPolygonComplex3(XPG,YPG,ZPG,NVERT)
        integer NVERT ! Number of vertices in supplied arrays (<=4095)
        real XPG(NVERT) ! Array of 3D PG area X co-ordinates
        real YPG(NVERT) ! Array of 3D PG area Y co-ordinates
        real ZPG(NVERT) ! Array of 3D PG area Z co-ordinates
        ! Draws a polygon in the 3D PG area, defined by the supplied XPG, YPG and ZPG arrays.
        ! This routine is functionally equivalent to IGrPolygonComplex, except that the coordinates
        ! are based on the (x,y) units defined via IPgUnits and the z units defined
        ! via IPgUnitsZ. The style of the polygon is determined by the routines in the GS
        ! subroutine group (IGrFillPattern etc.). The 2D equivalent of
        ! (XPG(1),YPG(1),ZPG(1)) becomes the current plotting position.
        !e.g. REAL XPG(4095),YPG(4095),ZPG(4095)
        !READ(20,*) N
        !NVERT = MIN(N,4095)
        !DO 100 I = 1,NVERT
        !READ(20,*) XPG(I),YPG(I),ZPG(I)
        !100 CONTINUE
        !C 3D graph type
        !CALL IPgNewPlot(PgZarrayPlot,1,NVALUE,PgLay3D,0)
        !CALL IPgPolygonComplex3(XPG,YPG,ZPG,NVERT)
        !INTERACTER Subroutine Reference PG Area Primitives
        !2-79
    end subroutine

    subroutine IPgPolyLine2(XPG,YPG,NVERT)
        integer NVERT ! Number of vertices in supplied arrays (<=4095)
        real XPG(NVERT) ! Array of 2D PG area X co-ordinates/Angles
        real YPG(NVERT) ! Array of 2D PG area Y co-ordinates/Radiuses
        ! Draws a polyline in the 2D PG area, defined by the supplied XPG and YPG arrays. This
        ! routine is functionally equivalent to IGrPolyLine, except that the co-ordinates are
        ! based on the units defined via IPgUnits for a Cartesian plot or IPgUnitsPolar
        ! for a polar plot. Angles for polar plots are measured in degrees, anti-clockwise from the
        ! 3-o'clock position. The style of the polyline is determined by the routines in the GS
        ! subroutine group (IGrColourN etc.).
        ! On exit (XPG(NVERT),YPG(NVERT)) becomes the current plotting position. The
        ! routine has no effect if NVERT<=1.
        !e.g. REAL XPG(4095),YPG(4095)
        !READ(20,*) N
        !NVERT = MIN(N,4095)
        !DO 100 I = 1,NVERT
        !READ(20,*) XPG(I),YPG(I)
        !100 CONTINUE
        !C 2D graph type
        !CALL IPgNewPlot(PgLinePlot,1,NVALUE,0,0)
        !CALL IPgPolyLine2(XPG,YPG,NVERT)
    end subroutine

    subroutine IPgPolyLine3(XPG,YPG,ZPG,NVERT)
        integer NVERT ! Number of vertices in supplied arrays (<=4095)
        real XPG(NVERT) ! Array of 3D PG area X co-ordinates
        real YPG(NVERT) ! Array of 3D PG area Y co-ordinates
        real ZPG(NVERT) ! Array of 3D PG area Z co-ordinates
        ! Draws a polyline in the 3D PG area, defined by the supplied XPG, YPG and ZPG arrays.
        ! This routine is functionally equivalent to IGrPolyLine, except that the co-ordinates
        ! are based on the (x,y) units defined via IPgUnits and the z units defined via
        ! IPgUnitsZ. The style of the polyline is determined by the routines in the GS
        ! subroutine group (IGrColourN etc.).
        ! On exit the 2D equivalent of (XPG(NVERT),YPG(NVERT)) becomes the current
        ! plotting position. The routine has no effect if NVERT<=1.
        !e.g. REAL XPG(4095),YPG(4095),ZPG(4095)
        !READ(20,*) N
        !NVERT = MIN(N,4095)
        !DO 100 I = 1,NVERT
        !READ(20,*) XPG(I),YPG(I),ZPG(I)
        !100 CONTINUE
        !C 3D graph type
        !CALL IPgNewPlot(PgZarrayPlot,1,NVALUE,PgLay3D,0)
        !CALL IPgPolyLine3(XPG,YPG,ZPG,NVERT)
        !PG Area Primitives INTERACTER Subroutine Reference
        !2-80
    end subroutine

    subroutine IPgUnitsFromGrUnits(GXPOS,GYPOS,PGXPOS,PGYPOS)
        real GXPOS ! Main graphics area x co-ordinate to convert ) in IGrUnits
        real GYPOS ! Main graphics area y co-ordinate to convert ) units
        real PGXPOS ! Returned PG area x co-ordinate) in IPgUnits
        real PGYPOS ! Returned PG area y co-ordinate) units
        ! Short-name : PGFRGU
        ! Converts an (x,y) co-ordinate to PG area units (as defined by IPgUnits) from main
        ! graphics area units (as defined by IGrUnits). This routine is particularly useful with
        ! routines such as IGrInputXY, since it allows co-ordinates expressed in terms of the
        ! main graphics area to be related back to the original data used to create a PG plot.
        ! See also IPgUnitsToGrUnits which performs the opposite conversion.
        !e.g. CALL IGrInputXY(X,Y)
        !CALL IPgUnitsFromGrUnits(X,Y,XPG,YPG)
    end subroutine

    subroutine IPgUnitsFromGrUnitsP(GXPOS,GYPOS,ANGLE,RADIUS)
        real GXPOS ! Main graphics area x co-ordinate to convert ) in IGrUnits
        real GYPOS ! Main graphics area y co-ordinate to convert ) units
        real ANGLE ! Returned PG area angle in degrees
        real RADIUS ! Returned PG area radius, in IPgUnitsPolar units
        ! Converts an (x,y) co-ordinate to 2D polar PG area units (as defined by
        ! IPgUnitsPolar) from main graphics area units (as defined by IGrUnits). It
        ! allows co-ordinates expressed in terms of the main graphics area to be related back to
        ! the original data used to create a polar PG plot. Angles are measured in degrees anticlockwise
        ! from the 3-o'clock position.
        ! The conversion performed by this routine depends on the aspect ratio. When only
        ! screen or hardcopy output is enabled the appropriate aspect ratio is used. When both
        ! screen and hardcopy are enabled the screen aspect ratio is used.
        ! See also IPgUnitsToGrUnitsP which performs the opposite conversion.
        !e.g. CALL IGrInputXY(X,Y)
        !CALL IPgUnitsFromGrUnits(X,Y,ANGLE,RADIUS)
    end subroutine

    subroutine IPgUnitsToGrUnits(PGXPOS,PGYPOS,GXPOS,GYPOS)
        real PGXPOS ! PG area x co-ordinate to convert ) in IPgUnits
        real PGYPOS ! PG area y co-ordinate to convert ) units
        real GXPOS ! Returned main graphics area x co-ordinate ) in IGrUnits
        real GYPOS ! Returned main graphics area y co-ordinate ) units
        ! Short-name : PGTOGU
        ! Converts an (x,y) co-ordinate from PG area units (as defined by IPgUnits) to main
        ! graphics area units (as defined by IGrUnits). This routine is of most use where PG
        ! routines are to be mixed with those from the GD/GC/GI/GP groups. The returned coordinates
        ! can be passed to any of the routines which operate on the main graphics area
        ! (i.e. any routine with a name which starts with IGr).
        ! INTERACTER Subroutine Reference PG Area Primitives
        ! 2-81
        ! See also IPgUnitsFromGrUnits which performs the opposite conversion.
        !e.g. CALL IPgUnits(0.0,0.0,30.0,1.0)
        !CALL IPgHistogram(XVALS)
        !CALL IPgUnitsToGrUnits(15.0,0.95,XMAIN,YMAIN)
        !CALL IGrCharOut(XMAIN,YMAIN,'Title at the top of the PG area')
    end subroutine

    subroutine IPgUnitsToGrUnits3(PGXPOS,PGYPOS,PGZPOS,GXPOS,GYPOS)
        real PGXPOS ! 3D PG area x co-ordinate to convert (in IPgUnits units)
        real PGYPOS ! 3D PG area y co-ordinate to convert (in IPgUnits units)
        real PGzPOS ! 3D PG area z co-ordinate to convert (in IPgUnitsZ units)
        real GXPOS ! Returned main graphics area x co-ordinate ) in IGrUnits
        real GYPOS ! Returned main graphics area y co-ordinate ) units
        ! Converts an (x,y,z) co-ordinate from 3D PG area units (as defined by IPgUnits and
        ! IPgUnitsZ) to main graphics area units (as defined by IGrUnits). This routine is
        ! of most use where 3D PG routines are to be mixed with those from the GD/GC/GP
        ! groups. The returned co-ordinates can be passed to any of the routines which operate
        ! on the main graphics area (i.e. any routine with a name which starts with IGr). Note
        ! that a 3D graph type must have been selected before calling this routine.
        ! See also IPgUnitsToGrUnits which performs the equivalent 2D conversion.
        !e.g. CALL IPgNewPlot(PgZarrayPlot,NSETS,NVALUE,PgLay3D,0)
        !CALL IPgUnits(0.0,0.0,30.0,1.0)
        !CALL IPgUnitsZ(0.0,100.0)
        !CALL IPgUnitsToGrUnits3(XPG,YPG,ZPG,X,Y)
        !CALL IGrCharOut(X,Y,'String at a 3D location')
    end subroutine

    subroutine IPgUnitsToGrUnitsP(ANGLE,RADIUS,GXPOS,GYPOS)
        real ANGLE ! PG area angle, in degrees
        real RADIUS ! PG area radius, in IPgUnitsPolar units
        real GXPOS ! Returned main graphics area x co-ordinate ) in IGrUnits
        real GYPOS ! Returned main graphics area y co-ordinate ) units
        ! Converts a polar (Angle,Radius) co-ordinate from 2D PG area units (as defined by
        ! IPgUnitsPolar) to main graphics area units (as defined by IGrUnits). Angles are
        ! measured in degrees, anti-clockwise from the 3-o'clock position. This routine is of most
        ! use where 2D PG routines are to be mixed with those from the GD/GC/GP groups. The
        ! returned co-ordinates can be passed to any of the routines which operate on the main
        ! graphics area (i.e. any routine with a name which starts with IGr).
        ! The conversion performed by this routine depends on the aspect ratio. When only
        ! screen or hardcopy output is enabled the appropriate aspect ratio is used. When both
        ! screen and hardcopy are enabled the screen aspect ratio is used.
        ! See also IPgUnitsFromGrUnitsP which performs the opposite conversion.
    end subroutine
!end module

