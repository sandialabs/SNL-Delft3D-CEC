!----- AGPL --------------------------------------------------------------------
!
!  Copyright (C)  Stichting Deltares, 2017-2020.
!
!  This file is part of Delft3D (D-Flow Flexible Mesh component).
!
!  Delft3D is free software: you can redistribute it and/or modify
!  it under the terms of the GNU Affero General Public License as
!  published by the Free Software Foundation version 3.
!
!  Delft3D  is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU Affero General Public License for more details.
!
!  You should have received a copy of the GNU Affero General Public License
!  along with Delft3D.  If not, see <http://www.gnu.org/licenses/>.
!
!  contact: delft3d.support@deltares.nl
!  Stichting Deltares
!  P.O. Box 177
!  2600 MH Delft, The Netherlands
!
!  All indications and logos of, and references to, "Delft3D",
!  "D-Flow Flexible Mesh" and "Deltares" are registered trademarks of Stichting
!  Deltares, and remain the property of Stichting Deltares. All rights reserved.
!
!-------------------------------------------------------------------------------

! $Id: unstruc.F90 65931 2020-02-05 10:39:47Z kernkam $
! $HeadURL: https://svn.oss.deltares.nl/repos/delft3d/tags/delft3d4/65936/src/engines_gpl/dflowfm/packages/dflowfm_kernel/src/unstruc.F90 $
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

! todo: na u1 substitutie checken of hu van de correcte kant kwam. Zo niet, setback en opnieuw
! todo: check if 1 loop may be saved in tridiag u1q1
! todo: turkin, tureps en vicwwu naar boven toe doorzetten bij weer nat maken
! todo, wcxyl op randen is niet goed doordat acl op randen niet goed is doordat meteomodule niet werkt met xz,yz in gespiegelde
! binnencelpunten. graag goed zetten

 subroutine inctime_user()
 use m_flowtimes
 use m_flowexternalforcings, only: nbndz, zbndz
 implicit none
 if (time1 >= time_user) then
     ! If not, current time_user was not yet reached (user interrupt in interface)
     time_user = time_user + dt_user                  !
     ! time_user = max(time_user, time1)              ! safety for now only, until sobektimestepping is introduced
     time_user = min(time_user,tstop_user)
     dnt_user  = dnt_user  + 1                        ! todo from, to
 end if
 end subroutine inctime_user

!> Increase the time_user with a delta t
!! Called from API.
 subroutine inctime_user_dt(dt)
 use m_flowtimes
 implicit none
 double precision, intent(in) :: dt !< increase time_user with delta t (dt)
 ! If not, current time_user was not yet reached (user interrupt in interface)
 time_user = time_user + dt                       !
 ! time_user = max(time_user, time1)              ! safety for now only, until sobektimestepping is introduced
 dnt_user  = dnt_user  + 1                        ! todo from, to
end subroutine inctime_user_dt


 subroutine flow_spatietimestep()                 ! do 1 flowstep
 use m_flowtimes
 use m_flowgeom, only: ndx
 use m_flowexternalforcings, only: nbndz, zbndz
 use m_flowparameters, only: janudge

 implicit none
 integer :: key, ierr
 integer :: i
 integer, external :: flow_modelinit

 if (ndx == 0) then
     ierr = flow_modelinit()
 end if

 if (ndx == 0) return                                ! No valid flow network was initialized

 call inctime_user()
 if (time0 >= time_user) then
    Tstop_user = tstop_user + dt_user
    time_user  = time_user  + dt_user
 endif
                                                     ! ipv time0
 tim1fld = max(time_user,tim1fld)
 if ( janudge.eq.1 ) call setzcs()
 call flow_setexternalforcings(tim1fld ,.false., ierr)    ! set field oriented forcings. boundary oriented forcings are in

 ! call flow_externalinput(time_user)                  ! receive RTC signals etc

 call flow_single_timestep(key, ierr)

 call updateValuesOnObervationStations()

 call flow_externaloutput(time1)                     ! receive signals etc, write map, his etc
                                                     ! these two functions are explicit. therefore, they are in the usertimestep
 end subroutine flow_spatietimestep

!> Runs flow steps for a certain period (do computational flowsteps for as long as timeinterval dtrange).
subroutine flow_run_sometimesteps(dtrange, iresult)                   ! do computational flowsteps for as long as timeinterval dtrange
   use m_flowtimes
   use unstruc_messages
   use m_partitioninfo
   use unstruc_display, only: jaGUI
   use dfm_error
   implicit none
   double precision, intent(in)  :: dtrange
   integer,          intent(out) :: iresult !< Error status, DFM_NOERR==0 if successful.
   integer                       :: key

   double precision :: timetarget

   iresult = DFM_GENERICERROR
   if (dtrange < 0) then
      timetarget = time1 + epsilon(1d0) ! dtrange < 0 means: auto pick a *single* timestep. Enforce this with a target time *just* larger than current time.
   else
      timetarget = time1 + dtrange
   end if

   timetarget = min(timetarget, tstop_user)


 do while (time1 < timetarget)                        ! nb, outside flow_singletimestep, time0=time1 !

    !! INIT only in case of new user timestep
    if (time1 >= time_user) then
       call flow_init_usertimestep(iresult)

       if (iresult /= DFM_NOERR) then
          goto 888
       end if
    end if

    !! RUN actual SINGLE computational timestep
    call flow_single_timestep(key, iresult)
    if (iresult /= DFM_NOERR) then
       goto 888
    end if

    !! FINALIZE only when a time_user is finished
    if (time1 >= time_user) then
       call flow_finalize_usertimestep(iresult)

       if (iresult /= DFM_NOERR) then
          goto 888
       end if
    end if

 enddo

   iresult = DFM_NOERR
   return ! Return with success.

888 continue
end subroutine flow_run_sometimesteps


!> A complete single user time step (init-run-finalize).
 subroutine flow_usertimestep(key, iresult)                   ! do computational flowsteps until timeuser
 use m_flowtimes
 use unstruc_messages
 use m_partitioninfo
 use unstruc_display, only: jaGUI
 use m_timer
 use dfm_error
 implicit none
   integer, intent(out) :: key     !< Key number if any key was pressed in GUI.
 integer, intent(out) :: iresult !< Error status, DFM_NOERR==0 if successful.

   iresult = DFM_GENERICERROR
   key = 0

   call flow_init_usertimestep(iresult)
   if (iresult /= DFM_NOERR) then
      goto 888
   end if

   call flow_run_usertimestep(key, iresult)
   if (iresult /= DFM_NOERR) then
      goto 888
   end if

   call flow_finalize_usertimestep(iresult)
   if (iresult /= DFM_NOERR) then
      goto 888
   end if

   iresult = DFM_NOERR
   return ! Return with success.

888 continue
end subroutine flow_usertimestep


!> Initializes a new user-timestep (advances user time, sets new meteo forcing)
!!
!! Should be followed by a flow_run_usertimestep and a flow_finalize_usertimestep.
subroutine flow_init_usertimestep(iresult)
   use m_flowtimes
   use dfm_error
   use MessageHandling
   use m_flowparameters, only: janudge
   use m_partitioninfo, only: jampi, abort_all

   implicit none
   integer, intent(out) :: iresult !< Error status, DFM_NOERR==0 if successful.

 iresult = DFM_GENERICERROR

 call inctime_user()

 tim1fld = max(time_user, tim1fld )
 if ( janudge.eq.1 ) call setzcs()
 call flow_setexternalforcings(tim1fld ,.false. , iresult)    ! set field oriented forcings. boundary oriented forcings are in
 if (iresult /= DFM_NOERR) then
    goto 888
 end if

 ! call flow_externalinput (time_user)                 ! receive signals etc
   iresult = DFM_NOERR
   return ! Return with success.

888 continue

 if (iresult /= DFM_NOERR) then
    write (msgbuf,*) ' Error found in EC-module ' ; call err_flush()
    if (jampi == 1) then
       write(msgbuf,*) 'Error occurs on one or more processes when setting external forcings on boundaries at time=', tim1bnd;
       call err_flush()
       ! Terminate all MPI processes
       call abort_all()
    endif
    goto 888
 end if

end subroutine flow_init_usertimestep


!> Runs a user-timestep (do computational flowsteps until timeuser), but not the init and finalize.
!!
!! Should be preceded by a flow_run_usertimestep and followed by a flow_finalize_usertimestep.
subroutine flow_run_usertimestep(key, iresult)                   ! do computational flowsteps until timeuser
   use m_flowtimes
   use unstruc_messages
   use m_partitioninfo
   use unstruc_display, only: jaGUI
   use dfm_error
   implicit none
   integer, intent(out) :: key
   integer, intent(out) :: iresult !< Error status, DFM_NOERR==0 if successful.

   key = 0
   iresult = DFM_GENERICERROR

 do while (time0 < time_user)                        ! nb, outside flow_singletimestep, time0=time1 !

    call flow_single_timestep(key, iresult)
    if (iresult /= DFM_NOERR .and. iresult /= DFM_TIMESETBACK) then
       goto 888
    end if

    if ( jaGUI.eq.1 ) then ! TODO: MICHAL Another Gui call

       call get_s_key(key)

       if ( jampi.eq.1 ) then
          call reduce_key(key)
       end if

       if (key == 1 ) then
           call mess(LEVEL_INFO, 'User interrupt')
           iresult = DFM_NOERR
           return
       end if
    end if
   enddo

   iresult = DFM_NOERR
   return ! Return with success.

888 continue
end subroutine flow_run_usertimestep


!> Finalizes the current user-timestep (monitoring and I/O).
!!
!! Should be called directly after a flow_run_usertimestep.
subroutine flow_finalize_usertimestep(iresult)
   use m_flowtimes
   use m_timer
   use m_flow
   use m_flowgeom
   use m_transport, only: constituents, NUMCONST, const_names
   use m_fourier_analysis
   use dfm_error
   use precision_basics
   use unstruc_files, only: defaultFilename
   use unstruc_model, only: getoutputdir, md_fou_step
   use m_partitioninfo, only: jampi, sdmn
   implicit none

   integer, intent(out) :: iresult !< Error status, DFM_NOERR==0 if successful.
   double precision, pointer, dimension(:,:) :: s1_ptr, ws_ptr, ucx_ptr,  ucy_ptr,  taus_ptr,bl_ptr, u1_ptr
   double precision, pointer, dimension(:,:) :: xs_ptr, ys_ptr, ucxa_ptr, ucya_ptr, ucmag_ptr, xu_ptr, yu_ptr
   integer, pointer, dimension(:,:)          :: kfs_ptr
   double precision, pointer, dimension(:,:,:) :: const_ptr
   double precision :: tem_dif
   character(len=255) :: filename_fou_out

   iresult = DFM_GENERICERROR

!   call fm_wq_processes_step(dt_user,time_user)
   if (ti_waqproc > 0) then
     if (comparereal(time_user, time_waqproc, eps10) == 0) then
         if ( jatimer.eq.1 ) call starttimer(IFMWAQ)
         call fm_wq_processes_step(ti_waqproc,time_user)
         if ( jatimer.eq.1 ) call stoptimer (IFMWAQ)
         tem_dif = time_user/ti_waqproc
         time_waqproc = (floor(tem_dif + 0.001d0)+1)*ti_waqproc
     endif
   endif

!   call mba_update(time_user)
   if (ti_waqbal > 0) then
     if (comparereal(time_user, time_mba, eps10) == 0) then
         call mba_update(time0)
         tem_dif = time_user/ti_waqbal
         if (ti_waqproc > 0d0) then
            time_mba = min((floor(tem_dif + 0.001d0)+1)*ti_waqbal, floor(tstop_user/ti_waqproc + 0.001d0)*ti_waqproc)
         else
            time_mba = min((floor(tem_dif + 0.001d0)+1)*ti_waqbal, tstop_user)
         endif
     endif
   endif
      
   if (comparereal(time1, time_user, eps10)>=0)  then
      if (comparereal(time1, time_user, eps10) <=0) then
         time1 = time_user
         time0 = time1
      endif
      if ( jatimer.eq.1 ) call starttimer(IOUTPUT)

!       only update values at the observation stations when necessary
!          alternative: move this to flow_externaloutput
      if (ti_his > 0) then
         if (comparereal(time1,time_his,eps10)>=0) then
              call  updateValuesOnObervationStations()
              if (jampi == 1) then
                 call  updateValuesOnCrossSections_mpi(time1)
                 call reduce_particles
              endif
              if (jahisbal > 0) then ! Update WaterBalances etc.
                 call updateBalance()
              endif
              if ( jacheckmonitor.eq.1 ) then
!                compute "checkerboard" monitor
                 call comp_checkmonitor()
         endif
      endif
      endif


      call flow_externaloutput(time1)

      if ( jatimer.eq.1 ) call stoptimer(IOUTPUT)

   endif

   if (fourierIsActive() .and. md_fou_step == 0) then
      if (fourierWithUc()) then
         call getucxucyeulmag(ndkx, workx, worky, ucmag, jaeulervel, 1)
      endif
      call postpr_fourier(time0, dt_user)
   endif

 iresult = DFM_NOERR
 return ! Return with success.

      888 continue

 end subroutine flow_finalize_usertimestep


 !> A complete single computational time step (init-perform-finalize).
 subroutine flow_single_timestep(key, iresult)                ! do only 1 flow timestep
 use m_flow
 use m_flowgeom
 use m_flowtimes
 use unstruc_model, only : jawritebalancefile
 use unstruc_netcdf
 use m_xbeach_netcdf
 use m_timer
 use unstruc_display, only : jaGUI
 use dfm_error
 implicit none

 integer :: key
 integer, intent(out) :: iresult !< Error status, DFM_NOERR==0 if successful.

 integer :: N, L

 iresult = DFM_GENERICERROR

! double precision :: t
! call checkspeed(t)

   call flow_init_single_timestep(iresult)
   if (iresult /= DFM_NOERR) then
      goto 888
   end if

   call flow_run_single_timestep(key, iresult)
   if (iresult /= DFM_NOERR .and. iresult /= DFM_TIMESETBACK) then
      goto 888
   end if

   call flow_finalize_single_timestep(iresult)
   if (iresult /= DFM_NOERR) then
      goto 888
   end if

   ! JRE DEBUG: avoid annoying dt_user interference
    call xbeach_write_stats(time1)
    call sedmor_write_stats(time1)
   iresult = DFM_NOERR
   return ! Return with success

888 continue
   ! Error
end subroutine flow_single_timestep


!> Initializes a single computational timestep, call this prior to flow_perform_single_timestep.
subroutine flow_init_single_timestep(iresult)
use m_flow
use m_flowgeom
use m_flowtimes
use m_timer
use dfm_error
implicit none

integer :: key
integer, intent(out) :: iresult !< Error status, DFM_NOERR==0 if successful.

integer :: N, L

 iresult = DFM_GENERICERROR

 if (lnx == 0) then
    iresult = DFM_MODELNOTINITIALIZED
    goto 888
 end if

 call klok(cpusteps(1))

 if ( jatimer.eq.1 ) call starttimer(ITIMESTEP)

 call flow_initimestep(0, iresult)                   ! initialise timestep

 if (iresult /= DFM_NOERR) then
    goto 888
 end if

   iresult = DFM_NOERR
   return ! Return with success

888 continue
   ! Error

end subroutine flow_init_single_timestep


!> Performs a single computational timestep, but not the init and finalize of the timestep.
subroutine flow_run_single_timestep(key, iresult)                ! do only 1 flow timestep
use m_flow
use m_flowgeom
use m_flowtimes
use unstruc_model, only : jawritebalancefile
use unstruc_netcdf
use m_timer
use unstruc_display, only : jaGUI
use dfm_error
implicit none

integer :: key
integer, intent(out) :: iresult !< Error status, DFM_NOERR==0 if successful. DFM_TIMESETBACK if succesful, but with timestep setbacks.

integer :: N, L

 iresult = DFM_GENERICERROR

 if (itstep >= 2) then
    call step_reduce(key)                            ! set a computational timestep implicit, reduce, elim conj grad substi
    if (dsetb > 0) then
       iresult = DFM_TIMESETBACK ! Warning about setbacks, but don't return directly, continue function normally
    end if
 else
    call velocities_explicit()                       ! progress without pressure coupling
    call transport()                                 ! progress without pressure coupling
    call update_part()
    time1  = time0 + dts                             ! progress without pressure coupling
 endif

   ! Finalize timestep code used to be here, now flow_finalize_single_timestep()

   call klok(cpusteps(2)) ; cpusteps(3) = cpusteps(3) + cpusteps(2) - cpusteps(1)

   ! Finalize timestep code used to be here, now flow_finalize_single_timestep()

   if (iresult /= DFM_TIMESETBACK) then
      iresult = DFM_NOERR
   end if

   return ! Return with success

888 continue
   ! Error

end subroutine flow_run_single_timestep


!> Finalizes a single time step, should be called directly after flow_run_single_timestep
subroutine flow_finalize_single_timestep(iresult)
use m_flow
use m_flowgeom
use m_flowtimes
use unstruc_model, only : jawritebalancefile
use unstruc_model, only : md_fou_step
use unstruc_netcdf
use m_timer
use unstruc_display, only : jaGUI
use dfm_error
use dfm_signals
use m_partitioninfo, only: jampi, sdmn, my_rank
use m_integralstats
use m_fourier_analysis
use m_oned_functions, only: updateTimeWetOnGround, updateTotalInflow1d2d, updateTotalInflowLat
use unstruc_channel_flow, only : network
implicit none
integer, intent(out) :: iresult
character(len=255)   :: filename_fou_out

   ! Timestep has been performed, now finalize it.

   if (ti_waqproc < 0d0) then
      if ( jatimer.eq.1 ) call starttimer(IFMWAQ)
      call fm_wq_processes_step(dts,time1)
      if ( jatimer.eq.1 ) call stoptimer (IFMWAQ)
   endif

 call flow_f0isf1()                                  ! mass balance and vol0 = vol1
    
 ! Update water depth at pressure points (for output).
 ! TODO: UNST-3415: investigate if this statement can be moved to step_reduce.
 hs = s1 - bl

 call structure_parameters

 dnt    = dnt + 1
 time0  = time1                                      ! idem
 dtprev = dts                                        ! save previous timestep

 if ( jatimer.eq.1 ) then ! TODO: AvD: consider moving timers to flow_perform_*
   call stoptimer(ITIMESTEP)
   numtsteps = numtsteps + 1
 end if

 ! call wriinc(time1)

  if (jaQinext > 0) then
     call updateCumulativeInflow(dts)
  end if

  call updateValuesOnCrossSections(time1)             ! Compute sum values across cross sections.
 if (jampi == 0 .or. (jampi == 1 .and. my_rank==0)) then
    if (numsrc > 0) then
       call updateValuesonSourceSinks(time1)         ! Compute discharge and volume on sources and sinks
    endif
 endif

 ! for 1D only
 if (network%loaded .and. ndxi-ndx2d > 0) then
    if (jamapTimeWetOnGround > 0) then
       call updateTimeWetOnGround(dts)
    end if
    if (jamapTotalInflow1d2d > 0) then
       call updateTotalInflow1d2d(dts)
    end if
    if (jamapTotalInflowLat > 0) then
       call updateTotalInflowLat(dts)
    end if
 end if
 ! note updateValuesOnObervationStations() in flow_usertimestep

 ! Time-integral statistics on all flow nodes.
 if (is_numndvals > 0) then
    call update_integralstats()
 end if

 if ( jaGUI.eq.1 ) then
    call TEXTFLOW()
 end if

 iresult = dfm_check_signals()                   ! Abort when Ctrl-C was pressed
 if (iresult /= DFM_NOERR) goto 888

 if (validateon) then
    call flow_validatestate(iresult)                ! abort when the solution becomes unphysical
 endif
 validateon = .true.
 if (iresult /= DFM_NOERR) goto 888

888 continue

   if (fourierIsActive() .and. md_fou_step == 1) then
      if (fourierWithUc()) then
         call getucxucyeulmag(ndkx, workx, worky, ucmag, jaeulervel, 1)
      endif
      call postpr_fourier(time0, dts)
   endif
end subroutine flow_finalize_single_timestep

 subroutine velocities_explicit()
 use m_flowgeom
 use m_flow
 use m_flowtimes
 implicit none
 integer :: n, L, LL, k1, k2

 if (itstep == 1) then
    u1 = (u0 - dts*adve)/(1d0 + dts*advi)
    do n  = 1, nbndu  !       boundaries at u points
       L     = kbndu(3,n)
       u1(L) = zbndu(n)
    end do
 endif
 q1   = u1*au

 squ = 0d0 ; sqi = 0d0
 if ( kmx.eq.0 ) then
    do L = 1,lnx
      if (q1(L) > 0) then
          k1 = ln(1,L) ; k2 = ln(2,L)
          squ(k1) = squ(k1) + q1(L)
          sqi(k2) = sqi(k2) + q1(L)
       else if (q1(L) < 0) then
          k1 = ln(1,L) ; k2 = ln(2,L)
          squ(k2) = squ(k2) - q1(L)
          sqi(k1) = sqi(k1) - q1(L)
       endif
    enddo
 else
    do LL = 1,lnx
       do L=Lbot(LL),Ltop(LL)
          if (q1(L) > 0) then
             k1 = ln(1,L) ; k2 = ln(2,L)
             squ(k1) = squ(k1) + q1(L)
             sqi(k2) = sqi(k2) + q1(L)
          else if (q1(L) < 0) then
             k1 = ln(1,L) ; k2 = ln(2,L)
             squ(k2) = squ(k2) - q1(L)
             sqi(k1) = sqi(k1) - q1(L)
          endif
       end do
    enddo
 end if
 end subroutine velocities_explicit

 subroutine flow_initimestep(jazws0, iresult)                     ! intialise flow timestep, also called once after flowinit
 use m_flowtimes
 use m_flow
 use m_flowgeom
 use unstruc_model, only: md_ident, md_restartfile
 use m_xbeach_data, only: swave, Lwave, uin, vin, cgwav
 use unstruc_channel_flow
 use m_1d_structures, only: initialize_structures_actual_params, set_u0isu1_structures
 use dfm_error
 use MessageHandling
 use m_partitioninfo
 implicit none

 integer          :: jazws0
 integer, intent(out) :: iresult !< Error status, DFM_NOERR==0 if succesful.
 integer          :: k, n, LL
 integer              :: ierror

 iresult = DFM_GENERICERROR

 call klok(cpuinistep(1))

 if (jazws0.eq.0)  s0 = s1                           ! progress water levels

 call bathyupdate()                                  ! only if jamorf == 1

 if(jazws0.eq.1 .and. len_trim(md_restartfile)>0) then
    ! ini timestep right after reading a rst file: prepare derived hs/ucx/etc.
    ! for writing of first map file snapshot, i.e., based on the s0/u0 values.
    hs = s0 - bl
 else
    hs = s1 - bl                                     ! total water height
 endif

! due to tolerance in poshcheck, hs may be smaller than 0 (but larger than -1e-10)
 hs = max(hs,0d0)


 if (nshiptxy > 0) then  ! quick fix only for ships
     call setdt()
 endif

 tim1bnd = max(time0+dts, tim1bnd)

 call klok(cpu_extra(1,38)) ! Start bnd
 call flow_setexternalforcingsonboundaries(tim1bnd , iresult)  ! boundary forcings
 call klok(cpu_extra(2,38)) ! End bnd

 if (iresult /= DFM_NOERR) then
    write (msgbuf,*) ' Error found in EC-module ' ; call err_flush()
    if (jampi == 1) then
       write(msgbuf,*) 'Error occurs on one or more processes when setting external forcings on boundaries at time=', tim1bnd;
       call err_flush()
       ! Terminate all MPI processes
       call abort_all()
    endif
    goto 888
 end if

 if (tlfsmo > 0d0 ) then
    alfsmo  = (tim1bnd - tstart_user) / tlfsmo
 endif

! apply XBeach wave boundary conditions
 if (jawave .eq. 4) then
    if ( swave.eq.1 ) then
       call xbeach_wave_bc()
       call xbeach_apply_wave_bc()
       call xbeach_wave_compute_celerities()        ! for setdt
    else
       uin = 0d0
       vin = 0d0
    endif
    call xbeach_flow_bc()
 end if

 call klok(cpu_extra(1,42)) ! Start u0u1
 if (jazws0.eq.0) then
    u0 = u1                           ! progress velocities
    call set_u0isu1_structures(network%sts)
 endif
 call klok(cpu_extra(2,42)) ! End u0u1


 advi = 0d0
 adve = 0d0

 call klok(cpu_extra(1,39)) ! Start huau
 call sethu(jazws0)

 call setau()                                        ! set au and cfuhi for conveyance after limited h upwind at u points
 call klok(cpu_extra(2,39)) ! End huau

 call klok(cpu_extra(1,43)) ! Start setumod
 if (newcorio == 1) then 
    call setumodnew(jazws0) 
 else
    call setumod(jazws0)                             ! set cell center velocities, should be here as prior to 2012 orso
 endif 
 call klok(cpu_extra(2,43)) ! End setumod

 call klok(cpu_extra(1,44)) ! Start cfuhi
 call setcfuhi()                                     ! set frictioncoefficient
 call klok(cpu_extra(2,44)) ! End cfuhi

 if (kmx == 0 .and. javeg > 0) then                  ! overwrite cfuhi in 2D with veg in plant area's
    call setbaptist()
 endif

 call klok(cpu_extra(1,45)) ! Start structactual
 call initialize_structures_actual_params(network%sts)
 call klok(cpu_extra(2,45)) ! Start structactual

 if (japillar == 1 .or. japillar == 3) then
    call pillar_upd()
 endif

 ! TIDAL TURBINES: Insert equivalent calls to updturbine and applyturbines here

 call klok(cpu_extra(1,40)) ! Start setdt
 if (jazws0.eq.0 .and. nshiptxy == 0)  then
    call setdt()                                     ! set computational timestep dt based on active hu's,
 end if
 call klok(cpu_extra(2,40)) ! End setdt

 if (nshiptxy > 0) then
     call setship()                                  ! in initimestep
 endif

 call klok(cpu_extra(1,41)) ! Start advec
 call advecdriver()                                  ! advec limiting for depths below chkadvdp, so should be called after all source terms such as spiralforce
 call klok(cpu_extra(2,41)) ! End advec

 if (jazws0.eq.1)  then
    call makeq1qaAtStart()                           ! compute q1 and qa to ensure exact restart
    call setkfs()
 endif

 if ( jaimplicit.eq.1 ) then
    call fillsystem_advec(ierror)
    if ( ierror.ne.0 ) goto 888
 end if

 if (jatem > 1 .and. jaheat_eachstep == 1) then
    call heatu(tim1bnd/3600d0)                                  ! from externalforcings
 endif

 call klok(cpuinistep(2)) ; cpuinistep(3) = cpuinistep(3) + cpuinistep(2) - cpuinistep(1)

 iresult = DFM_NOERR

 return ! Return with success

888 continue
 ! Error
   end subroutine flow_initimestep


 subroutine setbaptist()
 use m_flow
 use m_flowgeom
 implicit none
 integer          :: L, k1, k2
 double precision :: ap, Cz, Czb, Czr, rnL, diaL, stemhL, gamhg,Cda, areastem, umag,fac, facL, Cdaleaf

 do L = 1,lnx
    k1  = ln(1,L) ; k2 = ln(2,L)

    rnL = 0.5d0*( rnveg(k1) + rnveg(k2) )

    if (hu(L) > 0 .and. rnL > densvegminbap) then  ! overwrite cfuhi on veg locations with 2D Baptist
        if (jaBaptist <= 2) then                   ! compute Baptist on board
           call getcz(hu(L), frcu(L), ifrcutp(L), Czb, L)      ! standard Chezy coeff
           if (diaveg(k1) > 0 .and. diaveg(k2) > 0) then
              diaL = 0.5d0*( diaveg(k1) + diaveg(k2) )
           else
              diaL = max( diaveg(k1), diaveg(k2) )
           endif
           if ( stemheight(k1) > 0 .and. stemheight(k2) > 0) then
              stemhL = 0.5d0*( stemheight(k1) + stemheight(k2) )
           else
              stemhL = max( stemheight(k1), stemheight(k2) )
           endif
           stemhL   = min(stemhL,hu(L))
           areastem = diaL*stemhL
           if (jaCdvegsp == 1) then
              if (Cdvegsp(k1) > 0 .and. Cdvegsp(k2) > 0) then
                  Cdveg = 0.5d0*( Cdvegsp(k1) + Cdvegsp(k2) )
              else
                  Cdveg = max (Cdvegsp(k1), Cdvegsp(k2) )
              endif
           endif
           Cda      = Cdveg*areastem
           if (uchistem > 0d0 .and. expchistem < 0d0) then
              umag  = sqrt( u1(L)**2 + v(L)**2 )
              if (umag > 0d0) then
                 fac   = (umag/uchistem)**expchistem
              else
                 fac   = 1d0
              endif
              Cda   = Cda*fac
              !if ( leafarea(k1) > 0 .and. leafarea(k2) > 0) then
              !   arealeaf = 0.5d0*( leafarea(k1) + leafarea(k2) )
              !else
              !   arealeaf = max( leafarea(k1), leafarea(k2) )
              !endif
              if (uchileaf > 0d0 .and. expchileaf < 0d0) then
                 if (umag > 0d0) then
                    facL  = (umag/uchileaf)**expchileaf
                 else
                    facL = 1d0
                 endif
                 Cdaleaf  = Cdleaf*arealeaf*facL
                 Cda   = Cda + Cdaleaf
              endif
           endif

           gamhg    = 0.5d0*Cda*rnL/ag                         ! gamma*h/g
           ap       = gamhg + 1d0/(Czb*Czb)
           ! ap     = gamhg + (1d0/Czb*Czb)                    ! old=wrong
           Czr      = sqrt(1d0 / ap)

           if (stemhL < hu(L) - 0.01d0 ) then
              Czr   = Czr + (sag/vonkar)*log( hu(L) / stemhL ) ! resulting Baptist Chezy
           endif
           if (jaBaptist == 1) then
              cfuhi(L)   = ag/(Czr*Czr*hu(L))                  ! use as is, wrong morpho ?
           else if (jaBaptist == 2) then
              Cz         = Czr*sqrt(1d0+gamhg*Czb*Czb)
              cfuhi(L)   = ag/(Cz*Cz*hu(L))                    ! better for morfo
              alfav(L)   = ag*( 1d0/(Czr*Czr) - 1d0/(Cz*Cz) )  / hu(L)
           endif
        else if (jaBaptist == 3) then                          ! bij biologists through Python
           cfuhi(L) = cfuveg(L)/hu(L)
           alfav(L) = alfaveg(L)/hu(L)
        endif
    endif
 enddo

 end subroutine setbaptist

!> Validates the current flow state and returns whether simulation should be aborted.
!! Moreover, a final snapshot is written into the output files before aborting.
!!
!! Validity is determined by s01max, u01max and dtminbreak.
subroutine flow_validatestate(iresult)
 use unstruc_messages
 use m_flow
 use m_flowgeom
 use m_flowparameters
 use m_flowtimes
 use dfm_error
 implicit none
 integer, intent(out) :: iresult                     ! validation result status
 double precision :: dtavgwindow
 integer :: i, q

 iresult = DFM_NOERR

 q = 0

 if (s01max > 0) then     ! water level validation
    do i = 1,ndx
        if(abs(s1(i) - s0(i)) > s01max) then
            call mess(LEVEL_WARN,'water level change above threshold: (cell index, delta s[m]) = ', i, abs(s1(i) - s0(i)))
            ! TODO: UNST-725, once done, change the above back to LEVEL_ERROR
            q = 1
            exit
        end if
    end do
 end if

 if (u01max > 0) then     ! velocity validation
    do i = 1,lnx
        if(abs(u1(i) - u0(i)) > u01max) then
            call mess(LEVEL_ERROR,'velocity change above threshold: (flowlink index, delta u[m/s]) = ', i, abs(u1(i) - u0(i)))
            ! TODO: UNST-725, once done, change the above back to LEVEL_ERROR
            q = 1
            exit
        end if
    end do
 end if

if (dtminbreak > 0) then  ! smallest allowed timestep (in s), checked on a sliding average of several timesteps
   ! NOTE: this code below assumes that this routine is called once and exactly once every time step (i.e. in `dnt` rythm)
   dtavgwindow = (time1 - tvalswindow(idtwindow_start)) / max(1d0, min(dble(NUMDTWINDOWSIZE), dnt))
   if (dnt < dble(NUMDTWINDOWSIZE)) then
      ! First few time steps: just store all time1's until array is full
      tvalswindow(int(dnt+1)) = time1
   else
      ! Array is full already, overwrite the oldest element (i.e. at current idtwindow_start)
      ! and increment start index, cycling back to 1 if necessary.
      tvalswindow(idtwindow_start) = time1
      idtwindow_start = mod(idtwindow_start, NUMDTWINDOWSIZE) + 1
   end if

   ! Now ready for the actual dtminbreak check, but only do that once we have
   ! at least done dnt > NUMDTWINDOWSIZE time steps, to prevent the initial
   ! spin-up period to cause unwanted simulation breaks.
   if (dnt >= dble(NUMDTWINDOWSIZE) .and. dtavgwindow < dtminbreak) then
      write (msgbuf, '(a,e11.4,a,e11.4,a)') 'Comp. time step average below threshold: ', dtavgwindow, ' < ', dtminbreak, '.'
      call warn_flush() ! PENDING UNST-725, make this a warning instead of an error, because stopping will take place elsewhere in a clean way.
      q = 1
    end if
end if

if(q /= 0) then
    call flow_externaloutput_direct() ! Last-minute save of emergency snapshot in map/his/rst
    iresult = DFM_INVALIDSTATE
 end if

 end subroutine flow_validatestate


 subroutine advecdriver()
 use m_flowtimes
 use m_flow
 use m_flowgeom
 implicit none

 double precision :: dta, das, ds
 integer          :: L, k1, k2, k

 if (itstep == 3) then

   if (.not. allocated(adve0) ) then
      allocate(adve0(lnkx))
   endif

   dta = 0.7D0*dts/cflmx
   das = dta/dts
   do k = 1,2

      adve = 0d0

      call advec()
      if (k == 1) then
         adve0 = adve
      endif
      do L = 1,lnx
         k1 = ln(1,L) ; k2 = ln(2,L)
         ds = ag*dxi(L)*(s0(k2) - s0(k1))
         u1(L) = ( u1(L)*(1d0 - das) + u0(L)*das - dta*(adve(L) + ds) ) / (1d0 + dta*advi(L))
      enddo
      call setucxucyucxuucyunew()

   enddo
   ! adve = teta0*adve + (1d0-teta0)*adve0
   ! u1 = u0

 else

   call advec()                                       ! advection term, must be called after set-umod and cell velocity updates

 endif

 call setextforcechkadvec()                           ! set external forcings and check explicit part adve
 end subroutine advecdriver


 subroutine makeq1qaAtStart()
 use m_flow
 use m_flowgeom
 implicit none

 integer :: L

 do L = 1,lnx
    if (hu(L) > 0) then
       q1(L) = au(L)*( teta(L)*u1(L) + (1d0-teta(L))*u0(L) )
       qa(L) = au(L)*u1(L)
    else
       q1(L) = 0
       qa(L) = 0
    endif
 enddo

   end subroutine makeq1qaAtStart

 subroutine step_reduce(key)                         ! do a flow timestep dts guus, reduce once, then elimin conjugate grad substi
 use m_flow                                          ! when entering this subroutine, s1=s0, u1=u0, etc
 use m_flowgeom
 use m_sediment, only: stm_included
 use m_flowtimes
 use m_sferic
 use m_wind
 use m_reduce
 use m_ship
 use m_partitioninfo
 use m_timer
 use m_xbeach_data
 use MessageHandling
 use m_sobekdfm
 use unstruc_display
 use m_waves, only: hwav, twav, phiwav, rlabda, ustokes, uorb

 implicit none

 integer :: ndraw
 COMMON /DRAWTHIS/  ndraw(50)

 integer            :: key, LL, L, k1,k2
 integer            :: ja, k, ierror, n, kt, num, js1, noddifmaxlevm, nsiz
 character (len=40) :: tex
 double precision   :: wave_tnow, wave_tstop, t0, t1, dif, difmaxlevm
 double precision   :: hw,tw, uorbi,rkw,ustt,hh,cs,sn

 character(len=128) :: msg

!-----------------------------------------------------------------------------------------------
 numnodneg = 0
 if (wrwaqon.and.allocated(qsrcwaq)) then
    qsrcwaq0 = qsrcwaq ! store current cumulative qsrc for waq at the beginning of this time step
 end if

 111 continue

 time1    = time0 + dts                               ! try to reach time1
 dti      = 1d0/dts
 nums1it  = 0
 nums1mit = 0


 !call flow_set external forcingsonboundaries(time1) ! set boundary conditions for time that you attempt to reach, every step
                                                     ! should formally be at this position if setbacks occur
                                                     ! this may howver cause a problem for some boundary routines that do not
                                                     ! allow for subsequent calls at decreasing time
                                                     ! In that case put this in initimestep and accept non smooth bndc's



!-----------------------------------------------------------------------------------------------
 hs = max(hs,0d0)
 call furu()                                            ! staat in s0

 if ( itstep.ne.4 ) then                                ! implicit time-step

 222 if (nonlin == 2) then                               ! only for pressurised
       s1m = bl !  s1mini
       call volsur()
       difmaxlevm = 0d0 ;  noddifmaxlevm = 0
    endif

333 call s1ini()
    call pack_matrix()

 !-----------------------------------------------------------------------------------------------

444 call s1nod()                                        ! entry point for non-linear continuity

    call solve_matrix(s1, ndx,itsol)                    ! solve s1

    ! if (NDRAW(18) > 1) then
    !    nsiz = ndraw(18)-1
    !    call tekrai(nsiz,ja)
    !    call toemaar()
    ! endif

!    synchronise all water-levels
    if ( jampi.eq.1 ) then
       if ( jaoverlap.eq.0 ) then
          if ( jatimer.eq.1 ) call starttimer(IUPDSALL)
          call update_ghosts(ITYPE_SALL, 1, Ndx, s1, ierror)
          if ( jatimer.eq.1 ) call stoptimer(IUPDSALL)
       else
          if ( jatimer.eq.1 ) call starttimer(IUPDSALL)
          call update_ghosts(ITYPE_Snonoverlap, 1, Ndx, s1, ierror)
          if ( jatimer.eq.1 ) call stoptimer(IUPDSALL)
       end if
    end if

    call poshcheck(key)                                 ! s1 above local bottom? (return through key only for easier interactive)

    if (key == 1) then
       return                                           ! go to user control, timestep too small
    else if (key == 2 ) then
       if (wrwaqon.and.allocated(qsrcwaq)) then
          qsrcwaq = qsrcwaq0                            ! restore cumulative qsrc for waq from start of this time step to avoid
       end if                                           ! double accumulation and use of incorrect dts in case of time step reduction
       call setkfs()
       if (jposhchk == 2 .or. jposhchk == 4) then       ! redo without timestep reduction, setting hu=0 => 333 s1ini
          if (nonlin == 2) then
             goto 222
          else
             goto 333
          endif
       else
          goto 111                                      ! redo with timestep reduction => 111 furu
       endif
    endif

 else
    s1 = s0
 end if

 call volsur()

 if (nonlin > 0) then

    difmaxlev = 0d0 ; noddifmaxlev = 0

    do k = 1,ndx
       dif = abs(s1(k)-s00(k))

       if (dif  > difmaxlev ) then
          difmaxlev    = dif
           noddifmaxlev = k
       endif
       s00(k) = s1(k)
    enddo

    nums1it   = nums1it + 1

    if (nums1it > maxNonlinearIterations) then
       write(msgbuf, '(''No convergence in nonlinear solver at time '', g10.5,'' (s), time step is reduced from '', f8.4, '' (s) into '', f8.4, '' (s)'')') time0, dts, 0.5d0*dts
       !if (nonlin1D == 2) then
       !   ! Nested Newton
       !   !call err_flush()
       !else
          call warn_flush()
          dts = 0.5d0*dts
          dsetb  = dsetb + 1                               ! total nr of setbacks
          s1     = s0
          if (dts .lt. dtmin) then
              s1 = max(s1,bl)                              ! above bottom
              call okay(0)
              key = 1                                      ! for easier mouse interrupt
              return
          endif
          call setkfs()
          goto 111                                      ! redo with timestep reduction => 111 furu
       !endif
    endif

    !if (nums1it > 10) then
    !   write(tex,*) difmaxlev
    !   call gtext(tex,xz(noddifmaxlev), yz(noddifmaxlev), nums1it)
    !   call toemaar()
    !endif

    if ( jampi.eq.1 ) then
       if ( jatimer.eq.1 ) call starttimer(IMPIREDUCE)
       call reduce_double_max(difmaxlev)
       if ( jatimer.eq.1 ) call stoptimer (IMPIREDUCE)
    end if

    if ( difmaxlev > epsmaxlev) then
       ccr = ccrsav                                   ! avoid redo s1ini, ccr is altered by solve
       goto 444                                       ! standard non-lin iteration s1 => 444
    endif

    ! beyond or past this point s1 is converged

     if (nonlin == 2) then
       difmaxlevm = 0d0 ;  noddifmaxlevm = 0
       do k = 1,ndx
          dif = abs(s1m(k)-s1(k))
          if (dif  > difmaxlevm ) then
             difmaxlevm    = dif
             noddifmaxlevm = k
          endif
          s1m(k) = s1(k)                              ! s1m starts at value of converged inner loop s1
       enddo

       if (difmaxlevm > epsmaxlevm ) then
          nums1mit = nums1mit + 1
          call volsur()
          ccr = ccrsav                                ! avoid redo s1ini, ccr is altered by solve
          goto 444                                    ! when s1 .ne. s1m again do outer loop
       endif

    endif

    dnums1it = dnums1it + nums1it
 endif

!-----------------------------------------------------------------------------------------------
! TODO: AvD: consider moving everything below to flow_finalize single_timestep?
 call setkbotktop(0)                                 ! bottom and top layer indices and new sigma distribution

 call u1q1()                                         ! the vertical flux qw depends on new sigma => after setkbotktop
 call compute_q_total_1d2d()

 !if ( jacheckmonitor.eq.1 ) then
 !   call comp_checkmonitor()
 !end if

 if ( itstep.eq.4 ) then   ! explicit time-step
    call update_s_explicit()
 end if

 ! JRE: moved update of SWAN derived quantities here
 if (jawave==3) then
    if( kmx == 0 ) then
       hs = s1-bl
       hs = max(hs,0d0)
       call wave_comp_stokes_velocities()
       call wave_uorbrlabda()                       ! hwav gets depth-limited here
       call tauwave()
       if ( jaGUI.eq.1 ) then                                          ! this part is for online visualisation
          if (ntek > 0) then
             if (mod(int(dnt_user),ntek) .eq. 0) then
                call wave_makeplotvars()                                ! Potentially only at ntek interval
             end if
          endif
       endif
       ! wavfu: wave force at links, to be used in the advection equation
       call setwavfu()
       call setwavmubnd()
    end if
 end if
 if (jawave.eq.4 .and. jajre.eq.1) then
    hs = s1-bl
    hs = max(hs,0d0)
    if (swave.eq.1 ) then
       call xbeach_waves()
    endif
    call tauwave()
    if ( jaGUI.eq.1 ) then                                          ! this part is for online visualisation
       if (ntek > 0) then
          if (mod(int(dnt_user),ntek) .eq. 0) then
             call wave_makeplotvars()                                ! Potentially only at ntek interval
          end if
       endif
    endif
    call xbeach_mombalance()
 end if

  if (jawave==5) then
    if (kmx==0) then
       do L=1,lnx
          k1=ln(1,L); k2=ln(2,L)
          hh = hu(L); hw=0.5d0*(hwav(k1)+hwav(k2));tw=.5d0*(twav(k1)+twav(k2))
          cs = 0.5*(cos(phiwav(k1)*dg2rd)+cos(phiwav(k2)*dg2rd))
          sn = 0.5*(sin(phiwav(k1)*dg2rd)+sin(phiwav(k2)*dg2rd))
          call tauwavehk(hw, tw, hh, uorbi, rkw, ustt)
          ustokes(L) = ustt*(csu(L)*cs + snu(L)*sn)
       enddo
       do k=1,ndx
          call tauwavehk(hwav(k), twav(k), hs(k), uorbi, rkw, ustt)
          rlabda(k) = rkw; uorb(k) = uorbi
       enddo
       call tauwave()
    endif
 endif

 if (jased > 0 .and. stm_included) then
    if ( jatimer.eq.1 ) call starttimer(IEROSED)
    call fm_fallve()                   ! update fall velocities
    call fm_erosed()                   ! source/sink, bedload/total load
    if ( jatimer.eq.1 ) call stoptimer(IEROSED)
 end if

 ! secondary flow
 if ( jasecflow > 0 .and. kmx == 0 ) then
    call get_curvature()
    if( jaequili > 0 ) then
       call equili_spiralintensity()
    endif
 end if

 !SPvdP: timestep is now based on u0, q0
 !       transport is with u1,q1 with timestep based on u0,q0
 if ( jatimer.eq.1 ) call starttimer(ITRANSPORT)
 call transport()
 if ( jatimer.eq.1 ) call stoptimer (ITRANSPORT)

 !update particles
 call update_part()

 if (jased > 0 .and. stm_included) then
    call fm_bott3d() ! bottom update
    call setbobs()   ! adjust administration - This option only works for ibedlevtyp = 1, otherwise original bed level [bl] is overwritten to original value
    call volsur()                     ! update volumes 2d
    if (kmx>0) then
       call setkbotktop(0)            ! and 3D for cell volumes
    endif
 end if

 ! Moved to flow_finalize_single_timestep: call flow_f0isf1()                                  ! mass balance and vol0 = vol1

 if (layertype > 1 .and. kmx.gt.0 ) then

     ! ln = ln0 ! was ok.

 endif

 end subroutine step_reduce

 subroutine update_s_explicit()
    use m_flow
    use m_flowgeom
    use m_flowtimes
    use m_partitioninfo
    use m_timer
    use m_sobekdfm
    implicit none

    double precision            :: qwave
    integer                     :: k, k1, k2, L
    integer                     :: numchanged
    integer                     :: iter, ierror

    double precision, parameter :: dtol = 1d-16

!!   check if upwinddirection has changed
!    numchanged = 0
!    do L=1,Lnx
!       if ( u0(L)*u1(L).lt.-dtol ) then
!          numchanged = numchanged+1
!       end if
!    end do
!    if ( numchanged.gt.0 ) then
!!       write(6,*) numchanged
!       continue
!    end if

!    do iter=1,1
!
!!   recompute hu
!    call sethu(0)
!
!!   recompute Au
!    call setau()
!
!!   recompute q1, qa (as in u1q1)
!!$OMP PARALLEL DO           &
!!$OMP PRIVATE(L,k1,k2)
!    do L=1,Lnx
!       if ( hu(L).gt.0 ) then
!          k1 = ln(1,L)
!          k2 = ln(2,L)
!          q1(L) = au(L)*u1(L)
!          qa(L) = au(L)*u1(L)
!       else
!          q1(L) = 0d0
!          qa(L) = 0
!       end if
!    end do
!!$OMP END PARALLEL DO
!
!    do L = 1,lnx
!
!       if (q1(L) > 0) then
!          k1 = ln(1,L) ; k2 = ln(2,L)
!          squ(k1) = squ(k1) + q1(L)
!          sqi(k2) = sqi(k2) + q1(L)
!       else if (q1(L) < 0) then
!          k1 = ln(1,L) ; k2 = ln(2,L)
!          squ(k2) = squ(k2) - q1(L)
!          sqi(k1) = sqi(k1) - q1(L)
!       endif
!
!    enddo
!
!    sq = sqi-squ
!
!
!    sqwave = 0d0
!    do L=1,Lnx
!       k1 = ln(1,L); k2 = ln(2,L)
!       qwave = 2d0*sqrt(hu(L)*ag)*Au(L)   ! 2d0: safety
!       sqwave(k1) = sqwave(k1) + max(q1(L)+qwave,0d0)
!       sqwave(k2) = sqwave(k2) - min(q1(L)-qwave,0d0)
!    end do

    do k=1,Ndx
       s1(k) = s0(k) + sq(k)*bai(k)*dts
    end do
    call sets01zbnd(1) ! expl

!   synchronise all water-levels
    if ( jampi.eq.1 ) then
       if ( jatimer.eq.1 ) call starttimer(IUPDSALL)
       call update_ghosts(ITYPE_SALL, 1, Ndx, s1, ierror)
       if ( jatimer.eq.1 ) call stoptimer(IUPDSALL)
    end if

!    end do

    return
 end subroutine update_s_explicit

 subroutine poshcheck(key)
 use m_flow                                          ! when entering this subroutine, s1=s0, u1=u0, etc
 use m_flowgeom
 use m_flowtimes
 use m_partitioninfo
 use m_timer
 use unstruc_display, only: jaGUI
 
 implicit none

 integer :: key

 integer :: n, L, LL, LLL

 integer, dimension(2) :: idum

 Nodneg = 0 ; key = 0

 if ( jaGUI.eq.1 ) then
      call setcol(221) ! white
 end if


 if (jposhchk == 0) return

 do n = 1,ndxi                                                  ! check result

    if ( jampi.eq.1 ) then
!      exclude ghost cells
       if ( idomain(n).ne.my_rank ) cycle
    end if

    if (kfs(n) > 0) then
       if ( s1(n) < bl(n) ) then
           if ( s1(n) < bl(n) - 1d-10 ) then                     ! if ( s1(n) < bl(n) ) then

              nodneg = n ; numnodneg = numnodneg + 1
              if ( jaGUI.eq.1 ) then
                 call rcirc( xz(n), yz(n) )
              end if

              if (jposhchk == 1) then                            ! only timestep reduction

                 exit

              else if (jposhchk == 2 .or. jposhchk == 3) then    ! set dry all attached links

                 key = 2                                         ! flag redo setkfs

                 do LL  = 1, nd(n)%lnx
                    L   = iabs(nd(n)%ln(LL))
                    hu(L) = 0d0
                 enddo

              else if (jposhchk == 4 .or. jposhchk == 5) then    ! reduce links au

                 do LL  = 1, nd(n)%lnx
                    LLL = nd(n)%ln(LL); L = iabs(LLL)
                    if (hu(L) > 0) then
                       au(L) = 0.2d0*au(L)
                       if (au(L) < eps6) then
                          hu(L) = 0d0 ;  key = 2                 ! flag redo setkfs
                       endif
                    endif
                 enddo

              else if (jposhchk == 6 .or. jposhchk == 7) then    ! only set dry outflowing links

                 do LL  = 1, nd(n)%lnx
                    LLL = nd(n)%ln(LL); L = iabs(LLL)
                    if (LLL < 0 .and. u1(L) > 0 .or. &
                        LLL > 0 .and. u1(L) < 0 ) then
                        hu(L) = 0d0   ; key = 2                  !  flag redo setkfs
                    endif
                 enddo


              endif


           endif


        !   s1(n) = bl(n)
        endif
    endif

 enddo

 if ( jampi.eq.1 ) then
!   reduce nodneg and key
    idum = (/ key, nodneg /)

    if ( jatimer.eq.1 ) call starttimer(IMPIREDUCE)
!    call reduce_key(key)
    call reduce_int_max(2,idum)
    if ( jatimer.eq.1 ) call stoptimer(IMPIREDUCE)

    key = idum(1)
    nodneg = idum(2)
 end if

 if (nodneg /= 0) then
    if (jposhchk == 1 .or. jposhchk == 3   .or. jposhchk == 5 .or. jposhchk == 7) then
        dts = 0.7d0*dts
    endif
    dsetb  = dsetb + 1                               ! total nr of setbacks
    s1     = s0
    vol1 = vol0
    if (dts .lt. dtmin) then
        s1 = max(s1,bl)                              ! above bottom
        call okay(0)
        key = 1                                      ! for easier mouse interrupt
    endif
 endif

 end subroutine poshcheck


 subroutine volsur()                                 ! volsur entirely in s1 because of s1 iteration
 use m_flowgeom
 use m_flow
 use m_ship
 implicit none
 ! locals
 integer           :: japerim
 integer           :: L, n, k1, k2, k
 double precision  :: ha, hh

 japerim = 0

! call sets01zbnd(1) ! set s1 on z-boundaries   SPvdP: not necessary, values at the boundaries were already properly filled in solve_matrix, as the boundary nodes are included in the solution vector

 if (nonlin2D == 0) then

   !$OMP PARALLEL DO                              &
   !$OMP PRIVATE(n,hh)
    do n = 1,ndx2d
       hh = max(0d0, s1(n)-bl(n) )
       vol1(n) = ba(n)*hh
       a1(n)   = ba(n)
    enddo
   !$OMP END PARALLEL DO    !   TODO OMP|

 else

    vol1(1:ndx2d) = 0d0
    a1  (1:ndx2d) = 0d0

 endif

 if (nonlin == 0) then

    do n = ndx2d+1, ndxi
       hh = max(0d0, s1(n)-bl(n) )
       vol1_f(n) = ba(n)*hh
       vol1(n) = ba(n)*hh
       a1(n)   = ba(n)
    enddo

 else

    vol1_f(ndx2D+1:ndxi) = 0d0

    vol1  (ndx2D+1:ndxi) = 0d0
    a1    (ndx2D+1:ndxi) = 0d0

 endif

 if (nonlin == 2) then
    a1m = 0d0
 endif

 call VOL12D(japerim)                                   ! and add area's and volumes of 1D links

 do L = lnxi+1,Lnx
    k1 = ln(1,L) ; k2 = ln(2,L)
    a1  (k1) = ba(k2)                                   ! set bnd a1 to ba of inside point
    vol1(k1) = vol1(k2) ! a1(k1)*(s1(k1) - bl(k1))
    vol1_f(k1) = vol1_f(k2)
 enddo

 end subroutine volsur

 subroutine addlink1D(L,japerim)                        ! and add area's and volumes of 1D links
 use m_flowgeom
 use m_flow
 use m_missing
 use unstruc_channel_flow

 implicit none

 integer           :: japerim, L, ja, calcConv

 integer           :: k1, k2, K, LL
 double precision  :: ar1, wid1, cf1, ar2, wid2, cf2, dx1, dx2, widu, diam, perim
 double precision  :: hpr

 if (japerim == 0) then

    calcConv = 0
    k1  = ln(1,L) ; k2 = ln(2,L)

    dx1 = 0.5d0*dx(L) ; dx2 = dx1
    if (kcu(L) == 1) then
       if ( nd(k1)%lnx == 1 ) then
          dx1 = 2d0*dx1
       endif
       if ( nd(k2)%lnx == 1 ) then
          dx2 = 2d0*dx2
       endif
    endif


    if (kcs(k1) == 1) then
       hpr = s1(k1)-bob0(1,L)
       if (hpr >= 0d0) then
          call getprof_1D(L, hpr, ar1, wid1, japerim, calcConv, perim)
          vol1(k1) = vol1(k1) + dx1*ar1
          if (hpr < epshu) then
             ! make sure A1 gets a value, by computing the profile data, using a water depth of epshu.
             call getprof_1D(L, epshu, ar1, wid1, japerim, calcConv, perim)
          endif
          a1(k1) =   a1(k1) + dx1*wid1
       
          ! flow volume
          if(network%loaded) then
             call getprof_1D(L, hpr, ar1, wid1, 1, calcConv, perim)
             vol1_f(k1) = vol1_f(k1) + dx1*ar1
          else
             vol1_f(k1) = vol1(k1)
          endif
       endif
    endif

    if (kcs(k2) == 1) then
       hpr = s1(k2)-bob0(2,L)
       if (hpr >= 0d0) then
          call getprof_1D(L, hpr, ar2, wid2, japerim, calcConv, perim)
          vol1(k2) = vol1(k2) + dx2*ar2
          if (hpr < epshu) then
             ! make sure A1 gets a value, by computing the profile data, using a water depth of epshu.
             call getprof_1D(L, epshu, ar2, wid2, japerim, calcConv, perim)
          endif
          a1(k2) =   a1(k2) + dx2*wid2
          ! flow volume
          if(network%loaded) then
             call getprof_1D(L, hpr, ar2, wid2, 1, calcConv, perim)
             vol1_f(k2) = vol1_f(k2) + dx2*ar2
          else
             vol1_f(k2) = vol1(k2)
          endif
       endif
    endif

    if (nonlin == 2) then

       LL = L
       if (L > lnxi) then                                   ! for 1D boundary links, refer to attached link
          LL = LBND1D(L)
       endif

       if (network%loaded) then
          hpr = max(0d0,s1m(k1)-bob0(1,L))                   ! this statement is called most nr of times through waterlevel iteration
          if (hpr > 0d0) then
             call getprof_1D_min(L, hpr, ar1, wid1)
             a1m(k1)  = a1m(k1)  + dx1*wid1
             vol1(k1) = vol1(k1) - dx1*ar1
          endif

          hpr = max(0d0,s1m(k2)-bob0(2,L))                   ! this statement is called most nr of times through waterlevel iteration
          if (hpr > 0d0) then
             call getprof_1D_min(L, hpr, ar2, wid2)
             a1m(k2)  = a1m(k2)  + dx2*wid2
             vol1(k2) = vol1(k2) - dx2*ar2
          endif

       elseif (prof1D(3,LL) < 0 ) then                          ! closed
          if (kcs(k1) == 1) then
             hpr = max(0d0,s1m(k1)-bob0(1,L))                   ! this statement is called most nr of times through waterlevel iteration
             if (hpr > 0.5d0*prof1D(2,LL) ) then
                call getprof_1D_min(L, hpr, ar1, wid1)
                a1m(k1)  = a1m(k1)  + dx1*wid1
                vol1(k1) = vol1(k1) - dx1*ar1
             endif
          endif
          if (kcs(k2) == 1) then
             hpr = max(0d0,s1m(k2)-bob0(2,L))                   ! this statement is called most nr of times through waterlevel iteration
             if (hpr > 0.5d0*prof1D(2,LL) ) then
                call getprof_1D_min(L, hpr, ar2, wid2)
                a1m(k2)  = a1m(k2)  + dx2*wid2
                vol1(k2) = vol1(k2) - dx2*ar2
             endif
          endif
       endif

    endif

 else if (hu(L) > 0) then

    calcConv = 1
    call getprof_1D(L, hu(L), au(L), widu, japerim, calcConv, perim)  ! memory closeness of profiles causes this statement here instead of in setau
                                                            ! getprof1D sets cfu
 endif

 end subroutine addlink1D

 subroutine addlink1Dkcu3(L,japerim)                        ! and add area's and volumes of 1D link kcu3
 use m_flowgeom
 use m_flow
 use m_missing

 implicit none

 integer           :: japerim, L, ja

 integer           :: k1, k2, K, calcConv
 double precision  :: ar1, wid1, cf1, ar2, wid2, cf2, dx1, dx2, widu, perim
 double precision  :: hpr

 if (japerim == 0) then
    calcConv = 0
    k1  = ln(1,L) ; k2 = ln(2,L)

    hpr = max(0d0,s1(k1)-bl(k1))    ! this statement is called most nr of times through waterlevel iteration
    if (hpr > 0) then                             !
       call getprof_1D(L, hpr, ar1, wid1, japerim, calcConv, perim)
       dx1  = dx(L)*acl(L)
       a1(k1) =   a1(k1) + dx1*wid1
       vol1(k1)   = vol1(k1)   + dx1*ar1
       vol1_f(k1) = vol1_f(k1) + dx1*ar1
    endif

    hpr = max(0d0,s1(k2)-bl(k2))
    if (hpr > 0) then                             !
       call getprof_1D(L, hpr, ar2, wid2, japerim, calcConv, perim)
       dx2  = dx(L)*(1d0-acl(L))
       a1(k2) =   a1(k2) + dx2*wid2
       vol1(k2)   = vol1(k2)   + dx2*ar2
       vol1_f(k2) = vol1_f(k2) + dx2*ar2
    endif

 else if (hu(L) > 0) then
    calcConv = 1
       call getprof_1D(L, hu(L), au(L), widu, japerim, calcConv, perim)  ! memory closeness of profiles causes this statement here instead of in setau
                                                               ! getprof1D sets cfu
 endif
 end subroutine addlink1Dkcu3


 subroutine addlink1D2D(L,japerim)                         ! and add area's and volumes of 1D2D links
 use m_flowgeom
 use m_flow
 use m_missing

 implicit none

 integer           :: japerim, L

 integer           :: k1, k2, k3, k4, K, jaconv, jaconvu,ifrctyp
 double precision  :: hpr1, ar1, wid1, aconv1, hpr2, ar2, wid2, aconv2, aru, widu, aconvu
 double precision  :: dx1, dx2, frcn, BL1, BL2, b21, wu2, ai
 double precision  :: beta, bt2, deltaa,hyr, uucn, ucna


 k1  = ln(1,L) ; k2 = ln(2,L)
  if (bob0(1,L) < bob0(2,L)) then
    BL1 = bob0(1,L); BL2 = bob0(2,L)
 else
    BL1 = bob0(2,L); BL2 = bob0(1,L)
 endif
 wu2 = wu(L)
 b21 = BL2 - BL1
 ai  = b21/wu2

 if (japerim == 0) then

    hpr1   = s1(k1)-BL1                                                                            ! == 1,2: (ibedlevtyp=3), hrad = A/P   , link or node
    if (hpr1 > 0) then
       call getlinkareawid2D(L,wu2,b21,ai,hpr1,ar1,wid1)
       dx1   = 0.5d0*dx(L)*acl(L)
       if (k1 > ndx2D) dx1 = 2*dx1
       a1(k1)   = a1(k1)   + dx1*wid1
       vol1_f(k1) = vol1_f(k1) + dx1*ar1
       vol1(k1)   = vol1(k1)   + dx1*ar1
    endif

    hpr2 = s1(k2)-BL1                                                                              ! == 5,6: (ibedlevtyp=3), 2D conveyance, link or node
    if (hpr2 > 0) then
       call getlinkareawid2D(L,wu2,b21,ai,hpr2,ar2,wid2)
       dx2      = 0.5d0*dx(L)*(1d0-acl(L))
       if (k2 > ndx2D) dx2 = 2*dx2
       a1(k2)   = a1(k2)   + dx2*wid2
       vol1_f(k2) = vol1_f(k2) + dx2*ar2
       vol1(k2)   = vol1(k2)   + dx2*ar2
    endif

 else if (hu(L) > 0d0) then

    hpr1    = hu(L)

    if (jaconveyance2D > 0) then

       jaconv = min(2,jaconveyance2D)
       frcn = frcu(L) ; ifrctyp = ifrcutp(L)
       CALL getprof2d(hpr1,wu2,b21,ai,frcn,ifrctyp, widu,aru,aconvu,jaconv, beta, deltaa,hyr)

       if (frcn >  0) then
           cfuhi(L) = aifu(L)*ag*aconvu
       else
           cfuhi(L) = 0d0
       endif
       au(L) = aru
    else
       au(L) = hpr1*wu(L)
    endif
 endif
 end subroutine addlink1D2D


 subroutine addlink1D2Dinternal(L,japerim)                         ! and add area's and volumes of 1D2D links
 use m_flowgeom
 use m_flow
 use m_missing

 implicit none

 integer           :: japerim, L

 integer           :: k1, k2, k3, k4, K, jaconv, jaconvu,ifrctyp
 double precision  :: hpr1, ar1, wid1, aconv1, hpr2, ar2, wid2, aconv2, aru, widu, aconvu
 double precision  :: dx1, dx2, frcn, BL1, BL2, b21, wu2, ai
 double precision  :: beta, bt2, deltaa,hyr, uucn, ucna

 k1  = ln(1,L) ; k2 = ln(2,L)
  if (bob0(1,L) < bob0(2,L)) then
    BL1 = bob0(1,L); BL2 = bob0(2,L)
 else
    BL1 = bob0(2,L); BL2 = bob0(1,L)
 endif
 wu2 = wu(L)

 b21 = BL2 - BL1
 ai  = b21/wu2

 if (japerim == 0) then

    hpr1   = s1(k1)-BL1                                                                            ! == 1,2: (ibedlevtyp=3), hrad = A/P   , link or node
    if (hpr1 > 0) then
       call getlinkareawid2D(L,wu2,b21,ai,hpr1,ar1,wid1)
       dx1   = 0.5d0*dx(L)*0.5d0 ! acl(L)
       !if (k1 > ndx2D) dx1 = 2*dx1
       a1(k1)   = a1(k1)   + dx1*wid1
       vol1(k1)   = vol1(k1)   + dx1*ar1
       vol1_f(k1) = vol1_f(k1) + dx1*ar1
    endif

    hpr2 = s1(k2)-BL1                                                                              ! == 5,6: (ibedlevtyp=3), 2D conveyance, link or node
    if (hpr2 > 0) then
       call getlinkareawid2D(L,wu2,b21,ai,hpr2,ar2,wid2)
       dx2      = 0.5d0*dx(L)*0.5d0 ! (1d0-acl(L))
       !if (k2 > ndx2D) dx2 = 2*dx2
       a1(k2)   = a1(k2)   + dx2*wid2
       vol1(k2)   = vol1(k2)   + dx2*ar2
       vol1_f(k2) = vol1_f(k2) + dx2*ar2
    endif

 else if (hu(L) > 0d0) then

    hpr1    = hu(L)

    if (jaconveyance2D > 0) then

       jaconv = min(2,jaconveyance2D)
       frcn = frcu(L) ; ifrctyp = ifrcutp(L)
       CALL getprof2d(hpr1,wu2,b21,ai,frcn,ifrctyp, widu,aru,aconvu,jaconv, beta, deltaa,hyr)

       if (frcn >  0) then
           cfuhi(L) = aifu(L)*ag*aconvu
       else
           cfuhi(L) = 0d0
       endif
       au(L) = aru
    else
       au(L) = hpr1*wu(L)
    endif
 endif
 end subroutine addlink1D2Dinternal

 subroutine addlink2D(L,japerim)                           ! and add area's and volumes of 2D links
 use m_flowgeom
 use m_flow
 use m_missing

 implicit none

 integer           :: japerim, L

 integer           :: k1, k2, k3, k4, K, jaconv, jaconvu, ifrctyp
 double precision  :: hpr1, ar1, wid1, aconv1, hpr2, ar2, wid2, aconv2, aru, widu, aconvu
 double precision  :: dx1, dx2, frcn, BL1, BL2, b21, wu2, ai
 double precision  :: beta, bt2, deltaa, hyr, uucn, ucna, bob1, bob2, bb1, hsmall
 double precision  :: ditcharea, ditchw, ditchconv, Cz, convu

 double precision, external :: cor2linx, cor2liny

 if (japerim == 0) then

    bob1 = bob(1,L) ; bob2 = bob(2,L)
    if (bob1 < bob2) then
       BL1 = bob1 ; BL2 = bob2
    else
       BL1 = bob2 ; BL2 = bob1
    endif
    wu2 = wu(L)   ; b21 = BL2 - BL1 ; ai  = b21/wu2
    k1  = ln(1,L) ; k2  = ln(2,L)

    hpr1 = s1(k1)-BL1
    if (hpr1 > 0) then
       call getlinkareawid2D(L,wu2,b21,ai,hpr1,ar1,wid1)
       dx1      = 0.5d0*dx(L)*acl(L)
       a1(k1)   = a1(k1)   + dx1*wid1
       vol1(k1) = vol1(k1) + dx1*ar1
    endif

    hpr2 = s1(k2)-BL1                                                                          ! == 5,6: (ibedlevtyp=3), 2D conveyance, link or node
    if (hpr2 > 0) then
       call getlinkareawid2D(L,wu2,b21,ai,hpr2,ar2,wid2)
       dx2      = 0.5d0*dx(L)*(1d0-acl(L))
       a1(k2)   = a1(k2)   + dx2*wid2
       vol1(k2) = vol1(k2) + dx2*ar2
    endif

 else if (hu(L) > 0d0) then

    bob1 = bob(1,L) ; bob2 = bob(2,L)

    if (bob1 < bob2) then
       BL1 = bob1 ; BL2 = bob2
    else
       BL1 = bob2 ; BL2 = bob1
    endif
    wu2 = wu(L)

    b21 = BL2 - BL1 ; ai  = b21/wu2
    k1  = ln(1,L) ; k2  = ln(2,L)

    hpr1    = hu(L)

    if (jaconveyance2D > 0) then

       frcn = frcu(L) ; ifrctyp = ifrcutp(L)

       jaconv = jaconveyance2D

       if (jaconv >= 3) then                                                        !> see sysdoc5, 2D conveyance approach I , II
           if (bob(1,L) < bob(2,L)) then
               k3 = lncn(1,L) ; k4 = lncn(2,L)
           else
               k3 = lncn(2,L) ; k4 = lncn(1,L)
           endif

           !bb1 = sign(1d0, bob(2,L) - bob(1,L) )   ! faster coding?
           !k3  = lncn(1,L)*bb1 + lncn(2,L)*(1d0-bb1)
           !k4  = lncn(2,L)*bb1 + lncn(1,L)*(1d0-bb1)

           if (jaconv == 4) then
              hsmall = BL1 + hpr1 - BL2 ! depth at shallow side
              if ( hsmall/hpr1 > 0.9d0) then
                   jaconv = 1           ! Hydr rad
              endif
           endif

           if (jaconv >= 3) then
!              uucn = abs ( ucnx(k3)*csu(L) + ucny(k3)*snu(L))
              uucn = abs( csu(L)*cor2linx(L,1,ucnx(k3),ucny(k3)) + snu(L)*cor2liny(L,1,ucnx(k3),ucny(k3)) )
              ucna =     ( ucnx(k3)**2     + ucny(k3)**2 )
              if (ucna > 0d0 .and. uucn > 0d0) then
                  ucna = sqrt( ucna )
                  beta = sqrt( uucn /  ucna )
                 if (beta > 0.97d0) then
                    beta = 1d0
                 endif
              else
                 beta = 1d0    ! do simple hydraulic radius approach
              endif

!              uucn = abs ( ucnx(k4)*csu(L) + ucny(k4)*snu(L))
              uucn = abs( csu(L)*cor2linx(L,2,ucnx(k4),ucny(k4)) + snu(L)*cor2liny(L,2,ucnx(k4),ucny(k4)) )
              ucna =     ( ucnx(k4)**2     + ucny(k4)**2 )
              if (ucna > 0d0  .and. uucn > 0d0) then
                 ucna = sqrt( ucna)
                 bt2  = sqrt( uucn /  ucna )
                 if (bt2 > 0.97d0) then
                    bt2 = 1d0
                 endif
              else
                 bt2 = 1d0
              endif

              deltaa = (beta - bt2)  / wu2

              if (jaconv == 4) then
                  if (beta == 1d0 .and. bt2 == 1d0) then
                      jaconv = 2
                  endif
              endif

           endif

       endif

       CALL getprof2d(hpr1,wu2,b21,ai,frcn,ifrctyp, widu,aru,aconvu,jaconv, beta, deltaa,hyr)

       if (frcn >  0) then
           cfuhi(L) = aifu(L)*ag*aconvu
       else
           cfuhi(L) = 0d0
       endif
       au(L) = aru
    else
       au(L) = hpr1*wu(L)
    endif
 endif
 end subroutine addlink2D

 subroutine addlinkship2D(L,japerim)  ! but substract, nested Newton
 use m_ship
 use m_flowgeom
 use m_flow
 implicit none
 integer          :: L, japerim

 integer          :: k1, k2, k3, k4
 double precision :: BL1, BL2, b21, wu2, ai, wid1, wid2, hpr1, hpr2, dx1, dx2, ar1, ar2
 k1 = ln  (1,L) ; k2 = ln  (2,L)
 k3 = lncn(1,L) ; k4 = lncn(2,L)
 if (zspc(k3) .ne. 0d0 .or. zspc(k4) .ne. 0d0) then
    if (zspc(k3) < zspc(k4)) then
       BL1 = zspc(k3) ; BL2 = zspc(k4)
    else
       BL1 = zspc(k4) ; BL2 = zspc(k3)
    endif
    wu2  = wu(L)   ; b21 = BL2 - BL1 ; ai  = b21/wu2

    if (japerim == 0) then
       hpr1 = s1m(k1)-BL1
       if (hpr1 > 0) then
          call getlinkareawid2D(L,wu2,b21,ai,hpr1,ar1,wid1)
          dx1      = 0.5d0*dx(L)*acl(L)
          a1m(k1)  = a1m(k1)  + dx1*wid1
          vol1(k1) = vol1(k1) - dx1*ar1
       endif

       hpr2 = s1m(k2)-BL1
       if (hpr2 > 0) then
         call getlinkareawid2D(L,wu2,b21,ai,hpr2,ar2,wid2)
         dx2      = 0.5d0*dx(L)*(1d0-acl(L))
         a1m(k2)  = a1m(k2)  + dx2*wid2
         vol1(k2) = vol1(k2) - dx2*ar2
       endif
    else if (hu(L) > 0) then
       hpr1 = 0.5d0*(s1(k1) + s1(k2)) - BL1
       if (hpr1 > 0) then
          call getlinkareawid2D(L,wu2,b21,ai,hpr1,ar1,wid1)
          au(L) = au(L) - ar1
       endif
    endif
 endif
 end subroutine addlinkship2D

 subroutine volship( )   ! compute ship volume relative to fixed level 0d0
 use m_ship
 use m_flowgeom
 use m_flow
 implicit none

 integer          :: L, k1, k2, k3, k4
 double precision :: BL1, BL2, b21, wu2, ai, wid1, wid2, hpr1, hpr2, dx1, dx2, ar1, ar2, slotsav , dum
 slotsav = slotw2D ; slotw2D = 0d0
 v1ship  = 0d0
 do L = 1,lnx
    k1 = ln  (1,L) ; k2 = ln  (2,L)
    k3 = lncn(1,L) ; k4 = lncn(2,L)
    if (zspc(k3) .ne. 0d0 .or. zspc(k4) .ne. 0d0) then
       if (zspc(k3) < zspc(k4)) then
          BL1 = zspc(k3) ; BL2 = zspc(k4)
       else
          BL1 = zspc(k4) ; BL2 = zspc(k3)
       endif
       wu2  = wu(L)   ; b21 = BL2 - BL1 ; ai  = b21/wu2

       hpr1 = 0d0 - BL1
       if (hpr1 > 0D0) then
          call getlinkareawid2D(L,wu2,b21,ai,hpr1,ar1,wid1)
          dx1         = 0.5d0*dx(L)*acl(L)
          dx2         = 0.5d0*dx(L)*(1d0-acl(L))

          v1ship(k1)  = v1ship(k1) + dx1*ar1
          v1ship(k2)  = v1ship(k2) + dx2*ar1
       endif

    endif
 enddo
 slotw2D = slotsav
 end subroutine volship

 subroutine getlinkareawid2D(L,wu2,dz,ai,hpr,ar,wid)
 use m_flow, only : slotw2D

 implicit none
 integer         , intent(in ) :: L
 double precision, intent(in ) :: wu2,dz,ai,hpr
 double precision, intent(out) :: ar,wid
 double precision              :: hp2

 if (ai < 1d-3) then
 ! if (dz == 0d0) then
    wid = wu2 ; wid = wid + slotw2D
    ar  = wid * hpr
 else if (hpr < dz) then
    wid = wu2 * hpr / dz ; wid = wid + slotw2D
    ar  = 0.5d0*wid*hpr
 else
    wid = wu2 ; wid = wid + slotw2D
    hp2 = hpr - dz
    ar  = wid*0.5d0*(hpr + hp2)
 endif

 end subroutine getlinkareawid2D

 subroutine getprof2D(             hpr,wu2,dz,ai,frcn,ifrctyp, wid,ar,aconv,jaconv,beta,deltaa,hyr)
 use m_flow, only : slotw2D
 implicit none
 double precision, intent (in)  :: hpr,wu2,dz,ai,frcn
 double precision, intent (out) ::                             wid,ar,aconv                              ! aconv = (a/conv)**2
 integer,          intent (in)  ::                    ifrctyp,              jaconv
 double precision  :: d83 = 2.666666d0, d16 = 0.166666d0 , d23 = 0.666666d0, d43= 1.333333d0
 double precision  :: tt, hp2, hrad, Cz, cman, per, hyr, hav, conv, beta, deltaa
 double precision  :: d38 = 0.375d0 , d113 = 3.666666d0 , d311 = 0.27272727d0, hpr83, hp283
 integer           :: jac, L

 ! for jaconv >= 1, this routine gets conveyance, but without friction surface to horizontal plane surface ratio influence on conveyance
 ! this constant value, (1+(dz/dy)**2)**0.25 is computed once and is volume cell based instead of link based
 ! Aconv = (A/K)**2 = 1/(C.C.R), K=Conv=sum(ACsqrt(R))

 if (ai < 1d-3) then
 ! if (dz == 0d0) then
    wid = wu2 ; wid = wid + slotw2D ! wid = max(wid, slotw2d)
    ar  = wid * hpr
    hyr = hpr
 else if (hpr < dz) then
    wid = wu2 * hpr / dz ; wid = wid + slotw2D ! wid = max(wid, slotw2d)
    ar  = 0.5d0*wid*hpr
    if (jaconv == 1) then
       per = sqrt(hpr*hpr + wid*wid)
       hyr = ar/per
    endif
 else
    wid = wu2 ; wid = wid + slotw2D ! wid = max(wid, slotw2d)
    hp2 = hpr - dz
    ar  = wid*0.5d0*(hpr + hp2)
    if (jaconv == 1) then
       per = sqrt(dz*dz + wid*wid)
       hyr = ar/per
    endif
 endif

 if (jaconv == 0) then
    return
 else if (frcn == 0d0) then
    aconv = 0d0 ;  return
 else if (jaconv == 1) then                       ! hydraulic radius type

    call getcz(hyr, frcn, ifrctyp, Cz, L)
    aconv = 1d0/ (Cz*Cz*hyr)

 else if (jaconv >= 2) then                       ! 1D analytic conveyance type
    if (ifrctyp == 1) then
       cman = frcn
    else
       if (ai < 1d-3) then
          hav = hpr
       else if (hpr < dz) then
          hav = 0.5d0*hpr
       else
          hav = hpr -0.5d0*dz
       endif
       call getcz(hav, frcn, ifrctyp, Cz,L)
       cman = hav**d16/Cz
    endif

    jac = jaconv
    if (jaconv == 3 .and. beta == 0d0) jac = 2
    if (jac == 2) then
       if (ai < 1d-3 ) then                       ! see sysdoc 5 1D conveyance
          aconv = (cman/hpr**d23)**2
       else if (hpr < dz) then
          aconv = (d43*cman/hpr**d23)**2
       else
          aconv = (d43*cman*(hpr*hpr - hp2*hp2)/(hpr**d83-hp2**d83) )**2
       endif
    else
       if (ai < 1d-3 ) then                       ! see sysdoc 5 2D conveyance
          aconv = (cman / (beta*hpr**d23) )**2
       else if (hpr < dz) then
          hpr83 = hpr**d83
          conv  = ( beta - hpr*deltaa/ai ) * d38 * hpr83  + (deltaa*d311/ai)*hpr*hpr83
          conv  = conv / ai
          aconv = (cman*ar/conv)**2
       else
          hpr83 = hpr**d83; hp283 = hp2**d83
          conv  = ( beta - hpr*deltaa/ai ) * d38 * (hpr83 - hp283) + (deltaa*d311/ai)*(hpr*hpr83 - hp2*hp283)
          conv  = conv / ai
          aconv = (cman*ar/conv)**2
       endif
    endif
 endif
 end subroutine getprof2D

 subroutine fixedweirfriction2D(L,k1,k2,frL)                ! frL of fixed weir
 use m_flowgeom
 use m_flow
 use m_missing

 implicit none

 integer          :: L
 double precision :: frL

 integer          :: k1, k2
 double precision :: umod, uin, frLk1, frLk2, ucxk, ucyk, Cz, weirheight, weirlength, flatlength, a, ff

 if (frcu(L) == 0 .or. hu(L) < epshu) then
     frL = 0d0 ; return
 endif

 if (fixedweirtopfrictcoef .ne. dmiss) then               ! standard friction on weirtop only
     call getcz(hu(L), fixedweirtopfrictcoef, ifrcutp(L), Cz, L)
 else
     call getcz(hu(L), frcu(L), ifrcutp(L), Cz, L)
 endif

 umod  = sqrt( u1(L)*u1(L) + v(L)*v(L) )
 frL   = umod*ag / (Cz*Cz*hu(L))               ! on top of weir
 frLk1 = frL                                   ! on side 1
 frLk2 = frL                                   ! on side 2

 weirheight = max(0d0, 0.5d0*(bob(1,L) + bob(2,L)) - 0.5d0*(bl(k1) + bl(k2)) )
 weirlength = fixedweirtopwidth
 flatlength = max(weirlength , dx(L) - (weirlength + 2d0*weirheight*fixedweirtalud) )
 a          = weirlength / (weirlength + flatlength)

 if (ifxedweirfrictscheme == 1) then           ! simple bedlevel&velocity
                                               ! assumption + direct linearisation
    if (hs(k1) > 0d0) then
       ff    = min(1d0, hu(L)/hs(k1) )
       umod = sqrt( u1(L)*u1(L)*ff*ff + v(L)*v(L) )
       call getcz(hs(k1), frcu(L), ifrcutp(L), Cz, L)
       frLk1 = umod*ff*ag / (Cz*Cz*hs(k1))
    endif

    if (hs(k2) > 0d0) then
       ff    = min(1d0, hu(L)/hs(k2) )
       umod = sqrt( u1(L)*u1(L)*ff*ff + v(L)*v(L) )
       call getcz(hs(k2), frcu(L), ifrcutp(L), Cz, L)
       frLk2 = umod*ff*ag / (Cz*Cz*hs(k2))
    endif

    frL  = a*frL + (1d0-a)*( (frLk1+frLk2)*0.5d0 )

 else if (ifxedweirfrictscheme == 2) then         ! Without weir like WAQUA

    if (hs(k1) > 0d0) then
       ff    = min(1d0, hu(L)/hs(k1) )
       umod = sqrt( u1(L)*u1(L)*ff*ff + v(L)*v(L) )
       call getcz(hs(k1), frcu(L), ifrcutp(L), Cz, L)
       frLk1 = umod*ff*ag / (Cz*Cz*hs(k1))
    endif

    if (hs(k2) > 0d0) then
       ff    = min(1d0, hu(L)/hs(k2) )
       umod = sqrt( u1(L)*u1(L)*ff*ff + v(L)*v(L) )
       call getcz(hs(k2), frcu(L), ifrcutp(L), Cz, L)
       frLk2 = umod*ff*ag / (Cz*Cz*hs(k2))
    endif

    frL  = (frLk1+frLk2)*0.5d0

 else if (ifxedweirfrictscheme == 3) then       ! full undisturbed velocity reconstruction

    if (abs(u1(L)) > 0.1d0) then

       if (hs(k1) > 0d0) then
          call getucxucynoweirs(k1, ucxk, ucyk, ifixedweirscheme )
          umod = sqrt(ucxk*ucxk   + ucyk*ucyk)
          uin  = abs( ucxk*csu(L) + ucyk*snu(L) )
          call getcz(hs(k1), frcu(L), ifrcutp(L), Cz, L)
          frLk1 = umod*uin*ag / (Cz*Cz*hs(k1)*u1(L))
       endif

       if (hs(k2) > 0d0) then
          call getucxucynoweirs(k2, ucxk, ucyk, ifixedweirscheme )
          umod = sqrt(ucxk*ucxk   + ucyk*ucyk)
          uin  = abs( ucxk*csu(L) + ucyk*snu(L) )
          call getcz(hs(k2), frcu(L), ifrcutp(L), Cz, L)
          frLk2 = umod*uin*ag / (Cz*Cz*hs(k2)*u1(L))
       endif

    endif

    frL = a*frL + (1d0-a)*( (frLk1+frLk2)*0.5d0 )

 endif

 end subroutine fixedweirfriction2D

subroutine widar(hpr,dz,wu2,wid,ar)
 use m_flow, only :  slotw2D
 implicit none
 double precision :: hpr,dz,wu2,wid,ar,hyr
 double precision :: per, hp2
 if (dz/wu2 < 1d-3) then
    wid = wu2 ; wid = wid + slotw2D
    ar  = wid * hpr
 else if (hpr < dz) then
    wid = wu2 * hpr / dz ; wid = wid + slotw2D
    ar  = 0.5d0*wid*hpr
 else
    wid = wu2 ; wid = wid + slotw2D
    hp2 = hpr - dz
    ar  = wid*0.5d0*(hpr + hp2)
 endif
end subroutine widar


subroutine widarhyr(hpr,dz,wu2,wid,ar,hyr)
 use m_flow, only :  slotw2D
 implicit none
 double precision :: hpr,dz,wu2,wid,ar,hyr
 double precision :: per, hp2
 if (dz/wu2 < 1d-3) then
    wid = wu2 ; wid = wid + slotw2D
    ar  = wid * hpr
    hyr = hpr
 else if (hpr < dz) then
    wid = wu2 * hpr / dz ; wid = wid + slotw2D
    ar  = 0.5d0*wid*hpr
    per = sqrt(hpr*hpr + wid*wid)
    hyr = ar/per
 else
    wid = wu2 ; wid = wid + slotw2D ! wid = max(wid, slotw2d)
    hp2 = hpr - dz
    ar  = wid*0.5d0*(hpr + hp2)
    per = sqrt(dz*dz + wid*wid)
    hyr = ar/per
 endif
end subroutine widarhyr


subroutine getseg1D(hpr,wu2,dz,ai,frcn,ifrctyp, wid,ar,conv,perim,jaconv)  ! copy of above routine dressed out for 1D
 implicit none
 double precision, intent (in)  ::     hpr,wu2,dz,ai,frcn
 double precision, intent (out) ::                                 wid,ar,conv,perim        !
 integer,          intent (in)  ::                         ifrctyp                   ,jaconv
 double precision  :: d83 = 2.666666d0, d16 = 0.166666d0 , d23 = 0.666666d0, d43= 1.333333d0
 double precision  :: tt, hp2, hrad, Cz, cman, per, hav
 double precision  :: d38 = 0.375d0 , d113 = 3.666666d0 , d311 = 0.27272727d0, hpr83, hp283, d14 = 0.25d0
 integer           :: jac, L

 ! for jaconv >= 1, this routine gets 1D conveyance
 ! this constant value, (1+(dz/dy)**2)**0.25 is computed once and is volume cell based instead of link based

 if (ai < 1d-3) then
    wid = wu2
    ar  = wid * hpr
 else if (hpr < dz) then
    wid = wu2 * hpr / dz
    ar  = 0.5d0*wid*hpr
 else
    wid = wu2
    hp2 = hpr - dz
    ar  = wid*0.5d0*(hpr + hp2)
 endif

 if (jaconv == 0) then
    return
 else if (frcn == 0d0) then
    conv = 0d0 ;  return
 else if (jaconv == 1) then                       ! hydraulic radius type

    if (ai < 1d-3) then
       perim = wid
    else if (hpr < dz) then
       perim = sqrt(wid*wid + hpr*hpr)
    else
       perim = sqrt(wid*wid + (hpr-hp2)*(hpr-hp2) )
    endif

 else if (jaconv >= 2) then                       ! 1D analytic conveyance type
    if (ifrctyp == 1) then
       cman = frcn
    else
       if (ai < 1d-3) then
          hav = hpr
       else if (hpr < dz) then
          hav = 0.5d0*hpr
       else
          hav = hpr -0.5d0*dz
       endif
       call getcz(hav, frcn, ifrctyp, Cz, L)
       cman = hav**d16/Cz
    endif

    if (ai < 1d-3 ) then                       ! see sysdoc 5 1D conveyance
       conv = ( ar *hpr**d23             ) / ( cman                     )
    else if (hpr < dz) then
       conv = ( d38*hpr**d83             ) / ( cman*ai*(1d0+ai*ai)**d14 )
    else
       conv = ( d38*(hpr**d83-hp2**d83)  ) / ( cman*ai*(1d0+ai*ai)**d14 )
    endif

 endif
 end subroutine getseg1D

 subroutine VOL12D(japerim)                                 ! and add area's and volumes of 1D and 2D links, japerim=1: also set conveyance
 use m_flowgeom
 use unstruc_channel_flow
 use m_oned_functions
 use m_storage
 use m_flow
 use m_missing
 use m_ship

 implicit none

 integer           :: japerim

 integer           :: L, k1, k2, K, n, kk, kb, kt, nl1 , nl2, i, nstor
 double precision  :: hh, slotsav, sl1, sl2
 type(t_storage), dimension(:), pointer :: stors

 nl1 = nonlin1D
 nl2 = nonlin2D
 sl1 = slotw1D
 sl2 = slotw2D

 if (japerim == 1 .or. nonlin > 0) then



    nstor = network%stors%count
 if (japerim == 0 .and. nstor > 0) then
    stors => network%stors%stor
    do i = 1, nstor
       k1 = stors(i)%gridPoint
       vol1(k1) = vol1(k1) + getVolume(stors(i), s1(k1))
       a1(k1)   = a1(k1)   + getSurface(stors(i), s1(k1))
    enddo
 endif

 do L   = 1,lnx1D                                  ! regular 1D links
    if (kcu(L) == 4) then
       call addlink1D2D(L,japerim)                 ! 1D2D lateral inherits 2D
    else if (kcu(L) == 3) then
       if (ja1D2Dinternallinktype >= 1) then       ! testing one two...
          call addlink1D2Dinternal(L, japerim)
       else
          call addlink1Dkcu3(L,japerim)
       endif
    else
       call addlink1D(L,japerim)                   ! regular 1D link and original 1D2D internal links
    endif
 enddo
 endif

 if (japerim == 1 .or. nonlin2D > 0) then
    do L = lnx1D + 1, lnxi
       call addlink2D(L,japerim)                   ! regular 2D links
    enddo
 endif

 do L   = lnxi+1,lnx
    if (kcu(L) == -1) then
       if (japerim == 0 .and. nonlin1D == 0) cycle
       call addlink1D(L,japerim)                   ! 1D boundary links
    else
       if (japerim == 0 .and. nonlin2D == 0) cycle
       call addlink2D(L,japerim)                   ! 2D boundary links
    endif
 enddo

 if (nshiptxy > 0) then
    if (japerim == 1 .or. nonlin == 2 .and. japressurehull >= 2) then                     ! and nonlin == 2
       call addship2D(japerim)
       if (japressurehull == 3 .and. japerim == 0) then
          do n = 1,ndx
             vol1(n) = vol1(n) - v1ship(n)
          enddo
       endif
    endif
 endif

 if (japerim == 0) then

    if (nonlin2D > 0) then
       call addclosed_2D_walls()                   ! 2D Dichte wanden
    endif

 endif

 end subroutine VOL12D

 subroutine addclosed_2D_walls()
 use m_flowgeom
 use m_flow
 use m_missing

 implicit none

 integer          :: n, k1
 double precision :: bl1, aa1, hh1

 do n   = 1, mxwalls
    k1  = walls(1,n)
    bl1 = walls(13,n)
    aa1 = walls(17,n)
    hh1 = s1(k1) - bl1
    a1(k1)  = a1(k1) + aa1
    if (hh1 > 0d0) then
       vol1(k1) = vol1(k1) + aa1*hh1
    endif
 enddo

 end subroutine addclosed_2D_walls


 !> adjust bobs and iadvec for dams and structs
 subroutine adjust_bobs_for_dams_and_structs()
    use m_flowgeom
    use m_flow
    use m_netw
    use m_fixedweirs
    use unstruc_channel_flow
    use m_1d_structures
    use m_compound

    implicit none

    double precision :: zcdamn, minzcdamn, blmx
    type(t_structure), pointer :: pstru
    type(t_compound),  pointer :: pcompound

    integer :: L0
    integer          :: ng, k1, k2, L, n, istru, icompound, i

    do ng = 1,ncdamsg                                   ! loop over cdam signals, sethu
       zcdamn = zcdam(ng)
       do n   = L1cdamsg(ng), L2cdamsg(ng)
           k1       = kcdam(1,n)
           k2       = kcdam(2,n)
           L        = kcdam(3,n)
           blmx     = max(bl(k1), bl(k2))
           bob(1,L) = max(zcdamn,blmx)
           bob(2,L) = max(zcdamn,blmx)
        enddo
    enddo

    do ng = 1,ncgensg                                   ! loop over general structures signals, sethu
       zcdamn = zcgen(3*(ng-1)+1) ! TODO: actually, the crest/sill_width should be included here: not all flow links may be open
       do n   = L1cgensg(ng), L2cgensg(ng)
           k1       = kcgen(1,n)
           k2       = kcgen(2,n)
           L        = kcgen(3,n)
           blmx     = max(bl(k1), bl(k2))
           bob(1,L) = max(zcdamn,blmx)
           bob(2,L) = max(zcdamn,blmx)
           call switchiadvnearlink(L)
       enddo
    enddo

    do istru = 1, network%sts%count
        pstru => network%sts%struct(istru)
        zcdamn = get_crest_level(pstru)
        if (zcdamn == huge(1d0)) then
           ! Do not shut off structures that have no relevant crest (e.g. pumps)
           cycle
        end if

        do L0 = 1, pstru%numlinks
           L  = iabs(pstru%linknumbers(L0))
           k1 = ln(1,L)
           k2 = ln(2,L)
           bob(1,L) = max(zcdamn, bob0(1, L))
           bob(2,L) = max(zcdamn, bob0(2, L))
           iadv(L) = 22
           call switchiadvnearlink(L)
        enddo

    enddo

    ! correct BOBS for compound structures
    do icompound = 1, network%cmps%Count
       pcompound => network%cmps%compound(icompound)
       minzcdamn = huge(1d0)
       do i = 1, pcompound%numstructs
          istru = pcompound%structure_indices(i)
          pstru => network%sts%struct(istru)
          zcdamn = get_crest_level(pstru)
          if (zcdamn == huge(1d0)) then
             ! Obviously this is a pump. So do not adust the bob
             minzcdamn = huge(1d0)
             exit
          endif
          
          minzcdamn = min(minzcdamn, zcdamn)
       enddo
       if (minzcdamn < huge(1d0)) then
          do L0 = 1, pcompound%numlinks
             L  = iabs(pcompound%linknumbers(L0))
             k1 = ln(1,L)
             k2 = ln(2,L)
             bob(1,L) = max(minzcdamn, bob0(1, L))
             bob(2,L) = max(minzcdamn, bob0(2, L))
          enddo
       endif
    enddo
    
       
   !Adjust bobs for dambreak
   if (ndambreak > 0) then ! needed, because ndambreaksg may be > 0, but ndambreak==0, and then arrays are not available.
   do n = 1, ndambreaksg
      istru = dambreaks(n)
      if (istru.ne.0) then
         ! Update the bottom levels
         call adjust_bobs_on_dambreak_breach(network%sts%struct(istru)%dambreak%width, network%sts%struct(istru)%dambreak%crl,  LStartBreach(n), L1dambreaksg(n), L2dambreaksg(n), network%sts%struct(istru)%id)
      endif
   enddo
   end if

   return
   end subroutine adjust_bobs_for_dams_and_structs

subroutine sethu(jazws0)                            ! Set upwind waterdepth hu
 use m_flowgeom                                      ! Todo: higher order + limiter, see transport
 use m_flow
 use m_flowtimes
 use m_sediment
 use m_fixedweirs
 use m_sobekdfm
 use m_sferic
 use m_missing
 use m_netw, only: xk, yk
 use unstruc_model, only:md_restartfile
 use geometry_module, only: dbdistance

 implicit none

 ! locals
 integer           :: L, k1, k2, ku, kd, isg, LL, k, Ld, iup, nq, kk, ifrctyp, jazws0
 integer           :: n, kb, kb0, kt, itpbn, ng, jawet, Lb, nfw
 double precision  :: zb, hh, dtgh
 double precision  :: sup, bup, sk1, sk2, hs1, hs2, epsh, qdak
 double precision  :: hsav, hul, utp, hup
 double precision  :: huk1, huk2, hsku, sigm
 double precision  :: onet = 1d0/3d0
 double precision  :: twot = 2d0/3d0
 double precision  :: tgi  = 1d0/(2d0*9.81d0)
 double precision  :: ds, ds1, ds2, ds0, xx, hdl, bupmin, he, zcdamn, hcrest, uin, blmx, fdx
 double precision  :: h0, dzb, cz, sixth = 1d0/6d0, frcn, z00, sqcf, uuL, vhei, eup, ucxku, ucyku, vben, uLL, agwdxi

 double precision  :: Qweir_super, Qweir_sub, wu_orig
 double precision  :: weirrelax = 0.75d0
 double precision  :: Qrat, re, Edown, ucxkd, ucykd
 double precision  :: dp, d2, aa, hucrest, hunoweir, qweirsimple, ufac, efac

 double precision  :: avolk, hkruin, wsbov, wsben, d1, ewben, eweir, qvolk, qunit, hov, vov, vbov, hvolk, dte0, dtefri, qov, tol
 double precision  :: sl1, sl2, sl3, sku
 character (len=4) :: toest

 integer           :: k3, k4, itel, kuu, ku2, kku, ip , Lnu

 double precision, external :: dslim,  nod2linx, nod2liny

 ! SPvdP: s0 at the old time level already satisfies the boundary conditions at the old time level (see s1nod)
 !  Nevertheless, s0 at the boundary (at the old time-level) will now be filled with boundary conditions at the new time level
 if(jazws0==0 .or. len_trim(md_restartfile)==0) then
    ! if(jazws0==1 .and. len_trim(md_restartfile)>0) then s0 and s1 are read from restart file, in this case, no need to call the following subroutine
    call sets01zbnd(0)                               ! set s0 on z-boundaries
 endif

 if (uniformhu > 0d0) then
    hu = uniformhu ; return
 endif

 !
 ! SPvdP: water-levels at the velocity boundaries do already satisfy the Neumann condition (see s1nod)
 !
 !do n  = 1, nbndu                                    ! velocity boundaries
 !   kb     = kbndu(1,n)
 !   k2     = kbndu(2,n)
 !   s0(kb) = s0(k2)
 !enddo

 ! adjust bobs for controllable dams
 call adjust_bobs_for_dams_and_structs()

 avolk = twot*sqrt(twot*ag)
 nfw   = 0

 do L = 1,lnx

!   for cut-cells
    if (wu(L).eq.0d0 ) then
       hu(L) = 0d0
       cycle
    end if

    k1 = ln(1,L) ; k2 = ln(2,L)

    if (jazws0 == 0) then
       uuL = u1(L)
    else
       uuL = u0(L)
    endif

    if ( uuL > 0) then           ! was q1 (halfway the timestep), jazws0 assigns if start of loop or loop itself is considered
       iup = 1  ; ku = k1 ; kd = k2 ; isg =  1
    else if (uuL < 0) then
       iup = 2  ; ku = k2 ; kd = k1 ; isg = -1
    else if ( s0(k1) > s0(k2) ) then
       iup = 1  ; ku = k1 ; kd = k2 ; isg =  1
    else
       iup = 2  ; ku = k2 ; kd = k1 ; isg = -1
    endif

    sup = s0(ku)

    if (limtyphu > 0 ) then
        if (limtyphu == 21) then      ! central
           sup = 0.5d0*( s0(k1) + s0(k2) )
        else if (limtyphu == 22) then ! perot alfa
           sup = acl(L)*s0(k1) + (1d0-acl(L))*s0(k2)
        else if (limtyphu == 23) then ! regular linear interpolation
           sup = acl(L)*s0(k2) + (1d0-acl(L))*s0(k1)
        else                          ! usual limiters except 6
           if (uuL > 0) then
              ip = 0
           else
              ip = 3
           endif
           ds2 = s0(kd) - s0(ku)

           kku = klnup(1+ip,L)
           kuu = abs(kku) ; sku = dmiss
           if (kku < 0) then
              sku = s0(kuu)
           else if (kuu > 0) then
              ku2 = iabs(klnup(2+ip,L))
              if ( ku2 > 0) then
                 sl1 = slnup(1+ip,L) ; sl2  = slnup(2+ip,L)
                 sku = s0(kuu)*sl1 + s0(ku2)*sl2
              endif
           endif
           if (sku .ne. dmiss) then
              sl3 = slnup(3+ip,L)
              ds1 = (s0(ku)  - sku)*sl3
              sup = sup + dslim(ds1, ds2, limtyphu)
           endif
        endif
    endif

    ! TODO: while documenting 1D2D code, we discovered the following undesirable bup:
    ! it should by default be the max(bob1/2), if conveyance2D < 1. Not yet changed.
    bup = bob(iup,L)

    if (L <= lnx1D) then      ! 1D
       if (kcu(L) == 4 .and. jaconveyance2D >= 1) then
           bup = min( bob(1,L), bob(2,L) )
       else if (kcu(L) == 5 .or. kcu(L) == 7) then
           bup = max( bob(1,L), bob(2,L) )
       else
           bup = max( bob(1,L), bob(2,L) )
       endif
       if (jagrounlay > 0) then
          bup = bup + grounlay(L)
       endif

    else if (kmx == 0 .and. jaconveyance2D >= 1) then
       bup = min( bob(1,L), bob(2,L) )
    endif

    huL = sup-bup

    if (huL  > epshu) then

       if (ncdamsg > 0 .or. ifixedweirscheme > 0) then                           ! sethu

          if (iadv(L) == 21 .or. iadv(L) >= 23 .and. iadv(L) <= 25) then         ! weir velocity point


             if (iadv(L) >= 23 .and. iadv(L) <= 25) then                         ! undisturbed velocity as if no weir present, WAQUA like
                hunoweir  = sup - blu(L) ! bob(1,L)                              ! 23 = Rajaratnam, 24 = Tabellenboek, 25 = Villemonte
                hunoweir  = max(hunoweir, huL) 
                ucxku     = ucx(ku) ; ucyku = ucy(ku)
             else
                call getucxucynoweirs(ku, ucxku, ucyku, ifixedweirscheme )
             endif

             if (iadv(L) >= 23 .and. iadv(L) <= 25) then                         ! 23 = Rajaratnam, 24 = Tabellenboek, 25 = Villemonte
                 ! uin = ucxku*csfxw(nfw) + ucyku*snfxw(nfw)
                 uin = abs(u1(L))
             else
                 uin = ucxku*csu(L) + ucyku*snu(L)                               ! semi subgrid
             endif
             vhei = 0.5d0*uin*uin / ag
             eup  = hul + vhei

             if (iadv(L) == 21 .or. iadv(L) == 23) then

                hcrest= s0(kd) - bup

                if ( hcrest < hul ) then

                    huL = hcrest

                    if (hul < twot*eup) then ! supercritical

                       hul = twot*eup

                       hup = hcrest - hul

                       if (hup < 0) then
                          adve(L) = adve(L) - isg*hup*ag*dxi(L)
                       endif

                    endif


                endif ! hcrest< hul

             endif

             if (iadv(L) == -21) then !+-21

                if (jasfer3D == 1) then
                   uin = nod2linx(L,iup,ucxku,ucyku)*csu(L) + nod2liny(L,iup,ucxku,ucyku)*snu(L)
                endif
                fdx     = 0.5d0*dxi(L)*isg
                advi(L) = advi(L) + fdx*u0(L)
                adve(L) = adve(L) - fdx*uin*uin

             else if (iadv(L) == 23) then       ! simple Rajaratnam

                 ufac    = hunoweir / huL  ! compensates for undisturbed field velocity
                 efac    = 1d0 - (1d0/ufac**2)
                 advi(L) = advi(L) + 0.5d0*dxi(L)*abs(u1(L))*ufac*ufac*efac
                 huL     = hunoweir

             else if (iadv(L) == 24 .or. iadv(L) == 25) then  !  Tabellenboek or Villemonte from WAQUA

                 nfw    =  nfxwL(L)

                 wsbov  =  sup
                 wsben  =  s0(kd)
                 hkruin = -bup

                 ! d1     =  bup - blu(L)   !! old implementation

                 ! determine sill height downstream of weir
                 !
                 if (uin .ge. 0.0 ) then
                     d1 = shrxw(nfw)
                 else
                     d1 = shlxw(nfw)
                 endif

                 ! vbov   =  abs(u1(L))
                 ! vbov   =  sqrt(ucxku*ucxku + ucyku*ucyku)
                 vbov   =  abs(uin)
                 vhei   =  0.5d0*vbov*vbov / ag
                 eweir  =  max (0.000001d0, wsbov + hkruin) + vhei
                 qvolk  =  avolk*eweir**1.5d0
                 qunit  =  vbov*hunoweir

                 ! Compute energy height downstream (EWBEN)
                 vben   = qunit / max (0.000001d0,wsben - bl(kd))
                 vhei   =  0.5d0*vben*vben / ag
                 ewben  =  max (0.000001d0, wsben + hkruin) + vhei
                 ! limit downstream energy height EWBEN by upstream enegy height EWEIR
                 ewben = min(ewben, eweir)

                 ! Qunit  = abs(q1(L)) / wu(L)

                 hov    =  wsbov + hkruin
                 vov    =  qunit/hov
                 if (vov < 0.5d0 ) then
                    itel  = 0
                    hvolk = twot*eweir
                    tol   = 0.001d0 *max(0.0001d0, qunit)
                    qov   = 0d0
                    do while (itel < 100 .and. (abs(qunit - qov)) > tol )
                       itel = itel + 1
                       vov  = qunit / hov
                       hov  = max(hvolk, eweir - (vov**2)/(2d0*ag) )
                       qov  = vov*hov
                    enddo
                 endif
                 dte0   = weirdte(nfw)
                 dtefri = 0.0d0
                 call enloss(ag, d1, eweir, hkruin, hov,                   &
                             qunit, qvolk, toest, vov,                     &
                             ewben, wsbov, wsben, weirdte(nfw),              &
                             dtefri,iadv(L), crestlxw(nfw),                &
                             taludlxw(nfw), taludrxw(nfw), vegxw(nfw) )
                 weirdte(nfw) = (1d0 - waquaweirthetaw)*weirdte(nfw) + waquaweirthetaw*dte0
                 ! attention total waterdepth instead of water above crest
                 if ( toest == 'volk' ) then
                     vbov = qvolk/max(hunoweir, 1d-6 )
                 endif
                 if (vbov > 1d-4) then
                     agwdxi  = ag*weirdte(nfw)*dxi(L)
                     if (kmx == 0) then
                        advi(L) = advi(L) + agwdxi/vbov        ! 1/s
                     else
                        do LL = Lbot(L), Ltop(L)
                           uLL      = max(1d-4, abs(u1(LL)))
                           advi(LL) = advi(LL) + agwdxi/uLL
                        enddo
                    endif
                 endif
                 huL = hunoweir

             else


             endif

          endif ! kadepunt

       endif

       hu(L) = huL

    else
       hu(L) = 0d0
    endif

    if (kmx > 0) then
       Lb       = Lbot(L)
       ! hu(Lb:Lb+kmxL(L)-1 ) = 0d0 ! visualise
       if(hu(L) > 0d0) then
          kt      = ktop(ku)
          ! kb      = min ( ln( iup,Lb ) , kt )
          kb      = min ( ln0( iup,Lb ) , kt )  ! dickv

          kb0     = kb - 1                   ! kbot(ku) - 1
          Ltop(L) = Lb + kt - kb

          if (Ltop(L) > Lb + kmxL(L) - 1) then
             call qnerror('Ltop too large',' ',' ')
          endif

          hsku  = zws(kt) - zws(kb0)
          au(L) = 0d0
          do LL = Lb, Ltop(L)
             sigm   = (zws(kb+LL-Lb)-zws(kb0)) / hsku
             hu(LL) = sigm *hu(L)
             au(LL) = wu(L)*hu(LL)  ! this is only for now here, later move to addlink etc
             if (LL > Lb) then
                 au(LL) = wu(L)*(hu(LL)-hu(LL-1))
             endif
             au(L) = au(L) + au(LL) ! add to integrated 2Dh layer
          enddo

       else
          Ltop(L) = 1 ! lb - 1 ! 1 ! flag dry
       endif

    endif

 enddo

 do L = 1,lnx
    k1 = ln(1,L) ; k2 = ln(2,L)
    hsav  = max(epshs, acl(L)*hs(k1) + (1d0-acl(L))*hs(k2) )
    huvli(L) = 1d0 / hsav
 enddo

 if (lincontin == 1) then
    do L = 1,lnx
       hu(L) = -0.5d0*( bob(1,L) + bob(2,L) )
    enddo
 endif


 if (nbnd1d2d > 0) then       ! 1d2d boundary check for closed boundaries
    call sethu_1d2d()
 endif

 if (javeg > 0) then
    call setveg()
 endif

end subroutine sethu



 subroutine bathyupdate()
 use m_flowgeom
 use m_flow
 use m_netw, only : zk, zk0, zk1, numk
 use m_sediment   !, only : jamorf

 implicit none
 integer           :: L, k, kk, kkk, k1, k2, n, nn, ierr, ja, k3, k4
 double precision  :: znn, bobm, zki

 if (jamorf == 0) return
 if (stm_included) return ! Done in fm_bott3d

 if (.not. (ibedlevtyp == 1 .or. ibedlevtyp == 6) .and. jaceneqtr == 1 .and. .not. allocated(zn2rn) ) then ! netnode depth + netcell fluxes                                                        !

    if (allocated (zk1) ) deallocate( zk1)
    allocate  ( zk1(numk) , stat=ierr)
    call aerr ('zk1(numk)', ierr , numk) ; zk1 = 0d0

    ja = 0
    if (.not. allocated(zn2rn)) then
        ja = 1
    else if (size(zn2rn) < numk) then
        deallocate(zn2rn) ; ja = 1
    endif
    if (ja == 1) then
        allocate ( zn2rn(numk) , stat = ierr)
        call aerr('zn2rn(numk)', ierr , numk); zn2rn = 0d0
        do n = 1, ndx2d
           nn  = size(nd(n)%x)
           do kk = 1, nn
              kkk        = nd(n)%nod(kk)
              zn2rn(kkk) = zn2rn(kkk)   + ba(n)
           enddo
        enddo
    endif

 endif

 if (ibedlevtyp == 1 .or. ibedlevtyp == 6) then     ! tiledepth types

    bl   = bl + blinc

    do L = lnx1D+1, lnx
       bob(1,L)  = max( bl(ln(1,L)), bl(ln(2,L)) )
       bob(2,L)  = bob(1,L)
    enddo

 else                     ! netnode types

    if ( jaceneqtr == 1) then
       zk1  = 0d0
       do n = 1, ndx2d
          znn = blinc(n)
          if (znn .ne. 0d0) then
             nn  = size(nd(n)%x)
             do kk = 1, nn
                kkk      = nd(n)%nod(kk)
                zk1(kkk) = zk1(kkk) + znn*ba(n)
             enddo
          endif
       enddo

       do k = 1,numk
          if (zk1(k) .ne. 0d0) then
             if (zn2rn(k) >  0) then
                zki    = zk1(k)/zn2rn(k)     ! increment
                zk (k) = zk(k) + zki         ! new bathy
             endif
          endif
       enddo
    else ! update already done in subroutine  transport

    endif


    ! TODO: Herman: should we skip the step below if optional ibedlevmode==BLMODE_D3D?
    bl(1:ndxi) = 1d9

    do L = lnx1D+1, lnxi
       k3       = lncn(1,L)
       k4       = lncn(2,L)
       bob(1,L) = zk(k3)
       bob(2,L) = zk(k4)
       bobm     = min( bob(1,L), bob(2,L) )
       k1 = ln(1,L) ; k2 = ln(2,L)
       ! TODO: Herman: should we skip the step below if optional ibedlevmode==BLMODE_D3D?
       bl(k1)   = min( bl(k1), bobm)      ! here minimise based on connected lowest linklevels
       bl(k2)   = min( bl(k2), bobm)
    enddo

 endif

 ! call setaifu() ! or, do this every so many steps

 do k = 1,ndxi
    if (s1(k) < bl(k) )then
        s0(k) = bl(k) + 1d-9
        s1(k) = bl(k) + 1d-9
    endif
 enddo

 bob0(:, lnx1D+1:lnxi) = bob(:, lnx1D+1:lnxi)

 end subroutine bathyupdate

 subroutine writesluices()
 integer          :: mgat = 0, mgat2 = 0, k, j
 double precision :: t(6), h(6), tim, zgt, bed

 if (mgat .ne. 0) return

 t(1) =  0d0 ; h(1) =  0.0d0   ! door closed                     ! sea side
 t(2) =  2d0 ; h(2) =  0.2d0   ! open the gates
 t(3) =  3d0 ; h(3) =  0.2d0   ! levelling through open gates
 t(4) =  2d0 ; h(4) = 12.0d0   ! open the door
 t(5) = 12d0 ; h(5) = 12.0d0   ! boats through open door
 t(6) =  2d0 ; h(6) =  0.0d0   ! close the door

 tim = 0d0
 call newfil(mgat,  'zeegate_0001.tom')
 call newfil(mgat2, 'landgate_0001.tom')

 tim = 0d0 ; bed = -11d0
 write(mgat2,*) tim, bed

 do k = 1,100
    do j = 1,6
       tim = tim + t(j)
       zgt = bed + h(j)
       write(mgat,*) tim, zgt
    enddo
    do j = 1,6
       tim = tim + t(j)
       zgt = bed + h(j)
       write(mgat2,*) tim, zgt
    enddo

 enddo
 call doclose (mgat)  ; mgat  = -1
 call doclose (mgat2) ; mgat2 = -1

 end subroutine writesluices


 subroutine setau()                                  ! get wet cross-sections at u points, after limiters, setau = vol12D with japerim == 1
 use m_flowgeom
 use m_flow
 use unstruc_model
 use m_partitioninfo
 use m_timer
 implicit none

 integer                                           :: n, nq, L, k1, k2, nlowest
 integer                                           :: ierror, ng, Lnu, LL, iup
 double precision                                  :: at, ssav, wwav, blowest, fac, zlu, zgaten, sup, bupmin, bup, openfact, afac

 double precision, parameter                       :: FAC23 = 0.6666666666667d0

 ! call writesluices()

 if (kmx == 0) then


    call vol12D(1)

 endif

 do ng = 1,ngatesg  ! loop over gate signals, setau
    zgaten = zgate(ng) ; bupmin = 9d9
    do n  = L1gatesg(ng), L2gatesg(ng)
       LL  = kgate(3,n)
       if (hu(LL)  > 0d0) then
          bup      = min(bob(1,LL), bob(2,LL) )
          bupmin   = min(bupmin, bup)
          sup      =  bup + hu(LL)
          openfact = ( min(sup, zgaten) - bup ) / hu(LL)
          afac     =   min(1d0, max(0d0,1d0-openfact) )
          if (sup > zgaten) then
             hu(LL)   = hu(LL) - (sup - zgaten) ; au(LL)=hu(LL)*wu(LL)
             advi(LL) = advi(LL) + afac*0.5d0*abs(u1(LL))*dxi(LL)
          endif
          if (hu(LL)  < epshu) then
             hu(LL)   = 0d0 ; au(LL) = 0d0
          else if (kmx > 0) then
             do L   = Lbot(LL), Lbot(LL) + kmxL(LL) - 1
                if ( hu(L) > hu(L-1) ) then
                   ZLu = bup + hu(L-1)
                   fac = (zgaten-zLu) / ( hu(L) - hu(L-1) )
                   fac = max(0d0, min(1d0, fac ) )
                   Lnu = L
                   advi(L) = advi(L) + afac*0.5d0*abs(u1(L))*dxi(LL)
                   if (fac < 0.1d0 .and. L > Lbot(LL)) then
                      Lnu      = L - 1
                      !Ltop(LL) =    Lnu   ! keep total baroclinic pressure
                      hu(Lnu)  = hu(Lnu)   + fac*( hu(L) - hu(L-1) )
                      au(Lnu)  = au(Lnu)   + fac*  au(L)
                      exit
                   else
                      hu(Lnu)  = hu(Lnu-1) + fac*( hu(Lnu) - hu(Lnu-1) )
                      au(Lnu)  =             fac*  au(Lnu)
                   endif
                endif
             enddo
             au( Lnu+1 : Lbot(LL)+kmxL(LL)-1 ) = 0d0  ! -12346d0 ! 6 not 5
             hu( Lnu+1 : Lbot(LL)+kmxL(LL)-1 ) = 0d0  ! -12346d0 ! 6 not 5

          endif
       endif
    enddo
    if (bupmin /= 9d9) then
       zgate(ng) = max( zgate(ng), bupmin )
    end if

 enddo

 do ng = 1,ncgensg      ! loop over generalstruc signals, sethu
    zgaten = zcgen(3*(ng-1)+2) ; bupmin = 9d9
    ! wufac  = zcgen(3*(ng-1)+3)
    do n   = L1cgensg(ng), L2cgensg(ng)
       LL   = kcgen(3,n)
       if (hu(LL) > 0d0) then
          bup     = min(bob(1,LL), bob(2,LL) )
          if (kmx > 0) then
             do L   = Lbot(LL), Lbot(LL) + kmxL(LL) - 1
                if ( hu(L) > hu(L-1) ) then
                   ZLu = bup + hu(L-1)
                   fac = (zgaten-zLu) / ( hu(L) - hu(L-1) )
                   fac = max(0d0, min(1d0, fac ) )
                   Lnu = L
                   if (fac < 0.1d0) then
                      Lnu      = L - 1
                      ! Ltop(LL) =    Lnu
                      hu(Lnu)  = hu(Lnu)   + fac*( hu(L) - hu(L-1) )
                      au(Lnu)  = au(Lnu)   + fac*  au(L)
                      exit
                   else
                      hu(Lnu)  = hu(Lnu-1) + fac*( hu(Lnu) - hu(Lnu-1) )
                      au(Lnu)  =             fac*  au(Lnu)
                   endif
                endif
             enddo
             au( Ltop(LL)+1 : Lbot(LL)+kmxL(LL)-1 ) = 0d0  ! -12346d0 ! 6 not 5
          endif
       endif
    enddo
    if (bupmin /= 9d9) then
       zcgen(3*(ng-1)+2) = max( zcgen(3*(ng-1)+2), bupmin )
    end if

 enddo


 do n  = 1, nklep             ! check valves
    L  = iabs( Lklep(n) )
    call getflowdir(L,iup)
    if (iup*Lklep(n) < 0 ) then
       hu(L) = 0d0 ; au(L) = 0d0
       if (kmx > 0) then
          hu(Lbot(L) : Ltop(L) ) = 0d0
          au(Lbot(L) : Ltop(L) ) = 0d0
       endif
    endif
 enddo

 do n   = 1, nvalv             ! smoren
    L   = Lvalv(n)
    fac = max(0d0,min(1d0,valv(n)))
    if (fac > 1d-6) then 
       au(L) = fac*au(L)
    else 
       hu(L) = 0d0 ; au(L) = 0d0
       if (kmx > 0) then
          hu(Lbot(L) : Ltop(L) ) = 0d0
          au(Lbot(L) : Ltop(L) ) = 0d0
       endif
    endif
 enddo

 if ( nqbnd.eq.0 ) return

 huqbnd=0d0

 if (jbasqbnddownwindhs == 0) then
    do nq = 1,nqbnd ! discharge normalising Manning conveyance
       at    = 0d0

       ssav = 0d0 ; wwav = 0d0
       do n  = L1qbnd(nq), L2qbnd(nq)
          L  = kbndu(3,n)
          k2 = kbndu(2,n)

          if ( jampi.eq.1 ) then
!            exclude ghost nodes
             if ( idomain(k2).ne.my_rank ) then
                cycle
             end if
          end if

          if ( hu(L) > 0d0 ) then
             ssav = ssav + s1(k2)*wu(L)
             wwav = wwav + wu(L)
          endif
       enddo
       wwssav_all(1,nq) = wwav
       wwssav_all(2,nq) = ssav
    end do

    if ( jampi.eq.1 .and. japartqbnd.eq.1 ) then
       if ( jatimer.eq.1 ) call starttimer(IMPIREDUCE)
       call reduce_wwssav_all()
       if ( jatimer.eq.1 ) call stoptimer(IMPIREDUCE)
    end if
 end if

 do nq = 1,nqbnd ! discharge normalising Manning conveyance
    at    = 0d0

    if (jbasqbnddownwindhs == 0) then
       wwav = wwssav_all(1,nq)
       ssav = wwssav_all(2,nq)

       if (wwav > 0) then
          ssav   = ssav/wwav
          do n  = L1qbnd(nq), L2qbnd(nq)
             L  = kbndu(3,n)
             if ( hu(L) > 0d0 ) then
!                hu(L) = max(0d0, ssav - min( bob(1,L), bob(2,L) ) )
                huqbnd(n) = max(0d0, ssav - min( bob(1,L), bob(2,L) ) )
             endif
          enddo
       endif
    endif

    do n  = L1qbnd(nq), L2qbnd(nq)
       L  = kbndu(3,n)
       k2 = kbndu(2,n)

       if (jbasqbnddownwindhs == 1) then
          hu(L) = s1(k2) - bl(k2) !  Qbnd_downwind_hs
          call addlink2D(L,1)
          huqbnd(n) = hu(L)
       endif

       if (zbndq(n) < 0d0 .and. hu(L) < qbndhutrs) then
          hu(L) = 0d0 ; au(L) = 0d0
       else
          if ( jampi.eq.0 ) then
!            at = at + au(L)*hu(L)**FAC23
             at = at + au(L)*huqbnd(n)**FAC23
          else
!            exclude ghost nodes
             if ( idomain(k2).eq.my_rank ) then
!               at = at + au(L)*hu(L)**FAC23
                at = at + au(L)*huqbnd(n)**FAC23
             end if
          end if
       endif
    enddo
    at_all(nq) = at
 end do

 if ( jampi.eq.1 .and. japartqbnd.eq.1 ) then
    if ( jatimer.eq.1 ) call starttimer(IMPIREDUCE)
    call reduce_at_all()
    if ( jatimer.eq.1 ) call stoptimer(IMPIREDUCE)
 end if

 do nq = 1,nqbnd
    at = at_all(nq)
    if (at .ne. 0) then
       do n  = L1qbnd(nq), L2qbnd(nq)
          L  = kbndu(3,n)
!          zbndu(n) = (zbndu(n)*hu(L)**FAC23)/at
           zbndu(n) = (zbndq(n)*huqbnd(n)**FAC23)/at
       enddo
    endif
 enddo

 end subroutine setau

 subroutine sets01zbnd(n01)
 use m_flowgeom
 use m_flow
 use m_flowtimes
 use m_missing
 use m_sobekdfm
 use unstruc_model, only: md_restartfile
 implicit none
 integer          :: n, kb, k2, itpbn, L, n01
 double precision :: zb, hh, dtgh, alf, zcor
 double precision, external :: barocpsteric

 do n  = 1, nbndz                                    ! overrides for waterlevel boundaries
    kb      = kbndz(1,n)
    k2      = kbndz(2,n)
    L       = kbndz(3,n)
    itpbn   = kbndz(4,n)
    if     (itpbn == 1) then                         ! waterlevelbnd
       zb   = zbndz(n)
       if (alfsmo < 1d0) then
          zb = alfsmo*zb + (1d0-alfsmo)*zbndz0(n)
       endif
    else if (itpbn == 2) then                        ! neumannbnd, positive specified slope leads to inflow
       !zb   = s0(k2) + zbndz(n)*dx(L)
       zb   = s1(kb)
    else if (itpbn == 5) then                        ! Riemannbnd
       hh   = max(epshs, 0.5d0*( hs(kb) + hs(k2) ) )
       zb   = 2d0*zbndz(n) - zbndz0(n) - sqrt(hh/ag)*u1(L)
    else if (itpbn == 6) then                        ! outflowbnd
       if (u0(L) > 0) then   ! on inflow, copy inside
          zb = s0(k2)
          if (n01 == 0) then
             s0(kb) = max(zb, bl(kb)) ! TODO: AvD: if single time step is being restarted, then this line will have overwritten some of the old s0 values.
          else
             s1(kb) = max(zb, bl(kb))
          endif
      endif
    else if (itpbn == 7) then                         ! qhbnd
       zb   = zbndz(n)
       if (alfsmo < 1d0) then
          zb = alfsmo*zb + (1d0-alfsmo)*zbndz0(n)
       endif
    endif

    if (japatm > 0 .and. PavBnd > 0) then
       zb = zb - ( patm(kb) - PavBnd )/(ag*rhomean)
    endif

    !if (jasteric > 0) then
    !   zcor = barocpsteric(kb)/(ag*rhomean)
    !   zb   = zb - zcor
    !endif

!    zb = max( zb, bl(kb) + 1d-3 )

    if (itpbn < 6 .or. itpbn == 7) then
       if (n01 == 0) then
          s0(kb) = max(zb, bl(kb)) ! TODO: AvD: if single time step is being restarted, then this line will have overwritten some of the old s0 values.
       else
          s1(kb) = max(zb, bl(kb))
       endif
    endif

 enddo

 call  set_1d2d_01()

 end subroutine sets01zbnd

 double precision function barocpsteric(kb)
 use m_flowgeom
 use m_flow

 integer          :: kb
 integer          :: kk
 double precision, external :: densfm
 double precision           :: rhokk

 barocpsteric = 0d0
 do kk = ktop(kb), kbot(kb), -1
    rhokk        = densfm(steric(1,kk), steric(2,kk))
    rhokk        = rhokk - rhosteric
    barocpsteric = barocpsteric + ag*rhokk*(zws(kk) - zws(kk-1))
 enddo
end function barocpsteric


subroutine setdt()
   use m_partitioninfo
   use m_flowparameters, only: jawave
   use m_xbeach_data,    only: swave
   use m_flowtimes
   use m_flow,           only: kkcflmx
   use m_timer
   use unstruc_display,  only: jaGUI
   use m_sediment,       only: jased, stm_included, stmpar, jamorcfl
   implicit none

   double precision :: dtsc_loc

   integer          :: nsteps
   integer          :: jareduced

!  compute CFL-based maximum time step and limiting flownode/time step, per subomdain
   call setdtorg(jareduced) ! 7.1 2031

   dtsc_loc = dtsc

!  globally reduce time step
   if ( jampi.eq.1 .and. jareduced.eq.0 ) then
!     globally reduce dts (dtsc may now be larger)
      if ( jatimer.eq.1 ) call starttimer(IMPIREDUCE)
      call reduce_double_min(dts)
      if ( jatimer.eq.1 ) call stoptimer(IMPIREDUCE)
   end if
   
   ! morphological timestep reduction
   if (stm_included  .and. jamorcfl>0) then
      if (time1 > tstart_user + stmpar%morpar%tmor * tfac) then
         call fm_mor_maxtimestep()
      endif
   endif
   
   if ( jawave.eq.4 .and. swave.eq.1 ) then
      call xbeach_absgen_maxtimestep()
      call xbeach_wave_maxtimestep()
   end if
   
   if (jased .eq. 4 .and. stm_included) then
     call setdtmaxavalan(dts)
   end if
   
   dti = 1d0/dts
   dtsc = dts

!  account for user time step
   if (ja_timestep_auto >= 1) then
      if (dts > dtfacmax*dtprev) then
          dts = dtfacmax*dtprev
          nsteps = ceiling((time_user-time0) / dts)
          ! New timestep dts would be rounded down to same dtprev (undesired, so use nsteps-1)
          if (1000*dtprev > time_user-time0) then
             nsteps = ceiling((time_user-time0) / dts)
             if (nsteps == ceiling((time_user-time0) / dtprev)) then
                 nsteps = max(1,nsteps - 1)
             end if
             dts = (time_user-time0) / dble(nsteps)
             ! dtmax is always leading.
             if (dts > dt_max .or. dts > dtsc) then ! Fall back to smaller step anyway.
                dts    = (time_user-time0) / dble(nsteps+1)
             end if
          endif

      else
          ! dts = min (dts, dt_max) ! hk: commented out, already done this 15 lines above

          ! Fit timestep dts so that we will exactly reach time_user in future steps.
          !if ( time0+dts.ge.time_user ) then
          !   dts = min(dts, time_user-time0)
          !else
          ! NOTE: when the model has an extremely small timestep, nsteps gets an integer overflow,
          ! then becomes negative, so the max below sets nsteps=1, violating the dtmax requirement. (UNST-1926)
             nsteps = max(1,ceiling((time_user-time0) / dts ) )
             dts = ( time_user-time0 ) / dble(nsteps)
          !end if
      endif
   else
      dts = dt_max
      dtsc = 0d0    ! SPvdP: safety, was undefined but could be used later
      kkcflmx = 0   ! SPvdP: safety, was undefined but could be used later
   endif
   
   call timestepanalysis(dtsc_loc)

   if ( jaGUI.eq.1 ) then
      call tekcflmx()
   endif



end subroutine setdt

 subroutine setdtmaxavalan(dts)
 use m_fm_erosed, only: duneavalan, avaltime
 implicit none

 double precision,    intent(inout) :: dts   !timestep to use

 if (duneavalan) then
    if (dts > avaltime / 2d0 - 1d0 ) then
       dts = avaltime / 2d0 - 1d0 !make sure timestep is smaller than half the avaltime (e.g. with default avaltime 9 seconds)
    end if
 end if

 end subroutine setdtmaxavalan

 subroutine setdtorg(jareduced)                            ! set computational timestep dts
 use m_flowgeom
 use m_flow
 use m_flowtimes
! use unstruc_model
 use m_partitioninfo
 use m_missing
 use m_transport, only: time_dtmax, dtmax !, dtmin_transp, kk_dtmin
 implicit none


 integer,          intent(out) :: jareduced  ! maximum time-step is already globally reduced (1) or not (0)

 ! locals
 integer                       :: L, LL, k, n1, n2, nsteps, kk, kb, kt, k1,k2, k3, k4, Lb, Lt
 integer                       :: kk1, kk2
 double precision              :: rhomin, rhomax, cbaroc, drho
 double precision              :: hsx
 double precision              :: cuu                            ! flow velocity
 double precision              :: cuw                            ! wave velocity
 double precision              :: cudxi                          ! relevant courant velocity per length, mx
 double precision              :: cfltot, dtsw, dtsc2D
 !integer , save                :: mout = 0

 double precision              :: dxiAu                          !
 double precision              :: huv
 double precision              :: dtsc1, dtsc2
 double precision              :: squloc

 INTEGER                       :: NDRAW
 COMMON /DRAWTHIS/ ndraw(50)

 jareduced = 0
 if (jamapdtcell > 0) dtcell = 0d0

 if (ja_timestep_auto >= 1) then

    IF (NDRAW(28) == 30 .or. NDRAW(29) == 38) THEN
       plotlin = dt_max
    endif

    dts  = 1d9 ; kkcflmx = 0; kcflmx = 0

    if (ja_timestep_auto == 1 ) then   ! depth averaged timestep
       if ( itstep.ne.4 ) then   ! non-explicit time-step
          !if ( jatransportmodule.eq.1 .and. time_dtmax.eq.time1 ) then
          !   dts = dtmin_transp
          !   kkcflmx  = kk_dtmin
          !   jareduced = 1
          !else
          if (ja_timestep_nostruct > 0) then  !< Exclude (structure) links without advection from the time step limitation
             squcor(1:ndx) = squ(1:ndx) ! Start with already computed squ.
             do L = 1,lnx1d
                if (iadv(L) /= 0 .and. iadv(L) /= 22) then
                   cycle ! Do NOT exclude this link
                end if
                k1 = ln(1,L) ; k2 = ln(2,L)
                ! Undo some of the added q1 contributions in squ (as produced by u1q1()).
                if (q1(L) > 0) then
                   squcor(k1) = squcor(k1) - q1(L)
                else if (q1(L) < 0) then
                   squcor(k2) = squcor(k2) + q1(L)
                endif
             end do
          end if

          do k = 1,ndxi
             if ( jampi.eq.1 ) then
!               do not include ghost cells
                if ( idomain(k).ne.my_rank ) cycle
             end if

             if (ja_timestep_nostruct > 0) then  !< Exclude (structure) links without advection from the time step limitation
                squloc = squcor(k)
             else
                squloc = squ(k)
             end if

             if (squloc > eps10) then                   ! outflow only
                if (hs(k) > epshu .and. vol1(k) > 0.0 .and. squloc > 0.0) then
                   dtsc = cflmx*vol1(k)/squloc
                   if (jamapdtcell > 0) then
                      dtcell(k) = dtsc
                   endif
                   if (dtsc < dts) then
                      dts = dtsc  ; kkcflmx = k
                   endif
                   if (dtsc == 0d0) then
                      kkcflmx = k
                   endif
                endif
             endif
          enddo
          !end if
          continue
       else ! explicit time-step
          do k = 1,ndxi
             if ( jampi.eq.1 ) then
!               do not include ghost cells
                if ( idomain(k).ne.my_rank ) cycle
             end if
             if (sqwave(k) > eps10) then                   ! outflow only
                if (hs(k) > epshu) then
                   dtsc = cflmx*vol1(k)/sqwave(k)
                   if (jamapdtcell > 0) then
                      dtcell(k) = dtsc
                   endif
                   if (dtsc < dts) then
                      dts = dtsc  ; kkcflmx = k
                   endif
                endif
             endif
          enddo

       end if

    else if (ja_timestep_auto == 2 ) then   ! depth averaged timestep

       do k = 1,ndxi
          if ( jampi.eq.1 ) then
!            do not include ghost cells
             if ( idomain(k).ne.my_rank ) cycle
          end if
          if (squ(k) + sqi(k) > eps10) then                   ! outflow+inflow
             if (hs(k) > epshu .and. vol1(k) > 0.0) then
                dtsc = cflmx*vol1(k)/ (squ(k) + sqi(k))
                if (jamapdtcell > 0) then
                   dtcell(k) = dtsc
                endif
                if (dtsc < dts) then
                   dts = dtsc  ; kkcflmx = k
                endif

            endif
          endif
       enddo

    else if (ja_timestep_auto == 3 .or. ja_timestep_auto == 4) then      ! 3 = 2D out over layers, 4=2D in+out all layers

       do kk = 1,ndxi
          if ( jampi.eq.1 ) then
!            do not include ghost cells
             if ( idomain(kk).ne.my_rank ) cycle
          end if
          if (squ2D(kk) > eps10 .and. hs(kk) > epshu) then
             call getkbotktop(kk,kb,kt)
             do k = kb,kt
                if (squ2d(k) > eps10) then
                   dtsc = cflmx*vol1(k)/squ2d(k)         ! outflow or outflow+inflow
                   if (jamapdtcell > 0) then
                      dtcell(k) = dtsc
                   endif
                   if (dtsc < dts) then
                       dts = dtsc ; kkcflmx = kk ; kcflmx = k
                   endif
                endif
             enddo
          endif
       enddo

    else if (  ja_timestep_auto.eq.5 ) then   ! full 3D

!       if ( jatransportmodule.eq.1 .and. time_dtmax.eq.time1 ) then
!          dts = dtmin_transp
!          kkcflmx = kk_dtmin
!          jareduced = 1
!       else
       do kk=1,Ndxi
          if ( jampi.eq.1 ) then
!            do not include ghost cells
             if ( idomain(kk).ne.my_rank ) cycle
          end if
          if ( hs(kk).gt.epshu ) then
             call getkbotktop(kk,kb,kt)
             do k=kb,kt
                   if ( squ(k).gt.eps10 .or. sqi(k).gt.eps10 ) then
!                      dtsc = cflmx*vol1(k)/squ(k)
                      dtsc = cflmx*vol1(k)/max(squ(k),sqi(k))
                      if (jamapdtcell > 0) then
                         dtcell(k) = dtsc
                      endif
                   if ( dtsc.lt.dts ) then
                      dts     = dtsc ; kkcflmx = kk
                   endif
                end if
             end do
          end if
       end do
 !      end if

    else if (  ja_timestep_auto.eq.6) then
       do kk=1,Ndxi
          if ( jampi.eq.1 ) then
!            do not include ghost cells
             if ( idomain(kk).ne.my_rank ) cycle
          end if
          if ( hs(kk).gt.epshu ) then
             dtsc2D = dt_max
             if ( squ(kk).gt.eps10 ) then
                dtsc2D = cflmx*vol1(kk)/squ(kk)
             endif
             call getkbotktop(kk,kb,kt)
             do k=kb,kt
                if ( sqi(k).gt.eps10 ) then
                   dtsc = cflmx*vol1(k)/sqi(k)
                   dtsc = min(dtsc, dtsc2D)
                   if (jamapdtcell > 0) then
                      dtcell(k) = dtsc
                   endif
                   if ( dtsc.lt.dts ) then
                      dts     = dtsc ; kkcflmx = kk
                   endif
                end if
             end do
          end if
       end do

    else if (  ja_timestep_auto .eq. 7 ) then   ! full 3D plus barocline

        do LL = 1, Lnxi
           n1 = ln(1,LL) ; n2 = ln(2,LL)
           call getLbotLtop(LL, Lb, Lt)
           rhomin = 2d3; rhomax = -1d0
           do L = Lb, Lt
              k1 = ln(1,L) ; k2 = ln(2,L)
              rhomin = min(rhomin, rho(k1), rho(k2) )
              rhomax = max(rhomax, rho(k1), rho(k2) )
           enddo
           drho   = rhomax - rhomin
           cbaroc = sqrt( 0.25d0*ag*hu(LL)*drho*0.001d0) ! rhomax-rhomin
           do L = Lb, Lt
              squ(n1) = squ(n1) + au(L)*cbaroc
              squ(n2) = squ(n2) + au(L)*cbaroc
              sqi(n1) = sqi(n1) + au(L)*cbaroc
              sqi(n2) = sqi(n2) + au(L)*cbaroc
          enddo
        enddo

        do kk=1,Ndxi
          if ( jampi.eq.1 ) then
             if ( idomain(kk).ne.my_rank ) cycle         !            do not include ghost cells
          endif
          if ( hs(kk).gt.epshu ) then
             call getkbotktop(kk,kb,kt)
             do k = kb,kt
                if ( squ(k).gt.eps10 ) then
                   dtsc = cflmx*vol1(k)/ ( squ(k) + sqi(k) )
                   if (jamapdtcell > 0) then
                      dtcell(k) = dtsc
                   endif
                   if ( dtsc.lt.dts ) then
                      dts = dtsc  ; kkcflmx = kk
                   endif
                endif
             enddo
          endif
        enddo

     else if (  ja_timestep_auto .eq. 8 ) then   ! full 3D except top layer

        do kk=1,Ndxi
          if ( jampi.eq.1 ) then
!            do not include ghost cells
             if ( idomain(kk).ne.my_rank ) cycle
          end if
          if ( hs(kk).gt.epshu ) then
             call getkbotktop(kk,kb,kt)
             do k=kb,max(kb, kt-1)
                if ( squ(k).gt.eps10 ) then
                   dtsc = cflmx*vol1(k)/squ(k)
                   if (jamapdtcell > 0) then
                      dtcell(k) = dtsc
                   endif
                   if ( dtsc.lt.dts ) then
                      dts     = dtsc ; kkcflmx = kk
                   endif
                endif
             enddo
          endif
        enddo

     else if (  ja_timestep_auto .eq. 9 ) then   ! 2D outgoing and 3D incoming fluxes

        do kk=1,Ndxi
          if ( jampi.eq.1 ) then
!            do not include ghost cells
             if ( idomain(kk).ne.my_rank ) cycle
    endif
          if ( hs(kk).gt.epshu ) then
             dtsc = 9d9
             if ( squ(kk).gt.eps10) then
                dtsc = cflmx*vol1(kk)/squ(kk)
             endif
             call getkbotktop(kk,kb,kt)
             do k=kb, kt
                if ( sqi(k).gt.eps10 ) then
                   dtsc = min(dtsc, cflmx*vol1(k)/sqi(k) )
                   if (jamapdtcell > 0) then
                      dtcell(k) = dtsc
                   endif
                   if ( dtsc.lt.dts ) then
                      dts     = dtsc ; kkcflmx = kk
                   endif
                endif
             enddo
          endif
        enddo

     else if (  ja_timestep_auto .eq. 10 ) then   ! 2D outgoing and 3D incoming fluxes

        do kk=1,Ndxi
          if ( jampi.eq.1 ) then
!            do not include ghost cells
             if ( idomain(kk).ne.my_rank ) cycle
          end if
          if ( hs(kk).gt.epshu ) then
             dtsc = 9d9
             if ( squ(kk).gt.eps10) then
                dtsc = cflmx*vol1(kk)/squ(kk)
             endif
             call getkbotktop(kk,kb,kt)
             do k=kb, kt - 1
                if ( sqi(k).gt.eps10 ) then
                   dtsc = min(dtsc, cflmx*vol1(k)/sqi(k) )
                   if (jamapdtcell > 0) then
                      dtcell(k) = dtsc
                   endif
                   if ( dtsc.lt.dts ) then
                      dts     = dtsc ; kkcflmx = kk
                   endif
                endif
             enddo
          endif
        enddo


    endif

    ! Explicit time step restriction on viscosity term.
    if (ja_timestep_auto_visc .eq. 1 .and. ihorvic > 0) then
       if (kmx == 0) then
          if (istresstyp == 2 .or. istresstyp == 3) then     ! first set stressvector in cell centers
             do L = lnx1D+1,lnx
                if (hu(L) > 0) then                          ! link will flow
                   k1 = ln  (1,L) ; k2 = ln  (2,L)

                   if ( jampi.eq.1 ) then
                      if ( idomain(k1).ne.my_rank .and. idomain(k2).ne.my_rank ) cycle       ! do not include ghost cells
                   endif

                   dxiAu = dxi(L)*wu(L)
                   if (istresstyp == 3) then
                      dxiAu  = min(hs(k1), hs(k2)) * dxiAu
                   endif

                   huv = 0.5d0*( hs(k1) + hs(k2) )

                   if ( dxiAu.gt.0d0 .and. vicLu(L).gt.0d0 .and. huv > epshu) then ! see "setumod" for huv
                       dtsc = 0.2d0/(dxiAu*vicLu(L))
                       if ( istresstyp.eq.3 ) then
                          dtsc = dtsc * huv
                       end if

                       dtsc1 = dtsc*ba(k1)
                       if ( dtsc1.lt.dts ) then
                          dts     = dtsc1 ; kkcflmx = k1
                       endif

                       dtsc2 = dtsc*ba(k2)
                       if ( dtsc2.lt.dts ) then
                          dts     = dtsc2 ; kkcflmx = k2
                       endif

                       if (jamapdtcell > 0) then
                          dtcell(k1) = min( dtcell(k1), dtsc1 )
                          dtcell(k2) = min( dtcell(k2), dtsc2 )
                       endif
                   endif
                endif
             enddo
          endif
       else if (kmx > 0) then
          if (istresstyp == 2 .or. istresstyp == 3) then     ! first set stressvector in cell centers
             do LL = lnx1D+1,lnx
                if (abs(kcu(LL)) .ne. 2) cycle

                kk1 = ln  (1,LL) ; kk2 = ln  (2,LL)

                if ( jampi.eq.1 ) then
                   if ( idomain(kk1).ne.my_rank .and. idomain(kk2).ne.my_rank ) cycle       ! do not include ghost cells
                endif

                call getLbotLtop(LL,Lb,Lt)
                do L = Lb, Lt
                   k1 = ln  (1,L) ; k2 = ln  (2,L)
                   k3 = lncn(1,L) ; k4 = lncn(2,L)

                   dxiAu = dxi(LL)*wu(LL)
                   if (istresstyp == 3) then
                      dxiAu  = min( zws(k1)-zws(k1-1), zws(k2)-zws(k2-1)  ) * dxiAu
                   endif

                   huv    = 0.5d0 * ( (zws(k1)-zws(k1-1)) + (zws(k2)-zws(k2-1) ) )

                   if ( dxiAu.gt.0d0 .and. vicLu(L).gt.0d0 .and. huv.gt.epshu ) then
                       dtsc = 0.2d0/(dxiAu*vicLu(L))
                       if ( istresstyp.eq.3 ) then
                          dtsc = dtsc * huv
                       end if

                       dtsc1 = dtsc*ba(kk1)
                       if ( dtsc1.lt.dts ) then
                          dts     = dtsc1 ; kkcflmx = kk1
                       endif

                       dtsc2 = dtsc*ba(kk2)
                       if ( dtsc2.lt.dts ) then
                          dts     = dtsc2 ; kkcflmx = kk2
                       endif

                       if (jamapdtcell > 0) then
                          dtcell(k1) = min( dtcell(k1), dtsc1 )
                          dtcell(k2) = min( dtcell(k2), dtsc2 )
                       endif
                   endif
                enddo
             enddo
          endif
       endif
    endif

    if (dts  > dt_max) then
        dts  = dt_max ; kkcflmx = 0 ; dtsc = 0
    else
        dtsc = dts ! Courant-driven timestep
    endif

!    dtsc = dts ! Courant-driven timestep

!    if (kkcflmx > 0) then
!        numlimdt(kkcflmx) = numlimdt(kkcflmx) + 1
!    endif

!    if (dts > dtfacmax*dtprev) then
!        dts = dtfacmax*dtprev
!        nsteps = ceiling((time_user-time0) / dts)
!        ! New timestep dts would be rounded down to same dtprev (undesired, so use nsteps-1)
!        if (nsteps == ceiling((time_user-time0) / dtprev)) then
!            nsteps = max(1,nsteps - 1)
!        end if
!        dts = (time_user-time0) / dble(nsteps)
!
!        ! dtmax is always leading.
!        if (dts > dt_max .or. dts > dtsc) then ! Fall back to smaller step anyway.
!           dts    = (time_user-time0) / dble(nsteps+1)
!        end if
!    else
!        ! dts = min (dts, dt_max) ! hk: commented out, already done this 15 lines above
!
!        ! Fit timestep dts so that we will exactly reach time_user in future steps.
!        nsteps = max(1,ceiling((time_user-time0) / dts ) )
!        dts = ( time_user-time0 ) / dble(nsteps)
!    endif
 else
    dts = dt_max
    dtsc = 0d0    ! SPvdP: safety, was undefined but could be used later
    kkcflmx = 0   ! SPvdP: safety, was undefined but could be used later
 endif

! if (jatimestepanalysis == 1) then
!    if (mout == 0) then
!       call newfil(mout, trim(md_ident)//'.steps')
!       write(mout, '(A)')  'time0/60, dts, dtsc, kkcflmx, kcflmx-kbot(kkcflmx)+1, vol1(kcflmx), squ2D(kcflmx), squ(kcflmx), sqi(kcflmx) '
!    endif
!    if (kkcflmx > 0) then
!       if (kcflmx == 0) kcflmx = kkcflmx
!       if (ja_timestep_auto == 3 .or. ja_timestep_auto == 4 ) then
!          write(mout, '(3F14.4,2I8,4F14.4)')  time0/60d0, dts, dtsc, kkcflmx, kcflmx-kbot(kkcflmx)+1, vol1(kcflmx), squ2D(kcflmx), squ(kcflmx), sqi(kcflmx)
!       else
!          write(mout, '(3F14.4,2I8,4F14.4)')  time0/60d0, dts, dtsc, kkcflmx, kcflmx-kbot(kkcflmx)+1, vol1(kcflmx), squ  (kcflmx), squ(kcflmx), sqi(kcflmx)
!       endif
!    else
!       write(mout, '(3F14.4, I8)')         time0/60d0, dts, dtsc, kkcflmx
!    endif
! endif

 end subroutine setdtorg

 subroutine timestepanalysis(dtsc_loc)
    use m_flow
    use m_flowtimes
    use m_partitioninfo
    use unstruc_model, only: md_ident
    implicit none

    double precision, intent(in) :: dtsc_loc

    integer,          save       :: mout = 0

!   check if local maximum time step is also global maximum time step
    if ( jampi.eq.1 ) then
       if ( dtsc_loc.gt.dtsc ) then
          kkcflmx = 0
       end if
    end if

    if (kkcflmx > 0) then
       numlimdt(kkcflmx) = numlimdt(kkcflmx) + 1
    endif

    if (jatimestepanalysis == 1) then
       if (mout == 0) then
          call newfil(mout, trim(md_ident)//'.steps')
          write(mout, '(A)')  'time0/60, dts, dtsc, kkcflmx, kcflmx-kbot(kkcflmx)+1, vol1(kcflmx), squ2D(kcflmx), squ(kcflmx), sqi(kcflmx) '
       endif
       if (kkcflmx > 0) then
          if (kcflmx == 0) kcflmx = kkcflmx
          if (ja_timestep_auto == 3 .or. ja_timestep_auto == 4 ) then
             write(mout, '(3F14.4,2I8,4F14.4)')  time0/60d0, dts, dtsc, kkcflmx, kcflmx-kbot(kkcflmx)+1, vol1(kcflmx), squ2D(kkcflmx), squ(kcflmx), sqi(kcflmx)
          else
             write(mout, '(3F14.4,2I8,4F14.4)')  time0/60d0, dts, dtsc, kkcflmx, kcflmx-kbot(kkcflmx)+1, vol1(kcflmx), squ  (kcflmx), squ(kcflmx), sqi(kcflmx)
          endif
       else
          write(mout, '(3F14.4, I8)')         time0/60d0, dts, dtsc, kkcflmx
       endif
    endif

    return
 end subroutine timestepanalysis


 subroutine advec()                                  ! advection, based on u0, q0 24
 use m_flowtimes
 use m_flowgeom
 use m_flow
 use m_partitioninfo
 use m_fixedweirs
 use m_sferic

 implicit none

 ! locals
 double precision                  :: unormal        ! function unormal
 double precision                  :: dif            ! averaged waterdepth at flow link (m)
 integer                           :: L, k1, k2      ! link, nd1, nd2
 integer                           :: k12            ! nd1  or nd2
 integer                           :: k34            ! nod1 or nod2
 double precision                  :: ul1, ul2       ! just testing
 double precision                  :: uup            ! cell centered upwind u(L)
 double precision                  :: vup            ! cell centered upwind v(L) determines whether to use corner up or dwn in vdudy
 double precision                  :: ucnup          ! corner based  upwind u(L)
 double precision                  :: vcn3, vcn4, vcnu, qx
 double precision                  :: v12            ! Wenneker control volume (m3)
 double precision                  :: v12t, v1t, v2t ! time derivative of control volume (m3/s)
 double precision                  :: advil          ! local advi
 double precision                  :: advel          ! local adve

 double precision                  :: qu1            ! Flux times advection velocity node 1 (m4/s2)
 double precision                  :: qu2            ! idem                          node 2
 double precision                  :: qu1a           ! Flux times advection velocity node 1 (m4/s2)
 double precision                  :: qu2a           ! idem                          node 2
 double precision                  :: qu12a          ! both a
 double precision                  :: uqcxl          !
 double precision                  :: uqcyl          !
 double precision                  :: qu12, aa       ! both
 double precision                  :: cs, sn

 double precision                  :: QucWen         ! Sum over links of Flux times upwind cell centre velocity (m4/s2), do not include own link
 double precision                  :: QucPer         ! idem, include own link
 double precision                  :: QucPer3D       ! idem, include own link
 !double precision                  :: QucWeni        ! idem, only incoming
 double precision                  :: QucPeri        ! idem, inly incoming         nb: QucPeripiaczek is a subroutine
! double precision                  :: QunPeri

 double precision                  :: QucPerq1       ! ..
 double precision                  :: QucPercu       ! testing center differences
 double precision                  :: QufPer         ! testing adv of face velocities instead of centre upwind velocities

 !double precision                  :: Qucnu          ! = original of QucPer


 double precision                  :: visc           ! eddy viscosity term

 integer                           :: isg, jcheck, iadvL, ierr
 integer                           :: m, mu, md, mdd, iad, n, kk, kb
 double precision                  :: qxm, qxmu, uam, uamu, uamd, qxmd, du
 double precision                  :: vv1, vv2, dv1, dv2, quk, que
 double precision                  :: ucxku, ucyku, ai, ae, abh, vu1Di, volu, volui, hh, huvL, baik1, baik2
 double precision                  :: ucin, fdx, ql, qucx, qucy, ac1, ac2, uqn, qn, rhoinsrc, dzss, qnn
 integer                           :: LL,LLL,LLLL, Lb, Lt, Lay, i

 integer                           :: ierror, ku, kd, k, nfw, kt
 integer                           :: n12

 double precision                  :: quk1(3,kmxx), quk2(3,kmxx), volukk(kmxx)   ! 3D for 1=u, 2=turkin, 3=tureps

 integer                           :: kt1, kt2, n1, n2, kb1, kb2, Ltx0, ktx01, ktx02 , ktx1 , ktx2, Ltx, L1, ksb, kst
 double precision                  :: sigu, alf, bet1, bet2, hs1, hs2, vo1, vo2, zz1, zz2, econsfac
 double precision                  :: tol=1d-4 , sl, dzu, dzk, du1, du2, dux, duy, expl

 double precision                  :: quuk1(0:kmxx), quuk2(0:kmxx), volk1(0:kmxx), volk2(0:kmxx), sqak1(0:kmxx), sqak2(0:kmxx)
 double precision                  :: quuL1(0:kmxx), quuL2(0:kmxx), volL1(0:kmxx), volL2(0:kmxx), sqaL1(0:kmxx), sqaL2(0:kmxx)
 double precision                  :: sigk1(0:kmxx), sigk2(0:kmxx), siguL(0:kmxx)

 double precision,        external :: lin2nodx, lin2nody
 double precision,        external :: nod2linx, nod2liny
 double precision,        external :: dlimiter, dslim

 japiaczek33 = 0

 if (ifixedweirscheme >= 3 .and. ifixedweirscheme <= 5) then
    do L  = 1,lnxi
       if (iadv(L) == 21) then
          if (u0(L) > 0) then
             kd = ln(2,L) ; ku = ln(1,L)
          else
             kd = ln(1,L) ; ku = ln(2,L)
          endif
          call getucxucyweironly ( kd, ucx(kd), ucy(kd), ifixedweirscheme )
          call getucxucyweironly ( ku, ucx(ku), ucy(ku), ifixedweirscheme )
       endif
    enddo
 endif

 if (jabarrieradvection == 2) then
    do n = 1,ngatesg
       do L = L1gatesg(n), L2gatesg(n)
          LL = kgate(3,L) ; LL = iabs( LL )
          kd = ln(1,LL) ; ku = ln(2,LL)
          call getucxucybarrierzero ( LL, kd, ucx(kd), ucy(kd) )
          call getucxucybarrierzero ( LL, ku, ucx(ku), ucy(ku) )
       enddo
    enddo
    do n = 1,ngategen
       i = gate2cgen(n)
       do L = L1cgensg(i), L2cgensg(i)
          LL = kcgen(3,L) ; LL = iabs( LL )
          kd = ln(1,LL) ; ku = ln(2,LL)
          call getucxucybarrierzero ( LL, kd, ucx(kd), ucy(kd) )
          call getucxucybarrierzero ( LL, ku, ucx(ku), ucy(ku) )
       enddo
    enddo
 endif

 call sethigherorderadvectionvelocities()

 uqcx = 0d0 ; uqcy = 0d0 ; sqa = 0d0

 if (kmx == 0) then

   if (jasfer3d == 1) then

      do L = Lnx,1,-1
          k1 = ln(1,L) ; k2 = ln(2,L)
          qL = qa(L)
          uqcx(k1) = uqcx(k1) + qL*lin2nodx(L,1,ucxu(L),ucyu(L))
          uqcx(k2) = uqcx(k2) - qL*lin2nodx(L,2,ucxu(L),ucyu(L))
          uqcy(k1) = uqcy(k1) + qL*lin2nody(L,1,ucxu(L),ucyu(L))
          uqcy(k2) = uqcy(k2) - qL*lin2nody(L,2,ucxu(L),ucyu(L))
          sqa (k1) = sqa (k1) + ql
          sqa (k2) = sqa (k2) - ql
       enddo

   else

       do L = Lnx,1,-1
          k1 = ln(1,L) ; k2 = ln(2,L)
          qL = qa(L)
          uqcx(k1) = uqcx(k1) + qL*ucxu(L)
          uqcx(k2) = uqcx(k2) - qL*ucxu(L)
          uqcy(k1) = uqcy(k1) + qL*ucyu(L)
          uqcy(k2) = uqcy(k2) - qL*ucyu(L)
          sqa (k1) = sqa (k1) + ql
          sqa (k2) = sqa (k2) - ql
       enddo

    endif

 else

    do LL = Lnx,1,-1
       Lb = lbot(LL) ; Lt = ltop(LL)
       do L = Lb, Lt
          k1 = ln(1,L) !; k1 = min(k1, ktop(ln(1,LL) ) )
          k2 = ln(2,L) !; k2 = min(k2, ktop(ln(2,LL) ) )
          qL = qa(L)
          if (jasfer3d == 1) then
             uqcx(k1) = uqcx(k1) + qL*lin2nodx(LL,1,ucxu(L),ucyu(L))
             uqcx(k2) = uqcx(k2) - qL*lin2nodx(LL,2,ucxu(L),ucyu(L))
             uqcy(k1) = uqcy(k1) + qL*lin2nody(LL,1,ucxu(L),ucyu(L))
             uqcy(k2) = uqcy(k2) - qL*lin2nody(LL,2,ucxu(L),ucyu(L))
          else
             uqcx(k1) = uqcx(k1) + qL*ucxu(L)
             uqcx(k2) = uqcx(k2) - qL*ucxu(L)
             uqcy(k1) = uqcy(k1) + qL*ucyu(L)
             uqcy(k2) = uqcy(k2) - qL*ucyu(L)
          endif
          sqa (k1) = sqa (k1) + ql
          sqa (k2) = sqa (k2) - ql
       enddo
    enddo

 endif

 if (javau >= 6) then ! 3D checkerboard pepare explicit node based vertical advection
    if (jarhoxu == 0) then
       do kk = 1,ndxi
          call getkbotktop(kk,kb,kt)
          do k = kb, kt-1
             if ( qw(k) > 0d0) then
                 uqcx(k+1) = uqcx(k+1) - qw(k)*ucx(k)
                 uqcx(k  ) = uqcx(k  ) + qw(k)*ucx(k)
                 uqcy(k+1) = uqcy(k+1) - qw(k)*ucy(k)
                 uqcy(k  ) = uqcy(k  ) + qw(k)*ucy(k)
                 if (javau == 7 .and. k > kb ) then
                    dzu =  zws(k) - zws(k-2)      ! 2*dz of upwind face
                    if ( dzu > tol) then
                       dzk =  zws(k+1) - zws(k-1) ! 2*dz of this face
                       sl  =  dzk/dzu
                       du2 = (ucx(k+1) - ucx(k)   )
                       du1 = (ucx(k )  - ucx(k-1) )*sl
                       ! dux =  0.5d0*dlimiter(du1,du2,4)
                       dux =  0.5d0*dslim(du1,du2,4)
                       du2 = (ucy(k+1) - ucy(k)   )
                       du1 = (ucy(k )  - ucy(k-1) )*sl
                       ! duy =  0.5d0*dlimiter(du1,du2,4)
                       duy =  0.5d0*dslim(du1,du2,4)
                       uqcx(k+1) = uqcx(k+1) - qw(k)*dux
                       uqcx(k  ) = uqcx(k  ) + qw(k)*dux
                       uqcy(k+1) = uqcy(k+1) - qw(k)*duy
                       uqcy(k  ) = uqcy(k  ) + qw(k)*duy
                    endif
                 endif
             else if ( qw(k) < 0d0) then
                 uqcx(k+1) = uqcx(k+1) - qw(k)*ucx(k+1)
                 uqcx(k  ) = uqcx(k  ) + qw(k)*ucx(k+1)
                 uqcy(k+1) = uqcy(k+1) - qw(k)*ucy(k+1)
                 uqcy(k  ) = uqcy(k  ) + qw(k)*ucy(k+1)
                 if (javau == 7 .and. k < kt-1 ) then
                    dzu =  zws(k+2) - zws(k)      ! 2*dz of upwind face
                    if ( dzu > tol) then
                       dzk =  zws(k+1) - zws(k-1) ! 2*dz of this face
                       sl  =  dzk/dzu
                       du2 = (ucx(k)   - ucx(k+1) )
                       du1 = (ucx(k+1) - ucx(k+2) )*sl
                       ! dux =  0.5d0*dlimiter(du1,du2,4)
                       dux =  0.5d0*dslim(du1,du2,4)
                       du2 = (ucy(k)   - ucy(k+1) )
                       du1 = (ucy(k+1) - ucy(k+2) )*sl
                       ! duy =  0.5d0*dlimiter(du1,du2,4)
                       duy =  0.5d0*dslim(du1,du2,4)

                       uqcx(k+1) = uqcx(k+1) - qw(k)*dux
                       uqcx(k  ) = uqcx(k  ) + qw(k)*dux
                       uqcy(k+1) = uqcy(k+1) - qw(k)*duy
                       uqcy(k  ) = uqcy(k  ) + qw(k)*duy
                    endif
                 endif

             endif
             sqa(k+1) = sqa(k+1) - qw(k)
             sqa(k  ) = sqa(k  ) + qw(k)
          enddo
       enddo
    else
       do kk = 1,ndxi
          do k = kbot(kk), ktop(kk)-1
             if ( qw(k) > 0d0) then
                 uqcx(k+1) = uqcx(k+1) - qw(k)*ucx(k)*rho(k)
                 uqcx(k  ) = uqcx(k  ) + qw(k)*ucx(k)*rho(k)
                 uqcy(k+1) = uqcy(k+1) - qw(k)*ucy(k)*rho(k)
                 uqcy(k  ) = uqcy(k  ) + qw(k)*ucy(k)*rho(k)
             else if ( qw(k) < 0d0) then
                 uqcx(k+1) = uqcx(k+1) - qw(k)*ucx(k+1)*rho(k+1)
                 uqcx(k  ) = uqcx(k  ) + qw(k)*ucx(k+1)*rho(k+1)
                 uqcy(k+1) = uqcy(k+1) - qw(k)*ucy(k+1)*rho(k+1)
                 uqcy(k  ) = uqcy(k  ) + qw(k)*ucy(k+1)*rho(k+1)
             endif
             sqa(k+1) = sqa(k+1) - qw(k)
             sqa(k  ) = sqa(k  ) + qw(k)
          enddo
       enddo
    endif
 endif

 if (jarhoxu > 0) then
    sqa = sqa*rho
 endif

 do n  = 1,numsrc                             ! momentum
    if (arsrc(n) > 0) then                    ! if momentum desired
       if (qsrc(n) > 0) then
          kk  = ksrc(4,n)                     ! 2D pressure cell nr TO
          ksb = ksrc(5,n)                     ! cell nr
          kst = ksrc(6,n)                     ! cell nr
       else
          kk  = ksrc(1,n)                     ! 2D pressure cell nr FROM
          ksb = ksrc(2,n)                     ! cell nr
          kst = ksrc(3,n)                     ! cell nr
       endif

       if (kk > 0 .and. ksb > 0) then

          do k  = ksb,kst
             qnn = qsrc(n)
             qn  = qnn
             if (kmx > 0) then
                dzss  = zws(kst) - zws(ksb-1)
                if (dzss > epshs) then
                   qn = qnn*( zws(k) - zws(k-1) ) / dzss
                else
                   qn = qnn / (kst - ksb + 1)
                endif
             endif
             uqn = qn*qn / arsrc(n)

             if (jarhoxu > 0) then
                rhoinsrc = rhomean   ! just for now
                qn       = qn* rhoinsrc
                uqn      = uqn*rhoinsrc
             endif

             if (qsrc(n) > 0) then               ! from 1 to 2
                uqcx(k) = uqcx(k) - uqn*cssrc(2,n)
                uqcy(k) = uqcy(k) - uqn*snsrc(2,n)
             else                                ! from 2 to 1
                uqcx(k) = uqcx(k) + uqn*cssrc(1,n)
                uqcy(k) = uqcy(k) + uqn*snsrc(1,n)
             endif
             sqa(k) = sqa(k) - qn                ! sqa : out - in
          enddo

       endif
    endif
 enddo

 nfw = 0

 if (kmx == 0) then

 !$OMP PARALLEL DO                                                                   &
 !$OMP PRIVATE(L, advel,k1,k2,iadvL,qu1,qu2,volu,ai,ae,iad,volui,abh,hh,v12t,ku,kd,isg,n12, ucxku, ucyku, ucin, fdx)

 do L  = 1,lnx

  advel = 0                                          !  advi (1/s), adve (m/s2)

  if ( hu(L) > 0 ) then

    k1    = ln(1,L) ; k2 = ln(2,L)
    iadvL = iadv(L)

    if (L > lnxi) then
       if (iadvL == 77) then
          if (u0(L) < 0) iadvL = 0
       else if (u0(L) > 0) then
           iadvL = 0                                 ! switch off advection for inflowing waterlevel bnd's, if not normalvelocitybnds
       endif
       !vol1(k1) = 0d0
    endif

    if (iadvL == 33) then                       !

       if (jasfer3d == 1) then
          qu1   = csu(L)*nod2linx(L,1,uqcx(k1),uqcy(k1)) + snu(L)*nod2liny(L,1,uqcx(k1),uqcy(k1)) - u1(L)*sqa(k1)
          qu2   = csu(L)*nod2linx(L,2,uqcx(k2),uqcy(k2)) + snu(L)*nod2liny(L,2,uqcx(k2),uqcy(k2)) - u1(L)*sqa(k2)
       else
          qu1   = csu(L)*uqcx(k1) + snu(L)*uqcy(k1) - u1(L)*sqa(k1)
          qu2   = csu(L)*uqcx(k2) + snu(L)*uqcy(k2) - u1(L)*sqa(k2)
       endif

       if (jarhoxu == 0) then
          if (kcu(L) == 1) then
             volu  = acl(L)*vol1_f(k1) + (1d0-acl(L))*vol1_f(k2)
          else
             volu  = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2)
          endif
       else
          if (kcu(L) == 1) then
             volu  = acl(L)*vol1_f(k1)*rho(k1) + (1d0-acl(L))*vol1_f(k2)*rho(k2)
          else
             volu  = acl(L)*vol1(k1)*rho(k1) + (1d0-acl(L))*vol1(k2)*rho(k2)
          endif
       endif

       if (volu > 0) then
          advel = (acl(L)*qu1 + (1d0-acl(L))*qu2) / volu

          !if ( japiaczek33 == 1) then
          !   expl = ( acl(L)*sqa(k1) + (1d0-acl(L))*sqa(k2) ) / volu
          !   if (expl < 0d0) then
          !      advel   = advel   + expl*u1(L)
          !      advi(L) = advi(L) - expl
          !   endif
          !endif

       endif

    else if (iadvL == 44) then                       !

       if (vol1(k1) > 0) then
          if (jasfer3D == 1) then
             qu1   = csu(L)*nod2linx(L,1,uqcx(k1),uqcy(k1)) + snu(L)*nod2liny(L,1,uqcx(k1),uqcy(k1)) - u1(L)*sqa(k1)
          else
             qu1   = csu(L)*uqcx(k1) + snu(L)*uqcy(k1) - u1(L)*sqa(k1)
          endif
          advel = advel + acl(L)*qu1/vol1(k1)
       endif
       if (vol1(k2) > 0) then
          if (jasfer3D == 1) then
             qu2   = csu(L)*nod2linx(L,2,uqcx(k2),uqcy(k2)) + snu(L)*nod2liny(L,2,uqcx(k2),uqcy(k2)) - u1(L)*sqa(k2)
          else
             qu2   = csu(L)*uqcx(k2) + snu(L)*uqcy(k2) - u1(L)*sqa(k2)
          endif
          advel = advel +  (1d0-acl(L))*qu2 / vol1(k2)
       endif

    else if (iadvL == 3) then                             ! explicit first order mom conservative
                                                     ! based upon cell center excess advection velocity
       qu1 = 0                                       ! and Perot control volume
       if (vol1(k1) > 0) then
          qu1 = QucPer(1,L)                          ! excess momentum in/out u(L) dir. from k1
          qu1 = qu1*acl(L)                           ! Perot weigthing
       endif
       qu2 = 0
       if (vol1(k2) > 0) then
          qu2 = QucPer(2,L)                          ! excess momentum in/out u(L) dir. from k2
          qu2 = qu2*(1d0-acl(L))                     ! Perot weigthing
       endif
       volu  = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2)
       if (volu > 0) then
          advel = (qu1 + qu2)/volu                   ! dimension: ((m4/s2) / m3) =   (m/s2)
       endif

    else if (iadvL == 333) then                      ! explicit first order mom conservative
                                                     ! based upon cell center excess advection velocity
       qu1 = 0                                       ! and Perot control volume
       if (volau(k1) > 0) then
          qu1 = QucPer(1,L)                          ! excess momentum in/out u(L) dir. from k1
          qu1 = qu1*acl(L)/ volau(k1)                ! Perot weigthing
       endif
       qu2 = 0
       if (volau(k2) > 0) then
          qu2 = QucPer(2,L)                          ! excess momentum in/out u(L) dir. from k2
          qu2 = qu2*(1d0-acl(L))/ volau(k2)                     ! Perot weigthing
       endif
       advel = qu1 + qu2                             ! dimension: ((m4/s2) / m3) =   (m/s2)

    else if (iadvL == 30) then                       ! Same as 3, now with alfa = 0.5 in volumes and advection
                                                     ! based upon cell center excess advection velocity
       qu1 = 0
       if (vol1(k1) > 0) then
          qu1 = QucPer(1,L)                          ! excess momentum in/out u(L) dir. from k1
       endif
       qu2 = 0
       if (vol1(k2) > 0) then
          qu2 = QucPer(2,L)                          ! excess momentum in/out u(L) dir. from k2
       endif
       volu  = vol1(k1) + vol1(k2)
       if (volu > 0) then
          advel = (qu1 + qu2)/volu                   ! dimension: ((m4/s2) / m3) =   (m/s2)
       endif

    else if (iadvL == 31) then                       ! Thesis Olga 4.8
                                                     ! based upon cell center excess advection velocity
       if (jasfer3D == 1) then
          qu1   = csu(L)*nod2linx(L,1,uqcx(k1),uqcy(k1)) + snu(L)*nod2liny(L,1,uqcx(k1),uqcy(k1))
          qu2   = csu(L)*nod2linx(L,2,uqcx(k2),uqcy(k2)) + snu(L)*nod2liny(L,2,uqcx(k2),uqcy(k2))
       else
          qu1   = csu(L)*uqcx(k1) + snu(L)*uqcy(k1)
          qu2   = csu(L)*uqcx(k2) + snu(L)*uqcy(k2)
       endif
       advel = acl(L)*qu1 + (1d0-acl(L))*qu2

    else if (iadvL == 40) then                       !

       if (jasfer3D == 1) then
          qu1   = csu(L)*nod2linx(L,1,uqcx(k1),uqcy(k1)) + snu(L)*nod2liny(L,1,uqcx(k1),uqcy(k1)) - u1(L)*sqa(k1)
          qu2   = csu(L)*nod2linx(L,2,uqcx(k2),uqcy(k2)) + snu(L)*nod2liny(L,2,uqcx(k2),uqcy(k2)) - u1(L)*sqa(k2)
       else
          qu1   = csu(L)*uqcx(k1) + snu(L)*uqcy(k1) - u1(L)*sqa(k1)
          qu2   = csu(L)*uqcx(k2) + snu(L)*uqcy(k2) - u1(L)*sqa(k2)
       endif
       volu  = acl(L)*voldhu(k1) + (1d0-acl(L))*voldhu(k2)

       if (volu > 0) then
          advel = (acl(L)*qu1 + (1d0-acl(L))*qu2) / volu
       endif

    else if (iadvL == 1) then                        ! explicit first order mom conservative
                                                     ! based upon cell center advection velocity
                                                     ! and Wenneker control volume, now with
                                                     ! uqcx and uqcy arrays instead of function call, (much faster than excess form)

        volu      = vol1(k1) + vol1(k2)              ! Wennekers control volume
                                                     ! qu1     = ( uqcx(k1)*cs + uqcy(k1)*sn )
                                                     ! qu2     = ( uqcx(k2)*cs + uqcy(k2)*sn )
       if (volu   > 0) then
          if (jasfer3D == 1) then
             qu1 = csu(L)*(nod2linx(L,1,uqcx(k1),uqcy(k1)) + nod2linx(L,2,uqcx(k2),uqcy(k2)))
             qu2 = snu(L)*(nod2liny(L,1,uqcx(k1),uqcy(k1)) + nod2liny(L,2,uqcx(k2),uqcy(k2)))
          else
             qu1 = csu(L)*( uqcx(k1) + uqcx(k2) )
             qu2 = snu(L)*( uqcy(k1) + uqcy(k2) )
          endif
          v12t    = sq(k1) + sq(k2)                  ! time der. of v12
          advel   = (qu1 + qu2 + u1(L)*v12t) / volu  ! dimension: ((m4/s2) / m3) =   (m/s2)
       endif

    else if (iadvL == 2) then                        ! explicit first order mom conservative
                                                     ! based upon cell center excess advection velocity
       volu     = vol1(k1) + vol1(k2)                ! Wennekers control volume
       if (volu > 0) then
          qu1   = QucWen(1,L)                        ! excess momentum in u(L) dir. out of k1
          qu2   = QucWen(2,L)                        ! out of k2
          advel = (qu1 + qu2) / volu                 ! dimension: ((m4/s2) / m3) =   (m/s2)
       endif

   else if (iadvL == 4) then                         ! explicit first order mom conservative

       qu1 = 0                                       ! and Perot control volume
       if (vol1(k1) > 0) then
          qu1 = QucPeri(1,L)                         ! excess momentum in u(L) dir. from of k1
          qu1 = qu1*acl(L)                           ! Perot weigthing
       endif
       qu2 = 0
       if (vol1(k2) > 0) then
          qu2 = QucPeri(2,L)                         ! excess momentum in u(L) dir. from of k2
          qu2 = qu2*(1d0-acl(L))                     ! Perot weigthing
       endif

       volu  = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2)
       if (volu > 0) then
          advel = (qu1 + qu2)/volu                   ! dimension: ((m4/s2) / m3) =   (m/s2)
       endif

    else if (iadvL == 5 .or. iadvL ==6) then         ! 5,6 = advection like 3,4, now Piaczek teta

       if (kcu(L) ==1) then
          volu = acl(L)*vol1_f(k1) + (1d0-acl(L))*vol1_f(k2)
       else
          volu = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2)
       endif

       if (volu > 0) then
          volui = 1d0/volu
          if (vol1(k1) > 0) then
             call QucPeripiaczekteta(1,L,ai,ae,volu,iadvL-2)   ! excess momentum in u(L) dir. out of k1, include own
             abh     = acl(L)*volui
             adveL   = adveL   + abh*ae
             advi(L) = advi(L) + abh*ai
          endif
          if (vol1(k2) > 0) then
             call QucPeripiaczekteta(2,L,ai,ae,volu,iadvL-2)   ! excess momentum in u(L) dir. out of k2
             abh = (1d0-acl(L))*volui
             adveL   = adveL   + abh*ae
             advi(L) = advi(L) + abh*ai
          endif

       endif

    else if (iadvL >= 7 .and. iadvL <= 12) then      ! Piaczek fully implicit

       iad  = 3
       if (iadvL == 8 .or. iadvL == 10 .or. iadvL == 12) then
          iad = 4
       endif

       if (kcu(L) ==1) then
          volu = acl(L)*vol1_f(k1) + (1d0-acl(L))*vol1_f(k2)
       else
          volu = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2)
       endif

       if (volu > 0) then
          volui = 1d0/volu
          if (hs(k1) > 0) then
             call QucPeripiaczek(1,L,ai,ae,iad)   ! excess momentum in u(L) dir. out of k1, include own
             abh     = acl(L)*volui
             adveL   = adveL   + abh*ae
             advi(L) = advi(L) + abh*ai
          endif
          if (hs(k2) > 0) then
             call QucPeripiaczek(2,L,ai,ae,iad)   ! excess momentum in u(L) dir. out of k2
             abh = (1d0-acl(L))*volui
             adveL   = adveL   + abh*ae
             advi(L) = advi(L) + abh*ai
          endif

       endif

    else if (iadvL == 21) then                        ! subgrid weir small stencil, ifixedweirscheme = 3
                                                      ! upwind center velocity does not feel crest link

       !advel = 0.5d0*(  u0(L)*u0(L) - u0(L-1)*u0(L-1) ) / dx(L)

       if (u0(L)  > 0d0) then
          ku = k1 ; kd = k2 ; isg =  1 ; n12 = 1
       else
          ku = k2 ; kd = k1 ; isg = -1 ; n12 = 2
       endif

       call getucxucynoweirs(ku, ucxku, ucyku, ifixedweirscheme )
       if (jasfer3D == 1) then
          ucin = nod2linx(L,n12,ucxku,ucyku)*csu(L) + nod2liny(L,n12,ucxku,ucyku)*snu(L)
       else
          ucin = ucxku*csu(L) + ucyku*snu(L)
       endif

       fdx     = 0.5d0*dxi(L)*isg

       advi(L) = advi(L) + fdx*u0(L)
       advel   = advel   - fdx*ucin*ucin

    !    advel   = fdx*(u0(L)*u0(L) - ucin*ucin)

    else if (iadvL == 77) then                        ! supercritical inflow boundary

       abh     = bai(k1)*huvli(L)*acl(L)
       if (jasfer3D == 1) then
          adveL = adveL   - abh*q1(L)*(nod2linx(L,1,ucx(k1),ucy(k1))*csu(L) + nod2liny(L,1,ucx(k1),ucy(k1))*snu(L))
       else
          adveL = adveL   - abh*q1(L)*(ucx(k1)*csu(L)+ucy(k1)*snu(L))
       endif
       advi(L) = advi(L) + abh*q1(L)

    else if (iadvL == 38) then                       ! explicit first order mom conservative olga (17)
                                                     ! based upon cell center excess advection velocity
       qu1 = 0                                       ! and Perot control volume
       if (vol1(k1) > 0) then
          qu1 = QucPercu(1,L)                        ! excess momentum in/out uc(k1) dir. from k1
          qu1 = qu1*acl(L)/volau(k1)                 ! Perot weigthing
       endif
       qu2 = 0
       if (vol1(k2) > 0) then
          qu2 = QucPercu(2,L)                        ! excess momentum in/out uc(k2) dir. from k2
          qu2 = qu2*(1d0-acl(L))/volau(k2)           ! Perot weigthing
       endif
       advel = qu1 + qu2                             ! dimension: ((m4/s2) / m3) =   (m/s2)

    else if (iadvL == 34) then                       ! explicit first order mom conservative (stelling kramer)
                                                     ! based upon cell center excess advection velocity
       qu1 = 0                                       ! and Perot control volume
       if (vol1(k1) > 0) then
          qu1 = QucPer(1,L)                          ! excess momentum in/out u(L) dir. from k1
          qu1 = qu1*acl(L)*bai(k1)                   ! Perot weigthing
       endif
       qu2 = 0
       if (vol1(k2) > 0) then
          qu2 = QucPer(2,L)                          ! excess momentum in/out u(L) dir. from k2
          qu2 = qu2*(1d0-acl(L))*bai(k2)             ! Perot weigthing
       endif
       advel = (qu1 + qu2)*huvli(L)                  ! dimension: ((m4/s2) / m3) =   (m/s2)

    else if (iadvL == 35) then                       ! explicit first order mom conservative (stelling kramer)
                                                     ! based upon cell center excess advection velocity
       qu1 = 0                                       ! and Perot control volume
       if (vol1(k1) > 0) then
          qu1 = QufPer(1,L)                          ! excess momentum in/out u(L) dir. from k1
          qu1 = qu1*acl(L)                           ! Perot weigthing
       endif
       qu2 = 0
       if (vol1(k2) > 0) then
          qu2 = QufPer(2,L)                          ! excess momentum in/out u(L) dir. from k2
          qu2 = qu2*(1d0-acl(L))                     ! Perot weigthing
       endif
       volu  = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2)
       if (volu > 0) then
          advel = (qu1 + qu2)/volu                   ! dimension: ((m4/s2) / m3) =   (m/s2)
       endif

    else if (iadvL == 36) then                       ! explicit first order mom conservative
                                                     ! based upon cell center excess advection velocity
       qu1 = 0                                       ! and Perot control volume
       if (vol1(k1) > 0) then
          qu1 = QucPerq1(1,L)                        ! excess momentum in/out uc(k1) dir. from k1
          qu1 = qu1*acl(L)/vol1(k1)                  ! Perot weigthing
       endif
       qu2 = 0
       if (vol1(k2) > 0) then
          qu2 = QucPerq1(2,L)                        ! excess momentum in/out uc(k2) dir. from k2
          qu2 = qu2*(1d0-acl(L))/vol1(k2)            ! Perot weigthing
       endif
       advel = qu1 + qu2                             ! dimension: ((m4/s2) / m3) =   (m/s2)

    else if (iadvL == 37) then                       ! Kramer Stelling
       qu1 = 0d0
       if (vol1(k1) > 0) then
          qu1 = acl(L)*QucPerq1(1,L)/ba(k1)          ! excess momentum in/out u(L) dir. from k1
       endif
       qu2 = 0d0
       if (vol1(k2) > 0) then
          qu2 = (1d0-acl(L))*QucPerq1(2,L)/ba(k2)    ! excess momentum in/out u(L) dir. from k1
       endif
       advel = huvli(L)*(qu1 + qu2)

    endif

    adve(L) = adve(L) + advel

  endif

 enddo

 !$OMP END PARALLEL DO

 else                                                      ! Plus vertical

 do LL  = 1,lnx

    if ( hu(LL) > 0 ) then

       iadvL = iadv(LL)
       if (LL > lnxi) then
          if (iadvL == 77) then
             if (u0(LL) < 0) cycle
          else if (u0(LL) > 0) then
             cycle                                            ! switch off advection for inflowing waterlevel bnd's, if not normalvelocitybnds
          endif
       endif
       cs  = csu(LL)  ; sn  = snu(LL)
       Lb  = Lbot(LL) ; Lt  = Ltop(LL)
       ac1 = acl(LL)  ; ac2 = 1d0 - ac1

       if (iadv(LL) == 3) then
          call QucPer3Dsigma(1,LL,Lb,Lt,cs,sn,quk1)           ! sum of (Q*uc cell centre upwind normal) at side 1 of basis link LL
          call QucPer3Dsigma(2,LL,Lb,Lt,cs,sn,quk2)           ! sum of (Q*uc cell centre upwind normal) at side 2 of basis link LL

          do L = Lb, Lt
             advel = 0d0                                      ! advi (1/s), adve (m/s2)
             k1    = ln(1,L) ; k2 = ln(2,L)
             qu1   = 0d0
             if (vol1(k1) > 0) then
                qu1 = quk1(1,L-Lb+1)*ac1                      ! Perot weigthing
             endif
             qu2    = 0d0
             if (vol1(k2) > 0) then
                qu2 = quk2(1,L-Lb+1)*ac2                      ! Perot weigthing
             endif
             if (jarhoxu > 0) then
                volu  = ac1*vol1(k1)*rho(k1) + ac2*vol1(k2)*rho(k2)
             else
                volu  = ac1*vol1(k1)         + ac2*vol1(k2)
             endif
             if (volu > 0) then
                advel = (qu1 + qu2)/volu                      ! dimension: ((m4/s2) / m3) =   (m/s2)
             endif
             adve(L) = adve(L) + advel

          enddo

       else if ( iadv(LL) == 33 .or. iadv(LL) == 40 .or. iadv(LL) == 6 ) then                       !

          ! qu1   = csu(L)*uqcx(k1) + snu(L)*uqcy(k1) - u1(L)*sqa(k1)
          ! qu2   = csu(L)*uqcx(k2) + snu(L)*uqcy(k2) - u1(L)*sqa(k2)
          ! volu  = ac1*vol1(k1)    + ac2*vol1(k2)
          ! if (volu > 0) then
          !    advel = (acl(L)*qu1 + (1d0-acl(L))*qu2) / volu
          ! endif

          if (layertype == 1) then

             if (iadv(LL) == -6 ) then  ! .and. newzbndadv == 1 ) then

                do L = Lb, Lt
                   if (u1(L) > 0) then
                      k = ln(1,L)
                      n12 = 1
                   else
                      k = ln(2,L)
                      n12 = 2
                   endif
                   if (jasfer3D == 1) then
                      advel   = 2d0*( u1(L) - (cs*nod2linx(LL,n12,ucx(k),ucy(k)) + sn*nod2liny(LL,n12,ucx(k),ucy(k)) ) )*dxi(LL)
                   else
                      advel   = 2d0*( u1(L) - (cs*ucx(k) + sn*ucy(k) ) )*dxi(LL)
                   endif
                   if ( advel > 0d0 ) then
                      advi(L) = advi(L) + advel
                   else
                      adve(L) = adve(L) - cs*u1(L)*advel
                   endif
                enddo

             else

             do L = Lb, Lt
                k1    = ln(1,L) ; k2 = ln(2,L)
                if (jasfer3D == 1) then
                   qu1   =  cs*nod2linx(LL,1,uqcx(k1),uqcy(k1)) +  sn*nod2liny(LL,1,uqcx(k1),uqcy(k1)) - u1(L)*sqa(k1)
                   qu2   =  cs*nod2linx(LL,2,uqcx(k2),uqcy(k2)) +  sn*nod2liny(LL,2,uqcx(k2),uqcy(k2)) - u1(L)*sqa(k2)
                else
                   qu1   =  cs*uqcx(k1) + sn*uqcy(k1) - u1(L)*sqa(k1)
                   qu2   =  cs*uqcx(k2) + sn*uqcy(k2) - u1(L)*sqa(k2)
                endif

                if (jarhoxu > 0) then
                   if (kcu(LL) ==1) then
                      volu  = ac1*vol1_f(k1)*rho(k1) + ac2*vol1_f(k2)*rho(k2)
                   else
                      volu  = ac1*vol1(k1)*rho(k1) + ac2*vol1(k2)*rho(k2)
                   endif
                else
                   if (kcu(LL) ==1) then
                      volu  = ac1*vol1_f(k1)         + ac2*vol1_f(k2)
                   else
                      volu  = ac1*vol1(k1)         + ac2*vol1(k2)
                   endif
                endif

                if (volu > 0) then

                   adve(L) = adve(L) + (ac1*qu1 + ac2*qu2) / volu

                   !if ( japiaczek33 == 1) then
                   !   expl = ( acl(L)*sqa(k1) + (1d0-acl(L))*sqa(k2) ) / volu
                   !   if (expl < 0d0) then
                   !      adve(L) = adve(L) + expl*u1(L)
                   !      advi(L) = advi(L) - expl
                   !   endif
                   !endif

                endif
             enddo

             endif

          else if (layertype == 2 .and. jahazlayer == 0) then ! default fixed layers

             Ltx = Lt-Lb+1
             volukk(1:Ltx) = 0d0
             do L = Lb, Lt
                k1    = ln(1,L) ; k2 = ln(2,L)
                if (jarhoxu > 0) then
                   volukk(L-Lb+1)  = volukk(L-Lb+1) + ac1*vol1(k1)*rho(k1) + ac2*vol1(k2)*rho(k2)
                else
                   volukk(L-Lb+1)  = volukk(L-Lb+1) + ac1*vol1(k1) + ac2*vol1(k2)
                endif
             enddo
             do k = k1+1, ktop(ln(1,LL) )
                if (jarhoxu > 0) then
                   volukk(Lt-Lb+1) = volukk(Lt-Lb+1) + ac1*vol1(k)*rho(k)
                else
                   volukk(Lt-Lb+1) = volukk(Lt-Lb+1) + ac1*vol1(k)
                endif
             enddo
             do k = k2+1, ktop(ln(2,LL) )
                if (jarhoxu > 0) then
                   volukk(Lt-Lb+1) = volukk(Lt-Lb+1) + ac2*vol1(k)*rho(k)
                else
                   volukk(Lt-Lb+1) = volukk(Lt-Lb+1) + ac2*vol1(k)
                endif
             enddo

             do L = Lb, Lt
                k1    = ln(1,L) ; k2 = ln(2,L)
                if (jasfer3D == 1) then
                   qu1    = cs*nod2linx(LL,1,uqcx(k1),uqcy(k1)) + sn*nod2liny(LL,1,uqcx(k1),uqcy(k1)) - u1(L)*sqa(k1)
                   qu2    = cs*nod2linx(LL,2,uqcx(k2),uqcy(k2)) + sn*nod2liny(LL,2,uqcx(k2),uqcy(k2)) - u1(L)*sqa(k2)
                else
                   qu1    = cs*uqcx(k1) + sn*uqcy(k1) - u1(L)*sqa(k1)
                   qu2    = cs*uqcx(k2) + sn*uqcy(k2) - u1(L)*sqa(k2)
                endif

                if (volukk(L-Lb+1) > 0) then
                   adve(L) = adve(L) +  (ac1*qu1 + ac2*qu2) / volukk(L-Lb+1)

                   !if ( japiaczek33 == 1) then
                   !   expl = ( acl(L)*sqa(k1) + (1d0-acl(L))*sqa(k2) ) / volukk(L-Lb+1)
                   !   if (expl < 0d0) then
                   !      adve(L) = adve(L) + expl*u1(L)
                   !      advi(L) = advi(L) - expl
                   !   endif
                   !endif

                endif

             enddo

          else if (layertype == 2 .and. jahazlayer == 1) then

             n1  = ln(1,LL) ; n2 = ln(2,LL)
             call getkbotktop(n1,kb1,kt1) ; ktx1 = kt1-kb1+1
             call getkbotktop(n2,kb2,kt2) ; ktx2 = kt2-kb2+1
             Ltx = Lt-Lb+1

             volukk(1:Ltx) = 0d0

             do L = Lb, Lt
                k1    = ln(1,L) ; k2 = ln(2,L) ; L1 = L-Lb+1
                volukk(L1) = volukk(L1) + ac1*vol1(k1) + ac2*vol1(k2)
             enddo

             do k = k1+1, kt1
                volukk(Ltx) = volukk(Ltx) + ac1*vol1(k)
             enddo

             do k = k2+1, kt2
                volukk(Ltx) = volukk(Ltx) + ac2*vol1(k)
             enddo

             do L = Lb, Lt
                k1    = ln(1,L) ; k2 = ln(2,L) ; L1 = L-Lb+1
                if (volukk(L1) > 0) then
                   if (jasfer3D == 1) then
                      qu1   =  cs*nod2linx(LL,1,uqcx(k1),uqcy(k1)) +  sn*nod2liny(LL,1,uqcx(k1),uqcy(k1)) - u1(L)*sqa(k1)
                      qu2   =  cs*nod2linx(LL,2,uqcx(k2),uqcy(k2)) +  sn*nod2liny(LL,2,uqcx(k2),uqcy(k2)) - u1(L)*sqa(k2)
                   else
                      qu1     = cs*uqcx(k1) + sn*uqcy(k1) - u1(L)*sqa(k1)
                      qu2     = cs*uqcx(k2) + sn*uqcy(k2) - u1(L)*sqa(k2)

                   endif
                   adve(L) = adve(L) + (ac1*qu1 + ac2*qu2) / volukk(L-Lb+1)
                endif
             enddo

          else if (layertype == 2 .and. jahazlayer == 2 ) then  ! lineinterp

             n1  = ln(1,LL) ; n2 = ln(2,LL)
             call getkbotktop(n1,kb1,kt1)
             call getkbotktop(n2,kb2,kt2)
             hs1 = max(epshs, zws(kt1) - zws(kb1-1) )
             hs2 = max(epshs, zws(kt2) - zws(kb2-1) )

             ktx01 = kt1 - kb1 + 1
             ktx02 = kt2 - kb2 + 1

             volk1(0) = 0d0 ; quuk1(0) = 0d0 ; sqak1(0) = 0d0 ; sigk1(0) = 0d0
             do k = kb1, kt1
                volk1(k-kb1+1) = volk1(k-kb1) + vol1(k)
                if (jasfer3D == 1) then
                   quuk1(k-kb1+1) = quuk1(k-kb1) + cs*nod2linx(LL,1,uqcx(k),uqcy(k)) + sn*nod2liny(LL,1,uqcx(k),uqcy(k))
                else
                   quuk1(k-kb1+1) = quuk1(k-kb1) + cs*uqcx(k) + sn*uqcy(k)
                endif
                sqak1(k-kb1+1) = sqak1(k-kb1) + sqa(k)
                sigk1(k-kb1+1) = ( zws(k) - zws(kb1-1) ) / hs1
             enddo

             volk2(0) = 0d0 ; quuk2(0) = 0d0 ; sqak2(0) = 0d0 ; sigk2(0) = 0d0
             do k = kb2, kt2
                volk2(k-kb2+1) = volk2(k-kb2) + vol1(k)
                if (jasfer3D == 1) then
                   quuk2(k-kb2+1) = quuk2(k-kb2) + cs*nod2linx(LL,2,uqcx(k),uqcy(k)) + sn*nod2liny(LL,2,uqcx(k),uqcy(k))
                else
                   quuk2(k-kb2+1) = quuk2(k-kb2) + cs*uqcx(k) + sn*uqcy(k)
                endif
                sqak2(k-kb2+1) = sqak2(k-kb2) + sqa(k)
                sigk2(k-kb2+1) = ( zws(k) - zws(kb2-1) ) / hs2
             enddo

             do L = Lb, Lt  ;  Ltx0 = Lt - Lb + 1 ; siguL(0) = 0d0
                siguL(L-Lb+1) = hu(L) / hu(LL)
             enddo

             if (LL == 300) then
                advel = 0d0
             endif

             call lineinterp3( siguL, quuL1, volL1, sqaL1, Ltx0, sigk1, quuk1, volk1, sqak1, ktx01)

             call lineinterp3( siguL, quuL2, volL2, sqaL2, Ltx0, sigk2, quuk2, volk2, sqak2, ktx02)

             do L = Lb, Lt
                vo1  = volL1(L-Lb+1) - volL1(L-Lb)
                vo2  = volL2(L-Lb+1) - volL2(L-Lb)
                volu = vo1*ac1 + vo2*ac2

                if (volu > 0) then

                   qu1   = quuL1(L-Lb+1) - quuL1(L-Lb) - u1(L)*( sqaL1(L-Lb+1) - sqaL1(L-Lb) )
                   qu2   = quuL2(L-Lb+1) - quuL2(L-Lb) - u1(L)*( sqaL2(L-Lb+1) - sqaL2(L-Lb) )

                   advel = ( ac1*qu1 + ac2*qu2 ) / volu

                   if (L == Lb .and. LL == 300) then
                        advel = 1d0*advel
                   endif
                   adve(L) = adve(L) + advel
                endif
             enddo

          else if (layertype == 2 .and. jahazlayer == 4) then

             n1  = ln(1,LL) ; n2 = ln(2,LL)
             call getkbotktop(n1,kb1,kt1) ; ktx1 = kb1 + kmxn(n1) - 1
             call getkbotktop(n2,kb2,kt2) ; ktx2 = kb2 + kmxn(n2) - 1

             Ltx = Lt-Lb+1

             volukk(1:Ltx) = 0d0 ; quuk1(1:Ltx) = 0d0 ; sqak1(1:Ltx) = 0d0

             do k = kb1, ln(1,Lb) - 1                   ! below Lb n1
                volukk(1) = volukk(1)     + ac1*vol1(k)
                if (jasfer3D == 1) then
                   quuk1(1) = quuk1(1) + ac1*(cs*nod2linx(LL,1,uqcx(k),uqcy(k)) + sn*nod2liny(LL,1,uqcx(k),uqcy(k)))
                else
                   quuk1(1) = quuk1 (1)     + ac1*(cs*uqcx(k) + sn*uqcy(k))
                endif
                sqak1 (1) = sqak1 (1)     + ac1*sqa(k)
             enddo

             do k = kb2, ln(2,Lb) - 1                   ! below Lb n2
                volukk(1) = volukk(1)     + ac2*vol1(k)
                if (jasfer3D == 1) then
                   quuk1(1) = quuk1(1) + ac2*(cs*nod2linx(LL,2,uqcx(k),uqcy(k)) + sn*nod2liny(LL,2,uqcx(k),uqcy(k)))
                else
                   quuk1(1) = quuk1 (1)     + ac2*(cs*uqcx(k) + sn*uqcy(k))
                endif
                sqak1 (1) = sqak1 (1)     + ac2*sqa(k)
             enddo

             do L = Lb, Lt                              ! intermediate
                k1    = ln(1,L) ; k2 = ln(2,L) ; L1 = L-Lb+1
                volukk(L1) = volukk(L1) + ac1*vol1(k1)                    + ac2*vol1(k2)
                if (jasfer3D == 1) then
                   quuk1 (L1) = quuk1(L1) + ac1*(cs*nod2linx(LL,1,uqcx(k1),uqcy(k1)) + sn*nod2liny(LL,1,uqcx(k1),uqcy(k1))) +   &
                                            ac2*(cs*nod2linx(LL,2,uqcx(k2),uqcy(k2)) + sn*nod2liny(LL,2,uqcx(k2),uqcy(k2)))
                else
                   quuk1 (L1) = quuk1 (L1) + ac1*(cs*uqcx(k1) + sn*uqcy(k1)) + ac2*(cs*uqcx(k2) + sn*uqcy(k2))
                endif
                sqak1 (L1) = sqak1 (L1) + ac1*sqa(k1)                     + ac2*sqa(k2)
             enddo

             do k = k1+1, ktx1                          ! above Lt n1
                volukk(Ltx) = volukk(Ltx) + ac1*vol1(k)
                if (jasfer3D == 1) then
                   quuk1 (Ltx) = quuk1(Ltx)  + ac1*(cs*nod2linx(LL,1,uqcx(k),uqcy(k)) + sn*nod2liny(LL,1,uqcx(k),uqcy(k)))
                else
                   quuk1 (Ltx) = quuk1(Ltx)  + ac1*(cs*uqcx(k) + sn*uqcy(k))
                endif
                sqak1 (Ltx) = sqak1(Ltx)  + ac1*sqa(k)
             enddo

             do k = k2+1, ktx2                          ! above Lt n2
                volukk(Ltx) = volukk(Ltx) + ac2*vol1(k)
                if (jasfer3D == 1) then
                   quuk1 (Ltx) = quuk1(Ltx)  + ac2*(cs*nod2linx(LL,2,uqcx(k),uqcy(k)) + sn*nod2liny(LL,2,uqcx(k),uqcy(k)))
                else
                   quuk1 (Ltx) = quuk1 (Ltx) + ac2*(cs*uqcx(k) + sn*uqcy(k))
                endif
                sqak1 (Ltx) = sqak1 (Ltx) + ac2*sqa(k)
             enddo

             do L  = Lb, Lt
                L1 = L-Lb+1
                if (volukk(L1) > 0) then
                   adveL   = ( quuk1(L1) - u1(L)*sqak1(L1) ) / volukk(L1)
                   if (abs(advel) > 0.05) then
                      advel = 1d0*advel
                   endif
                   adve(L) = adve(L) + adveL
               endif
             enddo

          endif

       else if (iadv(LL) == 34) then                          ! Kramer Stelling, ba per cell weighted

          call QucPer3Dsigma(1,LL,Lb,Lt,cs,sn,quk1)           ! sum of (Q*uc cell centre upwind normal) at side 1 of basis link LL
          call QucPer3Dsigma(2,LL,Lb,Lt,cs,sn,quk2)           ! sum of (Q*uc cell centre upwind normal) at side 2 of basis link LL
          baik1 = bai( ln(1,LL) )
          baik2 = bai( ln(2,LL) )
          do L = Lb, Lt
             advel = 0                                        ! advi (1/s), adve (m/s2)
             k1    = ln(1,L) ; k2 = ln(2,L)
             qu1   = 0d0
             if (vol1(k1) > 0) then
                qu1 = quk1(1,L-Lb+1)*ac1*baik1
             endif
             qu2    = 0
             if (vol1(k2) > 0) then
                qu2 = quk2(1,L-Lb+1)*ac2*baik2            ! Perot weigthing
             endif
             huvL    = ac1*(zws(k1)-zws(k1-1)) + ac2*(zws(k2)-zws(k2-1))
             if (huvL > 0d0) then
                advel   = (qu1 + qu2)/huvL                         ! dimension: ((m4/s2) / m3) =   (m/s2)
                adve(L) = adve(L) + advel
             endif
          enddo

       else if (iadv(LL) == 5) then

          call QucPer3Dsigmapiaczekteta(LL,Lb,Lt,cs,sn,quk1,quk2)

          do L = Lb, Lt
              adve(L) = adve(L) + quk1(1,L-Lb+1)
              advi(L) = advi(L) + quk2(1,L-Lb+1)
          enddo

       else if (iadv(LL) == 44) then

            do L = Lb, Lt
               k1    = ln(1,L) ; k2 = ln(2,L)
               if (vol1(k1) > 0) then
                  if (jasfer3D == 1) then
                     qu1     = cs*nod2linx(LL,1,uqcx(k1),uqcy(k1)) + sn*nod2liny(LL,1,uqcx(k1),uqcy(k1)) - u1(L)*sqa(k1)
                  else
                     qu1     = cs*uqcx(k1)  + sn*uqcy(k1) - u1(L)*sqa(k1)
                  endif
                  adve(L) = adve(L) + ac1*qu1/vol1(k1)
               endif
               if (vol1(k2) > 0) then
                  if (jasfer3D == 1) then
                     qu2    =  cs*nod2linx(LL,2,uqcx(k2),uqcy(k2)) + sn*nod2liny(LL,2,uqcx(k2),uqcy(k2)) - u1(L)*sqa(k2)
                  else
                     qu2     = cs*uqcx(k2)  + sn*uqcy(k2) - u1(L)*sqa(k2)
                  endif
                  adve(L) = adve(L) + ac2*qu2/vol1(k2)
               endif
            enddo

       endif   ! advectiontypes

    endif      ! (hu)

 enddo         ! LL

 endif


 end subroutine advec

 subroutine setextforcechkadvec()
 use m_flow
 use m_flowparameters, only: trshcorio
 use m_flowgeom
 use m_netw
 use MessageHandling
 use m_alloc
 use m_wind
 use m_sferic
 use m_xbeach_data, only: Fx, Fy, swave, Lwave, hminlw, xb_started !, facmax, Trep

 implicit none

 integer          :: L,LL, Lb, Lt, k1,k2, kt1, kt2
 double precision :: dpatm, tidp, trshcorioi, fmax, floc, dzt, dztm, alf
 double precision :: GradHinUc
 double precision :: p1, p2, wfac, Dzk

 trshcorioi = 1d0/trshcorio

if (jawind > 0) then

    if (kmx == 0) then
       !$OMP PARALLEL DO                                          &
       !$OMP PRIVATE(L)
        do LL = 1,lnx
           if ( hu(LL) > 0 ) then
               wfac = 1d0
               if (jawindpartialdry == 1) then
                  Dzk  = abs( zk(lncn(1,LL)) - zk(lncn(2,LL)) )
                  if (Dzk > 0d0) then
                     wfac = min( 1d0, hu(LL) / Dzk )
                  endif
               endif
               ! wdsu/huvli = [(m^2/s^2)*m^-1]
               if (jawindhuorzwsbased == 0) then
                  adve(LL) = adve(LL) - wdsu(LL)*wfac/hu(LL)
               else
                  adve(LL) = adve(LL) - wdsu(LL)*wfac*huvli(LL)
               endif
           endif
        enddo
        !$OMP END PARALLEL DO

    else

        do LL  = 1,lnx
           if (hu(LL) > 0d0) then
               wfac = 1d0
               if (jawindpartialdry == 1) then
                  Dzk  = abs( zk(lncn(1,LL)) - zk(lncn(2,LL)) )
                  if (Dzk > 0d0) then
                     wfac = min( 1d0, hu(LL) / Dzk )
                  endif
               endif

               Lt = Ltop(LL)
               ! adve(Lt) = adve(Lt) - wdsu(LL) / max( toplayminthick, hu(Lt) - hu(Lt-1)  )

               alf = 1d0
               if (jawindhuorzwsbased == 0) then
                  dzt = hu(Lt) - hu(Lt-1)
               else
                  kt1 = ktop( ln(1,LL) ) ; kt2 = ktop( ln(2,LL) )
                  dzt = acL(LL)*(zws(kt1) - zws(kt1-1)) + (1d0-acL(LL))*(zws(kt2) - zws(kt2-1))
               endif
               if ( Lbot(LL) < Lt ) then
                  dztm  =  hu(Lt-1) - hu(Lt-2)
                  !if ( dzt < 0.8d0*dztm ) then
                  if ( dzt < 0.05d0 ) then
                     alf   =  dzt / ( dzt + dztm )
                     adve(Lt-1) = adve(Lt-1) - (1d0-alf)*wdsu(LL)*wfac / dztm
                  endif
               endif
               adve(Lt) = adve(Lt) - alf*wdsu(LL)*wfac / dzt
           endif
        enddo

    endif

 endif

 if (jawave == 3 .and. kmx .eq. 0) then      ! if a SWAN computation is performed, add wave forces to adve
                                             ! This part is mainly based on the wave forces formulation (wsu) of Delft3D (cucnp.f90)

     !if ( kmx.eq.0 ) then  ! 2D
     !$OMP PARALLEL DO                                          &
     !$OMP PRIVATE(L)
     do L  = 1,lnx
        adve(L) = adve(L) - wavfu(L)
     enddo
     !$OMP END PARALLEL DO
     !else
     !!$OMP PARALLEL DO                                          &
     !!$OMP PRIVATE(L)
     !   do LL  = 1,lnx
     !      !if ( hu(LL).gt.0 ) then ! need to check
     !         call LbotLtop(LL,Lb,Lt)
     !         do L=Lb,Lt
     !             adve(L) = adve(L) - wavfu(L)/(rhomean*hu(L))           ! Dimensions [m/s^2]
     !         end do
     !      !end if
     !   enddo
     !!$OMP END PARALLEL DO
     !end if

 endif

! JRE
 if (jawave .eq. 4 .and. Lwave.eq.1) then                              ! wave forcing from XBeach
     call xbeach_wave_compute_flow_forcing()
     !$OMP PARALLEL DO                                          &
     !$OMP PRIVATE(L)
     do L  = 1,Lnx
        floc = Fx(L)*csu(L) + Fy(L)*snu(L)
        adve(L) = adve(L) - floc/ (rhomean*max(hu(L), hminlw) ) ! Johan+Dano: lower depth set to 20cm, cf XBeach
     enddo
     !$OMP END PARALLEL DO

 endif

 if (japatm > 0 .or. jatidep > 0) then
    !$OMP PARALLEL DO                                          &
    !$OMP PRIVATE(L,k1,k2,dpatm,tidp)
    do L  = 1,lnx
       if ( hu(L) > 0 ) then
          k1     = ln(1,L) ; k2 = ln(2,L)

          if (japatm > 0) then
!             dpatm  = ( patm(k2) - patm(k1) )*dxi(L)/rhomean
!             if ( hu(L) < trshcorio ) then
!                 dpatm  = dpatm*hu(L)*trshcorioi
!             endif

             dpatm  = (patm(k2)-patm(k1))*dxi(L)/rhomean

             if (kmx == 0) then
                adve(L) = adve(L) + dpatm
             else
                adve( Lbot(L):Ltop(L) ) = adve( Lbot(L):Ltop(L) ) + dpatm
             endif

          endif

          if (jatidep > 0 .or. jaselfal > 0) then
             tidp  = ( tidep(1,k2) - tidep(1,k1) )*dxi(L)
             if ( hu(L) < trshcorio) then
                tidp = tidp*hu(L)*trshcorioi
             endif
             if (kmx == 0) then
                adve(L) = adve(L) - tidp
             else
                adve( Lbot(L):Ltop(L) ) = adve( Lbot(L):Ltop(L) ) - tidp
             endif

!            add to tidal forces
             tidef(L) = tidp
          endif
       endif
    enddo
    !$OMP END PARALLEL DO

    if ( jatidep.gt.0 .or. jaselfal.gt.0 .and. kmx.eq.0 ) then
       call comp_GravInput()
    end if

 endif

 ! Anti-creep
 if( kmx < 2 .and. jacreep == 1) then           ! A warning due to kmx<2 and anticreep on
     call mess(LEVEL_INFO, 'Error : Anti-creep must be switched off in a 1d/2d model!')
 endif

 if ( idensform > 0) then                                     ! Baroclinic pressure
    if ( jacreep == 1) then
       dsalL = 0d0
       dtemL = 0d0
       !$OMP PARALLEL DO PRIVATE(L)
       do L = 1,lnx
          if (hu(L) > 0d0) then
             call anticreep( L )
          endif
       enddo
       !$OMP END PARALLEL DO

     else

       call addbaroclinicpressure()

       if (abs(jabaroctimeint) == 2) then
           rho0 = rho                                           ! save rho
       else if (abs(jabaroctimeint) == 5) then
           if (jarhoxu > 0) then
              rho = rho0                                        ! restore rho
           endif
       endif
       jabaroctimeint = abs(jabaroctimeint)                     ! flag as initialised

    end if
 endif

 if ( jasecflow > 0 ) then                                         ! Secondary Flow

    do LL = 1,lnx
       call getcz( hu(LL), frcu(LL), ifrcutp(LL), czusf(LL), LL)   ! calculating chezy coefficient on the flow links
    enddo

    !
    if (kmx < 2) then
       call linkstocenterstwodoubles( czssf, czusf )               ! converting chezy cofficient to the flow nodes
       if( spirbeta > 0.0d0 ) then
          call get_spiralforce
       endif
    else
       !call linkstocenterstwodoubles( czssf, czusf )
       call get_spiral3d                                           ! compute equivalent secondary flow intensity
    endif
 end if


 if ( jaFrcInternalTides2D.gt.0 .and. kmx.eq.0 ) then   ! internal tides friction (2D only)
    call add_InternalTidesFrictionForces()
 end if


 if (chkadvd > 0) then                       ! niet droogtrekken door advectie, stress of wind (allen in adve)

    if (kmx == 0) then

       !$OMP PARALLEL DO                             &
       !$OMP PRIVATE(L,k1,k2)
       !$XOMP REDUCTION(+:nochkadv)
       do L  = 1,lnx

          if ( hu(L) > 0 ) then
             k1      = ln(1,L) ; k2 = ln(2,L)

             if     (hs(k1)  < 0.5d0*hs(k2) ) then
                if (adve(L)  < 0 .and. hs(k1) < chkadvd ) then
                    adve(L)  = adve(L)*hs(k1) / chkadvd ! ; nochkadv = nochkadv + 1
                endif
             else if (hs(k2) < 0.5d0*hs(k1) ) then
                if (adve(L)  > 0 .and. hs(k2) < chkadvd ) then
                    adve(L)  = adve(L)*hs(k2) / chkadvd ! ; nochkadv = nochkadv + 1
                endif
             endif
          endif

       enddo
       !$OMP END PARALLEL DO

    else

       !$OMP PARALLEL DO                             &
       !$OMP PRIVATE(L,k1,k2,LL,Lb,Lt)

       do LL  = 1,lnx
          if (hu(LL) > 0d0) then
             call getLbotLtop(LL,Lb,Lt)
             k1   = ln(1,LL) ; k2 = ln(2,LL)
             do L = Lb, Lt
                if      (hs(k1) < 0.5d0*hs(k2) ) then
                   if (adve(L)  < 0 .and. hs(k1) < chkadvd ) then
                       adve(L)  = adve(L)*hs(k1) / chkadvd ! ; nochkadv = nochkadv + 1
                   endif
                else if (hs(k2) < 0.5d0*hs(k1) ) then
                   if (adve(L)  > 0 .and. hs(k2) < chkadvd) then
                       adve(L)  = adve(L)*hs(k2) / chkadvd ! ; nochkadv = nochkadv + 1
                   endif
                endif
             enddo
          endif
      enddo

      !$OMP END PARALLEL DO

    endif

 endif
   end subroutine setextforcechkadvec

! =================================================================================================
! =================================================================================================
  subroutine getucxucybarrierzero ( Lf, ku, ucxku, ucyku )
 use m_flow
 use m_flowgeom
 implicit none

 integer           :: ku, L, LL, Ls, n12, Lf
 double precision  :: ucxku, ucyku, ww, ac1, cs, sn
 double precision, external :: lin2nodx, lin2nody

 ucxku = 0d0  ; ucyku = 0d0

 do LL = 1,nd(ku)%lnx
    Ls = nd(ku)%ln(LL); L = iabs(Ls)
    if (Ls < 0) then
       ac1 = acL(L)
       n12 = 1
    else
       ac1 = 1d0 - acL(L)
       n12 = 2
    endif
    ww = ac1*dx(L)*wu(L)
    cs = ww*csu(L) ; sn = ww*snu(L)
    if( L /= Lf ) then
       ucxku = ucxku + lin2nodx(L,n12,cs,sn)*u1(L)
       ucyku = ucyku + lin2nody(L,n12,cs,sn)*u1(L)
    endif
 enddo
 ucxku = ucxku/ba(ku)
 ucyku = ucyku/ba(ku)

 end subroutine getucxucybarrierzero

! =================================================================================================
! =================================================================================================
 subroutine getucxucyweironly ( ku, ucxku, ucyku, ischeme )
 use m_flow
 use m_flowgeom
 use m_sferic, only: jasfer3D
 implicit none

 integer           :: ku, LLL, LL, L, Ls, ischeme, n12

 double precision  :: ucxku, ucyku, ww, ac1, huweir, hunoweir, wl, wlno, at, cs, sn, fac

 double precision, external :: lin2nodx, lin2nody

 ucxku = 0d0  ; ucyku = 0d0
 huweir = 0d0 ; hunoweir = 0d0; wl = 0d0 ; wlno = 0d0; at = 0d0

 do LL = 1,nd(ku)%lnx
    Ls = nd(ku)%ln(LL); L = iabs(Ls)
    if (iadv(L) >= 21 .and. iadv(L) <= 29) then
       huweir = huweir + wu(L)*hu(L)
       wl     = wl     + wu(L)
    endif
 enddo
 huweir = huweir/wl


 do LL = 1,nd(ku)%lnx
    Ls = nd(ku)%ln(LL); L = iabs(Ls)
    if (Ls < 0) then
       ac1 = acL(L)
       n12 = 1
    else
       ac1 = 1d0 - acL(L)
       n12 = 2
    endif
    ww = ac1*dx(L)*wu(L)
    cs = ww*csu(L) ; sn = ww*snu(L)

    if (iadv(L) >= 21 .and. iadv(L) <= 29) then
       if (jasfer3D == 0) then
          ucxku = ucxku + cs*u0(L)
          ucyku = ucyku + sn*u0(L)
       else
          ucxku = ucxku + lin2nodx(L,n12,cs,sn)*u0(L)
          ucyku = ucyku + lin2nody(L,n12,cs,sn)*u0(L)
       endif
    else
       fac   = 1d0
       if (huweir > 0d0) fac = max(1d0, hu(L) / huweir )
       if (jasfer3D == 0) then
          ucxku = ucxku + cs*u0(L)*fac
          ucyku = ucyku + sn*u0(L)*fac
       else
          ucxku = ucxku + lin2nodx(L,n12,cs,sn)*u0(L)*fac
          ucyku = ucyku + lin2nody(L,n12,cs,sn)*u0(L)*fac
       endif
    endif
 enddo
 ucxku = ucxku/ba(ku)
 ucyku = ucyku/ba(ku)

 end subroutine getucxucyweironly

 subroutine getucxucynoweirs( ku, ucxku, ucyku, ischeme )
 use m_flow
 use m_flowgeom
 use m_sferic, only: jasfer3D
 implicit none

 integer           :: ku, LLL, LL, L, Ls, ischeme, n12

 double precision  :: ucxku, ucyku, ww, ac1, huweir, hunoweir, wl, wlno, at, cs, sn, fac

 double precision, external :: lin2nodx, lin2nody

 ucxku = 0d0  ; ucyku = 0d0
 huweir = 0d0 ; hunoweir = 0d0; wl = 0d0 ; wlno = 0d0; at = 0d0

 do LL = 1,nd(ku)%lnx
    Ls = nd(ku)%ln(LL); L = iabs(Ls)
    if (iadv(L) < 21 .or. iadv(L) > 29) then ! .ne. structures
       hunoweir = hunoweir + wu(L)*hu(L)
       wlno     = wlno     + wu(L)
    endif
 enddo
 if (wlno > 0d0 ) hunoweir = hunoweir/wlno

 do LL = 1,nd(ku)%lnx
    Ls = nd(ku)%ln(LL); L = iabs(Ls)
    if (Ls < 0) then
       ac1 = acL(L)
       n12 = 1
    else
       ac1 = 1d0 - acL(L)
       n12 = 2
    endif
    ww = ac1*dx(L)*wu(L)
    cs = ww*csu(L) ; sn = ww*snu(L)
    at = at + ww
    if (iadv(L) < 21 .or. iadv(L) > 29) then ! .ne. structures
       if (jasfer3D == 0) then
          ucxku = ucxku + cs*u0(L)
          ucyku = ucyku + sn*u0(L)
       else
          ucxku = ucxku + lin2nodx(L,n12,cs,sn)*u0(L)
          ucyku = ucyku + lin2nody(L,n12,cs,sn)*u0(L)
       endif
    else
       fac   = 1d0
       if (hunoweir > 0d0) fac = min(1d0, hu(L) / hunoweir )
       if (jasfer3D == 0) then
          ucxku = ucxku + cs*u0(L)*fac
          ucyku = ucyku + sn*u0(L)*fac
       else
          ucxku = ucxku + lin2nodx(L,n12,cs,sn)*u0(L)*fac
          ucyku = ucyku + lin2nody(L,n12,cs,sn)*u0(L)*fac
       endif
    endif
 enddo
 ucxku = ucxku/ba(ku)
 ucyku = ucyku/ba(ku)

 end subroutine getucxucynoweirs

 subroutine getucxucyweironlywrong ( ku, ucxku, ucyku, ischeme )
 use m_flow
 use m_flowgeom
 implicit none

 integer           :: ku, LLL, LL, L, Ls, ischeme

 double precision  :: ucxku, ucyku, wwx, wwy, ww, wwt, ac1, wwxt, wwyt, ux, uy

 ucxku = 0d0 ; ucyku = 0d0; wwt = 0d0; wwxt = 0d0 ; wwyt = 0d0
 do LL = 1,nd(ku)%lnx
    Ls = nd(ku)%ln(LL); L = iabs(Ls)
    if (iadv(L) == 21) then
       if (Ls < 0) then
          ac1 = acL(L)
       else
          ac1 = 1d0 - acL(L)
       endif
       ww    = ac1*dx(L)*wu(L)
       if (ischeme == 3) then
          wwx   = csu(L)*ww
          wwy   = snu(L)*ww
          ucxku = ucxku + wwx*u0(L)
          ucyku = ucyku + wwy*u0(L)
       else
          wwx   = abs(csu(L))*ww
          wwy   = abs(snu(L))*ww
          ux    = csu(L)*u0(L)
          uy    = snu(L)*u0(L)
          ucxku = ucxku + ux*wwx
          ucyku = ucyku + uy*wwy
       endif
       wwxt = wwxt + abs(wwx)
       wwyt = wwyt + abs(wwy)
    endif
 enddo

 if (wwxt > 0d0) ucxku = ucxku / wwxt
 if (wwyt > 0d0) ucyku = ucyku / wwyt

 end subroutine getucxucyweironlywrong

 subroutine getucxucynoweirswrong(ku, ucxku, ucyku, ischeme)  !wrong
 use m_flow
 use m_flowgeom
 implicit none

 integer           :: ku, LL, L, Ls, ischeme
 double precision  :: ucxku, ucyku, wwx, wwy, ww, wwt, ac1, wwxt, wwyt, ux, uy

 ucxku = 0d0 ; ucyku = 0d0; wwt = 0d0; wwxt = 0d0 ; wwyt = 0d0
 do LL = 1,nd(ku)%lnx
    Ls = nd(ku)%ln(LL); L = iabs(Ls)
    if ( iadv(L) < 21 .or. iadv(L) > 25 ) then  ! no weir
       if (Ls < 0) then
          ac1 = acL(L)
       else
          ac1 = 1d0 - acL(L)
       endif
       ww    = ac1*dx(L)*wu(L)
       if (ischeme == 3) then
          wwx   = csu(L)*ww
          wwy   = snu(L)*ww
          ucxku = ucxku + wwx*u0(L)
          ucyku = ucyku + wwy*u0(L)
       else
          wwx   = abs(csu(L))*ww
          wwy   = abs(snu(L))*ww
          ux    = csu(L)*u0(L)
          uy    = snu(L)*u0(L)
          ucxku = ucxku + ux*wwx
          ucyku = ucyku + uy*wwy
       endif
       wwxt = wwxt + abs(wwx)
       wwyt = wwyt + abs(wwy)
    endif
 enddo

 if (wwxt > 0d0) ucxku = ucxku / wwxt
 if (wwyt > 0d0) ucyku = ucyku / wwyt

 end subroutine getucxucynoweirswrong

subroutine setumod(jazws0)                          ! set cell center Perot velocities at nodes
                                                     ! set Perot based friction velocities umod at u point
                                                     ! set tangential velocities at u point
                                                     ! set velocity gradient at u point
                                                     ! set corner based Perot velocities

 use m_flow
 use m_flowgeom
 use m_flowtimes
 use m_sferic
 use m_wind
 use m_ship
 use m_missing
 use m_xbeach_data, only : DR, roller, swave
 use unstruc_model, only : md_restartfile
 implicit none

 integer,intent(in):: jazws0
 ! locals
 integer           :: L, LL, k, k1, k2, k12, k3, k4, kb, n, n1, n2, nn, ks, ierr
 double precision  :: ux, uy                         ! centre or node velocity x- and y components
 double precision  :: hsi, humx                      ! inverse centre depth, max depth u points
 double precision  :: qwd,qwd1,qwd2                  !
 double precision  :: qucx, qucy
 double precision  :: duxdn, duydn, duxdt, duydt     ! normal and tangential global ux,uy gradients
 double precision  :: vicl, c11, c12, c22, wudx, bai2, sxx, syy, snn

 double precision  :: sxw, syw, sf, ac1, ac2, csl, snl, wuw, ustar, suxw, suyw, uin, suxL, suyL
 double precision  :: cs, sn, dxi2, dyi2, sucheck
 double precision  :: chezy2, hhu, rt, hmin
 double precision  :: uu,vv,uucx,uucy, ff, ds, hup, fcor, vcor
 double precision  :: dundn, dutdn, dundt, dutdt, shearvar, delty, vksag6, Cz
 double precision  :: umodLL, volu, hul, dzz, adx, hdx, huv, qL, wcxu, wcyu
 double precision, allocatable:: u1_tmp(:)

 integer           :: nw, L1, L2, kbk, k2k, Ld, Lu, kt, Lb, Lt, Lb1, Lt1, Lb2, Lt2, kb1, kb2, ntmp

 double precision  :: depumin  ! external
 double precision  :: horvic   ! external
 double precision  :: horvic3  ! external

 double precision  :: DRL, nuhroller

 double precision  :: dxiAu, vicc

 integer :: ini = 0

 integer :: ndraw
 COMMON /DRAWTHIS/ ndraw(50)

 double precision, external :: nod2linx, nod2liny, lin2nodx, lin2nody, cor2linx, cor2liny
 double precision, external :: nod2wallx, nod2wally, wall2linx, wall2liny

 !if (jased > 0) then
 !   taucx = 0d0; taucy = 0d0
 !endif

 call klok(cpuumod(1))                               ! Perot velocities
 if(jazws0==1 .and. len_trim(md_restartfile)>0) then
   ! This is the moment after the restart file is read and before the first output of the inital info.
   ! At this moment, u0 is used to compute the cell-center velocities. And hs has been computed in flow_initimestep, using s0.
    ntmp = size(u1)
    allocate(u1_tmp(ntmp))
    u1_tmp = u1
    u1     = u0
    hs     = s0 - bl
    call setucxucyucxuucyu() !reconstruct cell-center velocities
    u1     = u1_tmp
    deallocate(u1_tmp)

    dti = 1d0/dts
 else
    call setucxucyucxuucyu()
 endif

 ! set friction velocities umod, tangential velocities v and velocity gradients and windstresses

 !$OMP PARALLEL DO                           &
 !$OMP PRIVATE(L,LL,Lb,Lt,k1,k2,cs,sn,hmin,fcor,vcor)
 do LL   = lnx1D+1,lnx
    hmin = min( hs(ln(1,LL)),hs(ln(2,LL)) )

    call getLbotLtop(LL,Lb,Lt)
    cs = csu(LL)  ; sn = snu(LL) ; v(LL) = 0d0
    do L = Lb,Lt
       k1 = ln(1,L) ; k2 = ln(2,L)

       if ( jasfer3D == 1 ) then
          v(L) =      acL(LL) *(-sn*nod2linx(LL,1,ucx(k1),ucy(k1)) + cs*nod2liny(LL,1,ucx(k1),ucy(k1))) +  &
                 (1d0-acL(LL))*(-sn*nod2linx(LL,2,ucx(k2),ucy(k2)) + cs*nod2liny(LL,2,ucx(k2),ucy(k2)))
       else
          v(L) =      acl(LL) *(-sn*ucx(k1) + cs*ucy(k1) ) + &
                 (1d0-acl(LL))*(-sn*ucx(k2) + cs*ucy(k2) )
       endif
       if (kmx > 0) then
          v(LL) = v(LL) + v(L)*Au(L) ! hk: activate when needed
       endif

       if (icorio > 0) then
          ! set u tangential
          if (icorio == 4) then
                 vcor = v(L)
          else
             if ( jasfer3D == 1 ) then
                 vcor =      acL(LL) *(-sn*nod2linx(LL,1,ucxq(k1),ucyq(k1)) + cs*nod2liny(LL,1,ucxq(k1),ucyq(k1))) +  &
                        (1d0-acL(LL))*(-sn*nod2linx(LL,2,ucxq(k2),ucyq(k2)) + cs*nod2liny(LL,2,ucxq(k2),ucyq(k2)))
             else
                 vcor =      acl(LL) *(-sn*ucxq(k1) + cs*ucyq(k1) ) + &     ! continuity weighted best sofar plus depth limiting
                        (1d0-acl(LL))*(-sn*ucxq(k2) + cs*ucyq(k2) )
             endif
          endif

          if (jsferic == 1) then
             fcor = fcori(LL)
          else
             fcor = fcorio
          endif
          if (fcor .ne. 0d0) then
             if (trshcorio > 0) then
                if ( hmin < trshcorio) then
                   fcor = fcor*hmin/trshcorio
                endif
             endif
             adve(L) = adve(L) - fcor*vcor
          endif
       endif

    enddo
    if (kmx > 0) then
       if ( Au(LL) .gt. 0d0 ) then ! hk: activate if needed
           v(LL) = v(LL) / Au(LL)
       endif
    endif

 enddo

 !$OMP END PARALLEL DO

! JR: compute depth-averaged tangential velocity in 3D  ! hk: integrated in prev loop, is this necessay each step?
! if ( kmx.gt.0 ) then
! !$OMP PARALLEL DO                           &
! !$OMP PRIVATE(L,LL,Lb,Lt)
!    do LL=1,Lnx
!       v(LL) = 0d0
!
!       call getLbotLtop(LL,Lb,Lt)
!       do L = Lb,Lt
!          v(LL) = v(LL) + v(L)*Au(L)
!       end do
!
!       if ( Au(LL).gt.0d0 ) then
!          v(LL) = v(LL) / Au(LL)
!       end if
!    end do
!     !$OMP END PARALLEL DO
! end if


 !updvertp

ihorvic = 0
if (vicouv > 0 .or. javiusp == 1 .or. Smagorinsky > 0 .or. Elder > 0 .or. kmx > 0) then
   ihorvic = 1
endif
if (ihorvic > 0 .or. jaconveyance2D>=3 .or. ndraw(29) == 37) then
   call setcornervelocities()                        ! must be called after ucx, ucy have been set
endif
if (vicouv < 0d0) then
   ihorvic = 0
endif

if (ihorvic > 0 .or. NDRAW(29) == 37) then
  dvxc = 0 ; dvyc = 0; suu = 0
  if (kmx == 0) then

     if (istresstyp == 2 .or. istresstyp == 3) then     ! first set stressvector in cell centers

       vksag6 = vonkar*sag/6d0
       do L = lnx1D+1,lnx
          if (hu(L) > 0) then                           ! link will flow

             cs = csu(L)  ; sn = snu(L)
             k1 = ln(1,L) ; k2 = ln(2,L)

             vicL = 0d0
             if (Elder > 0d0) then                     !  add Elder
                 call getcz(hu(L), frcu(L), ifrcutp(L), Cz, L)
                 vicL = vicL + Elder * (vksag6/Cz) * ( hu(L) ) * sqrt( u1(L)*u1(L) + v(L)*v(L) )  ! vonkar*sag/(6*Cz) = 0.009
             endif

             k3 = lncn(1,L) ; k4 = lncn(2,L)

             if ( jasfer3D == 1 ) then
                duxdn = ( nod2linx(L,2,ucx(k2),ucy(k2)) - nod2linx(L,1,ucx(k1),ucy(k1)) )*dxi(L)
                duydn = ( nod2liny(L,2,ucx(k2),ucy(k2)) - nod2liny(L,1,ucx(k1),ucy(k1)) )*dxi(L)
                duxdt = ( cor2linx(L,2,ucnx(k4),ucny(k4)) - cor2linx(L,1,ucnx(k3),ucny(k3)) ) * wui(L)
                duydt = ( cor2liny(L,2,ucnx(k4),ucny(k4)) - cor2liny(L,1,ucnx(k3),ucny(k3)) ) * wui(L)
             else
                duxdn   =  ( ucx(k2) -  ucx(k1)) * dxi(L)
                duydn   =  ( ucy(k2) -  ucy(k1)) * dxi(L)
                duxdt   =  (ucnx(k4) - ucnx(k3)) * wui(L)
                duydt   =  (ucny(k4) - ucny(k3)) * wui(L)
             endif

             if (Smagorinsky > 0 .or. NDRAW(29) == 37) then               ! add Smagorinsky
                dundn    =  cs*duxdn + sn*duydn
                dutdn    = -sn*duxdn + cs*duydn
                dundt    =  cs*duxdt + sn*duydt
                dutdt    = -sn*duxdt + cs*duydt
                if ( NDRAW(29) == 37 ) then   ! plot curl
                   plotlin(L) = (dutdn - dundt)
                endif
                if (Smagorinsky > 0) then
                   shearvar = 2d0*(dundn*dundn + dutdt*dutdt + dundt*dutdn) + dundt*dundt + dutdn*dutdn

                   vicL     = vicL + Smagorinsky*Smagorinsky*sqrt(shearvar)/( dxi(L)*wui(L) )
                endif

             endif

             if (nshiptxy > 0) then
                 if (vicuship /= 0d0) then
                    vicL = vicL + vicushp(L)
                 endif
             endif

             ! JRE: add roller induced viscosity
             if ((jawave .eq. 4) .and. (swave .eq. 1) .and. (roller .eq. 1)) then
                DRL = acL(L) * DR(k1) + (1-acL(L)) * DR(k2)
                nuhroller = hu(L) * (DRL / rhomean) ** (1d0/3d0)
                vicL = max(nuhroller, vicL)
             end if

!             if (viuchk < 0.5d0) then
!                vicL = min(vicL, viuchk*dti /( dxi(L)*dxi(L) + wui(L)*wui(L) ) )
!             endif

!            viuchk: safe would be min(vol1(k1)/nd(k1)%N, vol1(k2)/nd(k2)%N) * dti / (dxi(L)*Au(L)),
!                    hence 0.2d0*min(vol1(k1),vol1(k2))... is safe up to pentagons

             if (javiusp == 1) then       ! user specified part
                 vicc = viusp(L)
             else
                 vicc = vicouv
             endif
             vicL = vicL + vicc

             if (ja_timestep_auto_visc == 0) then
                dxiAu = dxi(L)*hu(L)*wu(L)
                if ( dxiAu.gt.0d0 ) then
                   vicL = min(vicL, 0.2d0*dti*min( vol1(k1) , vol1(k2) )  / dxiAu )  ! see Tech Ref.: Limitation of Viscosity Coefficient
                endif
             endif

             vicLu(L) = vicL                       ! horizontal eddy viscosity applied in mom eq.
             viu(L) = max(0d0, vicL - vicc)        ! modeled turbulent part

             c11    = cs*cs ; c12=cs*sn ; c22=sn*sn
             suxL   = duxdn + c11*duxdn + c12*(duydn - duxdt) - c22*duydt
             suyL   = duydn + c11*duxdt + c12*(duxdn + duydt) + c22*duydn

             suxL   = suxL*vicL/wui(L)
             suyL   = suyL*vicL/wui(L)
             if (istresstyp == 3) then
                hmin  = min(hs(k1), hs(k2))
                suxL  = hmin*suxL
                suyL  = hmin*suyL
             endif

             if ( jsferic.eq.1 .and. jasfer3D.eq.1 ) then
                dvxc(k1) = dvxc(k1) + lin2nodx(L,1,suxL,suyL)
                dvyc(k1) = dvyc(k1) + lin2nody(L,1,suxL,suyL)
                dvxc(k2) = dvxc(k2) - lin2nodx(L,2,suxL,suyL)
                dvyc(k2) = dvyc(k2) - lin2nody(L,2,suxL,suyL)
             else
                dvxc(k1) = dvxc(k1) + suxL
                dvyc(k1) = dvyc(k1) + suyL
                dvxc(k2) = dvxc(k2) - suxL
                dvyc(k2) = dvyc(k2) - suyL
             endif

          endif

       enddo

    else

        !$OMP PARALLEL DO                                  &
        !$OMP PRIVATE(L,k1,k2)
        do L = lnx1D+1,lnx
          if (hu(L) > 0) then                           ! link will flow
             k1 = ln(1,L) ; k2 = ln(2,L)
             if (istresstyp == 4 .or. istresstyp == 5) then             ! set stresscomponent in links right away
                suu(L) = acl(L)*horvic(1,L) + (1d0-acl(L))*horvic(2,L)
             else if (istresstyp == 6) then
                suu(L) = acl(L)*horvic3(1,L) + (1d0-acl(L))*horvic3(2,L)
             endif
          endif
        enddo
        !$OMP END PARALLEL DO

    endif

  else if (kmx > 0) then

     if (istresstyp == 2 .or. istresstyp == 3) then     ! first set stressvector in cell centers

       do LL = lnx1D+1,lnx

          if (abs(kcu(LL)) .ne. 2) cycle
          call getLbotLtop(LL,Lb,Lt)
          cs   = csu(LL)  ; sn = snu(LL)

          if (javiusp == 1) then    ! user specified part
              vicc = viusp(LL)
           else
              vicc = vicouv
          endif

          do L = Lb, Lt

             vicL = 0d0

             k1 = ln  (1,L) ; k2 = ln  (2,L)
             k3 = lncn(1,L) ; k4 = lncn(2,L)
             if ( jasfer3D == 1 ) then
                duxdn = ( nod2linx(LL,2,ucx(k2),ucy(k2)) - nod2linx(LL,1,ucx(k1),ucy(k1)) )*dxi(LL)
                duydn = ( nod2liny(LL,2,ucx(k2),ucy(k2)) - nod2liny(LL,1,ucx(k1),ucy(k1)) )*dxi(LL)
                duxdt = ( cor2linx(LL,2,ucnx(k4),ucny(k4)) - cor2linx(LL,1,ucnx(k3),ucny(k3)) ) * wui(LL)
                duydt = ( cor2liny(LL,2,ucnx(k4),ucny(k4)) - cor2liny(LL,1,ucnx(k3),ucny(k3)) ) * wui(LL)
             else
                duxdn =  ( ucx(k2) -  ucx(k1)) * dxi(LL)
                duydn =  ( ucy(k2) -  ucy(k1)) * dxi(LL)
                duxdt =  (ucnx(k4) - ucnx(k3)) * wui(LL)
                duydt =  (ucny(k4) - ucny(k3)) * wui(LL)
             endif


             if (Smagorinsky > 0 .or. NDRAW(29) == 37) then               ! add Smagorinsky
                dundn    =  cs*duxdn + sn*duydn
                dutdn    = -sn*duxdn + cs*duydn
                dundt    =  cs*duxdt + sn*duydt
                dutdt    = -sn*duxdt + cs*duydt
                if ( NDRAW(29) == 37 .and. L-Lb+1 == kplot ) then         ! plot curl
                   plotlin(LL) = (dutdn - dundt)
                endif
                if (Smagorinsky > 0) then
                   shearvar = 2d0*(dundn*dundn + dutdt*dutdt + dundt*dutdn) + dundt*dundt + dutdn*dutdn
                   vicL     = vicL + Smagorinsky*Smagorinsky*sqrt(shearvar)/( dxi(LL)*wui(LL) )
                endif
             endif

             vicL = vicL + vicc

             if (javiuplus3D > 0) then
                vicL = vicL + vicwwu(L)
             endif

             if (nshiptxy > 0) then
                 if (vicuship /= 0d0) then
                    vicL = vicL + vicushp(LL)
                 endif
             endif

             if (ja_timestep_auto_visc == 0) then
                dxiAu = dxi(LL)*Au(L)
                if ( dxiAu.gt.0d0 ) then
                   vicL = min(vicL, 0.2d0*dti*min( vol1(k1) , vol1(k2) )  / dxiAu )
                endif
             endif

             vicLu(L) = vicL                       ! horizontal eddy viscosity applied in mom eq.
             viu(L) = max(0d0, vicL - vicc)        ! modeled turbulent part

             c11    = cs*cs ; c12=cs*sn ; c22=sn*sn
             suxL   = duxdn + c11*duxdn + c12*(duydn - duxdt) - c22*duydt
             suyL   = duydn + c11*duxdt + c12*(duxdn + duydt) + c22*duydn

             suxL   = suxL*vicL/wui(LL)
             suyL   = suyL*vicL/wui(LL)
             if (istresstyp == 3) then
                hmin  = min( zws(k1)-zws(k1-1), zws(k2)-zws(k2-1)  )
                suxL  = hmin*suxL
                suyL  = hmin*suyL
             endif

             if ( jsferic.eq.1 .and. jasfer3D.eq.1 ) then
                dvxc(k1) = dvxc(k1) + lin2nodx(LL,1,suxL,suyL)
                dvyc(k1) = dvyc(k1) + lin2nody(LL,1,suxL,suyL)
                dvxc(k2) = dvxc(k2) - lin2nodx(LL,2,suxL,suyL)
                dvyc(k2) = dvyc(k2) - lin2nody(LL,2,suxL,suyL)
             else
                dvxc(k1) = dvxc(k1) + suxL
                dvyc(k1) = dvyc(k1) + suyL
                dvxc(k2) = dvxc(k2) - suxL
                dvyc(k2) = dvyc(k2) - suyL
             endif

          enddo

       enddo

     endif
   endif

 endif

 if (ihorvic > 0) then

     if (istresstyp == 2 .or. istresstyp == 3 ) then

        if (kmx == 0) then
          !$OMP PARALLEL DO                       &
          !$OMP PRIVATE(L,k1,k2,huv)

         do L = lnx1D+1,lnx
             if (hu(L) > 0) then                           ! link will flow
                 k1 = ln(1,L) ; k2 = ln(2,L)
                 huv    = 0.5d0*( hs(k1) + hs(k2) )         ! *huvli(L)
                 if (huv > epshu ) then

                    if ( jasfer3D == 1 ) then
                       suu(L) =      acl(L)  * bai(k1)*( csu(L)*nod2linx(L,1,dvxc(k1),dvyc(k1)) + snu(L)*nod2liny(L,1,dvxc(k1),dvyc(k1)) ) +    &
                                (1d0-acl(L)) * bai(k2)*( csu(L)*nod2linx(L,2,dvxc(k2),dvyc(k2)) + snu(L)*nod2liny(L,2,dvxc(k2),dvyc(k2)) )
                    else
                       suu(L) = acl(L)     *bai(k1)*( csu(L)*dvxc(k1) + snu(L)*dvyc(k1)  ) +  &
                               (1d0-acl(L))*bai(k2)*( csu(L)*dvxc(k2) + snu(L)*dvyc(k2)  )
                    endif

                    if (istresstyp == 3) then
                        suu(L) = suu(L) / huv
                    endif
                 endif
             endif
          enddo
          !$OMP END PARALLEL DO
        else

          !$OMP PARALLEL DO                       &
          !$OMP PRIVATE(LL,kb1,kb2,Lb,Lt,L,k1,k2,huv)

           do LL = lnx1D+1,lnx
              if (hu(LL) > 0d0) then
                 kb1 = ln(1,LL) ; kb2 = ln(2,LL)
                 call getLbotLtop(LL,Lb,Lt)
                 do L = Lb,Lt
                    k1 = ln(1,L) ; k2 = ln(2,L)
                    huv    = 0.5d0 * ( (zws(k1)-zws(k1-1)) + (zws(k2)-zws(k2-1) ) )
                    if (huv > epshu) then
                       if ( jasfer3D == 1 ) then
                          suu(L) =      acl(LL)  * bai(kb1)*( csu(LL)*nod2linx(LL,1,dvxc(k1),dvyc(k1)) + snu(LL)*nod2liny(LL,1,dvxc(k1),dvyc(k1)) ) +    &
                                   (1d0-acl(LL)) * bai(kb2)*( csu(LL)*nod2linx(LL,2,dvxc(k2),dvyc(k2)) + snu(LL)*nod2liny(LL,2,dvxc(k2),dvyc(k2)) )
                       else
                          suu(L) = acl(LL)     *bai(kb1)*( csu(LL)*dvxc(k1) + snu(LL)*dvyc(k1)  ) +  &
                                  (1d0-acl(LL))*bai(kb2)*( csu(LL)*dvxc(k2) + snu(LL)*dvyc(k2)  )
                       endif

                       if (istresstyp == 3) then
                          suu(L) = suu(L)/huv
                       endif
                    endif
                 enddo
             endif
          enddo

           !$OMP END PARALLEL DO

        endif


    endif

    do nw  = 1,mxwalls
       k1  = walls(1,nw)                              ! waterlevel point on the inside
       k3  = walls(2,nw)                              ! first corner
       k4  = walls(3,nw)                              ! second corner
       L1  = walls(4,nw)                              ! link attached to first corner
       L2  = walls(5,nw)                              ! link attached to second corner
       sf  = walls(6,nw)                              ! ustarfactor, ustar=sf*us
       cs  = walls(7,nw)                              ! sux = -cs*ustar
       sn  = walls(8,nw)                              ! suy = -sn*ustar
       wuw = walls(9,nw)                              ! width of wall

       if (irov == 1) then                            ! partial slip
          if (kmx == 0) then
             if ( jasfer3D.eq.1 ) then
                ustar = (cs*nod2wallx(nw,ucx(k1),ucy(k1)) + sn*nod2wally(nw,ucx(k1),ucy(k1)))*sf
             else
                ustar = (cs*ucx(k1) + sn*ucy(k1))*sf
             endif
             walls(16,nw) = ustar
             suxw  = -cs*ustar*abs(ustar)*wuw*bai(k1)
             suyw  = -sn*ustar*abs(ustar)*wuw*bai(k1)
             if (L1 .ne. 0) then
                csl     = csu(L1) ; snl = snu(L1) ; ac1 = walls(10,nw)
                if ( jasfer3D.eq.1 ) then
                   suu(L1) = suu(L1) + (csl*wall2linx(nw,1,suxw,suyw) + snl*wall2liny(nw,1,suxw,suyw))*ac1
                else
                   suu(L1) = suu(L1) + (csl*suxw + snl*suyw)*ac1
                endif
             endif
             if (L2 .ne. 0) then
                csl     = csu(L2) ; snl = snu(L2) ; ac2 = walls(11,nw)
                if ( jasfer3D.eq.1 ) then
                   suu(L2) = suu(L2) + (csl*wall2linx(nw,2,suxw,suyw) + snl*wall2liny(nw,2,suxw,suyw))*ac2
                else
                   suu(L2) = suu(L2) + (csl*suxw + snl*suyw)*ac2
                endif
             endif
          else
             call getkbotktop(k1,kb,kt)
             if ( L1.ne.0 ) call getLbotLtop(L1,Lb1,Lt1)
             if ( L2.ne.0 ) call getLbotLtop(L2,Lb2,Lt2)
             do k = kb, kt
                if ( jasfer3D.eq.1 ) then
                   ustar = (cs*nod2wallx(nw,ucx(k),ucy(k)) + sn*nod2wally(nw,ucx(k),ucy(k)))*sf
                else
                   ustar = (cs*ucx(k) + sn*ucy(k))*sf
                endif
                walls(16,nw) = ustar
                suxw  = -cs*ustar*abs(ustar)*wuw*bai(k1)
                suyw  = -sn*ustar*abs(ustar)*wuw*bai(k1)
                if (L1 .ne. 0) then
                   csl     = csu(L1) ; snl = snu(L1) ; ac1 = walls(10,nw)
                   if ( jasfer3D.eq.1 ) then
                      suu(Lb1+k-kb) = suu(Lb1+k-kb) + (csl*wall2linx(nw,1,suxw,suyw) + snl*wall2liny(nw,1,suxw,suyw))*ac1
                   else
                      suu(Lb1+k-kb) = suu(Lb1+k-kb) + (csl*suxw + snl*suyw)*ac1
                   endif
                endif
                if (L2 .ne. 0) then
                   csl     = csu(L2) ; snl = snu(L2) ; ac2 = walls(11,nw)
                   if ( jasfer3D.eq.1 ) then
                      suu(Lb2+k-kb) = suu(Lb2+k-kb) + (csl*wall2linx(nw,2,suxw,suyw) + snl*wall2liny(nw,2,suxw,suyw))*ac2
                   else
                      suu(Lb2+k-kb) = suu(Lb2+k-kb) + (csl*suxw + snl*suyw)*ac2
                   endif
                endif
             enddo
          endif
       else if (irov == 2) then                      ! no slip
          if ( jasfer3D.eq.1 ) then
             ustar = (cs*nod2wallx(nw,ucx(k1),ucy(k1)) + sn*nod2wally(nw,ucx(k1),ucy(k1)))
          else
             ustar = (cs*ucx(k1) + sn*ucy(k1))          ! component parallel to wall
          endif

          walls(16,nw) = 0d0

          if (javiusp == 1) then
              vicl = viusp(L)
          else
              vicl = vicouv
          endif

          delty  = ba(k1)/wuw                        ! cell area / wall width is distance between internal point and mirror point
          delty  = 0.5d0*delty
          suxw   = -(cs*ustar*vicl/delty)*wuw*bai(k1)
          suyw   = -(sn*ustar*vicl/delty)*wuw*bai(k1)
          if (L1 .ne. 0) then
             csl     = csu(L1) ; snl = snu(L1) ; ac1 = walls(10,nw)
             if ( jasfer3D.eq.1 ) then
                suu(L1) = suu(L1) + (csl*wall2linx(nw,1,suxw,suyw) + snl*wall2liny(nw,1,suxw,suyw))*ac1
             else
                suu(L1) = suu(L1) + (csl*suxw + snl*suyw)*ac1
             endif
          endif
          if (L2 .ne. 0) then
             csl     = csu(L2) ; snl = snu(L2) ; ac2 = walls(11,nw)
             if ( jasfer3D.eq.1 ) then
                suu(L2) = suu(L2) + (csl*wall2linx(nw,2,suxw,suyw) + snl*wall2liny(nw,2,suxw,suyw))*ac2
             else
                suu(L2) = suu(L2) + (csl*suxw + snl*suyw)*ac2
             endif
          endif
       else if (irov == 0) then                     ! free slip
          if ( jasfer3D.eq.1 ) then
             walls(16,nw) = (cs*nod2wallx(nw,ucx(k1),ucy(k1)) + sn*nod2wally(nw,ucx(k1),ucy(k1)))
             walls(16,nw) = cs*ucx(k1) + sn*ucy(k1)
          endif
       endif

    enddo

    if ( izbndpos.eq.0 ) then
       do L = lnxi+1,lnx  ! quick fix for open boundaries
          suu(L) = 2d0*suu(L)
       enddo
    end if

    adve = adve - suu

 endif

 call klok(cpuumod(2)) ; cpuumod(3) = cpuumod(3) + cpuumod(2) - cpuumod(1)


 end subroutine setumod

 subroutine setucxucyucxuucyu()
 use m_flowgeom
 use m_flow
 use m_sobekdfm
 use m_sediment, only: jased, stm_included
 use m_missing
 use m_flowparameters, only: jabarrieradvection
 use m_sferic
 implicit none

 integer          :: L, KK, k1, k2, k, nw, Lb, Lt, LL, nn, n, kt,kb, kbk, k2k
 integer          :: itpbn, newucxq=0
 double precision :: uu, vv, uucx, uucy, wcxu, wcyu, cs, sn, adx, ac1, ac2, wuw, hdx, hul, dzz, uin, duxdn, duydn
 double precision :: dischcorrection
 double precision :: uinx, uiny

 double precision, external :: nod2linx, nod2liny
 double precision, external :: lin2nodx, lin2nody

 ucxq = 0d0 ; ucyq = 0d0           ! zero arrays
 ucx = 0d0 ; ucy = 0d0

 if (kmx < 1) then                                   ! original 2D coding

    do L = 1,lnx1D
       if (u1(L) .ne. 0d0 .and. kcu(L) .ne. 3) then  ! link flows ; in 2D, the loop is split to save kcu check in 2D
          k1 = ln(1,L) ; k2 = ln(2,L)
          wcxu      = wcx1(L)*u1(L)
          ucx  (k1) = ucx  (k1) + wcxu
          ucxq (k1) = ucxq (k1) + wcxu*hu(L)
          wcyu      = wcy1(L)*u1(L)
          ucy  (k1) = ucy  (k1) + wcyu
          ucyq (k1) = ucyq (k1) + wcyu*hu(L)
          wcxu      = wcx2(L)*u1(L)
          ucx  (k2) = ucx  (k2) + wcxu
          ucxq (k2) = ucxq (k2) + wcxu*hu(L)
          wcyu      = wcy2(L)*u1(L)
          ucy  (k2) = ucy  (k2) + wcyu
          ucyq (k2) = ucyq (k2) + wcyu*hu(L)
       endif
    enddo

    do L = lnx1D + 1,lnx
       if (jabarrieradvection == 3) then
          if ( struclink(L) == 1 ) cycle
       endif
       if (u1(L) .ne. 0d0) then                      ! link flows
          k1 = ln(1,L) ; k2 = ln(2,L)
          wcxu      = wcx1(L)*u1(L)
          ucx  (k1) = ucx  (k1) + wcxu
          ucxq (k1) = ucxq (k1) + wcxu*hu(L)
          wcyu      = wcy1(L)*u1(L)
          ucy  (k1) = ucy  (k1) + wcyu
          ucyq (k1) = ucyq (k1) + wcyu*hu(L)
          wcxu      = wcx2(L)*u1(L)
          ucx  (k2) = ucx  (k2) + wcxu
          ucxq (k2) = ucxq (k2) + wcxu*hu(L)
          wcyu      = wcy2(L)*u1(L)
          ucy  (k2) = ucy  (k2) + wcyu
          ucyq (k2) = ucyq (k2) + wcyu*hu(L)
       endif
    enddo

    ! if (jased > 0 .or. ti_waq > 0) then !TODO: AvD: are we going to keep all these tau-components, or average at cell center directly?
          !taucx(ln(1,L)) = taucx(ln(1,L)) + wcx1(L)*tauu(L)
          !taucy(ln(1,L)) = taucy(ln(1,L)) + wcy1(L)*tauu(L)
          !taucx(ln(2,L)) = taucx(ln(2,L)) + wcx2(L)*tauu(L)
          !taucx(ln(2,L)) = taucx(ln(2,L)) + wcy2(L)*tauu(L)
    ! endif

 else
    do LL = 1,lnx
       Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
       do L = Lb, Lt
          if (u1(L) .ne. 0d0) then                         ! link flows
             k1 = ln0(1,L)                                 ! use ln0 in reconstruction and in computing ucxu, use ln when fluxing
             k2 = ln0(2,L)

             huL = hu(L)
             if (L>Lbot(LL)) then
                huL   = huL - hu(L-1)
             endif
             ucx (k1) = ucx (k1) + wcx1(LL)*u1(L)
             ucxq(k1) = ucxq(k1) + wcx1(LL)*u1(L)*huL
             ucy (k1) = ucy (k1) + wcy1(LL)*u1(L)
             ucyq(k1) = ucyq(k1) + wcy1(LL)*u1(L)*huL
             ucx (k2) = ucx (k2) + wcx2(LL)*u1(L)
             ucxq(k2) = ucxq(k2) + wcx2(LL)*u1(L)*huL
             ucy (k2) = ucy (k2) + wcy2(LL)*u1(L)
             ucyq(k2) = ucyq(k2) + wcy2(LL)*u1(L)*huL

          endif
       enddo

       if (jazlayercenterbedvel == 1) then ! copy bed velocity down
           do k1 = kbot(ln0(1,LL)), ln0(1,Lb) - 1
              ucx(k1) = ucx(k1) + wcx1(LL)*u1(Lb)
              ucy(k1) = ucy(k1) + wcy1(LL)*u1(Lb)
           enddo
           do k2 = kbot(ln0(2,LL)), ln0(2,Lb) - 1
              ucx(k2) = ucx(k2) + wcx2(LL)*u1(Lb)
              ucy(k2) = ucy(k2) + wcy2(LL)*u1(Lb)
           enddo
       endif

    enddo

 endif

 if (kmx < 1) then ! original 2D coding
    !$OMP PARALLEL DO           &
    !$OMP PRIVATE(k)
    do k = 1,ndxi
       if (hs(k) > 0d0)  then
          ucxq(k) = ucxq(k)/hs(k)
          ucyq(k) = ucyq(k)/hs(k)
          if (iperot == 2) then
             ucx (k) = ucxq(k)
             ucy (k) = ucyq(k)
          endif
       endif
    enddo
    !$OMP END PARALLEL DO
 else
    do nn = 1,ndxi
       if (hs(nn) > 0d0)  then
          kb = kbot(nn)
          kt = ktop(nn)
          ucxq(nn) = sum(ucxq(kb:kt)) / hs(nn) ! Depth-averaged cell center velocity in 3D, based on ucxq
          ucyq(nn) = sum(ucyq(kb:kt)) / hs(nn)
          do k = kb,kt
             dzz = zws(k) - zws(k-1)
             if (dzz > 0d0) then
                ucxq(k) = ucxq(k)/dzz
                ucyq(k) = ucyq(k)/dzz
             endif
             if (iperot == 2) then
                ucx(k) = ucxq(k)
                ucy(k) = ucyq(k)
             endif
          enddo
       endif
    enddo

 endif

 do n  = 1, nbndz                                     ! waterlevel boundaries
    kb = kbndz(1,n)
    k2 = kbndz(2,n)
    LL = kbndz(3,n)
    itpbn = kbndz(4,n)
    cs = csu(LL) ; sn = snu(LL)
    if (kmx == 0) then
       if (hs(kb) > epshs)  then
          if ( jacstbnd.eq.0 .and. itpbn.ne.2 ) then    ! Neumann: always
             if (jasfer3D == 1) then
                uin     = nod2linx(LL,2,ucx(k2),ucy(k2))*cs + nod2liny(LL,2,ucx(k2),ucy(k2))*sn
                ucx(kb) = uin*lin2nodx(LL,1,cs,sn)
                ucy(kb) = uin*lin2nody(LL,1,cs,sn)
                uin      = nod2linx(LL,2,ucxq(k2),ucyq(k2))*cs + nod2liny(LL,2,ucxq(k2),ucyq(k2))*sn
                ucxq(kb) = uin*lin2nodx(LL,1,cs,sn)
                ucyq(kb) = uin*lin2nody(LL,1,cs,sn)
             else
                uin     = ucx(k2)*cs + ucy(k2)*sn
                ucx(kb) = uin*cs
                ucy(kb) = uin*sn
                uin     = ucxq(k2)*cs + ucyq(k2)*sn
                ucxq(kb) = uin*cs
                ucyq(kb) = uin*sn
             end if
          else
             if (jasfer3D == 1) then
                uinx    = nod2linx(LL,2,ucx(k2),ucy(k2))
                uiny    = nod2liny(LL,2,ucx(k2),ucy(k2))
                ucx(kb) = lin2nodx(LL,1,uinx,uiny)
                ucy(kb) = lin2nody(LL,1,uinx,uiny)
                uinx    = nod2linx(LL,2,ucxq(k2),ucyq(k2))
                uiny    = nod2liny(LL,2,ucxq(k2),ucyq(k2))
                ucxq(kb) = lin2nodx(LL,1,uinx,uiny)
                ucyq(kb) = lin2nody(LL,1,uinx,uiny)
             else
                ucx(kb) = ucx(k2)
                ucy(kb) = ucy(k2)
                ucxq(kb) = ucxq(k2)
                ucyq(kb) = ucyq(k2)
             endif
          end if
          if (jased > 0 .and. stm_included) then
             dischcorrection = hs(k2) / hs(kb)
             !ucx(kb)  = ucx(kb)  * dischcorrection
             !ucy(kb)  = ucy(kb)  * dischcorrection
             ucxq(kb) = ucxq(kb) * dischcorrection
             ucyq(kb) = ucyq(kb) * dischcorrection
          endif
       endif
    else
       call getLbotLtop(LL,Lb,Lt)
       do L = Lb, Lt
          kbk = ln(1,L) ; k2k = ln(2,L)
          if ( jacstbnd.eq.0 .and. itpbn.ne.2 ) then
             if (jasfer3D == 1) then
                uin = nod2linx(LL,2,ucx(k2k),ucy(k2k))*cs + nod2liny(LL,2,ucx(k2k),ucy(k2k))*sn
                ucx(kbk) = uin*lin2nodx(LL,1,cs,sn)
                ucy(kbk) = uin*lin2nody(LL,1,cs,sn)
                ! Nabi: uin = nod2linx(LL,2,ucxq(k2k),ucyq(k2k))*cs + nod2liny(LL,2,ucxq(k2k),ucyq(k2k))*sn
                ucxq(kbk) = uin*lin2nodx(LL,1,cs,sn)
                ucyq(kbk) = uin*lin2nody(LL,1,cs,sn)
             else
                uin = ucx(k2k)*cs + ucy(k2k)*sn
                ucx(kbk) = uin*cs
                ucy(kbk) = uin*sn
                ucxq(kbk) = uin*cs ; ucyq(kbk) = uin*sn
             end if
          else
             if (jasfer3D == 1) then
                uinx     = nod2linx(LL,2,ucx(k2k),ucy(k2k))
                uiny     = nod2liny(LL,2,ucx(k2k),ucy(k2k))
                ucx(kbk) = lin2nodx(LL,1,uinx,uiny)
                ucy(kbk) = lin2nody(LL,1,uinx,uiny)
                uinx     = nod2linx(LL,2,ucxq(k2k),ucyq(k2k))
                uiny     = nod2liny(LL,2,ucxq(k2k),ucyq(k2k))
                ucxq(kbk) = lin2nodx(LL,1,uinx,uiny)
                ucyq(kbk) = lin2nody(LL,1,uinx,uiny)
             else
                ucx(kbk) = ucx(k2k)
                ucy(kbk) = ucy(k2k)
                ucxq(kbk) = ucxq(k2k)
                ucyq(kbk) = ucyq(k2k)
             end if
          end if
       enddo
    endif
 enddo

 if (jaZerozbndinflowadvection == 1) then
    do n  = 1, nbndz                                      ! on waterlevel boundaries put inflow advection velocity to 0
       LL = kbndz(3,n)
       do L  = Lbot(LL), Ltop(LL)
          k1 = ln(1,L)
          if (u1(LL) > 0) then
             ucx(k1) = 0d0 ; ucy(k1) = 0d0
          endif
       enddo
    enddo
 else if (jaZerozbndinflowadvection == 2) then
    do n  = 1, nbndz                                      ! on waterlevel boundaries put all advection velocity to 0
       LL = kbndz(3,n)
       do L  = Lbot(LL), Ltop(LL)
          k1 = ln(1,L)
          ucx(k1) = 0d0 ; ucy(k1) = 0d0
       enddo
    enddo
 endif

 do n  = 1,nbndu                                      ! velocity boundaries
    kb = kbndu(1,n)
    k2 = kbndu(2,n)
    LL = kbndu(3,n)
    cs = csu(LL) ; sn = snu(LL)
    if (kmx == 0) then
       if (hs(kb) > epshs)  then
          if ( jacstbnd.eq.0 ) then
             if (jasfer3D == 1) then
                uin     = nod2linx(LL,2,ucx(k2),ucy(k2))*cs + nod2liny(LL,2,ucx(k2),ucy(k2))*sn
                ucx(kb) = uin*lin2nodx(LL,1,cs,sn)
                ucy(kb) = uin*lin2nody(LL,1,cs,sn)

                uin     = nod2linx(LL,2,ucxq(k2),ucyq(k2))*cs + nod2liny(LL,2,ucxq(k2),ucyq(k2))*sn
                ucxq(kb) = uin*lin2nodx(LL,1,cs,sn)
                ucyq(kb) = uin*lin2nody(LL,1,cs,sn)
             else
                uin     = ucx(k2)*cs + ucy(k2)*sn
                ucx(kb) = uin*cs
                ucy(kb) = uin*sn
                uin      = ucxq(k2)*cs + ucyq(k2)*sn
                ucxq(kb) = uin*cs
                ucyq(kb) = uin*sn
             end if
          else
             if (jasfer3D == 1) then
                uinx    = nod2linx(LL,2,ucx(k2),ucy(k2))
                uiny    = nod2liny(LL,2,ucx(k2),ucy(k2))
                ucx(kb) = lin2nodx(LL,1,uinx,uiny)
                ucy(kb) = lin2nody(LL,1,uinx,uiny)

                uinx    = nod2linx(LL,2,ucxq(k2),ucyq(k2))
                uiny    = nod2liny(LL,2,ucxq(k2),ucyq(k2))
                ucxq(kb) = lin2nodx(LL,1,uinx,uiny)
                ucyq(kb) = lin2nody(LL,1,uinx,uiny)
             else
                ucx(kb) = ucx(k2)
                ucy(kb) = ucy(k2)
                ucxq(kb) = ucxq(k2)
                ucyq(kb) = ucyq(k2)
             end if
          end if
          if (jased > 0 .and. stm_included) then
             dischcorrection = hs(k2) / hs(kb)
             !ucx(kb)  = ucx(kb)  * dischcorrection
             !ucy(kb)  = ucy(kb)  * dischcorrection
             ucxq(kb) = ucxq(kb) * dischcorrection
             ucyq(kb) = ucyq(kb) * dischcorrection
          endif
       endif
    else
       do k   = 1, kmxL(LL)
          kbk = kbot(kb) - 1 + min(k,kmxn(kb))
          k2k = kbot(k2) - 1 + min(k,kmxn(k2))
          if ( jacstbnd.eq.0 ) then
             if (jasfer3D == 1) then
                uin     = nod2linx(LL,2,ucx(k2k),ucy(k2k))*cs + nod2liny(LL,2,ucx(k2k),ucy(k2k))*sn
                ucx(kbk) = uin*lin2nodx(LL,1,cs,sn)
                ucy(kbk) = uin*lin2nody(LL,1,cs,sn)
                ucxq(kbk) = uin*lin2nodx(LL,1,cs,sn)
                ucyq(kbk) = uin*lin2nody(LL,1,cs,sn)
             else
                uin = ucx(k2k)*cs + ucy(k2k)*sn
                ucx(kbk) = uin*cs
                ucy(kbk) = uin*sn
                ucxq(kbk) = uin*cs
                ucyq(kbk) = uin*sn
             end if
          else
             if (jasfer3D == 1) then
                uinx     = nod2linx(LL,2,ucx(k2k),ucy(k2k))
                uiny     = nod2liny(LL,2,ucx(k2k),ucy(k2k))
                ucx(kbk) = lin2nodx(LL,1,uinx,uiny)
                ucy(kbk) = lin2nody(LL,1,uinx,uiny)
                uinx     = nod2linx(LL,2,ucxq(k2k),ucyq(k2k))
                uiny     = nod2liny(LL,2,ucxq(k2k),ucyq(k2k))
                ucxq(kbk) = lin2nodx(LL,1,uinx,uiny)
                ucyq(kbk) = lin2nody(LL,1,uinx,uiny)
             else
                ucx(kbk) = ucx(k2k)
                ucy(kbk) = ucy(k2k)
                ucxq(kbk) = ucxq(k2k)
                ucyq(kbk) = ucyq(k2k)
             end if
          end if
       enddo
    endif
 enddo

 do n  = 1, nbndt                               ! tangential velocity boundaries, override other types
    kb = kbndt(1,n)
    k2 = kbndt(2,n)
    LL = kbndt(3,n)
    cs = csu(LL) ; sn = snu(LL)
    call getLbotLtop(LL,Lb,Lt)
    do L = Lb, Lt
       kbk  = ln(1,L)
       kk   = kmxd*(n-1)+L-Lb+1
       uu   = u0(L) ; vv = zbndt(kk) ! v(L)
       uucx = uu*cs - vv*sn
       uucy = uu*sn + vv*cs
       if (jasfer3D == 1) then
          ucx(kbk) = lin2nodx(LL,1,uucx,uucy)
          ucy(kbk) = lin2nody(LL,1,uucx,uucy)
          ucxq(kbk) = ucx(kbk)
          ucyq(kbk) = ucy(kbk)
       else
          ucx(kbk) = uucx
          ucy(kbk) = uucy
          ucxq(kbk) = ucx(kbk)
          ucyq(kbk) = ucy(kbk)
       end if
    enddo
 enddo

 if (zbnduxyval .ne. dmiss) then
     zbnduxy(1) = zbnduxyval
 endif

 do n  = 1, nbnduxy        ! do3d                     ! uxuy velocity boundaries, override other types
    kb = kbnduxy(1,n)
    LL = kbnduxy(3,n)
    call getLbotLtop(LL,Lb,Lt)
    do L = Lb, Lt
       kbk = ln(1,L)
       kk  = kmxd*(n-1)+L-Lb+1
       if (jasfer3D == 1) then
          ucx(kbk) = lin2nodx(LL,1,zbnduxy(2*kk-1),zbnduxy(2*kk))
          ucy(kbk) = lin2nody(LL,1,zbnduxy(2*kk-1),zbnduxy(2*kk))
          ucxq(kbk) = ucx(kbk)
          ucyq(kbk) = ucy(kbk)
       else
          ucx(kbk) = zbnduxy(2*kk-1)
          ucy(kbk) = zbnduxy(2*kk)
          ucxq(kbk) = ucx(kbk)
          ucyq(kbk) = ucy(kbk)
       end if
    enddo
 enddo

 do n  = 1, nbndn                                     ! normal velocity boundaries, override other types
    kb = kbndn(1,n)
    k2 = kbndn(2,n)
    LL = kbndn(3,n)
    cs = csu(LL) ; sn = snu(LL)
    call getLbotLtop(LL,Lb,Lt)
    do L = Lb, Lt
       kbk  = ln(1,L)
       kk   = kmxd*(n-1)+L-Lb+1
       uu   = zbndn(kk) ; vv = 0d0
       uucx = uu*cs - vv*sn                   !
       uucy = uu*sn + vv*cs
       if (jasfer3D == 1) then
          ucx(kbk) = lin2nodx(LL,1,uucx,uucy)
          ucy(kbk) = lin2nody(LL,1,uucx,uucy)
          ucxq(kbk) = ucx(kbk)
          ucyq(kbk) = ucy(kbk)
       else
          ucx(kbk) = uucx
          ucy(kbk) = uucy
          ucxq(kbk) = ucx(kbk)
          ucyq(kbk) = ucy(kbk)
       end if
    enddo
 enddo

 newucxq = 0
 if (newucxq == 1) then  ! test later, see testcase willem
 if (jasfer3D == 1) then  ! boundary points ucxq, ucyq, independend of bnd types
    do L = lnxi+1, lnx
       kb = ln(1,L) ; k2 = ln(2,L)
       do LL = Lbot(L), Ltop(L)
          uinx     = nod2linx(LL,2,ucxq(k2),ucyq(k2))
          uiny     = nod2liny(LL,2,ucxq(k2),ucyq(k2))
          ucxq(kb) = lin2nodx(LL,1,uinx,uiny)
          ucyq(kb) = lin2nody(LL,1,uinx,uiny)
       enddo
    enddo
 else
    do L = lnxi+1, lnx
       kb = ln(1,L) ; k2 = ln(2,L)
       do LL = Lbot(L), Ltop(L)
          ucxq(kb) = ucxq(k2)
          ucyq(kb) = ucyq(k2)
       enddo
    enddo
 endif
 endif



   do n=1,nbnd1d2d
       kb      = kbnd1d2d(1,n)
       k2      = kbnd1d2d(2,n)
       LL      = kbnd1d2d(3,n)

       if (kmx == 0) then     ! 2D
          if (jasfer3D == 1) then
             uinx = nod2linx(LL,2,ucx(k2),ucy(k2))
             uiny = nod2liny(LL,2,ucx(k2),ucy(k2))
             ucx(kb) = lin2nodx(LL,1,uinx,uiny)
             ucy(kb) = lin2nody(LL,1,uinx,uiny)
             ucxq(kb) = ucx(kb)
             ucyq(kb) = ucy(kb)
          else
             ucx(kb) = ucx(k2)
             ucy(kb) = ucy(k2)
             ucxq(kb) = ucx(kb)
             ucyq(kb) = ucy(kb)
          end if
       else     ! 3D

       endif
   end do

 if (limtypmom == 6) then

    ducxdx = 0d0; ducxdy = 0d0
    ducydx = 0d0; ducydy = 0d0
    do LL = 1,lnx
       Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
       do L = Lb, Lt
          k1 = ln(1,L)
          k2 = ln(2,L)
          if (jasfer3D == 1) then
             duxdn = dxi(LL)*(nod2linx(LL,2,ucx(k2),ucy(k2))-nod2linx(LL,1,ucx(k1),ucy(k1)))
          else
             duxdn = dxi(LL)*(ucx(k2) - ucx(k1))
          endif
          ducxdx(k1) = ducxdx(k1) + wcx1(LL)*duxdn
          ducxdy(k1) = ducxdy(k1) + wcy1(LL)*duxdn
          ducxdx(k2) = ducxdx(k2) + wcx2(LL)*duxdn
          ducxdy(k2) = ducxdy(k2) + wcy2(LL)*duxdn

          if (jasfer3D == 1) then
             duydn = dxi(LL)*(nod2liny(LL,2,ucx(k2),ucy(k2))-nod2liny(LL,1,ucx(k1),ucy(k1)))
          else
             duydn = dxi(LL)*(ucy(k2) - ucy(k1))
          endif
          ducydx(k1) = ducydx(k1) + wcx1(LL)*duydn
          ducydy(k1) = ducydy(k1) + wcy1(LL)*duydn
          ducydx(k2) = ducydx(k2) + wcx2(LL)*duydn
          ducydy(k2) = ducydy(k2) + wcy2(LL)*duydn
       enddo
    enddo

    !do nw  = 1,mxwalls   ! to be finished later zz
    !   csw = walls(7,nw)
    !   snw = walls(8,nw)
    !   ducdn = 2d0*(ucx(k1)*csw +
    !   ducxdx(k1) = ducxdx(k1) + *duxdn
    !enddo

 endif

 if (kmx < 1) then

    if (jasfer3D == 1) then
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(L)
       do L = 1,lnx
          if (qa(L) > 0) then                               ! set upwind ucxu, ucyu  on links
             ucxu(L) = nod2linx(L,1,ucx(ln(1,L)),ucy(ln(1,L)))
             ucyu(L) = nod2liny(L,1,ucx(ln(1,L)),ucy(ln(1,L)))
          else if (qa(L) < 0) then
             ucxu(L) = nod2linx(L,2,ucx(ln(2,L)),ucy(ln(2,L)))
             ucyu(L) = nod2liny(L,2,ucx(ln(2,L)),ucy(ln(2,L)))
          else
             ucxu(L) = 0d0
             ucyu(L) = 0d0
          endif
       enddo
       !$OMP END PARALLEL DO
    else
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(L)
       do L = 1,lnx
          if (qa(L) > 0) then                               ! set upwind ucxu, ucyu  on links
             ucxu(L) = ucx(ln(1,L))
             ucyu(L) = ucy(ln(1,L))
          else if (qa(L) < 0) then
             ucxu(L) = ucx(ln(2,L))
             ucyu(L) = ucy(ln(2,L))
          else
             ucxu(L) = 0d0
             ucyu(L) = 0d0
          endif
       enddo
       !$OMP END PARALLEL DO
    endif

 else

    if (jasfer3D == 1) then
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(LL,L,Lb,Lt)
       do LL = 1,lnx
          call getLbotLtop(LL,Lb,Lt)
          do L = Lb,Lt
             if (qa(L) > 0) then                               ! set upwind ucxu, ucyu  on links
                ucxu(L) = nod2linx(LL,1,ucx(ln0(1,L)),ucy(ln0(1,L)))
                ucyu(L) = nod2liny(LL,1,ucx(ln0(1,L)),ucy(ln0(1,L)))
                if (jarhoxu > 0) then
                   ucxu(L) = ucxu(L)*rho(ln(1,L))
                   ucyu(L) = ucyu(L)*rho(ln(1,L))
                endif
             else if (qa(L) < 0) then
                ucxu(L) = nod2linx(LL,2,ucx(ln0(2,L)),ucy(ln0(2,L)))
                ucyu(L) = nod2liny(LL,2,ucx(ln0(2,L)),ucy(ln0(2,L)))
                if (jarhoxu > 0) then
                   ucxu(L) = ucxu(L)*rho(ln(2,L))
                   ucyu(L) = ucyu(L)*rho(ln(2,L))
                endif
             else
                ucxu(L) = 0d0
                ucyu(L) = 0d0
             endif
          enddo
       enddo
       !$OMP END PARALLEL DO

    else

       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(LL,L,Lb,Lt)
       do LL = 1,lnx
          call getLbotLtop(LL,Lb,Lt)
          do L = Lb,Lt
             if (qa(L) > 0) then                               ! set upwind ucxu, ucyu  on links
                ucxu(L) = ucx(ln0(1,L))
                ucyu(L) = ucy(ln0(1,L))
                if (jarhoxu > 0) then
                   ucxu(L) = ucxu(L)*rho(ln(1,L))
                   ucyu(L) = ucyu(L)*rho(ln(1,L))
                endif
             else if (qa(L) < 0) then
                ucxu(L) = ucx(ln0(2,L))
                ucyu(L) = ucy(ln0(2,L))
                if (jarhoxu > 0) then
                   ucxu(L) = ucxu(L)*rho(ln(2,L))
                   ucyu(L) = ucyu(L)*rho(ln(2,L))
                endif
             else
                ucxu(L) = 0d0
                ucyu(L) = 0d0
             endif
          enddo
       enddo
       !$OMP END PARALLEL DO

    endif

 endif

end subroutine setucxucyucxuucyu



 subroutine setumodnew(jazws0)                          ! set cell center Perot velocities at nodes
                                                     ! set Perot based friction velocities umod at u point
                                                     ! set tangential velocities at u point
                                                     ! set velocity gradient at u point
                                                     ! set corner based Perot velocities

 use m_flow
 use m_flowgeom
 use m_flowtimes
 use m_sferic
 use m_wind
 use m_ship
 use m_missing
 use m_xbeach_data, only : DR, roller, swave
 use unstruc_model, only : md_restartfile
 implicit none

 integer,intent(in):: jazws0
 ! locals
 integer           :: L, LL, k, k1, k2, k12, k3, k4, kb, n, n1, n2, nn, ks, ierr
 double precision  :: ux, uy                         ! centre or node velocity x- and y components
 double precision  :: hsi, humx                      ! inverse centre depth, max depth u points
 double precision  :: qwd,qwd1,qwd2                  !
 double precision  :: qucx, qucy
 double precision  :: duxdn, duydn, duxdt, duydt     ! normal and tangential global ux,uy gradients
 double precision  :: vicl, c11, c12, c22, wudx, bai2, sxx, syy, snn

 double precision  :: sxw, syw, sf, ac1, ac2, csl, snl, wuw, ustar, suxw, suyw, uin, suxL, suyL
 double precision  :: cs, sn, dxi2, dyi2, sucheck
 double precision  :: chezy2, hhu, rt, hmin, hs1, hs2
 double precision  :: uu,vv,uucx,uucy, ff, ds, hup, fcor, vcor, fcor1, fcor2, fvcor, fvcorab
 double precision  :: dundn, dutdn, dundt, dutdt, shearvar, delty, vksag6, Cz
 double precision  :: umodLL, volu, hul, dzz, adx, hdx, huv, qL, wcxu, wcyu
 double precision, allocatable:: u1_tmp(:), vluban(:)

 integer           :: nw, L1, L2, kbk, k2k, Ld, Lu, kt, Lb, Lt, Lb1, Lt1, Lb2, Lt2, kb1, kb2, ntmp, m

 double precision  :: depumin  ! external
 double precision  :: horvic   ! external
 double precision  :: horvic3  ! external

 double precision  :: DRL, nuhroller

 double precision  :: dxiAu, vicc, vlban, fcLL

 integer :: ini = 0

 integer :: ndraw
 COMMON /DRAWTHIS/ ndraw(50)

 double precision, external :: nod2linx, nod2liny, lin2nodx, lin2nody, cor2linx, cor2liny
 double precision, external :: nod2wallx, nod2wally, wall2linx, wall2liny

 !if (jased > 0) then
 !   taucx = 0d0; taucy = 0d0
 !endif

 call klok(cpuumod(1))                               ! Perot velocities
 if(jazws0==1 .and. len_trim(md_restartfile)>0) then
   ! This is the moment after the restart file is read and before the first output of the inital info.
   ! At this moment, u0 is used to compute the cell-center velocities. And hs has been computed in flow_initimestep, using s0.
    ntmp = size(u1)
    allocate(u1_tmp(ntmp))
    u1_tmp = u1
    u1     = u0
    hs     = s0 - bl
    call setucxucyucxuucyunew() !reconstruct cell-center velocities
    u1     = u1_tmp
    deallocate(u1_tmp)

    dti = 1d0/dts
 else
    call setucxucyucxuucyunew()
 endif
 
 !$OMP PARALLEL DO                                  &
 !$OMP PRIVATE(LL,Lb,Lt,cs,sn,L,k1,k2)
 do LL   = lnx1D+1,lnx             ! set tangential velocities v
    if (hu(LL) == 0) cycle 
 
    call getLbotLtop(LL,Lb,Lt)
    cs = csu(LL)  ; sn = snu(LL) ; v(LL) = 0d0
      
    do L = Lb,Lt
       k1 = ln(1,L) ; k2 = ln(2,L)
 
       if ( jasfer3D == 1 ) then
          v(L) =      acL(LL) *(-sn*nod2linx(LL,1,ucx(k1),ucy(k1)) + cs*nod2liny(LL,1,ucx(k1),ucy(k1))) +  &
                 (1d0-acL(LL))*(-sn*nod2linx(LL,2,ucx(k2),ucy(k2)) + cs*nod2liny(LL,2,ucx(k2),ucy(k2)))
       else
          v(L) =      acl(LL) *(-sn*ucx(k1) + cs*ucy(k1) ) + &
                 (1d0-acl(LL))*(-sn*ucx(k2) + cs*ucy(k2) )
       endif
       if (kmx > 0) then
          v(LL) = v(LL) + v(L)*Au(L) ! hk: activate when needed
       endif
    enddo
    if (kmx > 0) then
       if ( Au(LL) .gt. 0d0 ) then ! hk: activate if needed
           v(LL) = v(LL) / Au(LL)
       endif
    endif
 enddo 
 !$OMP END PARALLEL DO

 if (icorio > 0 .and. icorio < 40) then   
    fcor1 = fcorio ; fcor2 = fcorio 
    !x$OMP PARALLEL DO                           &
    !x$OMP PRIVATE(L,LL,Lb,Lt,k1,k2,cs,sn,hs1,hs2,fcor,fcor1,fcor2,fvcor,vcor,volu,hmin)
    do LL   = lnx1D+1,lnx
       if (hu(LL) == 0) cycle 
       n1 = ln(1,LL) ; n2 = ln(2,LL)     
       hmin = min( hs(n1), hs(n2) )
   
       call getLbotLtop(LL,Lb,Lt)
       cs = csu(LL)  ; sn = snu(LL) ; v(LL) = 0d0
         
       if (icorio > 0 .and. jsferic > 0) then 
           if (icorio >= 4 .and. icorio <= 6) then 
               fcor1 = fcori(LL) ; fcor2 = fcor1      ! defined at u-point 
           else 
               fcor1 = fcori(n1) ; fcor2 = fcori(n2)  ! defined at zeta-points 
           endif
       endif
   
       do L = Lb,Lt
          k1 = ln(1,L) ; k2 = ln(2,L)
   
          if (icorio > 0) then
             fvcor = 0d0 
             ! set u tangential
             if (icorio <= 20) then ! Olga types
                if ( jasfer3D == 1 ) then
                    fvcor =      acL(LL) *(-sn*nod2linx(LL,1,ucxq(k1),ucyq(k1)) + cs*nod2liny(LL,1,ucxq(k1),ucyq(k1)))*fcor1 +  &
                            (1d0-acL(LL))*(-sn*nod2linx(LL,2,ucxq(k2),ucyq(k2)) + cs*nod2liny(LL,2,ucxq(k2),ucyq(k2)))*fcor2
                else
                    fvcor =      acl(LL) *(-sn*ucxq(k1) + cs*ucyq(k1) )*fcor1 + &    
                            (1d0-acl(LL))*(-sn*ucxq(k2) + cs*ucyq(k2) )*fcor2
                endif
             else                                      ! David types 
                if (icorio <= 26) then                 ! hs/hu 
                   hs1 = hs(n1) ; hs2 = hs(n2) 
                   if (kmx > 0) then
                      if ( mod(icorio,2) .ne. 0)  then ! odd nrs get local k-weighting 
                         hs1 = zws(k1) - zws(k1-1) ; hs2 = zws(k2) - zws(k2-1)
                      endif
                   endif
                   huv = hu(L)
                else if (icorio <= 28) then               ! ahus/ahu 
                   hs1 = hus(n1)       ; hs2 = hus(n2) 
                   if (kmx > 0) then
                      if ( mod(icorio,2) .ne. 0)  then ! odd nrs get local k-weighting 
                         hs1 = hus(k1) ; hs2 = hus(k2) 
                      endif
                   endif
                   huv = acl(LL)*hs1 + (1d0-acl(LL))*hs2  
                else if (icorio <= 30) then               ! like advec33 
                   if ( mod(icorio,2) .ne. 0)  then    ! odd nrs get local k-weighting 
                        hs1 = vol1(k1) ; hs2 = vol1(k2) 
                   else 
                        hs1 = vol1(n1) ; hs2 = vol1(n2)  
                   endif
                   huv = acl(LL)*hs1 + (1d0-acl(LL))*hs2  
                endif
   
                if (huv > 0) then 
                   if ( jasfer3D == 1 ) then
                       fvcor =     acL(LL) *(-sn*nod2linx(LL,1,ucxq(k1),ucyq(k1)) + cs*nod2liny(LL,1,ucxq(k1),ucyq(k1)))*fcor1*hs1 +  &
                              (1d0-acL(LL))*(-sn*nod2linx(LL,2,ucxq(k2),ucyq(k2)) + cs*nod2liny(LL,2,ucxq(k2),ucyq(k2)))*fcor2*hs2 
                   else
                       fvcor =     acl(LL) *(-sn*ucxq(k1) + cs*ucyq(k1) )*fcor1*hs1 + &    
                              (1d0-acl(LL))*(-sn*ucxq(k2) + cs*ucyq(k2) )*fcor2*hs2
                   endif
                   fvcor = fvcor/ huv 
                endif 
   
             endif 
   
             if (trshcorio > 0) then
                if ( hmin < trshcorio) then
                    fvcor = fvcor*hmin/trshcorio
                endif
             endif
             adve(L) = adve(L) - fvcor
   
             if (Corioadamsbashfordfac > 0d0) then 
                if (fvcoro(L) .ne. 0d0) then 
                   adve(L) = adve(L) - Corioadamsbashfordfac* (  fvcor - fvcoro(L)  )
                endif  
                fvcoro(L) = fvcor 
             endif 
          endif
   
       enddo
   
       if (icorio > 0 .and. Corioadamsbashfordfac > 0d0) then 
          fvcoro( Lt+1:Lb+kmxL(LL)-1 ) = 0d0  
       endif
  
    enddo
 
 else if (icorio == 45) then  

    !do n = 1, size(LLkkk,2)
    !   L1  = LLkkk(1,n) 
    !   L2  = LLkkk(2,n) 
    !   k1  = LLkkk(3,n) 
    !   k2  = LLkkk(4,n) 
    !   k3  = LLkkk(5,n) 
    !   fcLL =  fcorio*(-csu(L1)*snu(L2) + snu(L1)*csu(L2)) 
    !   adve(L1) = adve(L1) + 0.25*fcLL   
    !   adve(L2) = adve(L2) - 0.25*fcLL  
    !enddo 

 else if (icorio >= 65) then  

    if (.not. allocated(vluban) ) then 
       allocate(vluban(Lnkx)) 
    endif

    vluban = 0
    do m   = 1, mxban                                     ! bz based on netnodes area
       k   = nban(1,m)
       n   = nban(2,m)
       L1  = nban(3,m)
       L2  = nban(4,m)
       if (L1 > 0 .and. L2 > 0) then 
          vlban       = banf(m)*hs(k)
          if (icorio == 66) then 
             hs1      = acl(L1)*hs(ln(1,L1)) + (1d0-acl(L1))*hs(ln(2,L1))   
             hs2      = acl(L2)*hs(ln(1,L2)) + (1d0-acl(L2))*hs(ln(2,L2))   
             vlban    = 0.5d0*(hs1+hs2) 
          endif
          fcLL        = vlban*fcorio*(-csu(L1)*snu(L2) + snu(L1)*csu(L2))  ! tangential L1 L2 
          adve(L1)    = adve(L1) + u1(L2)*fcLL      
          adve(L2)    = adve(L2) - u1(L1)*fcLL  
          vluban(L1)  = vluban(L1)  + vlban     
          vluban(L2)  = vluban(L2)  + vlban     
       endif
    enddo 
    do L = 1,Lnx
       adve(L) = adve(L) / vluban(L) 
    enddo
 endif


ihorvic = 0
if (vicouv > 0 .or. javiusp == 1 .or. Smagorinsky > 0 .or. Elder > 0 .or. kmx > 0) then
   ihorvic = 1
endif
if (ihorvic > 0 .or. jaconveyance2D>=3 .or. ndraw(29) == 37) then
   call setcornervelocities()                        ! must be called after ucx, ucy have been set
endif
if (vicouv < 0d0) then
   ihorvic = 0
endif

if (ihorvic > 0 .or. NDRAW(29) == 37) then
  dvxc = 0 ; dvyc = 0; suu = 0
  if (kmx == 0) then

     if (istresstyp == 2 .or. istresstyp == 3) then     ! first set stressvector in cell centers

       vksag6 = vonkar*sag/6d0
       do L = lnx1D+1,lnx
          if (hu(L) > 0) then                           ! link will flow

             cs = csu(L)  ; sn = snu(L)
             k1 = ln(1,L) ; k2 = ln(2,L)

             vicL = 0d0
             if (Elder > 0d0) then                     !  add Elder
                 call getcz(hu(L), frcu(L), ifrcutp(L), Cz, L)
                 vicL = vicL + Elder * (vksag6/Cz) * ( hu(L) ) * sqrt( u1(L)*u1(L) + v(L)*v(L) )  ! vonkar*sag/(6*Cz) = 0.009
             endif

             k3 = lncn(1,L) ; k4 = lncn(2,L)

             if ( jasfer3D == 1 ) then
                duxdn = ( nod2linx(L,2,ucx(k2),ucy(k2)) - nod2linx(L,1,ucx(k1),ucy(k1)) )*dxi(L)
                duydn = ( nod2liny(L,2,ucx(k2),ucy(k2)) - nod2liny(L,1,ucx(k1),ucy(k1)) )*dxi(L)
                duxdt = ( cor2linx(L,2,ucnx(k4),ucny(k4)) - cor2linx(L,1,ucnx(k3),ucny(k3)) ) * wui(L)
                duydt = ( cor2liny(L,2,ucnx(k4),ucny(k4)) - cor2liny(L,1,ucnx(k3),ucny(k3)) ) * wui(L)
             else
                duxdn   =  ( ucx(k2) -  ucx(k1)) * dxi(L)
                duydn   =  ( ucy(k2) -  ucy(k1)) * dxi(L)
                duxdt   =  (ucnx(k4) - ucnx(k3)) * wui(L)
                duydt   =  (ucny(k4) - ucny(k3)) * wui(L)
             endif

             if (Smagorinsky > 0 .or. NDRAW(29) == 37) then               ! add Smagorinsky
                dundn    =  cs*duxdn + sn*duydn
                dutdn    = -sn*duxdn + cs*duydn
                dundt    =  cs*duxdt + sn*duydt
                dutdt    = -sn*duxdt + cs*duydt
                if ( NDRAW(29) == 37 ) then   ! plot curl
                   plotlin(L) = (dutdn - dundt)
                endif
                if (Smagorinsky > 0) then
                   shearvar = 2d0*(dundn*dundn + dutdt*dutdt + dundt*dutdn) + dundt*dundt + dutdn*dutdn

                   vicL     = vicL + Smagorinsky*Smagorinsky*sqrt(shearvar)/( dxi(L)*wui(L) )
                endif

             endif

             if (nshiptxy > 0) then
                 if (vicuship /= 0d0) then
                    vicL = vicL + vicushp(L)
                 endif
             endif

             ! JRE: add roller induced viscosity
             if ((jawave .eq. 4) .and. (swave .eq. 1) .and. (roller .eq. 1)) then
                DRL = acL(L) * DR(k1) + (1-acL(L)) * DR(k2)
                nuhroller = hu(L) * (DRL / rhomean) ** (1d0/3d0)
                vicL = max(nuhroller, vicL)
             end if

!             if (viuchk < 0.5d0) then
!                vicL = min(vicL, viuchk*dti /( dxi(L)*dxi(L) + wui(L)*wui(L) ) )
!             endif

!            viuchk: safe would be min(vol1(k1)/nd(k1)%N, vol1(k2)/nd(k2)%N) * dti / (dxi(L)*Au(L)),
!                    hence 0.2d0*min(vol1(k1),vol1(k2))... is safe up to pentagons

             if (javiusp == 1) then       ! user specified part
                 vicc = viusp(L)
             else
                 vicc = vicouv
             endif
             vicL = vicL + vicc

             if (ja_timestep_auto_visc == 0) then
                dxiAu = dxi(L)*hu(L)*wu(L)
                if ( dxiAu.gt.0d0 ) then
                   vicL = min(vicL, 0.2d0*dti*min( vol1(k1) , vol1(k2) )  / dxiAu )  ! see Tech Ref.: Limitation of Viscosity Coefficient
                endif
             endif

             vicLu(L) = vicL                       ! horizontal eddy viscosity applied in mom eq.
             viu(L) = max(0d0, vicL - vicc)        ! modeled turbulent part

             c11    = cs*cs ; c12=cs*sn ; c22=sn*sn
             suxL   = duxdn + c11*duxdn + c12*(duydn - duxdt) - c22*duydt
             suyL   = duydn + c11*duxdt + c12*(duxdn + duydt) + c22*duydn

             suxL   = suxL*vicL/wui(L)
             suyL   = suyL*vicL/wui(L)
             if (istresstyp == 3) then
                hmin  = min(hs(k1), hs(k2))
                suxL  = hmin*suxL
                suyL  = hmin*suyL
             endif

             if ( jsferic.eq.1 .and. jasfer3D.eq.1 ) then
                dvxc(k1) = dvxc(k1) + lin2nodx(L,1,suxL,suyL)
                dvyc(k1) = dvyc(k1) + lin2nody(L,1,suxL,suyL)
                dvxc(k2) = dvxc(k2) - lin2nodx(L,2,suxL,suyL)
                dvyc(k2) = dvyc(k2) - lin2nody(L,2,suxL,suyL)
             else
                dvxc(k1) = dvxc(k1) + suxL
                dvyc(k1) = dvyc(k1) + suyL
                dvxc(k2) = dvxc(k2) - suxL
                dvyc(k2) = dvyc(k2) - suyL
             endif

          endif

       enddo

    else

        !$OMP PARALLEL DO                                  &
        !$OMP PRIVATE(L,k1,k2)
        do L = lnx1D+1,lnx
          if (hu(L) > 0) then                           ! link will flow
             k1 = ln(1,L) ; k2 = ln(2,L)
             if (istresstyp == 4 .or. istresstyp == 5) then             ! set stresscomponent in links right away
                suu(L) = acl(L)*horvic(1,L) + (1d0-acl(L))*horvic(2,L)
             else if (istresstyp == 6) then
                suu(L) = acl(L)*horvic3(1,L) + (1d0-acl(L))*horvic3(2,L)
             endif
          endif
        enddo
        !$OMP END PARALLEL DO

    endif

  else if (kmx > 0) then

     if (istresstyp == 2 .or. istresstyp == 3) then     ! first set stressvector in cell centers

       do LL = lnx1D+1,lnx

          if (abs(kcu(LL)) .ne. 2) cycle
          call getLbotLtop(LL,Lb,Lt)
          cs   = csu(LL)  ; sn = snu(LL)

          if (javiusp == 1) then    ! user specified part
              vicc = viusp(LL)
           else
              vicc = vicouv
          endif

          do L = Lb, Lt

             vicL = 0d0

             k1 = ln  (1,L) ; k2 = ln  (2,L)
             k3 = lncn(1,L) ; k4 = lncn(2,L)
             if ( jasfer3D == 1 ) then
                duxdn = ( nod2linx(LL,2,ucx(k2),ucy(k2)) - nod2linx(LL,1,ucx(k1),ucy(k1)) )*dxi(LL)
                duydn = ( nod2liny(LL,2,ucx(k2),ucy(k2)) - nod2liny(LL,1,ucx(k1),ucy(k1)) )*dxi(LL)
                duxdt = ( cor2linx(LL,2,ucnx(k4),ucny(k4)) - cor2linx(LL,1,ucnx(k3),ucny(k3)) ) * wui(LL)
                duydt = ( cor2liny(LL,2,ucnx(k4),ucny(k4)) - cor2liny(LL,1,ucnx(k3),ucny(k3)) ) * wui(LL)
             else
                duxdn =  ( ucx(k2) -  ucx(k1)) * dxi(LL)
                duydn =  ( ucy(k2) -  ucy(k1)) * dxi(LL)
                duxdt =  (ucnx(k4) - ucnx(k3)) * wui(LL)
                duydt =  (ucny(k4) - ucny(k3)) * wui(LL)
             endif


             if (Smagorinsky > 0 .or. NDRAW(29) == 37) then               ! add Smagorinsky
                dundn    =  cs*duxdn + sn*duydn
                dutdn    = -sn*duxdn + cs*duydn
                dundt    =  cs*duxdt + sn*duydt
                dutdt    = -sn*duxdt + cs*duydt
                if ( NDRAW(29) == 37 .and. L-Lb+1 == kplot ) then         ! plot curl
                   plotlin(LL) = (dutdn - dundt)
                endif
                if (Smagorinsky > 0) then
                   shearvar = 2d0*(dundn*dundn + dutdt*dutdt + dundt*dutdn) + dundt*dundt + dutdn*dutdn
                   vicL     = vicL + Smagorinsky*Smagorinsky*sqrt(shearvar)/( dxi(LL)*wui(LL) )
                endif
             endif

             vicL = vicL + vicc

             if (javiuplus3D > 0) then
                vicL = vicL + vicwwu(L)
             endif

             if (nshiptxy > 0) then
                 if (vicuship /= 0d0) then
                    vicL = vicL + vicushp(LL)
                 endif
             endif

             if (ja_timestep_auto_visc == 0) then
                dxiAu = dxi(LL)*Au(L)
                if ( dxiAu.gt.0d0 ) then
                   vicL = min(vicL, 0.2d0*dti*min( vol1(k1) , vol1(k2) )  / dxiAu )
                endif
             endif

             vicLu(L) = vicL                       ! horizontal eddy viscosity applied in mom eq.
             viu(L) = max(0d0, vicL - vicc)        ! modeled turbulent part

             c11    = cs*cs ; c12=cs*sn ; c22=sn*sn
             suxL   = duxdn + c11*duxdn + c12*(duydn - duxdt) - c22*duydt
             suyL   = duydn + c11*duxdt + c12*(duxdn + duydt) + c22*duydn

             suxL   = suxL*vicL/wui(LL)
             suyL   = suyL*vicL/wui(LL)
             if (istresstyp == 3) then
                hmin  = min( zws(k1)-zws(k1-1), zws(k2)-zws(k2-1)  )
                suxL  = hmin*suxL
                suyL  = hmin*suyL
             endif

             if ( jsferic.eq.1 .and. jasfer3D.eq.1 ) then
                dvxc(k1) = dvxc(k1) + lin2nodx(LL,1,suxL,suyL)
                dvyc(k1) = dvyc(k1) + lin2nody(LL,1,suxL,suyL)
                dvxc(k2) = dvxc(k2) - lin2nodx(LL,2,suxL,suyL)
                dvyc(k2) = dvyc(k2) - lin2nody(LL,2,suxL,suyL)
             else
                dvxc(k1) = dvxc(k1) + suxL
                dvyc(k1) = dvyc(k1) + suyL
                dvxc(k2) = dvxc(k2) - suxL
                dvyc(k2) = dvyc(k2) - suyL
             endif

          enddo

       enddo

     endif
   endif

 endif

 if (ihorvic > 0) then

     if (istresstyp == 2 .or. istresstyp == 3 ) then

        if (kmx == 0) then
          !$OMP PARALLEL DO                       &
          !$OMP PRIVATE(L,k1,k2,huv)

         do L = lnx1D+1,lnx
             if (hu(L) > 0) then                           ! link will flow
                 k1 = ln(1,L) ; k2 = ln(2,L)
                 huv    = 0.5d0*( hs(k1) + hs(k2) )         ! *huvli(L)
                 if (huv > epshu ) then

                    if ( jasfer3D == 1 ) then
                       suu(L) =      acl(L)  * bai(k1)*( csu(L)*nod2linx(L,1,dvxc(k1),dvyc(k1)) + snu(L)*nod2liny(L,1,dvxc(k1),dvyc(k1)) ) +    &
                                (1d0-acl(L)) * bai(k2)*( csu(L)*nod2linx(L,2,dvxc(k2),dvyc(k2)) + snu(L)*nod2liny(L,2,dvxc(k2),dvyc(k2)) )
                    else
                       suu(L) = acl(L)     *bai(k1)*( csu(L)*dvxc(k1) + snu(L)*dvyc(k1)  ) +  &
                               (1d0-acl(L))*bai(k2)*( csu(L)*dvxc(k2) + snu(L)*dvyc(k2)  )
                    endif

                    if (istresstyp == 3) then
                        suu(L) = suu(L) / huv
                    endif
                 endif
             endif
          enddo
          !$OMP END PARALLEL DO
        else

          !$OMP PARALLEL DO                       &
          !$OMP PRIVATE(LL,kb1,kb2,Lb,Lt,L,k1,k2,huv)

           do LL = lnx1D+1,lnx
              if (hu(LL) > 0d0) then
                 kb1 = ln(1,LL) ; kb2 = ln(2,LL)
                 call getLbotLtop(LL,Lb,Lt)
                 do L = Lb,Lt
                    k1 = ln(1,L) ; k2 = ln(2,L)
                    huv    = 0.5d0 * ( (zws(k1)-zws(k1-1)) + (zws(k2)-zws(k2-1) ) )
                    if (huv > epshu) then
                       if ( jasfer3D == 1 ) then
                          suu(L) =      acl(LL)  * bai(kb1)*( csu(LL)*nod2linx(LL,1,dvxc(k1),dvyc(k1)) + snu(LL)*nod2liny(LL,1,dvxc(k1),dvyc(k1)) ) +    &
                                   (1d0-acl(LL)) * bai(kb2)*( csu(LL)*nod2linx(LL,2,dvxc(k2),dvyc(k2)) + snu(LL)*nod2liny(LL,2,dvxc(k2),dvyc(k2)) )
                       else
                          suu(L) = acl(LL)     *bai(kb1)*( csu(LL)*dvxc(k1) + snu(LL)*dvyc(k1)  ) +  &
                                  (1d0-acl(LL))*bai(kb2)*( csu(LL)*dvxc(k2) + snu(LL)*dvyc(k2)  )
                       endif

                       if (istresstyp == 3) then
                          suu(L) = suu(L)/huv
                       endif
                    endif
                 enddo
             endif
          enddo

           !$OMP END PARALLEL DO

        endif


    endif

    do nw  = 1,mxwalls
       k1  = walls(1,nw)                              ! waterlevel point on the inside
       k3  = walls(2,nw)                              ! first corner
       k4  = walls(3,nw)                              ! second corner
       L1  = walls(4,nw)                              ! link attached to first corner
       L2  = walls(5,nw)                              ! link attached to second corner
       sf  = walls(6,nw)                              ! ustarfactor, ustar=sf*us
       cs  = walls(7,nw)                              ! sux = -cs*ustar
       sn  = walls(8,nw)                              ! suy = -sn*ustar
       wuw = walls(9,nw)                              ! width of wall

       if (irov == 1) then                            ! partial slip
          if (kmx == 0) then
             if ( jasfer3D.eq.1 ) then
                ustar = (cs*nod2wallx(nw,ucx(k1),ucy(k1)) + sn*nod2wally(nw,ucx(k1),ucy(k1)))*sf
             else
                ustar = (cs*ucx(k1) + sn*ucy(k1))*sf
             endif
             walls(16,nw) = ustar
             suxw  = -cs*ustar*abs(ustar)*wuw*bai(k1)
             suyw  = -sn*ustar*abs(ustar)*wuw*bai(k1)
             if (L1 .ne. 0) then
                csl     = csu(L1) ; snl = snu(L1) ; ac1 = walls(10,nw)
                if ( jasfer3D.eq.1 ) then
                   suu(L1) = suu(L1) + (csl*wall2linx(nw,1,suxw,suyw) + snl*wall2liny(nw,1,suxw,suyw))*ac1
                else
                   suu(L1) = suu(L1) + (csl*suxw + snl*suyw)*ac1
                endif
             endif
             if (L2 .ne. 0) then
                csl     = csu(L2) ; snl = snu(L2) ; ac2 = walls(11,nw)
                if ( jasfer3D.eq.1 ) then
                   suu(L2) = suu(L2) + (csl*wall2linx(nw,2,suxw,suyw) + snl*wall2liny(nw,2,suxw,suyw))*ac2
                else
                   suu(L2) = suu(L2) + (csl*suxw + snl*suyw)*ac2
                endif
             endif
          else
             call getkbotktop(k1,kb,kt)
             if ( L1.ne.0 ) call getLbotLtop(L1,Lb1,Lt1)
             if ( L2.ne.0 ) call getLbotLtop(L2,Lb2,Lt2)
             do k = kb, kt
                if ( jasfer3D.eq.1 ) then
                   ustar = (cs*nod2wallx(nw,ucx(k),ucy(k)) + sn*nod2wally(nw,ucx(k),ucy(k)))*sf
                else
                   ustar = (cs*ucx(k) + sn*ucy(k))*sf
                endif
                walls(16,nw) = ustar
                suxw  = -cs*ustar*abs(ustar)*wuw*bai(k1)
                suyw  = -sn*ustar*abs(ustar)*wuw*bai(k1)
                if (L1 .ne. 0) then
                   csl     = csu(L1) ; snl = snu(L1) ; ac1 = walls(10,nw)
                   if ( jasfer3D.eq.1 ) then
                      suu(Lb1+k-kb) = suu(Lb1+k-kb) + (csl*wall2linx(nw,1,suxw,suyw) + snl*wall2liny(nw,1,suxw,suyw))*ac1
                   else
                      suu(Lb1+k-kb) = suu(Lb1+k-kb) + (csl*suxw + snl*suyw)*ac1
                   endif
                endif
                if (L2 .ne. 0) then
                   csl     = csu(L2) ; snl = snu(L2) ; ac2 = walls(11,nw)
                   if ( jasfer3D.eq.1 ) then
                      suu(Lb2+k-kb) = suu(Lb2+k-kb) + (csl*wall2linx(nw,2,suxw,suyw) + snl*wall2liny(nw,2,suxw,suyw))*ac2
                   else
                      suu(Lb2+k-kb) = suu(Lb2+k-kb) + (csl*suxw + snl*suyw)*ac2
                   endif
                endif
             enddo
          endif
       else if (irov == 2) then                      ! no slip
          if ( jasfer3D.eq.1 ) then
             ustar = (cs*nod2wallx(nw,ucx(k1),ucy(k1)) + sn*nod2wally(nw,ucx(k1),ucy(k1)))
          else
             ustar = (cs*ucx(k1) + sn*ucy(k1))          ! component parallel to wall
          endif

          walls(16,nw) = 0d0

          if (javiusp == 1) then
              vicl = viusp(L)
          else
              vicl = vicouv
          endif

          delty  = ba(k1)/wuw                        ! cell area / wall width is distance between internal point and mirror point
          delty  = 0.5d0*delty
          suxw   = -(cs*ustar*vicl/delty)*wuw*bai(k1)
          suyw   = -(sn*ustar*vicl/delty)*wuw*bai(k1)
          if (L1 .ne. 0) then
             csl     = csu(L1) ; snl = snu(L1) ; ac1 = walls(10,nw)
             if ( jasfer3D.eq.1 ) then
                suu(L1) = suu(L1) + (csl*wall2linx(nw,1,suxw,suyw) + snl*wall2liny(nw,1,suxw,suyw))*ac1
             else
                suu(L1) = suu(L1) + (csl*suxw + snl*suyw)*ac1
             endif
          endif
          if (L2 .ne. 0) then
             csl     = csu(L2) ; snl = snu(L2) ; ac2 = walls(11,nw)
             if ( jasfer3D.eq.1 ) then
                suu(L2) = suu(L2) + (csl*wall2linx(nw,2,suxw,suyw) + snl*wall2liny(nw,2,suxw,suyw))*ac2
             else
                suu(L2) = suu(L2) + (csl*suxw + snl*suyw)*ac2
             endif
          endif
       else if (irov == 0) then                     ! free slip
          if ( jasfer3D.eq.1 ) then
             walls(16,nw) = (cs*nod2wallx(nw,ucx(k1),ucy(k1)) + sn*nod2wally(nw,ucx(k1),ucy(k1)))
             walls(16,nw) = cs*ucx(k1) + sn*ucy(k1)
          endif
       endif

    enddo

    if ( izbndpos.eq.0 ) then
       do L = lnxi+1,lnx  ! quick fix for open boundaries
          suu(L) = 2d0*suu(L)
       enddo
    end if

    adve = adve - suu

 endif

 call klok(cpuumod(2)) ; cpuumod(3) = cpuumod(3) + cpuumod(2) - cpuumod(1)


 end subroutine setumodnew
 
 subroutine setucxucyucxuucyunew()   ! and reclaim ucxq, ucyq for Coriolis without interfering with Morfology
 use m_flowgeom
 use m_flow
 use m_sobekdfm
 use m_sediment, only: jased, stm_included
 use m_missing
 use m_flowparameters, only: jabarrieradvection
 use m_sferic
 implicit none

 integer          :: L, KK, k1, k2, k, nw, Lb, Lt, LL, nn, n, kt,kb, kbk, k2k, n1, n2
 integer          :: itpbn, newucxq=0
 double precision :: uu, vv, uucx, uucy, wcxu, wcyu, cs, sn, adx, ac1, ac2, wuw, hdx, hul, hsk, uin, duxdn, duydn, uhu, htrs
 double precision :: dischcorrection
 double precision :: uinx, uiny, ahu

 double precision,  allocatable :: husx, husy

 double precision, external :: nod2linx, nod2liny
 double precision, external :: lin2nodx, lin2nody

 ucxq = 0d0 ; ucyq = 0d0           ! zero arrays
 ucx  = 0d0 ; ucy  = 0d0

 if (kmx < 1) then                                   ! original 2D coding

    do L = 1,lnx1D
       if (u1(L) .ne. 0d0 .and. kcu(L) .ne. 3) then  ! link flows ; in 2D, the loop is split to save kcu check in 2D
          k1 = ln(1,L) ; k2 = ln(2,L)
          ucx(k1) = ucx(k1) + wcx1(L)*u1(L)
          ucy(k1) = ucy(k1) + wcy1(L)*u1(L)
          ucx(k2) = ucx(k2) + wcx2(L)*u1(L)
          ucy(k2) = ucy(k2) + wcy2(L)*u1(L)
       endif
    enddo

    do L = lnx1D + 1,lnx
       if (jabarrieradvection == 3) then
          if ( struclink(L) == 1 ) cycle
       endif
       if (u1(L) .ne. 0d0) then                      ! link flows
          k1 = ln(1,L) ; k2 = ln(2,L)
          ucx(k1) = ucx(k1) + wcx1(L)*u1(L)
          ucy(k1) = ucy(k1) + wcy1(L)*u1(L)
          ucx(k2) = ucx(k2) + wcx2(L)*u1(L)
          ucy(k2) = ucy(k2) + wcy2(L)*u1(L)
       endif
    enddo

 else
    do LL = 1,lnx
       Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
       do L = Lb, Lt
          if (u1(L) .ne. 0d0) then                         ! link flows
             k1 = ln0(1,L)                                 ! use ln0 in reconstruction and in computing ucxu, use ln when fluxing
             k2 = ln0(2,L)
             ucx (k1) = ucx (k1) + wcx1(LL)*u1(L)
             ucy (k1) = ucy (k1) + wcy1(LL)*u1(L)
             ucx (k2) = ucx (k2) + wcx2(LL)*u1(L)
             ucy (k2) = ucy (k2) + wcy2(LL)*u1(L)
          endif
       enddo

       if (jazlayercenterbedvel == 1) then ! copy bed velocity down
           do k1 = kbot(ln0(1,LL)), ln0(1,Lb) - 1
              ucx(k1) = ucx(k1) + wcx1(LL)*u1(Lb)
              ucy(k1) = ucy(k1) + wcy1(LL)*u1(Lb)
           enddo
           do k2 = kbot(ln0(2,LL)), ln0(2,Lb) - 1
              ucx(k2) = ucx(k2) + wcx2(LL)*u1(Lb)
              ucy(k2) = ucy(k2) + wcy2(LL)*u1(Lb)
           enddo
       endif

    enddo

 endif


 if (icorio == 5) then                                  ! original 2D coding hu weightings  

    if (kmx < 1) then                                   

       do L = lnx1D + 1,lnx
          if (u1(L) .ne. 0d0) then                      ! link flows
             k1 = ln(1,L) ; k2 = ln(2,L)
             huL = hu(L) 
             if (hhtrshcor > 0) huL = max(huL, hhtrshcor )
             uhu = u1(L)*huL 
             ucxq(k1) = ucxq(k1) + wcx1(L)*uhu
             ucyq(k1) = ucyq(k1) + wcy1(L)*uhu
             ucxq(k2) = ucxq(k2) + wcx2(L)*uhu
             ucyq(k2) = ucyq(k2) + wcy2(L)*uhu
          endif
       enddo

    else

       do LL = 1,lnx
          Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
          do L = Lb, Lt
             if (u1(L) .ne. 0d0) then                         ! link flows
                k1 = ln0(1,L)                                 ! use ln0 in reconstruction and in computing ucxu, use ln when fluxing
                k2 = ln0(2,L)
                huL = hu(L) - hu(L-1)
                if (hhtrshcor > 0) huL = max(huL, hhtrshcor ) 
                uhu      = u1(L)*huL 
                ucxq(k1) = ucxq(k1) + wcx1(LL)*uhu
                ucyq(k1) = ucyq(k1) + wcy1(LL)*uhu
                ucxq(k2) = ucxq(k2) + wcx2(LL)*uhu
                ucyq(k2) = ucyq(k2) + wcy2(LL)*uhu
             endif
          enddo
       enddo

    endif

 else if (icorio == 6) then                             ! hu2D weighting  

    if (kmx < 1) then                                   

       do L = lnx1D + 1,lnx
          if (u1(L) .ne. 0d0) then                      ! link flows
             k1 = ln(1,L) ; k2 = ln(2,L)
             huL = hu(L)  
             if (hhtrshcor > 0) huL = max(huL, hhtrshcor )    
             uhu = u1(L)*huL 
             ucxq(k1) = ucxq(k1) + wcx1(L)*uhu
             ucyq(k1) = ucyq(k1) + wcy1(L)*uhu
             ucxq(k2) = ucxq(k2) + wcx2(L)*uhu
             ucyq(k2) = ucyq(k2) + wcy2(L)*uhu
          endif
       enddo

    else

       do LL = 1,lnx
          Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
          huL = hu(LL)  
          if (hhtrshcor > 0) huL = max(huL, hhtrshcor )  
          do L = Lb, Lt
             if (u1(L) .ne. 0d0) then                         ! link flows
                k1 = ln0(1,L)                                 ! use ln0 in reconstruction and in computing ucxu, use ln when fluxing
                k2 = ln0(2,L)
                uhu      = u1(L)*huL  
                ucxq(k1) = ucxq(k1) + wcx1(LL)*uhu
                ucyq(k1) = ucyq(k1) + wcy1(LL)*uhu
                ucxq(k2) = ucxq(k2) + wcx2(LL)*uhu
                ucyq(k2) = ucyq(k2) + wcy2(LL)*uhu
             endif
          enddo
       enddo

    endif

 else if (icorio == 7) then                             ! ahuk type weigthings  

   if (kmx < 1) then                                   

       do L = lnx1D + 1,lnx
          if (u1(L) .ne. 0d0) then                      ! link flows
             k1 = ln(1,L) ; k2 = ln(2,L)
             huL = acl(L)*hs(k1) + (1d0-acl(L))*hs(k2) 
             if (hhtrshcor > 0) huL = max(huL, hhtrshcor ) 
             uhu = u1(L)*huL 
             ucxq(k1) = ucxq(k1) + wcx1(L)*uhu
             ucyq(k1) = ucyq(k1) + wcy1(L)*uhu
             ucxq(k2) = ucxq(k2) + wcx2(L)*uhu
             ucyq(k2) = ucyq(k2) + wcy2(L)*uhu
          endif
       enddo

    else

       do LL = 1,lnx
          Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
          do L = Lb, Lt
             if (u1(L) .ne. 0d0) then                         ! link flows
                k1 = ln0(1,L)                                 ! use ln0 in reconstruction and in computing ucxu, use ln when fluxing
                k2 = ln0(2,L)
                huL = acl(LL)*( zws(k1) - zws(k1-1) )  + (1d0-acl(LL))*( zws(k2) - zws(k2-1) ) 
                if (hhtrshcor > 0) huL = max(huL, hhtrshcor ) 
                uhu      = u1(L)*huL 
                ucxq(k1) = ucxq(k1) + wcx1(LL)*uhu
                ucyq(k1) = ucyq(k1) + wcy1(LL)*uhu
                ucxq(k2) = ucxq(k2) + wcx2(LL)*uhu
                ucyq(k2) = ucyq(k2) + wcy2(LL)*uhu
             endif
          enddo
       enddo

    endif

else if (icorio == 8) then                             ! ahu2D type weigthings  

   if (kmx < 1) then                                   

       do L = lnx1D + 1,lnx
          if (u1(L) .ne. 0d0) then                      ! link flows
             k1 = ln(1,L) ; k2 = ln(2,L)
             huL = acl(L)*hs(k1) + (1d0-acl(L))*hs(k2) 
             if (hhtrshcor > 0) huL = max(huL, hhtrshcor ) 
             uhu = u1(L)*huL 
             ucxq(k1) = ucxq(k1) + wcx1(L)*uhu
             ucyq(k1) = ucyq(k1) + wcy1(L)*uhu
             ucxq(k2) = ucxq(k2) + wcx2(L)*uhu
             ucyq(k2) = ucyq(k2) + wcy2(L)*uhu
          endif
       enddo

    else

       do LL = 1,lnx
          Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
          k1 = ln(1,LL) ; k2 = ln(2,LL)
          huL = acl(LL)*hs(k1) + (1d0-acl(LL))*hs(k2) 
          if (hhtrshcor > 0) huL = max(huL, hhtrshcor ) 
          do L = Lb, Lt
             if (u1(L) .ne. 0d0) then                         ! link flows
                k1 = ln0(1,L)                                 ! use ln0 in reconstruction and in computing ucxu, use ln when fluxing
                k2 = ln0(2,L)
                uhu      = u1(L)*huL  
                ucxq(k1) = ucxq(k1) + wcx1(LL)*uhu
                ucyq(k1) = ucyq(k1) + wcy1(LL)*uhu
                ucxq(k2) = ucxq(k2) + wcx2(LL)*uhu
                ucyq(k2) = ucyq(k2) + wcy2(LL)*uhu
             endif
          enddo
       enddo

    endif

else if (icorio == 9) then                             ! volk type weigthings  

   if (kmx < 1) then                                   

       do L = lnx1D + 1,lnx
          if (u1(L) .ne. 0d0) then                      ! link flows
             k1 = ln(1,L) ; k2 = ln(2,L)
             huL = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2) 
             if (hhtrshcor > 0)  huL = max(huL, hhtrshcor*( acl(L)*ba(k1) + (1d0-acl(L))*ba(k2) ) ) 
             uhu = u1(L)*huL 
             ucxq(k1) = ucxq(k1) + wcx1(L)*uhu
             ucyq(k1) = ucyq(k1) + wcy1(L)*uhu
             ucxq(k2) = ucxq(k2) + wcx2(L)*uhu
             ucyq(k2) = ucyq(k2) + wcy2(L)*uhu
          endif
       enddo

    else

       do LL = 1,lnx
          Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
          n1 = ln(1,LL) ; n2 = ln(2,LL)   
          if (hhtrshcor > 0) htrs = hhtrshcor*( acl(LL)*ba(n1) + (1d0-acl(LL))*ba(n2) ) 
          do L = Lb, Lt
             if (u1(L) .ne. 0d0) then                         ! link flows
                k1 = ln0(1,L)                                 ! use ln0 in reconstruction and in computing ucxu, use ln when fluxing
                k2 = ln0(2,L)
                huL = acl(LL)*vol1(k1) + (1d0-acl(LL))*vol1(k2)                    
                if (hhtrshcor > 0)  huL = max(huL, htrs  )  
                uhu      = u1(L)*huL  
                ucxq(k1) = ucxq(k1) + wcx1(LL)*uhu
                ucyq(k1) = ucyq(k1) + wcy1(LL)*uhu
                ucxq(k2) = ucxq(k2) + wcx2(LL)*uhu
                ucyq(k2) = ucyq(k2) + wcy2(LL)*uhu
             endif
          enddo
       enddo

    endif

else if (icorio == 10) then                             ! vol2D type weigthings  

   if (kmx < 1) then                                   

       do L = lnx1D + 1,lnx
          if (u1(L) .ne. 0d0) then                      ! link flows
             k1 = ln(1,L) ; k2 = ln(2,L)
             huL = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2)  
             if (hhtrshcor > 0)  huL = max(huL, hhtrshcor*( acl(L)*ba(k1) + (1d0-acl(L))*ba(k2) ) )     
             uhu = u1(L)*huL 
             ucxq(k1) = ucxq(k1) + wcx1(L)*uhu
             ucyq(k1) = ucyq(k1) + wcy1(L)*uhu
             ucxq(k2) = ucxq(k2) + wcx2(L)*uhu
             ucyq(k2) = ucyq(k2) + wcy2(L)*uhu
          endif
       enddo

    else

       do LL = 1,lnx
          Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
          k1 = ln(1,LL) ; k2 = ln(2,LL)
          huL = acl(LL)*vol1(k1) + (1d0-acl(LL))*vol1(k2) 
          if (hhtrshcor > 0)  huL = max(huL, hhtrshcor*( acl(LL)*ba(k1) + (1d0-acl(LL))*ba(k2) ) )    
          do L = Lb, Lt
             if (u1(L) .ne. 0d0) then                         ! link flows
                k1 = ln0(1,L)                                 ! use ln0 in reconstruction and in computing ucxu, use ln when fluxing
                k2 = ln0(2,L)
                uhu      = u1(L)*huL  
                ucxq(k1) = ucxq(k1) + wcx1(LL)*uhu
                ucyq(k1) = ucyq(k1) + wcy1(LL)*uhu
                ucxq(k2) = ucxq(k2) + wcx2(LL)*uhu
                ucyq(k2) = ucyq(k2) + wcy2(LL)*uhu
             endif
          enddo
       enddo

    endif

 
 endif

 if (icorio == 7 .or. icorio == 27) then   ! make ahus or ahusk
    hus = 0
    if (kmx < 1) then ! original 2D coding
       do L = 1,lnx
          k1  = ln(1,L) ; k2 = ln(2,L) 
          huL = acl(L)*hs(k1) + (1d0-acl(L))*hs(k2) 
          hus(k1) = hus(k1) + wcl(1,L)*huL  
          hus(k2) = hus(k2) + wcl(2,L)*huL  
       enddo
    else
       do LL = 1,lnx
          do L = Lbot(LL), Ltop(LL) 
             k1  = ln(1,L) ; k2 = ln(2,L) 
             huL = acl(LL)*( zws(k1) - zws(k1-1) )  + (1d0-acl(LL))*( zws(k2) - zws(k2-1) ) 
             hus(k1) = hus(k1) + wcl(1,LL)*huL  
             hus(k2) = hus(k2) + wcl(2,LL)*huL  
          enddo
       enddo
    endif 
 else if (icorio == 8 .or. icorio == 28) then   
    hus = 0
    if (kmx < 1) then ! original 2D coding
       do L = 1,lnx
          k1  = ln(1,L) ; k2 = ln(2,L) 
          huL = acl(L)*hs(k1) + (1d0-acl(L))*hs(k2) 
          hus(k1) = hus(k1) + wcl(1,L)*huL  
          hus(k2) = hus(k2) + wcl(2,L)*huL  
       enddo
    else
       do LL = 1,lnx
          k1  = ln(1,LL) ; k2 = ln(2,LL) 
          huL = acl(LL)*hs(k1) + (1d0-acl(LL))*hs(k2)
          do L = Lbot(LL), Ltop(LL) 
             hus(k1) = hus(k1) + wcl(1,LL)*huL  
             hus(k2) = hus(k2) + wcl(2,LL)*huL  
          enddo
       enddo
    endif 
 endif


 if (icorio == 5) then                       ! original hu/hs weighting 
    if (kmx < 1) then 
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(k)
       do k = 1,ndxi
          hsk = hs(k) 
          if (hsk > 0d0)  then
             if (hhtrshcor > 0)  hsk = max(hsk, hhtrshcor) 
             ucxq(k) = ucxq(k)/hsk
             ucyq(k) = ucyq(k)/hsk
          endif
       enddo
       !$OMP END PARALLEL DO
    else
       do nn = 1,ndxi
          if (hs(nn) > 0d0)  then
             kb = kbot(nn)
             kt = ktop(nn)
             do k = kb,kt 
                hsk = zws(k) - zws(k-1)
                if (hsk > 0d0) then
                   if (hhtrshcor > 0)  hsk = max(hsk, hhtrshcor) 
                   ucxq(k) = ucxq(k)/hsk
                   ucyq(k) = ucyq(k)/hsk
                endif
             enddo
          endif
       enddo
    endif

 else if (icorio == 6) then                       ! original hu/hs weighting 2D
    if (kmx < 1) then 
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(k)
       do k = 1,ndxi
          hsk = hs(k) 
          if (hsk > 0d0)  then
             if (hhtrshcor > 0)  hsk = max(hsk, hhtrshcor) 
             ucxq(k) = ucxq(k)/hsk
             ucyq(k) = ucyq(k)/hsk
          endif
       enddo
       !$OMP END PARALLEL DO
    else
       do nn = 1,ndxi
          hsk = hs(nn) 
          if (hsk > 0d0)  then
             if (hhtrshcor > 0)  hsk = max(hsk, hhtrshcor) 
             kb = kbot(nn)
             kt = ktop(nn)
             do k = kb,kt 
                ucxq(k) = ucxq(k)/hsk 
                ucyq(k) = ucyq(k)/hsk 
             enddo
          endif
       enddo
    endif

 else if (icorio == 7) then                  !          ahuk/ahusk weighting
  
    if (kmx < 1) then ! original 2D coding
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(k)
       do k = 1,ndxi
          if (hus(k) > 0d0)  then
             hsk = hus(k)   
             if (hhtrshcor > 0) hsk = max(hsk, hhtrshcor) 
             ucxq(k) = ucxq(k)/hsk
             ucyq(k) = ucyq(k)/hsk
          endif
       enddo
       !$OMP END PARALLEL DO
    else
       do nn = 1,ndxi
          if (hs(nn) > 0d0)  then
             kb = kbot(nn)
             kt = ktop(nn)
             do k = kb,kt 
                hsk = hus(k)
                if (hsk > 0d0) then
                   if (hhtrshcor > 0) hsk = max(hsk, hhtrshcor) 
                   ucxq(k) = ucxq(k)/hsk
                   ucyq(k) = ucyq(k)/hsk
                endif
             enddo
          endif
       enddo
    endif

 else if (icorio == 8) then                  !          ahu/ahus weighting
  
    if (kmx < 1) then ! original 2D coding
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(k)
       do k = 1,ndxi
          if (hus(k) > 0d0)  then
             hsk = hus(k)
             if (hhtrshcor > 0) hsk = max(hsk, hhtrshcor) 
             ucxq(k) = ucxq(k)/hsk
             ucyq(k) = ucyq(k)/hsk
          endif
       enddo
       !$OMP END PARALLEL DO
    else
       do nn = 1,ndxi
          if (hs(nn) > 0d0)  then
             kb = kbot(nn)
             kt = ktop(nn)
             hsk = hus(nn)
             if (hsk > 0) then 
                if (hhtrshcor > 0) hsk = max(hsk, hhtrshcor)
                do k = kb,kt  
                   ucxq(k) = ucxq(k)/hsk
                   ucyq(k) = ucyq(k)/hsk
                enddo
             endif
          endif
       enddo
    endif

 else if (icorio == 9) then                  !          voluk/volk weighting
  
    if (kmx < 1) then ! original 2D coding
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(k)
       do k = 1,ndxi
          if (vol1(k) > 0d0)  then
             hsk = vol1(k)  
             if (hhtrshcor > 0) hsk = max(hsk, hhtrshcor*ba(k))
             ucxq(k) = ucxq(k)/hsk
             ucyq(k) = ucyq(k)/hsk
          endif
       enddo
       !$OMP END PARALLEL DO
    else
       do nn = 1,ndxi
          if (vol1(nn) > 0d0)  then
             kb = kbot(nn)
             kt = ktop(nn)
             do k = kb,kt 
                hsk = vol1(k) 
                if (hsk > 0d0) then
                   if (hhtrshcor > 0) hsk = max(hsk, hhtrshcor*ba(nn))
                   ucxq(k) = ucxq(k)/hsk
                   ucyq(k) = ucyq(k)/hsk
                endif
             enddo
          endif
       enddo
    endif
 else if (icorio == 10) then                  !          volu/vol weighting 
  
    if (kmx < 1) then ! original 2D coding
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(k)
       do k = 1,ndxi
          if (vol1(k) > 0d0)  then
             hsk = vol1(k) 
             if (hhtrshcor > 0) hsk = max(hsk, hhtrshcor*ba(k))
             ucxq(k) = ucxq(k)/hsk
             ucyq(k) = ucyq(k)/hsk
          endif
       enddo
       !$OMP END PARALLEL DO
    else
       do nn = 1,ndxi
          if (vol1(nn) > 0d0)  then
             kb = kbot(nn)
             kt = ktop(nn)
             hsk = vol1(nn)  
             if (hsk > 0) then 
                if (hhtrshcor > 0) hsk = max(hsk, hhtrshcor*ba(nn))
                do k = kb,kt  
                   ucxq(k) = ucxq(k)/hsk
                   ucyq(k) = ucyq(k)/hsk
                enddo
             endif
          endif
       enddo
    endif
 
 else if (icorio > 0) then ! all Ham types
    ucxq = ucx
    ucyq = ucy
 endif

 if (icorio > 0) then  ! and no more touching after this 
    do LL = Lnxi+1,Lnx
       do L = lbot(LL), Ltop(LL) 
          k1 = ln(1,L) ; k2 = ln(2,L) 
          ucxq(k1) = ucxq(k2)
          ucyq(k1) = ucyq(k2)
       enddo
    enddo  
 endif

 do n  = 1, nbndz                                     ! waterlevel boundaries
    kb = kbndz(1,n)
    k2 = kbndz(2,n)
    LL = kbndz(3,n)
    itpbn = kbndz(4,n)
    cs = csu(LL) ; sn = snu(LL)
    if (kmx == 0) then
       if (hs(kb) > epshs)  then
          if ( jacstbnd.eq.0 .and. itpbn.ne.2 ) then    ! Neumann: always
             if (jasfer3D == 1) then
                uin     = nod2linx(LL,2,ucx(k2),ucy(k2))*cs + nod2liny(LL,2,ucx(k2),ucy(k2))*sn
                ucx(kb) = uin*lin2nodx(LL,1,cs,sn)
                ucy(kb) = uin*lin2nody(LL,1,cs,sn)
             else
                uin     = ucx(k2)*cs + ucy(k2)*sn
                ucx(kb) = uin*cs
                ucy(kb) = uin*sn
             end if
          else
             if (jasfer3D == 1) then
                uinx    = nod2linx(LL,2,ucx(k2),ucy(k2))
                uiny    = nod2liny(LL,2,ucx(k2),ucy(k2))
                ucx(kb) = lin2nodx(LL,1,uinx,uiny)
                ucy(kb) = lin2nody(LL,1,uinx,uiny)
             else
                ucx(kb) = ucx(k2)
                ucy(kb) = ucy(k2)
             endif
          end if
       endif
    else
       call getLbotLtop(LL,Lb,Lt)
       do L = Lb, Lt
          kbk = ln(1,L) ; k2k = ln(2,L)
          if ( jacstbnd.eq.0 .and. itpbn.ne.2 ) then
             if (jasfer3D == 1) then
                uin = nod2linx(LL,2,ucx(k2k),ucy(k2k))*cs + nod2liny(LL,2,ucx(k2k),ucy(k2k))*sn
                ucx(kbk) = uin*lin2nodx(LL,1,cs,sn)
                ucy(kbk) = uin*lin2nody(LL,1,cs,sn)
             else
                uin = ucx(k2k)*cs + ucy(k2k)*sn
                ucx(kbk) = uin*cs
                ucy(kbk) = uin*sn
             end if
          else
             if (jasfer3D == 1) then
                uinx     = nod2linx(LL,2,ucx(k2k),ucy(k2k))
                uiny     = nod2liny(LL,2,ucx(k2k),ucy(k2k))
                ucx(kbk) = lin2nodx(LL,1,uinx,uiny)
                ucy(kbk) = lin2nody(LL,1,uinx,uiny)
             else
                ucx(kbk) = ucx(k2k)
                ucy(kbk) = ucy(k2k)
             end if
          end if
       enddo
    endif
 enddo

 if (jaZerozbndinflowadvection == 1) then
    do n  = 1, nbndz                                      ! on waterlevel boundaries put inflow advection velocity to 0 on inflow
       LL = kbndz(3,n)
       do L  = Lbot(LL), Ltop(LL)
          k1 = ln(1,L)
          if (u1(LL) > 0) then
             ucx(k1) = 0d0 ; ucy(k1) = 0d0
          endif
       enddo
    enddo
 else if (jaZerozbndinflowadvection == 2) then
    do n  = 1, nbndz                                      ! on waterlevel boundaries put all advection velocity to 0 anyway
       LL = kbndz(3,n)
       do L  = Lbot(LL), Ltop(LL)
          k1 = ln(1,L)
          ucx(k1) = 0d0 ; ucy(k1) = 0d0
       enddo
    enddo
 endif

 do n  = 1,nbndu                                          ! velocity boundaries
    kb = kbndu(1,n)
    k2 = kbndu(2,n)
    LL = kbndu(3,n)
    cs = csu(LL) ; sn = snu(LL)
    if (kmx == 0) then
       if (hs(kb) > epshs)  then
          if ( jacstbnd.eq.0 ) then
             if (jasfer3D == 1) then
                uin     = nod2linx(LL,2,ucx(k2),ucy(k2))*cs + nod2liny(LL,2,ucx(k2),ucy(k2))*sn
                ucx(kb) = uin*lin2nodx(LL,1,cs,sn)
                ucy(kb) = uin*lin2nody(LL,1,cs,sn)
             else
                uin     = ucx(k2)*cs + ucy(k2)*sn
                ucx(kb) = uin*cs
                ucy(kb) = uin*sn
             end if
          else
             if (jasfer3D == 1) then
                uinx    = nod2linx(LL,2,ucx(k2),ucy(k2))
                uiny    = nod2liny(LL,2,ucx(k2),ucy(k2))
                ucx(kb) = lin2nodx(LL,1,uinx,uiny)
                ucy(kb) = lin2nody(LL,1,uinx,uiny)
             else
                ucx(kb) = ucx(k2)
                ucy(kb) = ucy(k2)
             end if
          end if
       endif
    else
       do k   = 1, kmxL(LL)
          kbk = kbot(kb) - 1 + min(k,kmxn(kb))
          k2k = kbot(k2) - 1 + min(k,kmxn(k2))
          if ( jacstbnd.eq.0 ) then
             if (jasfer3D == 1) then
                uin      = nod2linx(LL,2,ucx(k2k),ucy(k2k))*cs + nod2liny(LL,2,ucx(k2k),ucy(k2k))*sn
                ucx(kbk) = uin*lin2nodx(LL,1,cs,sn)
                ucy(kbk) = uin*lin2nody(LL,1,cs,sn)
             else
                uin = ucx(k2k)*cs + ucy(k2k)*sn
                ucx(kbk) = uin*cs
                ucy(kbk) = uin*sn
             end if
          else
             if (jasfer3D == 1) then
                uinx     = nod2linx(LL,2,ucx(k2k),ucy(k2k))
                uiny     = nod2liny(LL,2,ucx(k2k),ucy(k2k))
                ucx(kbk) = lin2nodx(LL,1,uinx,uiny)
                ucy(kbk) = lin2nody(LL,1,uinx,uiny)
             else
                ucx(kbk) = ucx(k2k)
                ucy(kbk) = ucy(k2k)
             end if
          end if
       enddo
    endif
 enddo

 do n  = 1, nbndt                               ! tangential velocity boundaries, override other types
    kb = kbndt(1,n)
    k2 = kbndt(2,n)
    LL = kbndt(3,n)
    cs = csu(LL) ; sn = snu(LL)
    call getLbotLtop(LL,Lb,Lt)
    do L = Lb, Lt
       kbk  = ln(1,L)
       kk   = kmxd*(n-1)+L-Lb+1
       uu   = u0(L) ; vv = zbndt(kk) ! v(L)
       uucx = uu*cs - vv*sn
       uucy = uu*sn + vv*cs
       if (jasfer3D == 1) then
          ucx(kbk) = lin2nodx(LL,1,uucx,uucy)
          ucy(kbk) = lin2nody(LL,1,uucx,uucy)
       else
          ucx(kbk) = uucx
          ucy(kbk) = uucy
       end if
    enddo
 enddo

 if (zbnduxyval .ne. dmiss) then
     zbnduxy(1) = zbnduxyval
 endif

 do n  = 1, nbnduxy        ! do3d                     ! uxuy velocity boundaries, override other types
    LL = kbnduxy(3,n)
    call getLbotLtop(LL,Lb,Lt)
    do L = Lb, Lt
       kbk = ln(1,L)
       kk  = kmxd*(n-1)+L-Lb+1
       if (jasfer3D == 1) then
          ucx(kbk) = lin2nodx(LL,1,zbnduxy(2*kk-1),zbnduxy(2*kk))
          ucy(kbk) = lin2nody(LL,1,zbnduxy(2*kk-1),zbnduxy(2*kk))
       else
          ucx(kbk) = zbnduxy(2*kk-1)
          ucy(kbk) = zbnduxy(2*kk)
       end if
       if (jazerozbndinflowadvection == 3) then  ! 
          k2 = ln(2,L) 
          ucx(k2) = 0.5d0*( ucx(kbk) + ucx(k2) ) 
          ucy(k2) = 0.5d0*( ucy(kbk) + ucy(k2) )
       endif  
    enddo
 enddo

 do n  = 1, nbndn                                     ! normal velocity boundaries, override other types
    kb = kbndn(1,n)
    k2 = kbndn(2,n)
    LL = kbndn(3,n)
    cs = csu(LL) ; sn = snu(LL)
    call getLbotLtop(LL,Lb,Lt)
    do L = Lb, Lt
       kbk  = ln(1,L)
       kk   = kmxd*(n-1)+L-Lb+1
       uu   = zbndn(kk) ; vv = 0d0
       uucx = uu*cs - vv*sn                   !
       uucy = uu*sn + vv*cs
       if (jasfer3D == 1) then
          ucx(kbk) = lin2nodx(LL,1,uucx,uucy)
          ucy(kbk) = lin2nody(LL,1,uucx,uucy)
       else
          ucx(kbk) = uucx
          ucy(kbk) = uucy
       end if
    enddo
 enddo

 do n=1,nbnd1d2d
    kb      = kbnd1d2d(1,n)
    k2      = kbnd1d2d(2,n)
    LL      = kbnd1d2d(3,n)

    if (kmx == 0) then     ! 2D
       if (jasfer3D == 1) then
          uinx = nod2linx(LL,2,ucx(k2),ucy(k2))
          uiny = nod2liny(LL,2,ucx(k2),ucy(k2))
          ucx(kb) = lin2nodx(LL,1,uinx,uiny)
          ucy(kb) = lin2nody(LL,1,uinx,uiny)
       else
          ucx(kb) = ucx(k2)
          ucy(kb) = ucy(k2)
       end if
    else     ! 3D

    endif
 end do

 if (limtypmom == 6) then

    ducxdx = 0d0; ducxdy = 0d0
    ducydx = 0d0; ducydy = 0d0
    do LL = 1,lnx
       Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
       do L = Lb, Lt
          k1 = ln(1,L)
          k2 = ln(2,L)
          if (jasfer3D == 1) then
             duxdn = dxi(LL)*(nod2linx(LL,2,ucx(k2),ucy(k2))-nod2linx(LL,1,ucx(k1),ucy(k1)))
          else
             duxdn = dxi(LL)*(ucx(k2) - ucx(k1))
          endif
          ducxdx(k1) = ducxdx(k1) + wcx1(LL)*duxdn
          ducxdy(k1) = ducxdy(k1) + wcy1(LL)*duxdn
          ducxdx(k2) = ducxdx(k2) + wcx2(LL)*duxdn
          ducxdy(k2) = ducxdy(k2) + wcy2(LL)*duxdn

          if (jasfer3D == 1) then
             duydn = dxi(LL)*(nod2liny(LL,2,ucx(k2),ucy(k2))-nod2liny(LL,1,ucx(k1),ucy(k1)))
          else
             duydn = dxi(LL)*(ucy(k2) - ucy(k1))
          endif
          ducydx(k1) = ducydx(k1) + wcx1(LL)*duydn
          ducydy(k1) = ducydy(k1) + wcy1(LL)*duydn
          ducydx(k2) = ducydx(k2) + wcx2(LL)*duydn
          ducydy(k2) = ducydy(k2) + wcy2(LL)*duydn
       enddo
    enddo

    !do nw  = 1,mxwalls   ! to be finished later zz
    !   csw = walls(7,nw)
    !   snw = walls(8,nw)
    !   ducdn = 2d0*(ucx(k1)*csw +
    !   ducxdx(k1) = ducxdx(k1) + *duxdn
    !enddo

 endif

 if (kmx < 1) then

    if (jasfer3D == 1) then
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(L)
       do L = 1,lnx
          if (qa(L) > 0) then                               ! set upwind ucxu, ucyu  on links
             ucxu(L) = nod2linx(L,1,ucx(ln(1,L)),ucy(ln(1,L)))
             ucyu(L) = nod2liny(L,1,ucx(ln(1,L)),ucy(ln(1,L)))
          else if (qa(L) < 0) then
             ucxu(L) = nod2linx(L,2,ucx(ln(2,L)),ucy(ln(2,L)))
             ucyu(L) = nod2liny(L,2,ucx(ln(2,L)),ucy(ln(2,L)))
          else
             ucxu(L) = 0d0
             ucyu(L) = 0d0
          endif
       enddo
       !$OMP END PARALLEL DO
    else
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(L)
       do L = 1,lnx
          if (qa(L) > 0) then                               ! set upwind ucxu, ucyu  on links
             ucxu(L) = ucx(ln(1,L))
             ucyu(L) = ucy(ln(1,L))
          else if (qa(L) < 0) then
             ucxu(L) = ucx(ln(2,L))
             ucyu(L) = ucy(ln(2,L))
          else
             ucxu(L) = 0d0
             ucyu(L) = 0d0
          endif
       enddo
       !$OMP END PARALLEL DO
    endif

 else

    if (jasfer3D == 1) then
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(LL,L,Lb,Lt)
       do LL = 1,lnx
          call getLbotLtop(LL,Lb,Lt)
          do L = Lb,Lt
             if (qa(L) > 0) then                               ! set upwind ucxu, ucyu  on links
                ucxu(L) = nod2linx(LL,1,ucx(ln0(1,L)),ucy(ln0(1,L)))
                ucyu(L) = nod2liny(LL,1,ucx(ln0(1,L)),ucy(ln0(1,L)))
                if (jarhoxu > 0) then
                   ucxu(L) = ucxu(L)*rho(ln(1,L))
                   ucyu(L) = ucyu(L)*rho(ln(1,L))
                endif
             else if (qa(L) < 0) then
                ucxu(L) = nod2linx(LL,2,ucx(ln0(2,L)),ucy(ln0(2,L)))
                ucyu(L) = nod2liny(LL,2,ucx(ln0(2,L)),ucy(ln0(2,L)))
                if (jarhoxu > 0) then
                   ucxu(L) = ucxu(L)*rho(ln(2,L))
                   ucyu(L) = ucyu(L)*rho(ln(2,L))
                endif
             else
                ucxu(L) = 0d0
                ucyu(L) = 0d0
             endif
          enddo
       enddo
       !$OMP END PARALLEL DO

    else

       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(LL,L,Lb,Lt)
       do LL = 1,lnx
          call getLbotLtop(LL,Lb,Lt)
          do L = Lb,Lt
             if (qa(L) > 0) then                               ! set upwind ucxu, ucyu  on links
                ucxu(L) = ucx(ln0(1,L))
                ucyu(L) = ucy(ln0(1,L))
                if (jarhoxu > 0) then
                   ucxu(L) = ucxu(L)*rho(ln(1,L))
                   ucyu(L) = ucyu(L)*rho(ln(1,L))
                endif
             else if (qa(L) < 0) then
                ucxu(L) = ucx(ln0(2,L))
                ucyu(L) = ucy(ln0(2,L))
                if (jarhoxu > 0) then
                   ucxu(L) = ucxu(L)*rho(ln(2,L))
                   ucyu(L) = ucyu(L)*rho(ln(2,L))
                endif
             else
                ucxu(L) = 0d0
                ucyu(L) = 0d0
             endif
          enddo
       enddo
       !$OMP END PARALLEL DO

    endif

 endif

end subroutine setucxucyucxuucyunew

!> Computes/gets cell centered horizontal x/y velocities, either Eulerian or Lagrangian, and when requested also magnitude.
!! Centralized routine for multiple uses in output files.
subroutine getucxucyeulmag(N, ucxeulg, ucyeulg, ucmago, jaeulervel, jaucmag)
   use m_flowgeom
   use m_flow, only: ndkx, ucx, ucy
   use m_flowparameters, only: jawave
   use m_waves, only: ustokes            ! available for all wave models

   implicit none

   integer,          intent(in   ) :: N          !< Length of cell arrays (probably ndkx)
   double precision, intent(  out) :: ucxeulg(N) !< Target array in which to store x-velocities.
   double precision, intent(  out) :: ucyeulg(N) !< Target array in which to store y-velocities.
   double precision, intent(  out) :: ucmago(N)  !< Target array in which to store velocity magnitudes. May be undefined when jaucmag==0.
   integer,          intent(in   ) :: jaeulervel !< Whether or not (1/0) to compute Eulerian velocities (i.e., substract Stokes drift)
   integer,          intent(in   ) :: jaucmag    !< Whether or not (1/0) to compute velocity magnitudes.

   ! Copy ucx/ucy to ucxeulg/ucyeulg
   ! They will optionally be transformed into Eulerian velocities
   ucxeulg(1:ndkx) = ucx(1:ndkx) ; ucyeulg(1:ndkx) = ucy(1:ndkx)

   ! Transform uxy/ucy into Eulerian velocities
   if (jaeulervel==1 .and. jawave>0) then
      call getucxucyeuler(N, ucxeulg, ucyeulg)
   endif

   ! Compute magnitude for vel.vectors (either Lagr. or Eul.)
   if (jaucmag == 1) then
      call getucmag(N, ucxeulg, ucyeulg, ucmago)
   end if

end subroutine getucxucyeulmag


!> Computes the Eulerian horizontal velocities.
!! In absence of waves, these are equal to the Lagrangian ucx/ucy.
!! The Stokes drift on links is averaged to cell centers using the Perot weights.
subroutine getucxucyeuler(N, ucxeu, ucyeu)
   use m_flowgeom
   use m_flow
   use m_waves, only: ustokes            ! available for all wave models

   implicit none

   integer,          intent(in   ) :: N        !< Length of cell arrays (probably ndkx)
   double precision, intent(  out) :: ucxeu(N) !< Target array in which to store Eulerian x-velocities
   double precision, intent(  out) :: ucyeu(N) !< Target array in which to store Eulerian y-velocities

   integer          :: i, Lb, Lt, L, LL, k, k1, k2
   double precision :: u1l, wcxu, wcyu, ueul

   ucxeu(1:ndkx) = ucx(1:ndkx) ; ucyeu(1:ndkx) = ucy(1:ndkx)
   if (jawave > 0) then
      do LL = 1,lnx
         Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
         do L = Lb, Lt
            if (ustokes(L) .ne. 0d0) then                    ! link flows
               k1 = ln(1,L)
               k2 = ln(2,L)
               ucxeu(k1) = ucxeu(k1) - wcx1(LL)*ustokes(L)
               ucyeu(k1) = ucyeu(k1) - wcy1(LL)*ustokes(L)
               ucxeu(k2) = ucxeu(k2) - wcx2(LL)*ustokes(L)
               ucyeu(k2) = ucyeu(k2) - wcy2(LL)*ustokes(L)
            endif
         enddo
      enddo
   endif
end subroutine getucxucyeuler


!> Computes the velocity magnitude in cell centers, typically used for output only.
!! All arrays via input arguments, not via use m_flow.
subroutine getucmag(N, ucxi, ucyi, ucmago)
   use m_flowgeom, only: ndx
   use m_flow, only: kmx

   implicit none
   integer,          intent(in   ) :: N         !< Length of cell arrays (probably ndkx)
   double precision, intent(in   ) :: ucxi(N)   !< Input array containing cell centered x-velocities.
   double precision, intent(in   ) :: ucyi(N)   !< Input array containing cell centered y-velocities.
   double precision, intent(  out) :: ucmago(N) !< Output array containing cell centered velocity magnitudes.

   integer          :: kk,k,kb,kt

   !call realloc(ucmag, ndkx, keepExisting = .false.)
   ! NOTE: workx/y contain the velocity vectors, possibly corrected into Eulerian velocities (see getucxucyeuler).
   if ( kmx.gt.0 ) then
      do kk=1,ndx
         call getkbotktop(kk,kb,kt)
         do k = kb,kt
            ucmago(k) = sqrt(ucxi(k)**2 + ucyi(k)**2) ! TODO: this does not include vertical/w-component now.
         end do
      end do
   else
      do kk = 1,ndx
            ucmago(kk) = sqrt(ucxi(kk)**2 + ucyi(kk)**2)
      enddo
   end if

end subroutine getucmag


 subroutine setlinktocenterweights()                 ! set center related linkxy weights

 use m_flow
 use m_netw
 use m_flowgeom
 use m_sferic

 implicit none

 double precision       :: wud, wuL1, wuL2, wuk, cs, sn
 integer                :: k, L, ierr, n, kk, n12, lnxmax
 integer                :: k1, k2, k3, k4, nn, LL, jaclosedcorner

 double precision       :: xloc, yloc, beta, aa1, wcw, alf
 double precision, allocatable       :: wwL(:)

 double precision, allocatable       :: wcxy (:,:)   ! center weight factors (2,ndx) , only for normalising
 double precision, allocatable       :: wc   (:)     ! center weight factors (ndx)   , only for normalising

 double precision, external :: lin2nodx, lin2nody

 if ( allocated (wcx1) )  deallocate(wcx1,wcy1,wcx2,wcy2)
 if ( allocated (wcxy ) ) deallocate(wcxy )
 if ( allocated (wcL  ) ) deallocate(wcL )

 allocate ( wcx1(lnx) , stat  = ierr) ; wcx1 = 0
 call aerr('wcx1(lnx)', ierr, lnx)
 allocate ( wcy1(lnx) , stat  = ierr) ; wcy1 = 0
 call aerr('wcy1(lnx)', ierr, lnx)
 allocate ( wcx2(lnx) , stat  = ierr) ; wcx2 = 0
 call aerr('wcx2(lnx)', ierr, lnx)
 allocate ( wcy2(lnx) , stat  = ierr) ; wcy2 = 0
 call aerr('wcy2(lnx)', ierr, lnx)
 allocate ( wcxy (2,ndx) , stat  = ierr) ; wcxy  = 0
 call aerr('wcxy (2,ndx)', ierr, 2*ndx)
 allocate ( wcL  (2,Lnx) , stat  = ierr) ; wcL   = 0
 call aerr('wcL  (2,Lnx)', ierr, 2*Lnx)
 allocate ( wc     (ndx) , stat  = ierr) ; wc    = 0
 call aerr('wc     (ndx)', ierr, ndx)

 do L = 1, lnx

    if (kcu(L) == 3) cycle ! no contribution from 1D2D internal links

    k1   = ln(1,L) ; k2 = ln(2,L)
    wud  = wu(L)*dx(L)
!    cs   = csu(L)
!    sn   = snu(L)

    wuL1  = acl(L)*wud
    wcL  (1,L ) = wuL1
    wc     (k1) = wc(k1) + wuL1

    wuL2  = (1d0-acl(L))*wud
    wcL  (2, L) = wuL2
    wc     (k2) = wc(k2) + wuL2

    cs = lin2nodx(L,1,csu(L),snu(L))
    sn = lin2nody(L,1,csu(L),snu(L))
    wcx1(L)     = cs*wuL1
    wcy1(L)     = sn*wuL1

    cs = lin2nodx(L,2,csu(L),snu(L))
    sn = lin2nody(L,2,csu(L),snu(L))
    wcx2(L)     = cs*wuL2
    wcy2(L)     = sn*wuL2

    wcxy (1,k1) = wcxy (1,k1) + abs(wcx1(L))
    wcxy (2,k1) = wcxy (2,k1) + abs(wcy1(L))

    wcxy (1,k2) = wcxy (1,k2) + abs(wcx2(L))
    wcxy (2,k2) = wcxy (2,k2) + abs(wcy2(L))
 enddo

 lnxmax = 0
 do n   = 1, mxwalls                                        ! wall contribution to scalar linktocenterweights
    k1  = walls(1,n)
    aa1 = 2d0*walls(17,n)
    wcw = 0d0
    lnxmax = max(lnxmax,  nd(k1)%lnx)
    call realloc(wwL, lnxmax, keepExisting = .false.)
    do kk = 1,size(nd(k1)%ln)
       LL = iabs(nd(k1)%ln(kk))
       n12 = 1 ; alf = acL(LL)
       if (k1 .ne. ln(1,LL) ) then
          n12 = 2 ; alf = 1d0-acL(LL)
       endif
       wuL1    =  alf*dx(LL)*wu(LL)
       cs      =  walls(8,n) ! outward positive
       sn      = -walls(7,n)
       wwL(kk) = abs(cs*csu(LL) + sn*snu(LL))
       wwL(kk) = wwL(kk)*wuL1
       wcw     = wcw + wwL(kk)
    enddo
    if (wcw > 0d0) then
       wc(k1) = wc(k1) + aa1
       do kk = 1,size(nd(k1)%ln)
          LL = iabs(nd(k1)%ln(kk))
          n12 = 1 ; alf = acL(LL)
          if (k1 .ne. ln(1,LL) ) then
             n12 = 2 ; alf = 1d0-acL(LL)
          endif
          wcL(n12,LL) = wcL(n12,LL) + wwL(kk)*aa1/wcw
       enddo
    endif
 enddo

 do L = 1, lnx
    k1 = ln(1,L) ; k2 = ln(2,L)
    if (iabs(kcu(L)) == 2 .or. iabs(kcu(L)) == 4) then      ! 2D links and 1D2D lateral links
       IF (kfs(K1) == 0) THEN                               ! kfs temporarily used as cutcell flag, set in cutcelwu
          wcx1(L) = wcx1(L)*bai(k1)
          wcy1(L) = wcy1(L)*bai(k1)
       ELSE
          if (wcxy(1,k1) .ne. 0) wcx1(L) = wcx1(L)/wcxy(1,k1)
          if (wcxy(2,k1) .ne. 0) wcy1(L) = wcy1(L)/wcxy(2,k1)
       ENDIF

       IF (kfs(K2) == 0) THEN
          wcx2(L) = wcx2(L)*bai(k2)
          wcy2(L) = wcy2(L)*bai(k2)
       ELSE
          if (wcxy(1,k2) .ne. 0) wcx2(L) = wcx2(L)/wcxy(1,k2)
          if (wcxy(2,k2) .ne. 0) wcy2(L) = wcy2(L)/wcxy(2,k2)
       ENDIF
    else
       wcx1(L) = wcx1(L)*bai(k1) !if (wcxy(2,k1) .ne. 0) /wcxy(2,k1)
       wcy1(L) = wcy1(L)*bai(k1) !if (wcxy(1,k1) .ne. 0) /wcxy(1,k1)
       wcx2(L) = wcx2(L)*bai(k2) !if (wcxy(2,k2) .ne. 0) /wcxy(2,k2)
       wcy2(L) = wcy2(L)*bai(k2) !if (wcxy(1,k2) .ne. 0) /wcxy(1,k2)
    endif
    if (wc(k1) > 0d0) wcL(1,L) = wcL(1,L) / wc(k1)
    if (wc(k2) > 0d0) wcL(2,L) = wcL(2,L) / wc(k2)

 enddo

 deallocate (wcxy, wc)
 if (allocated(wwL)) deallocate(wwL)

 kfs = 0

 end subroutine setlinktocenterweights



 subroutine setlinktocornerweights()                 ! set corner related link x- and y weights

 use m_flow
 use m_netw
 use m_flowgeom
 use geometry_module, only: normalin
 use m_sferic, only: jsferic, jasfer3D
 use m_missing, only : dmiss, dxymis
 use gridoperations

 implicit none

 double precision       :: ax, ay, wuL, wud, csa, sna
 integer                :: k, L, ierr, nx
 integer                :: k1, k2, k3, k4
 double precision       :: ff = 5d0
 integer                :: ka, kb, LL

 double precision,               allocatable :: wcnxy(:,:)  ! corner weight factors (2,numk) , only for normalising
 integer,          dimension(:), allocatable :: jacorner    ! corner node (1) or not (0), dim(numk)

 double precision, external                  :: lin2corx, lin2cory


 if ( allocated (wcnx3) ) deallocate(wcnx3,wcny3,wcnx4,wcny4)
 if ( allocated (wcnxy ) ) deallocate(wcnxy )
 allocate ( wcnx3(lnx)  , stat  = ierr) ; wcnx3 = 0
 call aerr('wcnx3(lnx) ', ierr, lnx)
 allocate ( wcny3(lnx)  , stat  = ierr) ; wcny3 = 0
 call aerr('wcny3(lnx) ', ierr, lnx)
 allocate ( wcnx4(lnx)  , stat  = ierr) ; wcnx4 = 0
 call aerr('wcnx4(lnx) ', ierr, lnx)
 allocate ( wcny4(lnx)  , stat  = ierr) ; wcny4 = 0
 call aerr('wcny4(lnx) ', ierr, lnx)

 if (kmx > 0 .and. jased > 0 .and. jased < 4) then
    if ( allocated (wcLn) ) deallocate(wcLn)
    allocate ( wcLn(2,lnx) , stat  = ierr) ; wcLn = 0
    call aerr('wcLn(2,lnx)', ierr, lnx)
 endif

 nx = 0
 do L = lnx1D+1, lnx
    k3 = lncn(1,L) ; k4 = lncn(2,L)
    nx = max(nx,k3,k4)
 enddo
 allocate ( wcnxy(3,numk) , stat  = ierr) ; wcnxy  = 0
 call aerr('wcnxy(3,numk)', ierr, 3*numk)

 allocate(  jacorner(numk), stat=ierr)
 jacorner = 0
 call aerr('jacorner(numk)', ierr, numk)

 do L = lnx1D+1, lnx
    if (abs(kcu(L)) == 1) then
       cycle
    endif

    wud  = wu(L)*dx(L)
    k3 = lncn(1,L) ; k4 = lncn(2,L)
    wcnxy(3,k3)= wcnxy(3,k3) + wud
    wcnxy(3,k4)= wcnxy(3,k4) + wud

    if (kmx > 0 .and. jased > 0 .and. jased < 4) then
       wcLn(1,L) = wud
       wcLn(2,L) = wud
    endif

!    csa  = max( 1d-6,abs(csu(L)) )
!    sna  = max( 1d-6,abs(snu(L)) )
    csa = max(1d-6,abs(lin2corx(L,1,csu(L),snu(L))))
    sna = max(1d-6,abs(lin2cory(L,1,csu(L),snu(L))))


    wuL  = acn(1,L)*wud
    if (jacomp == 1) then
       ax = csa*wuL
       ay = sna*wuL
    else
       ax = 0.5d0*wuL
       ay = ax
    endif
    wcnx3(L) = ax
    wcny3(L) = ay

    wcnxy(1,k3) = wcnxy (1,k3) + ax
    wcnxy(2,k3) = wcnxy (2,k3) + ay
!    wcnxy(1,k3) = wcnxy(1,k3) + lin2corx(L,1,ax,ay)
!    wcnxy(2,k3) = wcnxy(2,k3) + lin2cory(L,1,ax,ay)


!    csa  = max( 1d-6,abs(csu(L)) )
!    sna  = max( 1d-6,abs(snu(L)) )
    csa = max(1d-6,abs(lin2corx(L,2,csu(L),snu(L))))
    sna = max(1d-6,abs(lin2cory(L,2,csu(L),snu(L))))


    wuL  = acn(2,L)*wud
    if (jacomp == 1) then
       ax = csa*wuL
       ay = sna*wuL
    else
       ax = 0.5d0*wuL
       ay = ax
    endif
    wcnx4(L) = ax
    wcny4(L) = ay
    wcnxy (1,k4) = wcnxy (1,k4) + ax
    wcnxy (2,k4) = wcnxy (2,k4) + ay
!    wcnxy(1,k4) = wcnxy(1,k4) + lin2corx(L,2,ax,ay)
!    wcnxy(2,k4) = wcnxy(2,k4) + lin2cory(L,2,ax,ay)
 enddo


! count number of attached and closed boundary links, and store it temporarily in jacorner
 jacorner = 0
 do L=1,numL
    if ( ( kn(3,L).eq.2 .and. lnn(L).eq.1 .and. lne2ln(L).le.0 ) ) then
       k1 = kn(1,L)
       k2 = kn(2,L)
       jacorner(k1) = jacorner(k1) + 1
       jacorner(k2) = jacorner(k2) + 1
    end if
 end do

! post-process corner indicator: use ALL boundary nodes, and project on closed boundary later
!   used to be: nmk(k) - int(wcnxy (3,k)) == 2
 do k=1,numk
    if ( jacorner(k).ge.1 ) then
       jacorner(k) = 1
    else
       jacorner(k) = 0
    end if
 end do

 ! exclude all nodes with a disabled netlink attached from the projection
 do L=1,numL
    if ( kn(3,L).eq.0 ) then
       k1 = kn(1,L)
       k2 = kn(2,L)
       jacorner(k1) = 0
       jacorner(k2) = 0
    end if
 end do

 do L = lnx1D+1, lnx
    if (abs(kcu(L)) == 1) cycle
    k3 = lncn(1,L) ; k4 = lncn(2,L)
    if (wcnxy(1,k3) .ne. 0) wcnx3(L) = wcnx3(L)/wcnxy(1,k3)
    if (wcnxy(2,k3) .ne. 0) wcny3(L) = wcny3(L)/wcnxy(2,k3)
    if (wcnxy(1,k4) .ne. 0) wcnx4(L) = wcnx4(L)/wcnxy(1,k4)
    if (wcnxy(2,k4) .ne. 0) wcny4(L) = wcny4(L)/wcnxy(2,k4)

    if (kmx > 0 .and. jased > 0 .and. jased < 4) then
       if (wcnxy(3,k3) .ne. 0) wcLn(1,L) = wcLn(1,L) / wcnxy(3,k3)
       if (wcnxy(3,k4) .ne. 0) wcLn(2,L) = wcLn(2,L) / wcnxy(3,k4)
    endif

    if (irov == 2) then  ! zero cornervelocities for no-slip

       if (int(wcnxy (3,k3)) .ne. nmk(k3) ) then
               wcnx3(L) = 0d0 ; wcny3(L) = 0d0
       endif

       if (int(wcnxy (3,k4)) .ne. nmk(k4) ) then
               wcnx4(L) = 0d0 ; wcny4(L) = 0d0
       endif

    endif

 enddo

 nrcnw = 0
 do k  = 1,numk                                 ! set up admin for corner velocity alignment at closed walls

!    if ( nmk(k) - int(wcnxy (3,k)) == 2 ) then ! two more netlinks than flowlinks to this corner
     if ( jacorner(k).eq.1 ) then
        nrcnw = nrcnw + 1                       ! cnw = cornerwall point (netnode)
    endif
 enddo

 if ( allocated  (cscnw) ) deallocate(cscnw,sncnw,kcnw,nwalcnw,sfcnw)
 allocate ( cscnw(nrcnw) , stat  = ierr) ; cscnw = 0
 call aerr('cscnw(nrcnw)', ierr, nrcnw )
 allocate ( sncnw(nrcnw) , stat  = ierr) ; sncnw = 0
 call aerr('sncnw(nrcnw)', ierr, nrcnw )
 allocate (  kcnw(nrcnw) , stat  = ierr) ; kcnw  = 0
 call aerr(' kcnw(nrcnw)', ierr,  nrcnw )
 allocate (  nwalcnw(2,nrcnw) , stat  = ierr) ; nwalcnw = 0
 call aerr(' nwalcnw(2,nrcnw)', ierr,  2*nrcnw )
 allocate (  sfcnw(nrcnw) , stat  = ierr) ; sfcnw  = 0
 call aerr(' sfcnw(nrcnw)', ierr,  nrcnw)

 nrcnw = 0
 do k  = 1,numk                                ! set up admin for corner velocity alignment at closed walls

!    if ( nmk(k) - int(wcnxy (3,k)) == 2 ) then ! two more netlinks than flowlinks to this corner
    if ( jacorner(k).eq.1 ) then
       nrcnw = nrcnw + 1                       ! cnw = cornerwall point (netnode)
       kcnw(nrcnw) = k
       ka = 0 ; kb = 0
       do LL = 1,nmk(k)
          L  = nod(k)%lin(LL)                  ! netstuff
          if (lnn(L) == 1) then
             if (ka == 0) then
                if ( lne2ln(L).le.0 .and. kn(3,L).ne.0 ) then ! SPvdP: closed boundaries used in determination of normal vector only
                   call othernode(k,L,ka) ! use other node on closed boundary
                else
                   ka = k  ! use own node on open boundary
                endif
             else if (kb == 0 .and. kn(3,L).ne.0 ) then
                 if ( lne2ln(L).le.0 ) then ! SPvdP: closed boundaries used in determination of normal vector only
                    call othernode(k,L,kb) ! use other node on closed boundary
                 else
                    kb = k  ! use own node on closed boundary
                endif
             endif
          endif
       enddo
       if (ka .ne. 0 .and. kb .ne. 0 .and. ka.ne.kb ) then     ! only for 2D netnodes
          call normalin(xk(ka), yk(ka), xk(kb), yk(kb), csa, sna, xk(k), yk(k), jsferic, jasfer3D, dxymis)
          cscnw(nrcnw) = csa
          sncnw(nrcnw) = sna
       endif

    endif

 enddo

 deallocate (wcnxy, acn, jacorner)

 end subroutine setlinktocornerweights


 subroutine setcornervelocities()                    ! set corner related velocity x- and y components

 use m_flow
 use m_netw
 use m_flowgeom
 use m_sferic

 implicit none

 integer                    :: L, k1, k2, k3, k4, k, kk, LL, Lb, Lt, kw
 integer                    :: m, n
 double precision           :: uLx, uLy, csk, snk, sg

 double precision, external :: nod2linx, nod2liny, lin2corx, lin2cory

 ucnx = 0 ; ucny = 0

 if (kmx == 0) then

    if (jacomp <= 1) then

       do L   = lnx1D+1,lnx
          k1  = ln  (1,L) ; k2 = ln  (2,L)
          k3  = lncn(1,L) ; k4 = lncn(2,L)
          if (jasfer3D == 0) then
             uLx = 0.5d0*( ucx(k1) + ucx(k2) )
             uLy = 0.5d0*( ucy(k1) + ucy(k2) )
          else
             uLx = 0.5d0*( nod2linx(L,1,ucx(k1),ucy(k1)) + nod2linx(L,2,ucx(k2),ucy(k2)))
             uLy = 0.5d0*( nod2liny(L,1,ucx(k1),ucy(k1)) + nod2liny(L,2,ucx(k2),ucy(k2)))
          endif

          ucnx(k3) = ucnx(k3) + uLx*wcnx3(L)
          ucny(k3) = ucny(k3) + uLy*wcny3(L)
          ucnx(k4) = ucnx(k4) + uLx*wcnx4(L)
          ucny(k4) = ucny(k4) + uLy*wcny4(L)
       enddo

    else                                                ! use banf instead

       do m = 1, mxban                                  ! bz based on netnodes area
          k = nban(1,m)
          n = nban(2,m)
          ucnx(k) = ucnx(k) + banf(m)*ucx(n)
          ucny(k) = ucny(k) + banf(m)*ucy(n)
       enddo
       ucnx = ucnx / ban
       ucny = ucny / ban

    endif

    do kw   = 1, nrcnw                                   ! cornervelocities aligned with closed walls
       csk  = cscnw(kw)
       snk  = sncnw(kw)
       k    = kcnw (kw)
       sg   = csk*ucnx(k) + snk*ucny(k)
       ucnx(k) = sg*csk
       ucny(k) = sg*snk
    enddo

 else

    if (jased > 0 .and. jased < 4) then
       ustbc = 0d0
    endif

    if (jacomp == jacomp ) then ! for now in 3D use org method

       do LL   = lnx1D+1,lnx
          if (abs(kcu(LL)) == 2) then
             call getLbotLtop(LL,Lb, Lt)
             do L = Lb,Lt
                k1  = ln  (1,L) ; k2 = ln  (2,L)
                k3  = lncn(1,L) ; k4 = lncn(2,L)
                if (jasfer3D == 0) then
                   uLx = 0.5d0*( ucx(k1) + ucx(k2) )
                   uLy = 0.5d0*( ucy(k1) + ucy(k2) )
                else
                   uLx = 0.5d0*( nod2linx(LL,1,ucx(k1),ucy(k1)) + nod2linx(LL,2,ucx(k2),ucy(k2)))
                   uLy = 0.5d0*( nod2liny(LL,1,ucx(k1),ucy(k1)) + nod2liny(LL,2,ucx(k2),ucy(k2)))
                endif

                ucnx(k3) = ucnx(k3) + uLx*wcnx3(LL)
                ucny(k3) = ucny(k3) + uLy*wcny3(LL)
                ucnx(k4) = ucnx(k4) + uLx*wcnx4(LL)
                ucny(k4) = ucny(k4) + uLy*wcny4(LL)
                if (L == Lb) then
                   k3 = lncn(1,LL) ;  k4 = lncn(2,LL)
                   ucnx(k3)  = ucnx(k3)  + uLx*wcnx3(LL)
                   ucny(k3)  = ucny(k3)  + uLy*wcny3(LL)
                   ucnx(k4)  = ucnx(k4)  + uLx*wcnx4(LL)
                   ucny(k4)  = ucny(k4)  + uLy*wcny4(LL)
                   if (jased > 0 .and. jased < 4) then
                      ustbc(k3) = ustbc(k3) + ustb(LL)*wcLn(1,LL)
                      ustbc(k4) = ustbc(k4) + ustb(LL)*wcLn(2,LL)
                   endif
                endif
             enddo
          endif
       enddo

    else

    endif

    do kw   = 1, nrcnw                                 ! cornervelocities aligned with closed walls
       kk   = kcnw (kw)
       csk  = cscnw(kw)
       snk  = sncnw(kw)
       do k = kbotc(kk), kbotc(kk) + kmxc(kk) - 1
          sg      = csk*ucnx(k) + snk*ucny(k)
          ucnx(k) = sg*csk
          ucny(k) = sg*snk
       enddo
       sg       = csk*ucnx(kk) + snk*ucny(kk)
       ucnx(kk) = sg*csk
       ucny(kk) = sg*snk
    enddo

 endif

 end subroutine setcornervelocities


 subroutine linkstocenters(vnod,vlin)                    ! set flow node value based on flow link values scalar

 use m_flow
 use m_netw
 use m_flowgeom

 implicit none

 double precision       :: vlin(lnkx)
 real                   :: vnod(ndkx)
 integer                :: L, k1, k2, LL, Lb, Lt, kk, kb, kt, k

 vnod = 0d0

 if (kmx == 0) then
    do L   = 1,lnx
       k1  = ln  (1,L) ; k2 = ln  (2,L)
       vnod(k1) = vnod(k1) + vlin(L)*wcL(1,L)
       vnod(k2) = vnod(k2) + vlin(L)*wcL(2,L)
    enddo
 else
    do LL  = 1,lnx
       call getLbotLtop(LL,Lb,Lt)
       do L = Lb,Lt
          k1  = ln  (1,L) ; k2 = ln  (2,L)
          vnod(k1) = vnod(k1) + vlin(L)*wcL(1,LL)
          vnod(k2) = vnod(k2) + vlin(L)*wcL(2,LL)
       enddo
    enddo

    !$OMP PARALLEL DO                                          &
    !$OMP PRIVATE(kk,kb,kt,k)
    do kk = 1,ndx
       call getkbotktop(kk,kb,kt)
       do k = kt+1, kb+kmxn(kk)-1
          vnod(k) = vnod(kt)
       enddo
    enddo
    !$OMP END PARALLEL DO
 endif
 end subroutine linkstocenters

  subroutine linkstocenterstwodoubles(vnod,vlin)                    ! set flow node value based on flow link values scalar

 use m_flow
 use m_netw
 use m_flowgeom

 implicit none

 double precision       :: vlin(lnkx)
 double precision       :: vnod(ndkx)
 integer                :: L, k1, k2, LL, Lb, Lt, kk, kb, kt, k

 vnod = 0d0

 if (kmx == 0) then
    do L   = 1,lnx
       k1  = ln  (1,L) ; k2 = ln  (2,L)
       vnod(k1) = vnod(k1) + vlin(L)*wcL(1,L)
       vnod(k2) = vnod(k2) + vlin(L)*wcL(2,L)
    enddo
 else
    do LL  = 1,lnx
       call getLbotLtop(LL,Lb,Lt)
       do L = Lb,Lt
          k1  = ln  (1,L) ; k2 = ln  (2,L)
          vnod(k1) = vnod(k1) + vlin(L)*wcL(1,LL)
          vnod(k2) = vnod(k2) + vlin(L)*wcL(2,LL)
       enddo
    enddo

    !$OMP PARALLEL DO                                          &
    !$OMP PRIVATE(kk,kb,kt,k)
    do kk = 1,ndx
       call getkbotktop(kk,kb,kt)
       do k = kt+1, kb+kmxn(kk)-1
          vnod(k) = vnod(kt)
       enddo
    enddo
    !$OMP END PARALLEL DO
 endif
 end subroutine linkstocenterstwodoubles

 subroutine linkstocenterstwodoubles2(vnod,vlin,vlin2)      ! both vlin and vlin2 to vnod(1,* and vnod(2,*
 use m_flow
 use m_netw
 use m_flowgeom

 implicit none

 double precision       :: vlin(lnkx), vlin2(lnkx)
 double precision       :: vnod(2,ndkx)
 integer                :: L, k1, k2, LL, Lb, Lt, kk, kb, kt, k

 vnod = 0d0
 if (kmx == 0) then
    do L   = 1,lnx
       k1  = ln  (1,L) ; k2 = ln  (2,L)
       vnod(1,k1) = vnod(1,k1) + vlin (L)*wcL(1,L)
       vnod(1,k2) = vnod(1,k2) + vlin (L)*wcL(2,L)
       vnod(2,k1) = vnod(2,k1) + vlin2(L)*wcL(1,L)
       vnod(2,k2) = vnod(2,k2) + vlin2(L)*wcL(2,L)
    enddo
 else
    do LL  = 1,lnx
       call getLbotLtop(LL,Lb,Lt)
       do L = Lb,Lt
          k1  = ln  (1,L) ; k2 = ln  (2,L)
          vnod(1,k1) = vnod(1,k1) + vlin (L)*wcL(1,LL)
          vnod(1,k2) = vnod(1,k2) + vlin (L)*wcL(2,LL)
          vnod(2,k1) = vnod(2,k1) + vlin2(L)*wcL(1,LL)
          vnod(2,k2) = vnod(2,k2) + vlin2(L)*wcL(2,LL)
       enddo
    enddo

    !$OMP PARALLEL DO                                          &
    !$OMP PRIVATE(kk,kb,kt,k)
    do kk = 1,ndx
       call getkbotktop(kk,kb,kt)
       do k = kt+1, kb+kmxn(kk)-1
          vnod(1,k) = vnod(1,kt)
          vnod(2,k) = vnod(2,kt)
       enddo
    enddo
    !$OMP END PARALLEL DO
 endif
 end subroutine linkstocenterstwodoubles2

 subroutine setcentertolinkorientations()
    use m_flowgeom
    use network_data, only: xk, yk
    use m_sferic
    use m_alloc
    use unstruc_messages
    use geometry_module, only :half, spher2locvec
    use m_missing, only : dmiss

    implicit none

    double precision               :: xL, yL

    integer                        :: i, k, k3, k4
    integer                        :: L

    integer                        :: ierr

    double precision, parameter    :: dtol = 1d-8

    if ( allocated (csb) ) deallocate(csb)
    if ( allocated (snb) ) deallocate(snb)

    if ( jsferic.eq.0 .or. jasfer3D.eq.0 ) return

    allocate ( csb(2,Lnx) , stat  = ierr) ; csb = 1d0
    call aerr('csb(2,Lnx)', ierr, 2*Lnx)
    allocate ( snb(2,Lnx) , stat  = ierr) ; snb = 0d0
    call aerr('snb(2,Lnx)', ierr, 2*Lnx)

    do L=1,Lnx
       if ( L.eq.12 ) then
          continue
       end if
       k3    = lncn(1,L)
       k4    = lncn(2,L)

!      compute flowlink midpoint coordinates (xL,yL)
       call half(xk(k3),yk(k3),xk(k4),yk(k4),xL,yL, jsferic, jasfer3D)

       do i=1,2
          k = ln(i,L)

!         compute orientation w.r.t. link mid point
          call spher2locvec(xz(k),yz(k),1,(/xL/),(/yL/),(/1d0/),(/0d0/),csb(i,L),snb(i,L),jsferic, jasfer3D, dmiss)
       end do
    end do

    return
 end subroutine setcentertolinkorientations



 subroutine setcornertolinkorientations()
    use m_flowgeom
    use network_data, only: xk, yk
    use m_sferic
    use m_alloc
    use unstruc_messages
    use m_missing, only : dmiss
    use geometry_module, only :half, spher2locvec
    implicit none

    double precision               :: xL, yL

    integer                        :: i, k, k3, k4
    integer                        :: L

    integer                        :: ierr

    double precision, parameter    :: dtol = 1d-8

    if ( allocated (csbn) ) deallocate(csbn)
    if ( allocated (snbn) ) deallocate(snbn)

    if ( jsferic.eq.0 .or. jasfer3D.eq.0 ) return

    allocate ( csbn(2,Lnx) , stat  = ierr) ; csbn = 1d0
    call aerr('csbn(2,Lnx)', ierr, 2*Lnx)
    allocate ( snbn(2,Lnx) , stat  = ierr) ; snbn = 0d0
    call aerr('snbn(2,Lnx)', ierr, 2*Lnx)

    do L=1,Lnx
       k3    = lncn(1,L)
       k4    = lncn(2,L)

!      compute flowlink midpoint coordinates (xL,yL)
       call half(xk(k3),yk(k3),xk(k4),yk(k4),xL,yL,  jsferic, jasfer3D)


       if ( yk(k3).eq.90d0 .or. yk(k4).eq.90d0 ) then
          continue
       end if

!      compute orientation w.r.t. link mid point
       call spher2locvec(xk(k3),yk(3),1,(/xL/),(/yL/),(/1d0/),(/0d0/),csbn(1,L),snbn(1,L), jsferic, jasfer3D, dmiss)
       call spher2locvec(xk(k4),yk(4),1,(/xL/),(/yL/),(/1d0/),(/0d0/),csbn(2,L),snbn(2,L), jsferic, jasfer3D, dmiss)
    end do

    return
 end subroutine setcornertolinkorientations


 !> set wall to flowlinks and wall to flownode oientations
 subroutine setwallorientations()
    use m_flowgeom
    use network_data, only: xk, yk
    use m_sferic
    use m_alloc
    use m_missing, only : dmiss
    use geometry_module, only :half, spher2locvec

    implicit none

    double precision :: xh, yh

    integer          :: k1, k3, k4
    integer          :: L1, L2
    integer          :: nw

    integer          :: ierr

    if ( allocated (csbw) ) deallocate(csbw)
    if ( allocated (snbw) ) deallocate(snbw)

    if ( allocated (csbwn) ) deallocate(csbwn)
    if ( allocated (snbwn) ) deallocate(snbwn)

    if ( jsferic.eq.0 .or. jasfer3D.eq.0 ) return

    allocate ( csbw(2,mxwalls) , stat  = ierr) ; csbw = 1d0
    call aerr('csbw(2,mxwalls)', ierr, 2*Lnx)
    allocate ( snbw(2,mxwalls) , stat  = ierr) ; snbw = 0d0
    call aerr('snbw(2,mxwalls)', ierr, 2*Lnx)


    allocate ( csbwn(mxwalls) , stat  = ierr) ; csbwn = 1d0
    call aerr('csbwn(mxwalls)', ierr, 2*Lnx)
    allocate ( snbwn(mxwalls) , stat  = ierr) ; snbwn = 0d0
    call aerr('snbwn(mxwalls)', ierr, 2*Lnx)

    do nw=1,mxwalls
       k1 = walls(1,nw) ! inner flownode
       k3 = walls(2,nw) ! first corner (netnode)
       k4 = walls(3,nw) ! second corner (netnode)
       L1 = walls(4,nw) ! first flowlink
       L2 = walls(5,nw) ! second flowlink

!      compute wall midpoint coordinates
       call half(xk(k3),yk(k3),xk(k4),yk(k4),xh,yh, jsferic, jasfer3D)

!      compute orientation of flowlinks w.r.t. wall mid point
       if ( L1.gt.0 ) then
          call spher2locvec(xu(L1),yu(L1),1,(/xh/),(/yh/),(/1d0/),(/0d0/),csbw(1,nw),snbw(1,nw),jsferic, jasfer3D, dmiss)
       end if
       if ( L2.gt.0 ) then
          call spher2locvec(xu(L2),yu(L2),1,(/xh/),(/yh/),(/1d0/),(/0d0/),csbw(2,nw),snbw(2,nw),jsferic, jasfer3D, dmiss)
       end if

!      compute orientation of flownode w.r.t. wall mid point
       call spher2locvec(xz(k1),yz(k1),1,(/xh/),(/yh/),(/1d0/),(/0d0/),csbwn(nw),snbwn(nw),jsferic, jasfer3D, dmiss)
    end do

    return
 end subroutine setwallorientations


 !> compute viscous flux balance of cell ln (n12,L) in coordinate frame of L
 double precision function horvic(n12,L)             ! horizontal viscosity term
 use m_flow
 use m_flowgeom
 use m_missing
 use m_sferic
 implicit none

 integer :: L                                        ! in direction of link L
 integer :: n12                                      ! find hor visc term for cell 1 or 2

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12, k1, k2, k3, k4, isig                ! relevant node, 1 or 2
 double precision :: cs, sn, csL, snL
 double precision :: duxdn, duydn, duxdt, duydt, txx, tyy, c11,c12,c22, vicl

 double precision :: txx_k12, tyy_k12
 integer          :: ik1, ik2, in3, in4

 double precision, external :: nod2linx, nod2liny, lin2nodx, lin2nody, cor2linx, cor2liny

 horvic = 0d0
 csL    = csu(L) ; snL = snu(L)
 k12    = ln(n12,L)


 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links

    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if (LLLL .ne. L) then

       if (LLL < 0) then
          cs =  csu(LLLL)
          sn =  snu(LLLL)
          k1 = ln  (1,LLLL) ; k2 = ln  (2,LLLL)    ! k1 = k12
          k3 = lncn(1,LLLL) ; k4 = lncn(2,LLLL)
          ik1 = 1
          ik2 = 2
          in3 = 1
          in4 = 2
       else
          cs = -csu(LLLL)
          sn = -snu(LLLL)
          k1 = ln  (2,LLLL) ; k2 = ln  (1,LLLL)    ! k1 = k12
          k3 = lncn(2,LLLL) ; k4 = lncn(1,LLLL)
          ik1 = 2
          ik2 = 1
          in3 = 2
          in4 = 1
       endif

       if (jasfer3D == 0) then
          duxdn =  ( ucx(k2) -  ucx(k1)) * dxi(LLLL)
          duydn =  ( ucy(k2) -  ucy(k1)) * dxi(LLLL)
          duxdt =  (ucnx(k4) - ucnx(k3)) * wui(LLLL)
          duydt =  (ucny(k4) - ucny(k3)) * wui(LLLL)
       else
          duxdn = ( nod2linx(LLLL,ik2,ucx(k2),ucy(k2))-nod2linx(LLLL,ik1,ucx(k1),ucy(k1)) ) * dxi(LLLL)
          duydn = ( nod2liny(LLLL,ik2,ucx(k2),ucy(k2))-nod2liny(LLLL,ik1,ucx(k1),ucy(k1)) ) * dxi(LLLL)
          duxdt = ( cor2linx(LLLL,in4,ucnx(k4),ucny(k4))-cor2linx(LLLL,in3,ucnx(k3),ucny(k3)) ) * wui(LLLL)
          duydt = ( cor2liny(LLLL,in4,ucnx(k4),ucny(k4))-cor2liny(LLLL,in3,ucnx(k3),ucny(k3)) ) * wui(LLLL)
       endif

       c11   = cs*cs ; c12=cs*sn ; c22=sn*sn
       txx   = duxdn + c11*duxdn + c12*(duydn - duxdt) - c22*duydt
       tyy   = duydn + c11*duxdt + c12*(duxdn + duydt) + c22*duydn

       if (javiusp == 1) then
           vicl = viusp(LLLL)
       else
           vicl = vicouv
       endif


       txx_k12 = lin2nodx(LLLL,ik1,txx,tyy)
       tyy_k12 = lin2nody(LLLL,ik1,txx,tyy)

       if (istresstyp == 4) then
          if (jasfer3D == 0) then
             horvic = horvic + ( txx*csl + tyy*snl )*wu(LLLL)*vicL
          else
             horvic = horvic + ( nod2linx(L,n12,txx_k12,tyy_k12)*csl + nod2liny(L,n12,txx_k12,tyy_k12)*snl )*wu(LLLL)*vicL
          endif

       else if (istresstyp == 5) then  ! volume averaged
          ! horvic = horvic + ( txx*csl + tyy*snl )*au(LLLL)*vicL
          horvic = horvic + ( nod2linx(L,n12,txx_k12,tyy_k12)*csl + nod2liny(L,n12,txx_k12,tyy_k12)*snl )*au(LLLL)*vicL
       endif

    endif

 enddo
 horvic = horvic*bai(k12)
 if (istresstyp == 5) then  ! volume averaged
    horvic = horvic / hs(k12)
 endif
 end function Horvic


 double precision function horvic3(n12,L)             ! horizontal viscosity term, out of face normal and tang comp's
 use m_flow
 use m_flowgeom
 use m_missing
 implicit none

 integer :: L                                        ! in direction of link L
 integer :: n12                                      ! find hor visc term for cell 1 or 2

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12, k1, k2, k3, k4, isig                ! relevant node, 1 or 2
 double precision :: cs, sn, csL, snL, vicl
 double precision :: duxdn, duydn, duxdt, duydt, txx, tyy, c, s, cs2
 double precision :: uuk1, vvk1, uuk2, vvk2, uuk3, uuk4, dux, duy, dvx, tuu, tvv

 double precision :: txx_k12, tyy_k12

 integer          :: ik1, ik2, in3, in4

 double precision, external :: nod2linx, nod2liny, lin2nodx, lin2nody, cor2linx, cor2liny

 horvic3 = 0d0
 csL     = csu(L) ; snL = snu(L)
 k12     = ln(n12,L)
 vicL    = vicouv

 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links

    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if (LLLL .ne. L) then

       if (LLL < 0) then
          cs =  csu(LLLL)
          sn =  snu(LLLL)
          k1 = ln  (1,LLLL) ; k2 = ln  (2,LLLL)
          k3 = lncn(1,LLLL) ; k4 = lncn(2,LLLL)
          ik1 = 1
          ik2 = 2
          in3 = 1
          in4 = 2
       else
          cs = -csu(LLLL)
          sn = -snu(LLLL)
          k1 = ln  (2,LLLL) ; k2 = ln  (1,LLLL)
          k3 = lncn(2,LLLL) ; k4 = lncn(1,LLLL)
          ik1 = 2
          ik2 = 1
          in3 = 2
          in4 = 1
       endif

!       uuk1  =  cs* ucx(k1) + sn* ucy(k1)
!       vvk1  = -sn* ucx(k1) + cs* ucy(k1)
!       uuk2  =  cs* ucx(k2) + sn* ucy(k2)
!       vvk2  = -sn* ucx(k2) + cs* ucy(k2)

       uuk1 =  cs*nod2linx(LLLL,ik1,ucx(k1),ucy(k1)) + sn*nod2liny(LLLL,ik1,ucx(k1),ucy(k1))
       vvk1 = -sn*nod2linx(LLLL,ik1,ucx(k1),ucy(k1)) + cs*nod2liny(LLLL,ik1,ucx(k1),ucy(k1))
       uuk2 =  cs*nod2linx(LLLL,ik2,ucx(k2),ucy(k2)) + sn*nod2liny(LLLL,ik2,ucx(k2),ucy(k2))
       vvk2 = -sn*nod2linx(LLLL,ik2,ucx(k2),ucy(k2)) + cs*nod2liny(LLLL,ik2,ucx(k2),ucy(k2))

       dux   = (uuk2 - uuk1)*dxi(LLLL)
       dvx   = (vvk2 - vvk1)*dxi(LLLL)

!       uuk3  =  cs*ucnx(k3) + sn*ucny(k3)
!       uuk4  =  cs*ucnx(k4) + sn*ucny(k4)
       uuk3 = cs*cor2linx(LLLL,in3,ucnx(k3),ucny(k3)) + sn*cor2liny(LLLL,in3,ucnx(k3),ucny(k3))
       uuk4 = cs*cor2linx(LLLL,in4,ucnx(k4),ucny(k4)) + sn*cor2liny(LLLL,in4,ucnx(k4),ucny(k4))

       duy   = (uuk4 - uuk3)*wui(LLLL)

       tuu   = dux + dux
       tvv   = duy + dvx

       txx   = tuu*cs - tvv*sn
       tyy   = tuu*sn + tvv*cs

       if (javiusp == 1) then
           vicl = viusp(LLLL)
       else
           vicl = vicouv
       endif

       txx_k12 = lin2nodx(LLLL,ik1,txx,tyy)
       tyy_k12 = lin2nody(LLLL,ik1,txx,tyy)

!       horvic3 = horvic3 + ( txx*csl + tyy*snl )*wu(LLLL)*vicL
       horvic3 = horvic3 + ( nod2linx(L,n12,txx_k12,tyy_k12)*csl + nod2liny(L,n12,txx_k12,tyy_k12)*snl )*wu(LLLL)*vicL

    endif

 enddo
 horvic3 = horvic3*bai(k12)

 end function Horvic3

 Subroutine setvelocityfield()
 use m_flow
 use m_flowgeom
 implicit none
 integer          :: k,k1,k2,L
 double precision :: xx,yy,ux,uy,yyy,uuu, ykmx

 uy = -0.5d0
 ux =  0.5d0*sqrt(3d0)

 ykmx = 100d0 ! 0d0

 do k = 1,ndx
    xx     = xz(k)
    yy     = yz(k) ! ykmx - yz(k)

    if (iuvfield == 1) then                          ! kwadratic horizontal
       ucx(k) = yy*yy
       ucy(k) = 0
    else if (iuvfield == 2) then                     ! kwadratic 30 degrees
       yyy    = -uy*xx + ux*yy
       uuu    = yyy*yyy
       ucx(k) = uuu*ux
       ucy(k) = uuu*uy
    else if (iuvfield == 3) then                     ! circular
       ucx(k) = -yy
       ucy(k) =  xx
    else if (iuvfield == 4) then                     ! linear horizontal
       ucx(k) =  yy
       ucy(k) =  0
    else if (iuvfield == 5) then                     ! linear 30 degrees
       yyy    = -uy*xx + ux*yy
       uuu    = yyy
       ucx(k) = uuu*ux
       ucy(k) = uuu*uy
    else if (iuvfield == 6) then                     ! random
       ucx(k) = 2 + sin(0.1d0*k)
       ucy(k) =     cos(1.5d0*k)
    endif

 enddo
 do L = 1,lnx
    k1 = ln(1,L) ; k2 = ln(2,L)
    u1(L)  = ( (1d0-acl(L))*ucx(k1) + acl(L)*ucx(k2) )*csu(L)  +   &  ! reversed acl weighting
             ( (1d0-acl(L))*ucy(k1) + acl(L)*ucy(k2) )*snu(L)
 enddo

 u0 = u1
 s0 = s1

 call setcornervelocities()

 end subroutine setvelocityfield

 double precision function QucWen(n12,L)             ! sum of (Q*uc cell centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                      ! leaving the cell = +
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12                                      ! relevant node, 1 or 2, L/R
 double precision cs, sn, ucin, ucinx, uciny
 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 QucWen = 0d0
 cs     = csu(L)
 sn     = snu(L)

 k12  = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) == 0d0 .or. L == LLLL) then        ! skip, this is link L itself

    else

!       ucin = ucxu(LLLL)*cs + ucyu(LLLL)*sn - u1(L)
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       ucin = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn - u1(L)

       if (LLL > 0) then                             ! incoming link
          QucWen = QucWen - qa(LLLL)*ucin
       else
          QucWen = QucWen + qa(LLLL)*ucin
       endif

    endif

 enddo

 end function QucWen

 double precision function QucPer(n12,L)             ! sum of (Q*uc cell centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                      ! leaving the cell = +
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12      , kup                                ! relevant node, 1 or 2, L/R
 double precision :: cs, sn, ucin, ucinx, uciny

 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 QucPer = 0d0
 cs     = csu(L)
 sn     = snu(L)

 k12  = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) == 0d0) then                       ! include own link

    else

!       ucin = ucxu(LLLL)*cs + ucyu(LLLL)*sn  - u1(L)
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       ucin = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn - u1(L)

       if (LLL > 0) then                             ! incoming link
          QucPer = QucPer - qa(LLLL)*ucin
       else
          QucPer = QucPer + qa(LLLL)*ucin
       endif

    endif

 enddo

 end function QucPer


 subroutine QucPer3Dsigma(n12,LL,Lb,Lt,cs,sn,quk1)     ! sum of (Q*uc cell centre upwind normal) at side n12 of basis link LL
 use m_flow                                            ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                        ! leaving the cell = +
 use m_sferic
 implicit none

 integer,          intent(in) :: n12,LL,Lb,Lt          ! working for basis link LL
 double precision, intent(in) :: cs, sn
 double precision, intent(out):: quk1(3,Lt-Lb+1)       !

 ! locals
 integer          :: La, LLL, LLLL, Lb2, Lt2, Lk       ! for links LL,
 integer          :: k12, Lkin                         ! relevant node, 1 or 2, L/R
 double precision :: ucin, tkein, epsin                ! velocity surplus

 double precision :: ucinx, uciny
 integer          :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 Quk1  = 0d0

 k12  = ln(n12,LL)
 do La   = 1, nd(k12)%lnx                              ! loop over all attached links
    LLL  = nd(k12)%ln(La)
    nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
    LLLL = iabs(LLL)

    Lb2  = Lbot(LLLL) ; Lt2 = Ltop(LLLL)
    do Lk = LB2, LT2

      if ( qa(Lk) .ne. 0) then                         ! include own link

         ucinx = lin2nodx(LLLL,nn12,ucxu(Lk),ucyu(Lk))
         uciny = lin2nody(LLLL,nn12,ucxu(Lk),ucyu(Lk))

         if (jarhoxu > 0) then
            if (jasfer3D == 0) then
               ucin = (ucxu(Lk)*cs + ucyu(Lk)*sn)*rhou(Lk)  - u1(Lb + Lk - Lb2)*rhou(Lb + Lk - Lb2)
            else
               ucin  = (nod2linx(LL,n12,ucinx,uciny)*cs + nod2liny(LL,n12,ucinx,uciny)*sn)*rhou(Lk)  - u1(Lb + Lk - Lb2)*rhou(Lb + Lk - Lb2)
            endif
         else
            if (jasfer3D == 0) then
               ucin = ucxu(Lk)*cs + ucyu(Lk)*sn  - u1(Lb + Lk - Lb2)
            else
               ucin  = nod2linx(LL,n12,ucinx,uciny)*cs + nod2liny(LL,n12,ucinx,uciny)*sn - u1(Lb + Lk - Lb2)
            endif
         endif
         if (LLL > 0) then                             ! incoming link
            ucin = -1d0*ucin
         endif
         Lkin = min (Lk-Lb2+1, Lt-Lb+1)                ! for fixed layers just add to top index
         Quk1(1,Lkin) = Quk1(1,Lkin) + qa(Lk)*ucin

      endif

   enddo

 enddo

 end subroutine QucPer3Dsigma

 subroutine QucPer3Dsigmapiaczekteta(LL,Lb,Lt,cs,sn,ae,ai)  ! Piaczekteta in 3D

 use m_flow                                                 ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom
 use m_flowtimes, only : dts                                !
 use m_sferic
 implicit none

 integer,          intent(in) :: LL,Lb,Lt                   ! working for basis link LL
 double precision, intent(in) :: cs, sn
 double precision, intent(out):: ae(Lt-Lb+1)                ! explicit part
 double precision, intent(out):: ai(Lt-Lb+1)                ! implicit part


 ! locals
 integer          :: La, LLL, LLLL, Lb2, Lt2, Lk            ! for links LL,
 integer          :: k12, n12, k1, k2                       ! relevant node, 1 or 2, L/R
 double precision :: ucin, cfl, tet, volu, ac, acq          ! velocity surplus

 double precision ::  ucinx, uciny
 integer          :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 ae = 0d0 ; ai = 0d0

 do n12 = 1,2
    if (n12 ==1) then
        ac = acL(LL)
    else
        ac = 1d0-acL(LL)
    endif
    k12  = ln(n12,LL)
    do La   = 1, nd(k12)%lnx                                ! loop over all attached links
       LLL  = nd(k12)%ln(La)
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       LLLL = iabs(LLL)

       Lb2  = Lbot(LLLL) ; Lt2 = Ltop(LLLL)
       do Lk = LB2, LT2

          if ( qa(Lk) .ne. 0) then                          ! include own link
             k1   = ln(1,Lb+Lk-Lb2)  ;  k2 = ln(2,Lb+Lk-Lb2)
             volu = acL(LL)*vol1(k1) + (1d0-acl(LL))*vol1(k2)
             if (volu > 0d0) then
                cfl  = abs(qa(Lk))*dts/volu
                if (nd(k12)%lnx ==3) cfl=1.4d0*cfl
                if (cfl > 0d0) then
                   tet  = max(0d0, 1d0 - 1d0/cfl  )
                   if (jasfer3D == 0) then
                      ucin = ucxu(Lk)*cs + ucyu(Lk)*sn  - (1d0-tet)*u1(Lb + Lk - Lb2)
                   else
                      ucinx = lin2nodx(LLLL,nn12,ucxu(Lk),ucyu(Lk))
                      uciny = lin2nody(LLLL,nn12,ucxu(Lk),ucyu(Lk))
                      ucin  = nod2linx(LL,n12,ucinx,uciny)*cs + nod2liny(LL,n12,ucinx,uciny)*sn  - (1d0-tet)*u1(Lb + Lk - Lb2)
                   endif

                   acq  = ac*qa(Lk)/volu
                   if (LLL > 0) then                        ! incoming link
                      ae(Lk-Lb2+1) = ae(Lk-Lb2+1) - acq*ucin
                      ai(Lk-Lb2+1) = ai(Lk-Lb2+1) + acq*tet
                   else
                      ae(Lk-Lb2+1) = ae(Lk-Lb2+1) + acq*ucin
                      ai(Lk-Lb2+1) = ai(Lk-Lb2+1) - acq*tet
                   endif
                endif
             endif

          endif

       enddo

    enddo

 enddo

 end subroutine QucPer3Dsigmapiaczekteta

 double precision function QucPerq1(n12,L)           ! sum of (Q*uc cell centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                      ! leaving the cell = +
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12      , kup                                ! relevant node, 1 or 2, L/R
 double precision :: cs, sn, ucin, ucinx, uciny
 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 QucPerq1 = 0d0
 cs       = csu(L)
 sn       = snu(L)

 k12  = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) == 0d0) then                       ! include own link

    else

!       ucin = ucxu(LLLL)*cs + ucyu(LLLL)*sn  - u1(L)
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       ucin  = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn  - u1(L)

       if (LLL > 0) then                             ! incoming link
          QucPerq1 = QucPerq1 - q1(LLLL)*ucin
       else
          QucPerq1 = QucPerq1 + q1(LLLL)*ucin
       endif

    endif

 enddo

 end function QucPerq1


 double precision function QufPer(n12,L)             ! sum of (Q*uc cell centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                      ! leaving the cell = +
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12      , kup                           ! relevant node, 1 or 2, L/R
 double precision :: cs, sn, ucin, snL, csL, ufx, ufy, ucinx, uciny

 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 QufPer = 0d0
 cs     = csu(L)
 sn     = snu(L)

 k12  = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) == 0d0) then                       ! include own link

    else

       csL  =      csu(LLLL) ; snL = snu(LLLL)
       ufx  = csL * u1(LLLL) - snL * v  (LLLL)
       ufy  = csL * v (LLLL) + snL * u1 (LLLL)
!
!       ucin = ufx*cs + ufy*sn  - u1(L)
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       ucinx = lin2nodx(LLLL,nn12,ufx,ufy)
       uciny = lin2nody(LLLL,nn12,ufx,ufy)
       ucin  = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn  - u1(L)

       if (LLL > 0) then                             ! incoming link
          QufPer = QufPer - qa(LLLL)*ucin
       else
          QufPer = QufPer + qa(LLLL)*ucin
       endif

    endif

 enddo

 end function QufPer

 double precision function QucPercu(n12,L)             ! sum of (Q*uc cell centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                      ! leaving the cell = +
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12      , kup                           ! relevant node, 1 or 2, L/R
 double precision :: cs, sn, ucin, ucinx, uciny

 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 QucPercu = 0d0
 cs       = csu(L)
 sn       = snu(L)

 k12  = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) == 0d0) then                       ! include own link

    else

!       ucin = ( ucxu(LLLL) - ucx(k12) )*cs + (ucyu(LLLL) - ucy(k12) )*sn
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL)) - ucx(k12)
       uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL)) - ucy(k12)
       ucin  = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn


       if (LLL > 0) then                             ! incoming link
          QucPercu = QucPercu - q1(LLLL)*ucin
       else
          QucPercu = QucPercu + q1(LLLL)*ucin
       endif

    endif

 enddo

 end function QucPercu



 double precision function QucPeri(n12,L)             ! sum of (Q*uc cell centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                      ! leaving the cell = +
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12                                      ! relevant node, 1 or 2, L/R
 double precision :: cs, sn, ucin, ucinx, uciny

 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 QucPeri = 0d0
 cs      = csu(L)
 sn      = snu(L)

 k12  = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) == 0d0) then                       ! include own link

    else if ( LLL*qa(LLLL) > 0d0) then               ! only incoming

!       ucin = ucxu(LLLL)*cs + ucyu(LLLL)*sn  - u1(L)
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       ucin  = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn - u1(L)
       if (LLL > 0) then                             ! incoming link
          QucPeri = QucPeri - qa(LLLL)*ucin
       else
          QucPeri = QucPeri + qa(LLLL)*ucin
       endif

    endif

 enddo

 end function QucPeri


 double precision function Qucnu(n12,L)              ! sum of (Q*uc cell centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                      ! leaving the cell = +
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12, kup                                 ! relevant node, 1 or 2, L/R
 double precision :: cs, sn, ucin, ucinx, uciny

 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 Qucnu = 0d0
 cs   = csu(L)
 sn   = snu(L)

 k12  = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)


    !if (qa(L) == 0d0 .or. L == LLLL ) then

    !else
       if ( qa(LLLL) > 0 ) then                      ! upwind cell centered velocity lies at kup=
          kup = ln(1,LLLL)
       else
          kup = ln(2,LLLL)
       endif
!       ucin = ucx(kup)*cs + ucy(kup)*sn - u1(L)
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       ucin  = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn - u1(L)

       if (LLL > 0) then                             ! incoming link
          Qucnu = Qucnu - qa(LLLL)*ucin
       else
          Qucnu = Qucnu + qa(LLLL)*ucin
       endif
    !endif


 enddo

 end function Qucnu


 double precision function QucWeni(n12,L)            ! sum of (Q*uc cell centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom                                      ! leaving the cell = +
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12                                      ! relevant node, 1 or 2, L/R
 double precision cs, sn, ucin, ucinx, uciny

 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 QucWeni = 0d0
 cs      = csu(L)
 sn      = snu(L)

 k12  = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) == 0d0 .or. L == LLLL) then        ! skip, this is link L itself

    else if ( LLL*qa(LLLL) > 0d0) then               ! only incoming

!       ucin = ucxu(LLLL)*cs + ucyu(LLLL)*sn  - u1(L)
       nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
       ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
       ucin  = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn - u1(L)

       if (LLL > 0) then                             ! incoming link
          QucWeni = QucWeni - qa(LLLL)*ucin
       else
          QucWeni = QucWeni + qa(LLLL)*ucin
       endif

    endif

 enddo

 end function QucWeni



 !double precision function QunPeri(n12,L)            ! sum of (Q*un face node upwind normal) at side n12 of link L
 !use m_flow                                          ! advect the corner velocities (dimension: m4/s2)
 !use m_flowgeom                                      ! leaving the cell = +
 !implicit none
 !
 !integer :: L                                        ! for link L,
 !integer :: n12                                      ! find normal velocity components of the other links
 !
 !! locals
 !integer :: LL, LLL, LLLL                            ! for links LL,
 !integer :: k12                                      ! relevant node, 1 or 2, L/R
 !double precision cs, sn, ucin, unxu, unyu, aa
 !
 !QunPeri = 0d0
 !cs      = csu(L)
 !sn      = snu(L)
 !
 !k12  = ln(n12,L)
 !
 !do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
 !   LLL  = nd(k12)%ln(LL)
 !   LLLL = iabs(LLL)
 !
 !   if ( qa(LLLL) == 0d0) then                       ! include own link
 !
 !   else if ( LLL*qa(LLLL) > 0d0) then               ! only incoming
 !
 !      unxu = 0.5d0*( ucnx(lncn(1,LLLL)) + ucnx(lncn(2,LLLL)) )
 !      unyu = 0.5d0*( ucny(lncn(1,LLLL)) + ucny(lncn(2,LLLL)) )
 !
 !
 !      ucin = unxu*cs + unyu*sn  - u1(L)
 !      if (LLL > 0) then                             ! incoming link
 !          aa = acl(LLLL)
 !          QunPeri = QunPeri - qa(LLLL)*ucin
 !      else
 !          aa = 1d0-acl(LLLL)
 !          QunPeri = QunPeri + qa(LLLL)*ucin
 !      endif
 !
 !   endif
 !
 !enddo
 !
 !end function QunPeri


 subroutine QucPeripiaczek(n12,L,ai,ae,iad)          ! sum of (Q*uc cell IN centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom
 use m_flowtimes                                     ! leaving the cell = +
 use m_sferic
 implicit none

 integer :: n12,L,iad                                ! for link L,
 double precision ai, ae

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12, kup, ja                             ! relevant node, 1 or 2, L/R
 double precision :: cs, sn, ucin, cfl, tet, ucinx, uciny

 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 ai = 0d0 ; ae = 0d0
 cs      = csu(L)
 sn      = snu(L)

 k12     = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) .ne. 0d0) then                     !

       ja = 0
       if (iad == 3) then
          ja = 1                                     ! all in odd schemes
       else if ( LLL*qa(LLLL) > 0d0 ) then
          ja = 1                                     ! incoming only otherwise
       endif

       if (ja == 1) then
          if (jasfer3D == 0) then
             ucin = ucxu(LLLL)*cs + ucyu(LLLL)*sn
          else
             nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
             ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
             uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
             ucin  = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn
          endif
          if (LLL > 0) then                          ! incoming link
             ae = ae - qa(LLLL)*ucin
             ai = ai + qa(LLLL)
          else
             ae = ae + qa(LLLL)*ucin
             ai = ai - qa(LLLL)
          endif

       endif

    endif

 enddo

 end subroutine Qucperipiaczek

subroutine QucPeripiaczekteta(n12,L,ai,ae,volu,iad)  ! sum of (Q*uc cell IN centre upwind normal) at side n12 of link L
 use m_flow                                          ! advect the cell center velocities (dimension: m4/s2)
 use m_flowgeom
 use m_flowtimes                                     ! leaving the cell = +
 use m_sferic
 implicit none
 integer :: n12,L,iad                                ! for link L,
 double precision ai, ae, volu

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12, kup, ja                             ! relevant node, 1 or 2, L/R
 double precision :: cs, sn, ucin, cfl, tet, ucinx, uciny

 integer :: nn12

 double precision, external:: lin2nodx, lin2nody, nod2linx, nod2liny

 ai = 0d0 ; ae = 0d0
 cs      = csu(L)
 sn      = snu(L)

 k12     = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)

    if ( qa(LLLL) .ne. 0d0) then                     !

       ja = 0
       if (iad == 3) then
          ja = 1                                     ! all in odd schemes
       else if ( LLL*qa(LLLL) > 0d0 ) then
          ja = 1                                     ! incoming only otherwise
       endif

       if (ja == 1) then

          cfl  = abs(qa(LLLL))* dts/volu
          if (nd(k12)%lnx ==3) cfl=1.4d0*cfl
          if (cfl > 0) then
             tet  = max(0d0, 1d0 - 1d0/cfl  )
             if (jasfer3D == 1) then
                nn12 = 1; if ( LLL.gt.0 ) nn12 = 2
                ucinx = lin2nodx(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
                uciny = lin2nody(LLLL,nn12,ucxu(LLLL),ucyu(LLLL))
                ucin  = nod2linx(L,n12,ucinx,uciny)*cs + nod2liny(L,n12,ucinx,uciny)*sn - u1(L)*(1d0-tet)
             else
                ucin = ucxu(LLLL)*cs + ucyu(LLLL)*sn - u1(L)*(1d0-tet)
             endif

             if (LLL > 0) then                             ! incoming link
                ae = ae - qa(LLLL)*ucin
                ai = ai + qa(LLLL)*tet
             else
                ae = ae + qa(LLLL)*ucin
                ai = ai - qa(LLLL)*tet
             endif
          endif

       endif

    endif

 enddo

 end subroutine Qucperipiaczekteta

 double precision function Qsum(k)                   ! sum of Q out of k (m3/s)
 use m_flow
 use m_flowgeom
 implicit none

 integer :: k                                        ! for node k,

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,

 Qsum = 0d0

 do LL   = 1, nd(k)%lnx                              ! loop over all attached links
    LLL  = nd(k)%ln(LL)
    LLLL = iabs(LLL)

    if ( q1(LLLL) == 0d0 ) then                      ! skip, this is link L itself, net result = 0

    else if (LLL > 0) then                           ! incoming link
       Qsum = Qsum - q1(LLLL)
    else
       Qsum = Qsum + q1(LLLL)
    endif

 enddo

 end function Qsum


 double precision function qzeta(n12,L)              ! average specific q in zeta point comparable to fls
 use m_flow                                          ! qdo = 0.5*(qleft+qright)
 use m_flowgeom
 implicit none

 integer :: L                                        ! for link L,
 integer :: n12                                      ! find normal velocity components of the other links

 ! locals
 integer :: LL, LLL, LLLL                            ! for links LL,
 integer :: k12, kup                                 ! relevant node, 1 or 2, L/R

 qzeta = 0d0

 k12   = ln(n12,L)
 do LL   = 1, nd(k12)%lnx                            ! loop over all attached links
    LLL  = nd(k12)%ln(LL)
    LLLL = iabs(LLL)
    qzeta = qzeta + q1(LLLL)
 enddo
 end function Qzeta

 double precision function depumin(k)                ! min hu of node k
 use m_flow
 use m_flowgeom
 implicit none

 integer :: k

 ! locals
 integer :: L, LL                                    ! for link L,

 depumin = 1e9
 do L       = 1, nd(k)%lnx
    LL      = iabs(nd(k)%ln(L))
    depumin = min( depumin,hu(L) )
 enddo
 end function depumin

 subroutine setuniformwind()
 use m_wind
 use m_sferic
 use m_flowgeom
 implicit none
 double precision :: wdir

 jawind = 2
 wdir   = (90d0 - winddir)*dg2rd

 if (.not. allocated(wx) ) then
     allocate (  wx(lnx), wy(lnx) )
 endif

 wx   = windsp*cos(wdir)
 wy   = windsp*sin(wdir)
 call setwindstress()
 end subroutine setuniformwind

 !> Initializes the entire current model (geometry, boundaries, initial state)
 !! @return Error status: error (/=0) or not (0)
 integer function flow_modelinit() result(iresult)                     ! initialise flowmodel
 use m_flowgeom,    only: jaFlowNetChanged, ndx, lnx, kfs
 use waq,           only: reset_waq
 use m_flow,        only: zws, zws0, kmx, jasecflow, lnkx
 use m_flowtimes
 use network_data,  only: netstat, NETSTAT_CELLS_DIRTY
 use gridoperations, only: make1D2Dinternalnetlinks
 use m_partitioninfo
 use m_timer
 use m_flowtimes
 use unstruc_model ! , only: md_ident, md_restartfile,  writeMDUFilepointer, md_foufile, md_flowgeomfile, md_snapshotdir, md_numthreads
 use unstruc_files, only: mdia
 use unstruc_netcdf
 use MessageHandling
 use m_flowparameters, only: jawave, jatrt, jacali, jacreep, jatransportmodule, jamd1dfile
 use dfm_error
 use m_fm_wq_processes, only: jawaqproc
 use m_vegetation
 use m_integralstats
 use m_xbeach_data, only: instat, newstatbc
 use m_oned_functions
 use unstruc_display, only : ntek, jaGUI
 use m_alloc
 use m_bedform
 use m_fm_update_crosssections, only: fm_update_mor_width_area
 use unstruc_netcdf_map_class
 use unstruc_caching
 !
 ! To raise floating-point invalid, divide-by-zero, and overflow exceptions:
 ! Activate the following line (See also statements below)
 !use ifcore
 !
#ifdef _OPENMP
 use omp_lib
#endif

 implicit none

 integer              :: jw, istat, L, ierr
 integer, external    :: flow_flowinit
 double precision     :: cpu_waqinit
 !
 ! To raise floating-point invalid, divide-by-zero, and overflow exceptions:
 ! Activate the following 3 lines, See also statements below
 !INTEGER*4 OLD_FPE_FLAGS, NEW_FPE_FLAGS
 !NEW_FPE_FLAGS = FPE_M_TRAP_OVF + FPE_M_TRAP_DIV0 + FPE_M_TRAP_INV
 !OLD_FPE_FLAGS = FOR_SET_FPE (NEW_FPE_FLAGS)
 !

 iresult = DFM_GENERICERROR

 call datum2(rundat2)
 L = len_trim(rundat2)
 call klok(cpuall(1))

 IF (ti_waq > 0d0) then
    call makedir(getoutputdir('waq'))  ! No problem if it exists already.
 end if

 call klok(cpu_extra(1,1)) ! Basic steps

 md_snapshotdir =  trim(getoutputdir())                  ! plot output to outputdir
 ! Make sure output dir for plot files exists
 if (len_trim(md_snapshotdir) > 0) then
    call makedir(md_snapshotdir) ! No problem if it exists already.
 end if

 if ( jatimer.eq.1 ) then
    call initimer()
 end if

 call unc_set_ncformat(md_ncformat)

 call reset_unstruc_netcdf_map_class()

 call resetflow()

 call reset_waq()

 call klok(cpu_extra(2,1)) ! End basic steps

! JRE
 call klok(cpu_extra(1,2)) ! Wave input
 if (jawave == 4) then
    call xbeach_wave_input()  ! will set swave and lwave
 endif
 call klok(cpu_extra(2,2)) ! End wave input


 call klok(cpu_extra(1,3)) ! Internal links
 if (md_jamake1d2dlinks == 1) then
    ierr = make1D2Dinternalnetlinks()
     if (ierr /= DFM_NOERR) then
      call mess(LEVEL_WARN,'Error, failed to create 1D2D links.')
      goto 1234
    end if
 end if
 call klok(cpu_extra(2,3)) ! End internal links

 ! TODO: unc_wri_map_header

 call klok(cpu_extra(1,4)) ! Flow geometry
 call mess(LEVEL_INFO,'Initializing flow model geometry...')
 if ( jampi.eq.0 ) then
    call flow_geominit(0)                                ! initialise flow geometry based upon present network, time independent
                                                         ! make directional wave grid

    call mess(LEVEL_INFO,'Done initializing flow model geometry.')

    if (ndx == 0) then
      call mess(LEVEL_WARN,'ndx == 0, please check MDU-file')
      iresult = DFM_MODELNOTINITIALIZED
      goto 1234
    end if
 else
    call flow_geominit(1)  ! first phase only

    if ( Ndx.gt.0 ) then
       call mess(LEVEL_INFO,'Start partitioning model...')
       if ( jatimer.eq.1 ) call starttimer(IPARTINIT)

       call partition_init_1D2D(md_ident, iresult)   ! 1D & 2D (hence the name, thanks to Herman for pointing this out)

       if ( jatimer.eq.1 ) call stoptimer(IPARTINIT)
       call mess(LEVEL_INFO,'Done partitioning model.')

       if ( iresult.eq.0 ) then
          call update_geom(1)     ! update geometry in ghost area

          call flow_geominit(2)   ! second phase
          call update_geom(2)     ! update geometry in ghost area

          call disable_invalid_ghostcells_with_wu()  ! disable ghost cells that are not being synchronised by setting wu's to zero

          call mess(LEVEL_INFO,'Done initializing flow model geometry.')
       else
         call mess(LEVEL_WARN,'Error in 2D partitioning initialization.')
         goto 1234
       end if
    else
       call mess(LEVEL_WARN,'No network, please check MDU-file')
       iresult = DFM_MODELNOTINITIALIZED
       goto 1234
    end if
 end if
 call klok(cpu_extra(2,4)) ! End flow geometry


 if( kmx > 0 .and. jasecflow > 0) then         ! An error announcement (or warning, with correction to jasecflow to 0)
    jasecflow = 0
    call mess(LEVEL_WARN,'Warning: Secondary Flow is not applicable in 3D computation !!')
    call mess(LEVEL_WARN,'         Secondary flow is turned off')
 endif

 call klok(cpu_extra(1,5)) ! bobsongullies
 call setbobsongullies()
 call klok(cpu_extra(2,5)) ! End bobsongullies

 if (javeg > 0) then
    ! NOTE: AvD: hardcoded for now: if vegetation is on, maintain max shear stresses for Peter and Jasper.
    is_numndvals = 3
 end if

 ! 3D: flow_allocflow will set kmxn, kmxL and kmxc arrays
 call klok(cpu_extra(1,37)) ! alloc flow
 call flow_allocflow()                               ! allocate   flow arrays
 call klok(cpu_extra(2,37)) ! end alloc flow
 !
 if (jawave > 0) then
    call alloc9basicwavearrays()
 endif
 if (jawave > 2 .or. (jased > 0 .and. stm_included)) then
    call flow_waveinit()
 endif
 ! Construct a default griddim struct for D3D subroutines, i.e. fourier, sedmor or trachytopen
 call klok(cpu_extra(1,7)) ! Flow griddim
 if ( len_trim(md_foufile) > 0 .or. len_trim(md_sedfile) > 0 .or. jatrt == 1) then
    call D3Dflow_dimensioninit()
 endif
 call klok(cpu_extra(2,7)) ! End flow griddim

 call klok(cpu_extra(1,8)) ! Bed forms
 if ((jased > 0 .and. stm_included) .or. bfm_included .or. jatrt > 0 ) then
    call flow_bedforminit(1)        ! bedforms stage 1: datastructure init
 endif
 call klok(cpu_extra(2,8)) ! End bed forms

 !! flow1d -> dflowfm initialization
 call klok(cpu_extra(1,9)) ! 1d roughness
 call set_1d_roughnesses()
 call klok(cpu_extra(2,9)) ! End 1d roughness

 ! need number of fractions for allocation of sed array
 call klok(cpu_extra(1,10)) ! sedmor
 if ( len_trim(md_sedfile) > 0 ) then
      call flow_sedmorinit ()
 endif
 call klok(cpu_extra(2,10)) ! End sedmor

 call klok(cpu_extra(1,11)) ! bedform
 if ((jased > 0 .and. stm_included) .or. bfm_included ) then
    call flow_bedforminit(2)        ! bedforms  stage 2: parameter read and process
 endif
 call klok(cpu_extra(2,11)) ! End bedform

 call klok(cpu_extra(1,12)) ! vertical administration
 if (jampi == 1) then
!   update vertical administration
    call update_vertadmin()

    !3D: partition_init needs kmxn and kmxL arrays for 3D send- and ghostlists
    if ( jatimer.eq.1 ) call starttimer(IPARTINIT)
    call partition_init_3D(iresult)
    if ( jatimer.eq.1 ) call stoptimer(IPARTINIT)

    if (iresult /= DFM_NOERR) then
      call mess(LEVEL_WARN,'Error in 3D partitioning initialization.')
      goto 1234
    end if

#ifdef _OPENMP
    ! If MPI is on for this model, *and* no user-define numthreads was set, then disable OpenMP.
    if (md_numthreads == 0) then
       call omp_set_num_threads(1)
! TODO: AvD: else, reset to maximum? Especially in library mode when multiple models can be run after one another?
    else
       call omp_set_num_threads(md_numthreads)
    end if
#endif

 else ! No MPI, but handle OpenMP settings:
#ifdef _OPENMP
    if (md_numthreads /= 0) then
       call omp_set_num_threads(md_numthreads)
    end if
#endif
 end if
 call klok(cpu_extra(2,12)) ! vertical administration

 call klok(cpu_extra(1,13)) ! netlink tree 0
 if ((jatrt == 1) .or. (jacali == 1)) then
     call netlink_tree(0)
 endif
 call klok(cpu_extra(2,13)) ! end netlink tree

 call klok(cpu_extra(1,14)) ! flow trachy init
 if (jatrt == 1) then
    call flow_trachyinit ()                          ! initialise the trachytopes module
 end if
 call klok(cpu_extra(2,14)) ! end flow trachy init

 call klok(cpu_extra(1,15)) ! calibration init
 if (jacali == 1) then
     call calibration_init()                          ! initialise the calibration memory structures and read .cld and .cll files
 end if
 call klok(cpu_extra(2,15)) ! end calibration init

 call klok(cpu_extra(1,16)) ! netlink tree 1
 if ((jatrt == 1) .or. (jacali == 1)) then
     call netlink_tree(1)
 endif
 call klok(cpu_extra(2,16)) ! netlink tree 1

 !! flow1d -> dflowfm update
 call klok(cpu_extra(1,17)) ! save 1d
 if (stm_included) then
    call save_1d_nrd_vars_in_stm()
 end if
 call klok(cpu_extra(2,17)) ! end save 1d

! initialize waq and add to tracer administration
 call klok(cpu_extra(1,18)) ! waq processes init
 if ( len_trim(md_subfile) > 0 ) then
    call fm_wq_processes_ini_sub()
 end if
 call klok(cpu_extra(2,18)) ! end waq processes init

 call klok(cpu_extra(1,19)) ! transport module
 if ( jatransportmodule.ne.0 ) then
    call ini_transport()
 end if
 call klok(cpu_extra(2,19)) ! end transport module

! initialize part
 call klok(cpu_extra(1,20)) ! part init
 call ini_part(1, md_partfile, md_partjatracer, md_partstarttime, md_parttimestep, md_part3Dtype)
 call klok(cpu_extra(2,20)) ! end part init

 call klok(cpu_extra(1,21)) ! observations init
 call flow_obsinit()                                 ! initialise stations and cross sections on flow grid + structure his (1st call required for call to flow_trachy_update)
 call klok(cpu_extra(2,21)) ! end observations init

 cpu_extra(:,22) = 0.0d0    ! call removed
 call klok(cpu_extra(1,23)) ! flow init
 iresult = flow_flowinit()                           ! initialise flow arrays and time dependent params for a given user time
 if (iresult /= DFM_NOERR) then
    goto 1234
 end if
 call klok(cpu_extra(2,23)) ! end flow init

! initialize waq and add to tracer administration
 cpu_waqinit = cpu_extra(2,18) - cpu_extra(1,18)
 call klok(cpu_extra(1,18)) ! waq processes init
 cpu_extra(1,18) = cpu_extra(1,18) - cpu_waqinit ! deduct first initialisation phase of waq processes
 if (ti_waqproc /= 0d0) then
    if ( jawaqproc .eq. 1 ) then
       call fm_wq_processes_step(ti_waqproc,time_user)
    endif
 endif
 call klok(cpu_extra(2,18)) ! end waq processes init
 
 call klok(cpu_extra(1,24)) ! MBA init
 if (ti_waqbal > 0) then
    call mba_init()
 endif
 call klok(cpu_extra(2,24)) ! end MBA init

 call klok(cpu_extra(1,25)) ! update MOR width
 if (stm_included) then
     call fm_update_mor_width_area()
 endif
 call klok(cpu_extra(2,25)) ! end update MOR width

 call klok(cpu_extra(1,26)) ! dredging init
 if ( len_trim(md_dredgefile) > 0 .and. stm_included) then
    call flow_dredgeinit()          ! dredging and dumping. Moved here because julrefdate needed
 endif
 call klok(cpu_extra(2,26)) ! end dredging init

 call klok(cpu_extra(1,27)) ! Xbeach init
 if (jawave .eq. 4) then
    call xbeach_wave_init()

    if ( trim(instat).eq.'stat' .or. trim(instat)=='stat_table') then   ! for stationary solver: initialize with stationary field
       call xbeach_stationary()
       newstatbc   = 0
       if ( jaGUI.eq.1 ) then                                          ! this part is for online visualisation
          if (ntek > 0) then
             if (mod(int(dnt_user),ntek) .eq. 0) then
                call wave_makeplotvars()                                ! Potentially only at ntek interval
             end if
          endif
       endif
    end if
 end if
 call klok(cpu_extra(2,27)) ! end Xbeach init

 call klok(cpu_extra(1,28)) ! observations init 2
 call flow_obsinit()                                 ! initialise stations and cross sections on flow grid + structure his (2nd time required to fill values in observation stations)
 call klok(cpu_extra(2,28)) ! end observations init 2

 call klok(cpu_extra(1,29)) ! structure parameters
 call structure_parameters()                         ! initialize structure values, after flow_flowinit() so that initial water levels and discharges are already set.
 call klok(cpu_extra(2,29)) ! end structure parameters

 call klok(cpu_extra(1,30)) ! trachy update
 if (jatrt == 1) then
    call flow_trachyupdate()                         ! Perform a trachy update step to correctly set initial field quantities
 endif                                               ! Generally flow_trachyupdate() is called from flow_setexternalforcings()
 call klok(cpu_extra(2,30)) ! end trachy update

 call klok(cpu_extra(1,31)) ! set fcru mor
 if ((jased>0) .and. stm_included) then
    if (jamd1dfile == 0) then
       call set_frcu_mor(1)        !otherwise frcu_mor is set in getprof_1d()
    endif
    call set_frcu_mor(2)
 endif
 call klok(cpu_extra(2,31)) ! end set fcru mor

 call klok(cpu_extra(1,32)) ! flow ini timestep
 call flow_initimestep(1, iresult)                   ! 1 also sets zws0
 call klok(cpu_extra(2,32)) ! end flow ini timestep


 jaFlowNetChanged = 0


 ! Initialise Fourier Analysis
 call klok(cpu_extra(1,33)) ! Fourier init
 if (len_trim(md_foufile)>0) then
    call flow_fourierinit()
 endif
 call klok(cpu_extra(2,33)) ! end Fourier init



 call klok(cpu_extra(1,34)) ! writeMDUFilepointer
 call mess(LEVEL_INFO, '** Model initialization was successful **')
 call mess(LEVEL_INFO, '* Active Model definition:')! Print model settings in diagnostics file.
 call writeMDUFilepointer(mdia, .true., istat)

 call mess(LEVEL_INFO, '**')
 call klok(cpu_extra(2,34)) ! end writeMDUFilepointer

 call klok(cpu_extra(1,35)) ! write flowgeom ugrid
 if (len_trim(md_flowgeomfile) > 0) then             ! Save initial flow geometry to file.
    if (md_unc_conv == UNC_CONV_UGRID) then
       call unc_write_net_flowgeom_ugrid(trim(md_flowgeomfile)) ! UGRID
    else
       call unc_write_net_flowgeom(trim(md_flowgeomfile)) ! CFOLD
    end if
 end if
 call klok(cpu_extra(2,35)) ! end write flowgeom ugrid

 ! store the grid-based information in the cache file
 call klok(cpu_extra(1,36)) ! remainder
 call storeCachingFile(filename = md_ident, usecaching = md_usecaching)

call writesomeinitialoutput()

 call klok(cpu_extra(2,36)) ! End remainder
 iresult = DFM_NOERR
 return
1234 continue
!  BEGIN DEBUG
   !call dum_makesal()
   !call dum_makeflowfield()
!  END DEBUG


end function flow_modelinit

subroutine D3Dflow_dimensioninit()
    use m_flowgeom
    use grid_dimens_module
    use m_d3ddimens
    use m_flow !, only: ndkx, lnkx
    implicit none

    integer :: L

    ! Construct a default griddim struct and gd_dimens (delft3D) struct
    call d3dgrid_dimens(gddimens, gddimens_ptr, max(ndkx,lnkx), 1, ndxi, lnxi, ndkx, lnkx) ! Here we only use ndxi, lnxi (interior). NOTE: caller to fouana will still pass entire s1 arrays etc.(1:ndx), and that only works since it is a  rank-1 array!

    call simplegrid_dimens(griddim, ndx, 1)
    griddim%xz                   => xz
    griddim%yz                   => yz
    griddim%celltype(1:ndxi)     =  1 ! Internal cells
    griddim%celltype(ndxi+1:ndx) =  2 ! Boundary cells
    griddim%mmax                 = ndxi
    griddim%nmmax                = ndxi

    ! generate table for boundary mirroring of input
    allocate(griddim%nmbnd(ndx-ndxi,2))
    do L = lnxi+1, lnx
       griddim%nmbnd(LN(1, L)-ndxi,1) = LN(1, L)  ! point outside net
       griddim%nmbnd(LN(1, L)-ndxi,2) = LN(2, L)  ! point inside net
    enddo

end subroutine D3Dflow_dimensioninit


subroutine flow_sedmorinit()
    use m_sediment
    use m_rdstm
    use m_flow, only: kmx, ndkx, lnkx, iturbulencemodel
    use morphology_data_module !, only: nullsedtra, allocsedtra
    use sediment_basics_module
    use message_module, only: clearstack, initstack
    use grid_dimens_module
    use unstruc_model ! including: md_tunit
    use unstruc_files
    use m_flowgeom
    use m_flowtimes
    use m_physcoef, only: rhomean, ag, backgroundwatertemperature
    use m_turbulence, only: rho
    use m_initsedtra, only: initsedtra
    use m_rdmorlyr, only: rdinimorlyr
    use m_flowexternalforcings, only: sfnames, numfracs, nopenbndsect, openbndname, openbndlin, nopenbndlin
    use m_transport, only: ISED1, ISEDN, ifrac2const, const_names, constituents
    use m_flowparameters, only: jatransportmodule, jasecflow, ibedlevtyp, jasal, jatem
    use m_bedform, only: bfmpar, bfm_included
    use unstruc_channel_flow
    use m_branch
    use m_oned_functions, only: gridpoint2cross
    use m_fm_morstatistics
    use MessageHandling

    implicit none

    logical :: error, have_mudbnd, have_sandbnd, ex, success
    character(20) , dimension(:), allocatable :: nambnd        !   TO DO nambnd: needed for morphological bc
    character     , dimension(200)            :: mes
    character(40)                             :: errstr
   !type(griddimtype) :: griddim
    type (bedbndtype)     , dimension(:) , pointer :: morbnd
    integer                                   :: kk, k, kbot, ktop, i, j, isus, ifrac, isusmud, isussand, isf, ised, Lf, npnt, j0, ierr
    integer                                   :: ibr, nbr, pointscount, k1
    integer                                   :: npnterror=0   !< number of grid points without cross-section definition
    type(t_branch), pointer                   :: pbr


!! executable statements -------------------------------------------------------
!
!   activate morphology if sediment file has been specified in the mdu file
!
    if (.not.stm_included) return

    if ( stm_included .and. jased.ne.0 .and. jatransportmodule.eq.0 ) then
       call mess(LEVEL_FATAL, 'unstruc::flow_sedmorinit - Please use transport module when Sedimentmodelnr == 4, by setting TransportMethod = 1 under [numerics].')
       return
    end if
    !
    inquire (file = trim(md_sedfile), exist = ex)
    if (.not. ex) then
       call mess(LEVEL_FATAL, 'unstruc::flow_sedmorinit - *.sed file in mdu file does not exist.')
       return
    end if

    inquire (file = trim(md_morfile), exist = ex)
    if (.not. ex) then
       call mess(LEVEL_FATAL, 'unstruc::flow_sedmorinit - *.mor file in mdu file does not exist.')
       return
    end if

    if( allocated( nambnd) ) deallocate( nambnd )
    allocate( nambnd(nopenbndsect) )
    do k = 1,nopenbndsect
       nambnd(k) = openbndname(k)
    enddo

    call rdstm(stmpar, griddim, md_sedfile, md_morfile, filtrn='', lundia=mdia, lsal=jasal, ltem=jatem, ltur=max(0,iturbulencemodel-1), lsec=jasecflow, lfbedfrm=bfm_included, julrefday=julrefdat, dtunit='Tunit='//md_tunit, nambnd=nambnd, error=error)
    if (error) then
        call mess(LEVEL_FATAL, 'unstruc::flow_sedmorinit - Error in subroutine rdstm.')
        return
    end if

    do i = 1, stmpar%lsedtot
       if (stmpar%trapar%iform(i) == 19 .or. stmpar%trapar%iform(i) == 20) then
          if (jawave .ne. 4) then
             call mess(LEVEL_FATAL, 'unstruc::flow_sedmorinit - Sediment transport formula '//trim(stmpar%trapar%name(i))//' is not supported without the surfbeat model.')
             return
          end if
       end if
    end do

    ! Set transport velocity definitions according to morfile settings, replaces Transportvelocity keyword in MDU, repeat functionality
    !
    jatranspvel = 1                              ! default eul bedload, lag susp load
    if (stmpar%morpar%eulerisoglm) then
        jatranspvel = 2                          ! everything euler
    end if

    if (stmpar%morpar%glmisoeuler) then
        jatranspvel = 0                          ! everything lagrangian
    end if
    !
    call nullsedtra(sedtra)
    call allocsedtra(sedtra, stmpar%morpar%moroutput, max(kmx,1), stmpar%lsedsus, stmpar%lsedtot, 1, ndx, 1, lnx, stmpar%morpar%nxx, stmpar%morpar%moroutput%nstatqnt)

    morbnd              => stmpar%morpar%morbnd
    do k = 1,nopenbndsect
       j0 = 0
       if( k > 1 ) j0 = nopenbndlin(k-1)
       npnt = nopenbndlin(k) - j0
       morbnd(k)%npnt = npnt
       if( associated(morbnd(k)%nm) ) deallocate( morbnd(k)%nm, morbnd(k)%nxmx, morbnd(k)%lm )
       allocate (morbnd(k)%nm(npnt) )
       allocate( morbnd(k)%nxmx(npnt) )
       allocate( morbnd(k)%lm(npnt) )
       allocate( morbnd(k)%alfa_dist(npnt) )
       allocate( morbnd(k)%alfa_mag(npnt) )
       do j = 1,npnt
          Lf = lne2ln( openbndlin(j+j0) )
          morbnd(k)%lm(j) = Lf
          morbnd(k)%nxmx(j) = ln(2,Lf)
          morbnd(k)%nm(j)   = ln(1,Lf)
          if( j == 1 ) then
             morbnd(k)%alfa_dist(j) = wu(Lf)
          else
             morbnd(k)%alfa_dist(j) = morbnd(k)%alfa_dist(j-1) + wu(Lf)
          endif
          morbnd(k)%alfa_mag(j) = 1.0d0
       enddo
    enddo

    if ( jased.eq.4 .and. ibedlevtyp .ne. 1 ) then
        if (stmpar%morpar%bedupd) then
           call mess(LEVEL_FATAL, 'unstruc::flow_sedmorinit - BedlevType should equal 1 in combination with SedimentModelNr 4 ')   ! setbobs call after fm_erosed resets the bed level for ibedlevtyp > 1, resulting in no bed level change
           return
        else
           call mess(LEVEL_WARN , 'unstruc::flow_sedmorinit - BedlevType should equal 1 in combination with SedimentModelNr 4 ')
        endif
    end if

    nbr = network%brs%count
    if ( jased.eq.4 .and. nbr > 0) then
       do ibr = 1, nbr
           pbr => network%brs%branch(ibr)
           pointscount = pbr%gridPointsCount
           do i = 1, pointscount
              k1 = pbr%grd(i)
              if (gridpoint2cross(k1)%cross(1) .eq. 0) then
                 npnterror = npnterror + 1
                 call mess(LEVEL_WARN , 'Grid point '//trim(pbr%gridPointIDs(i))//' has no cross section. This is a requirement for morphological updating.')
              endif
           enddo
       enddo
       write(errstr,'(I0)') npnterror
       if (stmpar%morpar%bedupd) then
          if( npnterror > 0 ) then
             call mess(LEVEL_FATAL, 'A cross section is needed at every grid point for morphological updating. '//trim(errstr)//' grid points detected without cross section. Please adjust the input.')
             return
          endif
       endif
    endif

    if ( associated(mtd%seddif) .and. .false.) then ! for re-initialize
       deallocate(mtd%dzbdt)
       deallocate(mtd%uau)
       deallocate(mtd%rhowat)

       deallocate(mtd%seddif)
       deallocate(mtd%sed)
       deallocate(mtd%ws)
       deallocate(mtd%blchg)

       call clearstack (mtd%messages)
       deallocate(mtd%messages)
    end if

    ! ad hoc allocation of dummy variables
    allocate(mtd%dzbdt(ndx))
    allocate(mtd%uau(lnkx))
    allocate(mtd%rhowat(ndkx))
    allocate(mtd%seddif(stmpar%lsedsus,ndkx))
    allocate(mtd%sed(stmpar%lsedsus,ndkx))
    allocate(mtd%ws(ndkx,stmpar%lsedsus))
    allocate(mtd%blchg(Ndx))
    allocate(mtd%messages)
    call initstack     (mtd%messages)
    !
    mtd%dzbdt       = 0.0_fp
    mtd%uau         = 0.0_fp
    if (kmx .eq. 0) then
       mtd%rhowat   = rhomean
    else
       mtd%rhowat   = rho        ! TO DO JRE: update every timestep when 3D and jasal>0 or jatem>0
    end if
    mtd%seddif      = 0.0_fp
    mtd%sed         = 0.0_fp
    mtd%ws          = 0.0_fp
    mtd%blchg       = 0.0_fp
    !
    ! Array for transport.f90
    mxgr = stmpar%lsedsus
    if ( allocated(sed) ) deallocate(sed)
    if (stmpar%lsedsus .gt. 0) then
       allocate(sed(stmpar%lsedsus,Ndkx))
       sed = 0d0
    end if
    vismol          = 4.d0/(20.d0 + backgroundwatertemperature)*1d-5 ! Van Rijn, 1993, from iniphys.f90
    !
    call rdinimorlyr(stmpar%lsedtot, stmpar%lsedsus, mdia, error, &
                   & griddim, stmpar%morlyr, stmpar%morpar, stmpar%sedpar, &
                   & .false., .false.)
    if (error) then
        call mess(LEVEL_FATAL, 'unstruc::flow_sedmorinit - Error in subroutine rdinimorlyr.')
        return
    end if
    !    set pointers
    call inipointers_erosed()
    call initsedtra(sedtra, stmpar%sedpar, stmpar%trapar, stmpar%morpar, stmpar%morlyr, rhomean, ag, vismol, 1, ndx, ndx, stmpar%lsedsus, stmpar%lsedtot)
    !
    !   for boundary conditions: map suspended fractions index to total fraction index
    !
    if (allocated(sedtot2sedsus)) deallocate(sedtot2sedsus)
    allocate(sedtot2sedsus(stmpar%lsedsus))
    sedtot2sedsus = 0
    isus = 1
    isusmud = 0
    isussand = 0
    do ifrac=1, stmpar%lsedtot
       if (stmpar%sedpar%sedtyp(ifrac) == SEDTYP_COHESIVE .or. &
           stmpar%sedpar%sedtyp(ifrac) == SEDTYP_NONCOHESIVE_SUSPENDED) then
          sedtot2sedsus(isus) = ifrac
          isus = isus + 1
       end if
       !
       ! Count them
       !
       if (stmpar%sedpar%sedtyp(ifrac) == SEDTYP_COHESIVE) isusmud = isusmud + 1
       if (stmpar%sedpar%sedtyp(ifrac) == SEDTYP_NONCOHESIVE_SUSPENDED) isussand = isussand + 1
    end do
    !
    if (numfracs > 0) then    ! fractions from boundaries
       !
       ! Check whether all suspended fractions sand/mud have boundaries
       !
       have_mudbnd = .false.
       have_sandbnd = .false.
       do isf = 1, stmpar%lsedsus
          if (stmpar%sedpar%sedtyp(sedtot2sedsus(isf))==SEDTYP_COHESIVE) then
             have_mudbnd = .true.
          end if

          if (stmpar%sedpar%sedtyp(sedtot2sedsus(isf))==SEDTYP_NONCOHESIVE_SUSPENDED) then
             have_sandbnd = .true.
          end if
       end do

       !if (have_mudbnd)  stmpar%morpar%eqmbcmud = .false.
       !if (have_sandbnd) stmpar%morpar%eqmbcsand = .false.

    end if
    !
    !
    ! If Van Rijn 2004 transport formula is used (iform = -2), switch on the
    ! bed roughness height predictor. By default this predictor is set to the
    ! Van Rijn 2004 formulations; give a warning if this has been set to a
    ! different predictor by the user.
    !
    do i = 1, stmpar%lsedtot
       if (stmpar%trapar%iform(i) == -2) then
          if (bfmpar%bdfrpt /= 0) then
             call mess(LEVEL_WARN, 'unstruc::flow_sedmorinit - Van Rijn 2004 transport formula combined with different bedform roughness predictor.')
          endif
          bfmpar%lfbedfrmrou = .true.
          exit
       endif
    enddo
    !
    ! Set output interval in case that moroutput%avgintv(1)>0d0
    !
    if (stmpar%morpar%moroutput%morstats .and. (.not. stmpar%morpar%moroutput%dmsedcum) .and. (stmpar%morpar%moroutput%nstatqnt==1+stmpar%lsedtot)) then
       stmpar%morpar%moroutput%morstats = .false.
       call mess(LEVEL_WARN, 'unstruc::flow_sedmorinit - Time vector for morstats specified in mor-file, but no quantities. Skipping morstats output.')
    endif
    !
    if (stmpar%morpar%moroutput%morstats) then
       ! Check whether anything is asked in mor file
       success = .true.
       if (.not. size(stmpar%morpar%moroutput%avgintv,1)==3) then
          success = .false.
       end if
       call getOutputTimeArrays(stmpar%morpar%moroutput%avgintv, ti_seds, ti_sed, ti_sede, success)
       if (ti_sed > (tstop_user-tstart_user)) then
          ti_sed = tstop_user-tstart_user
          call mess(LEVEL_WARN, 'unstruc::flow_sedmorinit - The averaging interval for time averaged sedmor output is larger than output duration in the simulation.')
          write(msgbuf, *)      '                           Setting ''AverageSedmorOutputInterval'' from *.mor file to tstop-tstart = ', ti_sed, ' s.'
          call warn_flush()
       endif
       time_sed = tstart_user + stmpar%morpar%tmor*tfac    ! model time
       ti_seds  = max(ti_seds,time_sed)
       time_sed = ti_seds
       !
       call morstats_setflags()
    end if
    !
    ! Arrays for transports before upwinding and bed slope effects
    if (stmpar%morpar%moroutput%rawtransports) then
       if (allocated(sbcx_raw)) then
          deallocate(sbcx_raw, sbcy_raw,sswx_raw,sswy_raw,sbwx_raw,sbwy_raw)
       endif
       call realloc(sbcx_raw,(/ndx, stmpar%lsedtot/),stat=ierr,fill=0d0, keepExisting=.false.)
       call realloc(sbcy_raw,(/ndx, stmpar%lsedtot/),stat=ierr,fill=0d0, keepExisting=.false.)
       call realloc(sbwx_raw,(/ndx, stmpar%lsedtot/),stat=ierr,fill=0d0, keepExisting=.false.)
       call realloc(sbwy_raw,(/ndx, stmpar%lsedtot/),stat=ierr,fill=0d0, keepExisting=.false.)
       call realloc(sswx_raw,(/ndx, stmpar%lsedtot/),stat=ierr,fill=0d0, keepExisting=.false.)
       call realloc(sswy_raw,(/ndx, stmpar%lsedtot/),stat=ierr,fill=0d0, keepExisting=.false.)
    endif

    return
end subroutine flow_sedmorinit

subroutine flow_dredgeinit()
   use m_dad
   use m_rddredge,   only: rddredge, initdredge
   use unstruc_model, only: md_dredgefile
   use m_sediment, only: stm_included, jased
   use m_flowparameters, only: jatransportmodule
   use MessageHandling, only: mess, LEVEL_FATAL

   implicit none

   logical                   :: error

   if (.not.stm_included) return
   dad_included = len_trim(md_dredgefile) /= 0
   if (.not. dad_included) return

   if ( stm_included .and. jased.ne.0 .and. jatransportmodule.eq.0 ) then
      call mess(LEVEL_FATAL, 'unstruc::flow_dredgeinit - Please use transport module with sediment model 4.')
   end if

   call initdredge(dadpar)
   call rddredge(dadpar, md_dredgefile, error)
   if (error) then
      call mess(LEVEL_FATAL, 'unstruc::flow_dredgeinit - Error in initialisation of dredging module.')
   end if

end subroutine flow_dredgeinit
!
! Bedform prediction routines
!
subroutine flow_bedforminit(stage)
   use m_bedform
   use m_bedform_io, only: fm_rdbedformpar, fm_initbedformpar
   use unstruc_model, only: md_bedformfile
   use MessageHandling, only: mess, LEVEL_FATAL

   implicit none

   logical                      :: error
   integer, intent(in)          :: stage

   if (stage==1) then

      call fm_initbedformpar(bfmpar, error)              ! need to initialize the data structure for
                                                         ! eg dredge, tauwave and bed roughness, even if no bedformfile there..
                                                         ! this resets bfmpar%lfbedfrmrou = .true. to .false., so need two stages:
                                                         ! one before sedmorinit, and one after
      if (error) then
         call mess(LEVEL_FATAL, 'unstruc::flow_bedforminit - Error in initialisation of bedform module.')
         return
      end if

   else if (stage==2) then

      !
      bfm_included = len_trim(md_bedformfile) /= 0
      if (.not. bfm_included) return
      !
      call fm_rdbedformpar(bfmpar, md_bedformfile, error)
      if (error) then
         call mess(LEVEL_FATAL, 'unstruc::flow_bedforminit - Error in reading of bedform file.')
         return
      end if
   end if

end subroutine flow_bedforminit


!! Initialise net link based kd-tree for trachytopes or calibration
subroutine netlink_tree(phase)

    use network_data, only: numl, xk, yk, kn
    use kdtree2Factory
    use m_missing
    use m_sferic, only: jsferic, jasfer3D
    use geometry_module, only :half
    implicit none

    integer :: L, k1, k2, ierror
    integer, intent(in)  :: phase

    double precision, dimension(:), allocatable :: xuL       !< xu points on net-links
    double precision, dimension(:), allocatable :: yuL       !< yu points on net-links

    if (phase == 0) then
    !   allocation step
        allocate(xuL(numL), yuL(numL))
        xuL = DMISS
        yuL = DMISS
        do L=1,numL
           k1 = kn(1,L)
           k2 = kn(2,L)
           call half(xk(k1), yk(k1),  xk(k2), yk(k2), xuL(L), yuL(L), jsferic, jasfer3D)
        end do

        !   build kdtree
        call build_kdtree(treeglob,numL,xuL,yuL,ierror,jsferic, dmiss)
        call realloc_results_kdtree(treeglob,1)   ! safety

        if ( allocated(xuL) ) deallocate(xuL)
        if ( allocated(yuL) ) deallocate(yuL)

    endif

    if (phase == 1) then
    !   deallocation step
        if ( treeglob%itreestat.ne.ITREE_EMPTY ) call delete_kdtree2(treeglob)
    endif

end subroutine



!! Initialise trachytope module containing FM data for trachytopes.
!! Note that arrays are dimensioned on the number of net links
!! This was done so that roughness characteristics can be specified
!! not related to the location of open boundaries, which are not
!! yet available at the time the model is constructed.
!! Besides that certain sediment transport formulae require a
!! Cf at the flow node, which can only accurately be deterimined if the
!! values at net links are known.
subroutine flow_trachyinit()
    use grid_dimens_module
    use network_data, only: numl, lne, xk, yk, kn, lnn
    use unstruc_model   ! (contains md_ptr)
    use m_flowparameters
    use m_flowgeom
    use m_physcoef, only: ifrctypuni, frcuni
    use m_flow, only: kmx, zslay, hs, ucx, ucy, z0urou
    use m_flowtimes, only: dts, dt_user
    use m_trachy   ! (FM module containing trachy data structure)
    use m_rdtrt    ! (contains dimtrt)
    use m_trtrou   ! (contains chktrt)
    use unstruc_files, only: mdia
    use m_bedform, only: bfmpar
    use m_sediment
    use unstruc_messages
    use trachytopes_data_module, only: TRACHY_UNDEFINED, TRACHY_NOT_IN_SUBDOMAIN ! = -99999, -77777
    use m_monitoring_crosssections, only: crs, ncrs
    use m_observations,  only: namobs, numobs
    use kdtree2Factory
    use m_missing
    use m_sferic, only: jsferic,jasfer3D
    use geometry_module, only: dbdistance, half
    use m_vegetation, only: jabaptist
    !
    implicit none
    !
    integer, pointer :: ntrtcrs
    integer, pointer :: ntrtobs
    !
    double precision :: xE, yE, xF, yF, x, y, dist
    double precision, parameter :: dtol_trachy = 1d-4        !< tolerance for distance in finding net-link numbers based on xuL,yuL
    !
    double precision, dimension(:), allocatable :: xuL       !< xu points on net-links
    double precision, dimension(:), allocatable :: yuL       !< yu points on net-links
    !
    integer :: istat, ierror
    integer :: itt
    integer :: k, kL, kR, k1, k2
    integer :: icrs
    integer :: iobs
    integer :: itrt
    integer :: itrtcrs
    integer :: itrtobs
    integer :: L
    integer :: LF
    integer :: ddbval   = 0
    integer :: threshold_abort_current

    double precision :: dummy_tunit = 1d0
    double precision :: cz_dum, hh
    !
    logical :: lftrto
    logical :: error
    logical :: trt_in_arl = .false.                           ! is trachytope in arl definitions (used for error logging of discharge and waterlevel dependent trachytopes)
    !
    character(256),          pointer   :: flnmD50
    character(256),          pointer   :: flnmD90
    logical,                 pointer   :: lfbedfrmrou
    !
    ! Pointers to module vars
    !
    flnmD50       => bfmpar%flnmD50
    flnmD90       => bfmpar%flnmD90
    lfbedfrmrou   => bfmpar%lfbedfrmrou
    !
    if (allocated(sig        )) deallocate(sig        )
    if (allocated(umag       )) deallocate(umag       )
    if (allocated(z0rou      )) deallocate(z0rou      )
    if (allocated(dx_trt     )) deallocate(dx_trt     )
    if (allocated(hu_trt     )) deallocate(hu_trt     )
    if (allocated(kcu_trt    )) deallocate(kcu_trt    )

    kmaxtrt = max(kmx, 1)
    allocate(sig(kmaxtrt)) ; sig = 0d0
    allocate(umag(ndx))    ; umag  = 0d0
    allocate(z0rou(ndx))   ; z0rou = 0d0
    !
    ! Allocate arrays for moving data from flow links to net links
    !
    allocate(hu_trt(numl))
    allocate(kcu_trt(numl)) ! TODO: alle deallocs oplossen, zodra FM ook een flow_finalize heeft.
    allocate(dx_trt(numl))
    !
    !
    ! Temporariliy set threshold for abort to LEVEL_FATAL
    threshold_abort_current = threshold_abort
    threshold_abort = LEVEL_FATAL
    !
    if (jawave==0) then
       do k = 1, ndx
          hh = max(hs(k), epshs)
          call getczz0(hh, frcuni, ifrctypuni, cz_dum, z0rou(k))
       end do
    else
       z0rou = 0d0
       do L=1,lnx
          k1=ln(1,L); k2=ln(2,L)
          z0rou(k1) = z0rou(k1) + wcl(1,L)*z0urou(L)
          z0rou(k2) = z0rou(k2) + wcl(2,L)*z0urou(L)
       enddo
    end if
    !
                                                               ! Delft3D       sig        FM      slay        at centre cell (FM)         conversion FM to Delft3D style
                                                               !             0 = top             1 = top
    do k = 1, kmx                                              ! k = 1         -1/6      j=kmx      1                                       sig(1) = 1.0 - 0.5*slay(kmx)   - 0.5*slay(kmx-1)
        sig(k) = 1.0 - 0.5*zslay(kmx-k+1,1) - 0.5*zslay(kmx-k,1) ! k = 2         -1/2      j= 2      2/3    0.5*slay(j) + 0.5*slay(j-1)       sig(2) = 1.0 - 0.5*slay(kmx-1) - 0.5*slay(kmx-1-1)
    end do                                                     ! k = 3 = kmx   -5/6      j= 1      1/3                                      sig(3) = 1.0 - 0.5*slay(kmx-2) - 0.5*slay(kmx-2-1)
                                                               !                         j= 0       0                                       sig(k) = 1.0 - 0.5*slay(kmx-k+1) - 0.5*slay(kmx-k)
                                                               !             -1 = bed             0 = bed

    error = .false.

    ! If trachytopes not defined return
    !if (jatrt == 0) return

    ! Construct a default griddim struct (dimension is lnx = number of flow links )  ! (better dimension is numl based on number of net links)
    ! (Contrary to the morphology routine call (where the dimension is ndxi)
    ! [TO DO: make uniform, or adjust griddim structure to allow both flow nodes, net links (& flow-links)?]
    call simplegrid_dimens(griddim, numl, 1)

    ! Construct memory structure for trachytopes on flow links
    call inittrachy(trachy_fl, 1, istat)

    ! Read dimensions of trachytope memory structure
    call dimtrt(mdia    ,error     ,trachy_fl,   trtdef_ptr , &
              & griddim )
    if (error) then
        call SetMessage(LEVEL_FATAL, 'flow_trachyinit:: Error reading trachytope dimensions (dimtrt)')
    end if

    call rdtrt(mdia      ,error     ,lftrto    , dt_user   , &                !lftrto = jatrt (read twice, in unstruc_model and rdtrt), so always true after rdtrt
             & kmaxtrt   ,itimtt    ,trachy_fl , &
             & griddim   ,0.1_fp    ,trtdef_ptr    ,.false.   , &
             & ddbval    ,dummy_tunit)
    if (error) then
        call SetMessage(LEVEL_FATAL, 'flow_trachyinit:: Error reading trachytopes (rdtrt)')
    end if

    ! Initialise kcu_trt
    kcu_trt = 1
    do L = 1,numl
       trachy_fl%dir(1)%kcu_trt(L) = kcu_trt(L) ! Copy here to be able to pass on to chktrt. TODO: choose which kcu_trt should remain (or both).
    enddo

    ! Check if trachytopes are defined
    call chktrt(mdia     , error  , griddim, &
              & trachy_fl, flnmD50, flnmD50, lfbedfrmrou, stm_included, ddbval)
    if (error) then
        call SetMessage(LEVEL_FATAL, 'unstruc::flow_trachyinit - Error reading trachytope definitions')
    end if

    allocate(xuL(numL), yuL(numL))   ! can we refer to tree instead ?
    xuL = DMISS
    yuL = DMISS
    do L=1,numL
       k1 = kn(1,L)
       k2 = kn(2,L)
       call half(xk(k1), yk(k1),  xk(k2), yk(k2), xuL(L), yuL(L),  jsferic, jasfer3D)
    end do

    ! Update neighboring links and distance weighting
    do L = 1,numl ! loop is safe for 1D/1D-2D
        kL = lne(1,L)   !flow node neighbouring net-link on from-side  (also for 1D, and 1D-2D)
        kR = lne(2,L)   !flow node neighbouring net-link on to-side    (also for 1D, and 1D-2D)
        if (kL == 0 .and. kR == 0) cycle ! special case for dry areas
        !
        if (kL /= 0 .and. kR /= 0) then

           trachy_fl%dir(1)%lin(1,L) = iabs(kL)
           trachy_fl%dir(1)%lin(2,L) = iabs(kR)
           if (lne2ln(L) > 0) then
               ! net link corresponds to flow link
               trachy_fl%dir(1)%acLin(L) = acl(lne2ln(L))
           else
               ! for example: net link at thin dam internally in the domain
               trachy_fl%dir(1)%acLin(L) = dbdistance(xz(kL),yz(kL),xuL(L),xuL(L),jsferic, jasfer3D, dmiss)/ &
                                           dbdistance(xz(kL),yz(kL),xz(kR),yz(kR),jsferic, jasfer3D, dmiss)
           endif
        else
           ! net link is on closed boundary (Note: 1D network should not get here)
           trachy_fl%dir(1)%lin(1,L) = max(iabs(kR),iabs(kL))
           trachy_fl%dir(1)%lin(2,L) = max(iabs(kR),iabs(kL))
           trachy_fl%dir(1)%acLin(L) = 1.0
        end if
    end do
    !
    ! determine if umag is needed.
    !
    update_umag = .false.
    itrt = 0
    do while ((.not. update_umag) .and. (itrt < trachy_fl%gen%ntrt))
       itrt = itrt + 1
       ! The statement could be optimized a bit more to be evaluated only if such area definitions exist.
       if ((trachy_fl%gen%ittdef(itrt, 2) == 103) .or. (trachy_fl%gen%ittdef(itrt, 2) == 104) .or. (trachy_fl%gen%ittdef(itrt, 2) == 155)) then    ! if Van Rijn roughness predictor or Struiksma roughness predictor or Vaestila vegetation roughness
          update_umag = .true.
       end if
    enddo
    !
    itrt = 0
    do while ((.not. trachy_resistance) .and. (itrt < trachy_fl%gen%ntrt))
       itrt = itrt + 1
       ! The statement could be optimized a bit more to be evaluated only if such area definitions exist (see above).
       if ((trachy_fl%gen%ittdef(itrt, 2) == 154) .or. (trachy_fl%gen%ittdef(itrt, 2) == 155) .or. (trachy_fl%gen%ittdef(itrt, 2) == 156)) then    ! if Baptist type 154
          trachy_resistance = .true.
       end if
    enddo
    if (trachy_resistance .and. (jabaptist >= 2)) then
        call mess(LEVEL_ERROR, 'Trachytopes and Vegetationmodelnr >= 2 cannot be used in the same simulation', mdia)
    endif
    !
    ! Connection to FM definitions
    !
    if (ifrctypuni==0) then
       rouflo = 'CHEZ'
    elseif (ifrctypuni==1) then
       rouflo = 'MANN'
    elseif (ifrctypuni==2) then
       rouflo = 'WHIT'
    elseif (ifrctypuni==3) then
       rouflo = 'WHIT'
    else
       call SetMessage(LEVEL_FATAL, 'Unsupported friction type specified in combination with trachytopes')
    endif

    do L = 1, numl
        kL = lne(1,L) ; kR = lne(2,L)
        if (kL == 0 .and. kR == 0) cycle
        LF = lne2ln(L)
        if (LF > 0) then
            !link is on flow-link
            dx_trt(L) = dx(LF)
        else
            ! link is not on flow-link --> closed boundary
            ! get x,y on midpoint of edge
            xE = xuL(L)
            yE = yuL(L)
            ! get x,y on midpoint of neighbouring flow node
            xF = xz(trachy_fl%dir(1)%lin(1,L))
            yF = yz(trachy_fl%dir(1)%lin(1,L))
            dx_trt(L) = 2.0*dbdistance(xE,yE,xF,yF,jsferic, jasfer3D, dmiss)  ! determine distance (as if it were a flow node)    (dx - oppervlakte/net link lengte ?) (test 2. cel-gemiddelde ruwheid) (3. veel cellen ... )
        end if
    enddo

    do itt = 1, trachy_fl%dir(1)%nttaru

       if (trachy_fl%dir(1)%ittaru(itt,4) == TRACHY_MISSING_VALUE) then
           x=trachy_fl%dir(1)%rttxyz(itt,1)
           y=trachy_fl%dir(1)%rttxyz(itt,2)
           ! z=trachy_fl%dir(1)%rttxyz(itt,3) (not used).

           ! fill query vector
           call make_queryvector_kdtree(treeglob,x,y, jsferic)

           ! find nearest link
           call kdtree2_n_nearest(treeglob%tree,treeglob%qv,1,treeglob%results)

           ! get link number
           L = treeglob%results(1)%idx

           ! check distance
           dist = treeglob%results(1)%dis
           ! dist = dbdistance(xuL(L),yuL(L),x,y)  (alternatively)

           if ( dist.lt.dtol_trachy .and. lnn(L) > 0) then
               trachy_fl%dir(1)%ittaru(itt,4) = L  !(net link number)
           else
               trachy_fl%dir(1)%ittaru(itt,4) = TRACHY_NOT_IN_SUBDOMAIN
           end if
       end if
    end do

    ! check cross-section names and link to local FM cross-section index
    ntrtcrs => trachy_fl%gen%ntrtcrs
    do itrtcrs = 1,ntrtcrs
        do icrs = 1,ncrs
            if (trim(trachy_fl%gen%crs(itrtcrs)%name) == trim(crs(icrs)%name)) then
                trachy_fl%gen%crs(itrtcrs)%id = icrs
            end if
        end do

        itrt = trachy_fl%gen%ittdef(trachy_fl%gen%crs(itrtcrs)%itrt,1)

        trt_in_arl = .false.
        itt = 0
        do while ((.not. trt_in_arl) .and. (itt < trachy_fl%dir(1)%nttaru))
           itt = itt + 1
           if (trachy_fl%dir(1)%ittaru(itt,3) == itrt) then    ! if trachytope is included in .arl file
              trt_in_arl = .true.
           end if
        enddo

        if ((trachy_fl%gen%crs(itrtcrs)%id == TRACHY_UNDEFINED) .and. trt_in_arl) then
            call SetMessage(LEVEL_FATAL, 'Error reading trachytopes: Cross-section does not exist in "'//trim(trachy_fl%gen%md_ttdfile)//'": '//trim(trachy_fl%gen%crs(itrtcrs)%rec132))
        end if
    end do

    ! check observation-station names and link to local FM observation-station index
    ntrtobs => trachy_fl%gen%ntrtobs
    do itrtobs = 1,ntrtobs
        do iobs = 1,numobs
            if (trim(trachy_fl%gen%obs(itrtobs)%name) == trim(namobs(iobs))) then
                trachy_fl%gen%obs(itrtobs)%id = iobs
            end if
        end do

        itrt = trachy_fl%gen%ittdef(trachy_fl%gen%obs(itrtobs)%itrt,1)

        trt_in_arl = .false.
        itt = 0
        do while ((.not. trt_in_arl) .and. (itt < trachy_fl%dir(1)%nttaru))
           itt = itt + 1
           if (trachy_fl%dir(1)%ittaru(itt,3) == itrt) then    ! if trachytope is included in .arl file
              trt_in_arl = .true.
           end if
        enddo

        if ((trachy_fl%gen%obs(itrtobs)%id == TRACHY_UNDEFINED) .and. trt_in_arl) then
            call SetMessage(LEVEL_FATAL, 'Error reading trachytopes: Observation station does not exist in "'//trim(trachy_fl%gen%md_ttdfile)//'": '//trim(trachy_fl%gen%obs(itrtobs)%rec132))
        end if
    end do


    if ( allocated(xuL) ) deallocate(xuL)
    if ( allocated(yuL) ) deallocate(yuL)
    threshold_abort = threshold_abort_current

end subroutine flow_trachyinit


subroutine flow_trachyupdate()
    use unstruc_messages
    use unstruc_files, only: mdia
    use m_flow, only: kmx, zslay, ucx, ucy, cftrt, hu, hs, frcu, ifrcutp, cftrtfac, jacftrtfac, s1
    use m_flowgeom, only: ndx, lnx, kcu, dx, lne2ln, ln2lne, nd, bob, bl
    use m_physcoef
    use m_trachy
    use m_trtrou
    use m_flowparameters, only: eps8, epshs, jacali
    use network_data, only: numl, lne, kn
    use m_monitoring_crosssections
    use m_observations, only: numobs, valobs, IPNT_S1
    use m_calibration, only: calibration_backup_frcu
    use m_sediment
    use m_bedform,  only: bfmpar
    use m_alloc
    use m_vegetation, only: alfav
    !
    implicit none
    !
    integer, pointer :: ntrtcrs
    integer, pointer :: ntrtobs
    !
    integer n, L, LF, k, KL, KR
    integer :: icrs
    integer :: iobs
    integer :: itrtcrs
    integer :: itrtobs
    !
    logical             :: error
    logical, save       :: init_trt = .true.              !< first time function is called
    !
    integer                                , pointer   :: nxx
    integer                                , pointer   :: lsedtot
    integer                                , pointer   :: i50
    integer                                , pointer   :: i90
    real(fp)             , dimension(:)    , pointer   :: rhosol
    real(fp)             , dimension(:,:)  , pointer   :: dxx

    logical                                , pointer   :: spatial_bedform
    real(fp)             , dimension(:)    , pointer   :: bedformD50
    real(fp)             , dimension(:)    , pointer   :: bedformD90
    real(fp)             , dimension(:)    , pointer   :: rksr
    real(fp)             , dimension(:)    , pointer   :: rksmr
    real(fp)             , dimension(:)    , pointer   :: rksd
    !
    error = .false.
    lfdxx = .false.
    !
    if (stm_included) then
       nxx             => stmpar%morpar%nxx
       dxx             => sedtra%dxx
       i50             => stmpar%morpar%i50
       i90             => stmpar%morpar%i90
       rhosol          => stmpar%sedpar%rhosol
       lsedtot         => stmpar%lsedtot
       lfdxx = .true.
    end if
    ! these always exist
    spatial_bedform => bfmpar%spatial_bedform
    bedformD50      => bfmpar%bedformD50
    bedformD90      => bfmpar%bedformD90
    rksr            => bfmpar%rksr
    rksmr           => bfmpar%rksmr
    rksd            => bfmpar%rksd
    !
    ! prepare cross-section information to pass to trachytopes module
    !
    ntrtcrs => trachy_fl%gen%ntrtcrs
    do itrtcrs=1,ntrtcrs
         icrs = trachy_fl%gen%crs(itrtcrs)%id
         if (.not. (icrs == TRACHY_UNDEFINED)) then
            trachy_fl%gen%crs(itrtcrs)%val = crs(icrs)%sumvalcur(IPNT_Q1C)
         endif
    end do
    !
    ! prepare observation-station information to pass to trachytopes module
    !
    ntrtobs => trachy_fl%gen%ntrtobs
    do itrtobs=1,ntrtobs
        iobs = trachy_fl%gen%obs(itrtobs)%id
        if (.not. (iobs == TRACHY_UNDEFINED)) then
            trachy_fl%gen%obs(itrtobs)%val = valobs(IPNT_S1, iobs)
        endif
    end do
    !
    !
    if (update_umag) then
        ! probably cheaper than looping over all trachtope definitions first (see code below)?
        do n = 1, ndx
           umag(n) = sqrt(ucx(n)**2.0 + ucy(n)**2.0)
        end do
        !
        ! Same code as above but does only updates umag where it is needed
        !
        ! do itt = 1, trachy%dir(1)%nttaru
        !    if ((trachy%dir(1)%ittaru(itt,3) == 103) .or. (trachy%dir(1)%ittaru(itt,3) == 104)) then    ! if Van Rijn roughness predictor or Struiksma roughness predictor
        !        LF = trachy%dir(1)%ittaru(itt,4)                   ! corresponding flow link
        !        do m = 1, 2
        !            n = trachy%dir(1)%ln(m,LF)                       ! corresponding cell centre
        !            umag(n) = sqrt(ucx(n)**2.0 + ucx(n)**2.0)
        !        end do
        !    end if
        ! end do
        !
        ! Alternative: pre-determine flow links which require the variable umag to be set.
        !
    end if
    !
    ! Update water levels and link info (open or closed) on net-links
    !
    do L = 1, numl
        kL = lne(1,L) ; kR = lne(2,L)
        if (kL == 0 .and. kR == 0) cycle
        LF = lne2ln(L)
        if (LF > 0) then
            ! flow link crosses with net link
            if (hu(LF) > 0) then
                kcu_trt(L) = 1     ! warning: kcu arrays in Delft3d and Dflow-FM have different meanings
            else
                kcu_trt(L) = 0
            end if
            hu_trt(L)  = hu(LF)
            trachy_fl%dir(1)%blu_trt(L)  = min( bob(1,LF), bob(2,LF) )
        else
            ! net link lies on boundary, take neighbouring flow node value.
            hu_trt(L)  = hs(trachy_fl%dir(1)%lin(1,L))
            trachy_fl%dir(1)%blu_trt(L) = bl(trachy_fl%dir(1)%lin(1,L))
            kcu_trt(L) = 0        !link is not on flow-link --> closed boundary  ! TO DO: this line causes that the roughness is not computed in trtrou (important for morphology in combination with trachtopes along closed boundaries)
        end if
    enddo
    !
    ! Update background friction and water level
    !
    if (init_trt) then
        !
        do L = 1, numl
            kL = lne(1,L) ; kR = lne(2,L)
            if (kL == 0 .and. kR == 0 ) cycle
            trachy_fl%dir(1)%zsu_prev(L) = trachy_fl%dir(1)%blu_trt(L) + hu_trt(L)
        end do
        !
        do LF = 1, lnx
            if (ifrcutp(LF) /= ifrctypuni) then
                error = .true.
                call mess(LEVEL_ERROR, 'Only uniform background roughness definition supported in combination with Trachytopes', mdia)
            end if
        end do
        do L = 1, numl
            kL = lne(1,L) ; kR = lne(2,L)
            if (kL == 0 .and. kR == 0) cycle
            LF = lne2ln(L)
            if (LF > 0) then
                cftrt(L,3) = frcu(LF)  !link is on flow-link
            else
                k = trachy_fl%dir(1)%lin(1,L)  ! neighbouring flow node
                cftrt(L,3) = 0.0
                do n = 1,nd(k)%lnx
                    LF = iabs(nd(k)%ln(n))  ! neighbouring flow links to flow node
                    cftrt(L,3) = cftrt(L,3) + frcu(LF)
                end do
                cftrt(L,3) = cftrt(L,3)/max(nd(k)%lnx,1)
            end if
        enddo
    init_trt = .false.
    end if
    !
    ! Perform computation of vegetation and alluvial roughness
    !
    if (stm_included) then
       call trtrou(mdia     ,kmaxtrt   ,numl      , &                                            ! lnx instead of numl ?
                & cftrt     ,rouflo    ,linit     ,dx_trt    , &
                & hu_trt    ,kcu_trt   ,sig       , &
                & z0rou     ,1         ,waqol     ,trachy_fl , &
                & umag      ,1         ,numl      ,1         , ndx      , &                      ! first entry in row r(u1) should be gdp%gderosed%umod !!WO-temp
                & rhomean   ,ag        ,vonkar    , viskin   , &              ! ~z0 used for what?   ~viskin instead of vicmol (Delft3D)
                & eps8      ,epshs     ,spatial_bedform      ,bedformD50,bedformD90, &
                & rksr      ,rksmr     ,rksd      ,error,  &
                & lfdxx     ,nxx       ,lsedtot   ,dxx       , i50      , i90 ,    &
                & rhosol)
    else
        call trtrou(mdia     ,kmaxtrt   ,numl      , &
                & cftrt     ,rouflo    ,linit     ,dx_trt    , &
                & hu_trt    ,kcu_trt   ,sig       , &
                & z0rou     ,1         ,waqol     ,trachy_fl , &
                & umag      ,1         ,numl      ,1         , ndx      , &
                & rhomean   ,ag        ,vonkar    , viskin   , &
                & eps8      ,epshs     ,spatial_bedform      ,bedformD50,bedformD90, &
                & rksr      ,rksmr     ,rksd      ,error,  &
                & lfdxx     ,2         ,1   )      ! nxx, lsedtot
    end if

    if (error) then
        call mess(LEVEL_ERROR, 'Error computing trachytopes', mdia)
    end if
    !
    ! Return vegetation and aluvial roughness to flow-links
    !
    do LF = 1, lnx
        L        = ln2lne(LF)
        frcu(LF) = cftrt(L,2)   !--> cfrou (L,1) to do Delft3D check ...
        if (jacftrtfac == 1) then
           frcu(LF) = frcu(LF) * cftrtfac(LF)  ! This has probably become obsolete
        end if
    end do
    !
    if (trachy_resistance) then
        do LF = 1, lnx
            L = ln2lne(LF)
            alfav(LF) = trachy_fl%dir(1)%rttfu(L,1)/2.0_fp
        enddo
    endif
    !
    if (jacali == 1) then
        call calibration_backup_frcu()
    endif

    !
    ! Example Delft3D call :
    !
    !    call trtrou(lundia    ,kmax      ,nmmax, &
    !              & r(cfurou) ,rouflo    ,.false.   ,r(guu)    ,r(gvu)    , &
    !              & r(hu)     ,i(kcu)    ,r(sig)    , &
    !              & r(z0urou) ,1         ,waqol     , gdtrachy , &
    !              & r(u1)     ,nmlb      ,nmub      , & ! first entry in row r(u1) should be gdp%gderosed%umod !!WO-temp
    !              & rhow      ,ag        ,z0        , vonkar   , vicmol   , &
    !              & eps       ,dryflc    , &
    !              & lfdxx     ,nxx       , dxx      , i50      , i90      ,rhosol, &
    !              & lsedtot   ,spatial_bedform      ,bedformD50,bedformD90, &
    !              & rksr      ,rksmr     , rksd     ,error)
    !

end subroutine flow_trachyupdate

! Initialise calibration factors
subroutine calibration_init()
 use m_calibration
 use unstruc_messages
 use unstruc_model, only: md_cldfile, md_cllfile
 use m_flowgeom,    only: lnx
 use m_flow,        only: ifrcutp, ifrctypuni, frcu, frcu_bkp

 implicit none
 !
 integer         :: LF
 logical         :: error

 do LF = 1, lnx
     if (ifrcutp(LF) /= ifrctypuni) then
         error = .true.
         call mess(LEVEL_ERROR, 'Only uniform background roughness definition supported in combination with [calibration]DefinitionFile')
     end if
 end do

 call read_cldfile(md_cldfile, clddata, GET_DIMENSIONS)
 call read_cldfile(md_cldfile, clddata, FILL_DATA)
 !
 call read_cllfile(md_cllfile, clddata, GET_DIMENSIONS)
 call read_cllfile(md_cllfile, clddata, FILL_DATA)
 !
 ! TO DO: check for obs en crs in domain (similar to trachy code below)

                    ! ! TO DO: Update to allow cross-sections for parts outside domain which are inactive
                    !!itrt = trachy_fl%gen%ittdef(trachy_fl%gen%crs(itrtcrs)%itrt,1)
                    !
                    !!cld_in_arl =  .false.
                    !!itt = 0
                    !!do while ((.not. trt_in_arl) .and. (itt < trachy_fl%dir(1)%nttaru))
                    !!   itt = itt + 1
                    !!   if (trachy_fl%dir(1)%ittaru(itt,3) == itrt) then    ! if trachytope is included in .arl file
                    !!      trt_in_arl = .true.
                    !!   end if
                    !!enddo
                    !!
                    !! TO DO: move to after reading cll ?
                    !if ((clddata%crs(icldcrs) == intmiss) .and. cld_in_arl) then
                    !    call mess(LEVEL_ERROR, 'Error reading calibration definition file: Cross-section does not exist in "'//trim(md_cldfile)//'": '//rec132)
                    !    error = .true.
                    !    goto 9999
                    !end if
                    !
 !
end subroutine calibration_init


subroutine calibration_update()
 use m_calibration
 use m_flow,        only: frcu, frcu_bkp, cfclval
 use m_flowgeom,    only: lnx, ln2lne

 integer :: LF
 integer :: L

 ! Update calibration definitions for discharge and water level dependent values
 call update_clddata()

 ! Update average calibration areal definitions (background calibration value = 1)
 call update_clldata()

 ! Apply calibration factor
 do LF = 1, lnx
     L        = ln2lne(LF)
     frcu(LF) = frcu_bkp(LF) * cfclval(L)
 end do

end subroutine calibration_update

subroutine set_frcu_mor(dim)
    use m_flow, only: frcu, frcu_mor
    use m_flowgeom, only: lnx, lnxi, lnx1d, lnx1Db
    integer, intent(in) :: dim

    integer :: L

    if (dim == 1) then
       do L = 1, lnx1d  ! 1D int
           frcu_mor(L) = frcu(L)
       enddo
       do L = lnxi+1, lnx1Db ! 1D bnd
           frcu_mor(L) = frcu(L)
       enddo
    endif
    if (dim == 2) then
       do L = lnx1d+1, lnxi ! 2D int
           frcu_mor(L) = frcu(L)
       enddo
       do L = lnx1Db+1, lnx ! 2D bnd
           frcu_mor(L) = frcu(L)
       enddo
    endif
end subroutine set_frcu_mor

subroutine cosphiunetcheck(jausererror)
 use m_flowgeom
 use network_data
 use m_alloc
 use unstruc_messages
 use unstruc_display, only: jaGUI
 use m_missing
 use m_partitioninfo
 use m_plotdots

 IMPLICIT NONE
 integer, intent(in) :: jausererror !< Whether or not (1/0) to topup a error message when bad ortho occurs.
 double precision, external :: cosphiunet
 double precision :: csph
 integer :: ndraw, L
 integer :: k1, k2
 integer :: i
 COMMON /DRAWTHIS/ ndraw(50)

 nlinkbadortho = 0
 nlinktoosmall = 0
 call realloc(linkbadqual, 1000)

 ! No checks if no cells are known yet.
 if (nump <= 0) then
    return
 end if

 if ( jampi.eq.0 ) then
    do L = numl1D+1,numl
       csph = cosphiunet(L)
       if (csph /= dmiss .and. abs(csph) > cosphiutrsh) then
          nlinkbadortho = nlinkbadortho+1
           linkbadqual(nlinkbadortho) = L
       endif
       if (nlinkbadortho >= 1000) exit
    enddo
 else

 !  do not check orthogonality in parallel runs (findcells may have created non-existing cells in ghost area)

 end if

 if (nlinkbadortho > 0) then
     numdots = 0
     do i=1,nlinkbadortho
        L = linkbadqual(i)
        call adddot(0.5d0*(xk(kn(1,L)) + xk(kn(2,L))), 0.5d0*(yk(kn(1,L)) + yk(kn(2,L))))
     end do

     if (jausererror == 1) then
        if ( jagui.eq.1 ) then
            call qnerror('network is not orthogonal','increase cosphiu trsh in network params if you want to create flow model anyway ', ' ')
        else
            call mess(LEVEL_ERROR, 'network is not orthogonal')
        end if ! if ( jagui.eq.1 ) then
     end if
     NDRAW(2)=5 !< Automatically set 'Display > Network + crossing/quality checks'
     call resetflow() ; return
 end if

end subroutine cosphiunetcheck

subroutine dbdistancehk(xa,ya,xb,yb,dist) ! easy way to get a distance in one line of code, without need for specifying 3 modules :
use m_sferic, only: jsferic, jasfer3D
use geometry_module, only: dbdistance
USE M_MISSING
double precision :: xa,ya,xb,yb,dist
dist = DBDISTANCE(xa,ya,xb,yb,jsferic, jasfer3D, dmiss)
end subroutine dbdistancehk

subroutine writesomeinitialoutput()
 use m_sferic
 use m_flow
 use m_netw
 use m_flowgeom
 use m_flowtimes
 use unstruc_messages
 use m_partitioninfo
 use m_samples
 use unstruc_model, only: md_ident
 use geometry_module, only: dbdistance

 implicit none
 integer          :: k, mbalat,mwrong,L,msam, n, nf, jacheckba = 0
 double precision :: batotown(1), batot(1), voltotown(1), volto(1), dist, dismin

 batotown = 0 ; voltotown = 0

 call klok  (cpuall(2))
 call datum (rundat0)

 write(msgbuf,'(a,a)') 'Modelinit finished   at: '         , rundat0                  ; call msg_flush()

 msgbuf = ' ' ; call msg_flush()
 msgbuf = ' ' ; call msg_flush()

 write(msgbuf,'(a,I25)')    'nr of netnodes         ( )  :' , numk                       ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of netlinks         ( )  :' , numl                       ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of flownodes        ( )  :' , ndx                        ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of openbnd cells    ( )  :' , ndx - ndxi                 ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of 1D-flownodes     ( )  :' , ndxi - ndx2d               ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of flowlinks        ( )  :' , lnx                        ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of internal links   ( )  :' , lnxi                       ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of 1D links         ( )  :' , lnx1D                      ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of closed walls     ( )  :' , mxwalls                    ; call msg_flush()

 if (kmx > 0) then
 write(msgbuf,'(a,I25)')    'max nr of layers       ( )  :' , kmx                        ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of 3D cells         ( )  :' , ndkx-2*ndx                 ; call msg_flush()
 write(msgbuf,'(a,I25)')    'nr of 3D links         ( )  :' , Lnkx-2*lnx                 ; call msg_flush()
 endif

 msgbuf = ' ' ; call msg_flush()
 msgbuf = ' ' ; call msg_flush()

 if (jacheckba == 1)  then
    if (jampi == 1) then
       L = index(md_ident,'_0') - 1
       call oldfil(msam, 'ba_'//trim(md_ident(1:L))//'.xyz')
       call reasam(msam, 0)
       call newfil(mwrong, 'bawrong_'//trim(md_ident)//'.xyz')
   endif
   call newfil(mbalat, 'ba_'//trim(md_ident)//'.xyz')
 endif

 DO K = 1,NDXI
    if (jampi == 1) then
       if (idomain(k) == my_rank) then
          batotown(1)  = batotown(1)  +   ba(k)
          voltotown(1) = voltotown(1) + vol1(k)
          if (jacheckba == 1) then
              write(mbalat,*) xz(k), yz(k), ba(k)
              if (ns > 0) then
                 dismin = 1d9 ; nf = 0
                 do n = 1,ns
                    call dbdistancehk(xz(k), yz(k), xs(n), ys(n), dist)
                    if (dist  < dismin) then
                       dismin = dist
                       nf     = n
                    endif
                 enddo
                 if (nf > 0 .and. dismin < 1d0) then
                    if ( abs( ba(k) - zs(nf) ) > 1d-4 ) then
                        write(mwrong,'(4F20.5)') xz(k), yz(k), ba(k), zs(nf)
                    endif
                 endif
              endif
           endif
       endif
    else
       batotown(1)  = batotown(1)  +   ba(k)
       voltotown(1) = voltotown(1) + vol1(k)
       if (jacheckba == 1) then
          write(mbalat,*) xz(k), yz(k), ba(k)
       endif
    endif
 enddo

 if (jacheckba == 1) then
    call doclose(mbalat)
    if (jampi == 1) then
       call doclose(mwrong)
    endif
 endif

 write(msgbuf,'(a,E25.10)') 'my model area          (m2) :' , batotown                   ; call msg_flush()
 if (jampi == 1) then
 k = 1
 call reduce_double_sum(k, batotown, batot )
 write(msgbuf,'(a,E25.10)') 'total model area       (m2) :' , batot                      ; call msg_flush()
 endif

 write(msgbuf,'(a,E25.10)') 'my model volume        (m3) :' , voltotown                  ; call msg_flush()
 if (jampi == 1) then
 k = 1
 call reduce_double_sum(k, voltotown, volto )
 write(msgbuf,'(a,E25.10)') 'total model volume     (m3) :' , volto                     ; call msg_flush()
 endif

 msgbuf = ' ' ; call msg_flush()
 msgbuf = ' ' ; call msg_flush()


 end subroutine writesomeinitialoutput

 subroutine writesomefinaloutput()
 use m_sferic
 use m_flow
 use m_flowgeom
 use m_flowtimes
 use unstruc_messages
 use m_timer
 use m_netw
 use m_partitioninfo
 use m_monitoring_crosssections
 use m_observations, only : mxls
 use unstruc_model, only : md_subfile
#ifdef _OPENMP
 use omp_lib
#endif

 implicit none

 integer           :: k, mout, i
 double precision  :: frac, tot, dtav
 double precision  :: dum, f
 double precision  :: tstop

 character(len=20), dimension(size(cpu_extra,2)) :: cpu_extra_label

 if (ndx == 0) then
    write(msgbuf,'(a)')    'Empty model, no flow cells found. No statistics to report.'; call msg_flush()
    return
 end if

 frac = cpusol(3) / max(1d-10,cpusteps(3))
 call klok(cpuall(3))
 tot  = ( cpuall(3) - cpuall(2) )/ max(1d0, ndx*(dnt-1) )
 dtav = (tstop_user - tstart_user)/max(1d0, dnt-1)

 do k = 1,3
    msgbuf = ' ' ; call msg_flush()
 enddo

! use current time instead of tstop_user in statistics
 tstop = time1
 if ( tstop.ne.tstop_user ) then
   write(msgbuf,'(a,I25)')    'Simulation did not reach stop time'                       ; call msg_flush()
 end if
 msgbuf = ' ' ; call msg_flush()
 msgbuf = ' ' ; call msg_flush()
 msgbuf = ' ' ; call msg_flush()

 write(msgbuf,'(a,F25.10)') 'nr of timesteps        ( )  :' , dnt-1                      ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'average timestep       (s)  :' , dtav                       ; call msg_flush()

 msgbuf = ' ' ; call msg_flush()
 msgbuf = ' ' ; call msg_flush()

 f = 24d0*3600d0
 write(msgbuf,'(a,F25.10)') 'simulation period      (d)  :' , (tstop - tstart_user)/f  ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'total computation time (d)  :' , (cpuall(3) - cpuall(1))/f  ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time modelinit         (d)  :' , (cpuall(2) - cpuall(1))/f  ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time steps (+ plots)   (d)  :' , (cpuall(3) - cpuall(2))/f  ; call msg_flush()

 msgbuf = ' ' ; call msg_flush()

 f = 3600d0
 write(msgbuf,'(a,F25.10)') 'simulation period      (h)  :' , (tstop - tstart_user)/f  ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'total computation time (h)  :' , (cpuall(3) - cpuall(1))/f  ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time modelinit         (h)  :' , (cpuall(2) - cpuall(1))/f  ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time steps (+ plots)   (h)  :' , (cpuall(3) - cpuall(2))/f  ; call msg_flush()

 msgbuf = ' ' ; call msg_flush()

 write(msgbuf,'(a,F25.10)') 'simulation period      (s)  :' , tstop - tstart_user   ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'total computation time (s)  :' , cpuall(3) - cpuall(1)      ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time modelinit         (s)  :' , cpuall(2) - cpuall(1)      ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time steps (+ plots)   (s)  :' , cpuall(3) - cpuall(2)      ; call msg_flush()
 cpu_extra_label       = ' '
 cpu_extra_label(1:45) = [ 'Basic steps         ', 'Wave input          ', 'Internal links      ', &
                           'Flow geometry       ', 'Bobsongullies       ', 'Wave initialisation ', &
                           'Flow grid           ', 'Bed forms init (1)  ', '1D rougnhess        ', &
                           'Sed/mor             ', 'Bed forms init (2)  ', 'Adm. vertical       ', &
                           'Net link tree 0     ', 'Flow trachy init    ', 'Calibration init    ', &
                           'Net link tree 1     ', 'Save 1d             ', 'WAQ processes init  ', &
                           'Transport init      ', 'Part init           ', 'Observations init   ', &
                           'Structures init     ', 'Flow init           ', 'MBA init            ', &
                           'Update MOR width    ', 'Dredging init       ', 'Xbeach init         ', &
                           'Observations init 2 ', 'Structure parameters', 'Trachy update       ', &
                           'Set fcru MOR        ', 'Flow init           ', 'Fourier init        ', &
                           'MDU file pointer    ', 'Flowgeom            ', 'Remainder           ', &
                           'Flow alloc          ', 'initime setbnd      ', 'initime sethuau     ', &
                           'initime setdt       ', 'initime advec       ', 'initime u0u1        ', &
                           'initime setumod     ', 'initime cfuhi       ', 'initime structactual']

 do i = 1,size(cpu_extra,2)
     if ( cpu_extra_label(i) /=  ' ' ) then
         write(msgbuf,'(a,a,F25.10)') 'extra timer:' , cpu_extra_label(i), cpu_extra(2,i) - cpu_extra(1,i)      ; call msg_flush()
     endif
 enddo

 msgbuf = ' ' ; call msg_flush()
 msgbuf = ' ' ; call msg_flush()

 write(msgbuf,'(a,F25.10)') 'time iniexternalforc.  (s)  :' , cpuiniext(3)               ; call msg_flush()

 msgbuf = ' ' ; call msg_flush()

 write(msgbuf,'(a,F25.10)') 'time inistep           (s)  :' , cpuinistep(3)              ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time setumod           (s)  :' , cpuumod(3)                 ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time furu              (s)  :' , cpufuru(3)                 ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time solve             (s)  :' , cpusol(3)                  ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time setexternalforc.  (s)  :' , cpuext(3)                  ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time setexternalfbnd.  (s)  :' , cpuextbnd(3)               ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'time steps             (s)  :' , cpusteps(3)                ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'fraction solve/steps   ( )  :' , frac                       ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'total/(dnt*ndx)        (s)  :' , tot                        ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'av nr of cont. it s1it ( )  :' , dnums1it/max(dnt,1d-8)     ; call msg_flush()

 if ( jatimer.eq.1 ) then
    write(msgbuf,'(a,F25.10)') 'time transport [s]         :' , gettimer(1,ITRANSPORT)
    call msg_flush()
    if (ti_waqproc /= 0) then
       write(msgbuf,'(a,F25.10)') 'time processes [s]         :' , gettimer(1,IFMWAQ)
       call msg_flush()
    endif
    write(msgbuf,'(a,F25.10)') 'time debug     [s]         :' , gettimer(1,IDEBUG)
    call msg_flush()

    write(msgbuf,'(a,F25.10)') 'time filter coeff.      [s]:' , gettimer(1,IFILT_COEF)
    call msg_flush()
    write(msgbuf,'(a,F25.10)') 'time filter solve       [s]:' , gettimer(1,IFILT_SOLV)
    call msg_flush()
    write(msgbuf,'(a,F25.10)') 'time filter cnstr. mat. [s]:' , gettimer(1,IFILT_MAT)
    call msg_flush()
    write(msgbuf,'(a,F25.10)') 'time filter copy back   [s]:' , gettimer(1,IFILT_COPYBACK)
    call msg_flush()
    write(msgbuf,'(a,F25.10)') 'time filter other       [s]:' , gettimer(1,IFILT_OTHER)
    call msg_flush()
    write(msgbuf,'(a,F25.10)') 'time filter             [s]:' , gettimer(1,IFILT)
    call msg_flush()
 end if

 do k = 1,3
    msgbuf = ' ' ; call msg_flush()
 enddo

 write(msgbuf,'(a,a)') 'Computation started  at: '         , rundat0                  ; call msg_flush()
 call datum(rundat0)
 write(msgbuf,'(a,a)') 'Computation finished at: '         , rundat0                  ; call msg_flush()
 msgbuf = ' ' ; call msg_flush()

 write(msgbuf,'(a,F25.10)') 'simulation period      (h)  :' , (tstop - tstart_user)/3600d0 ; call msg_flush()
 write(msgbuf,'(a,F25.10)') 'total time in timeloop (h)  :' , (cpuall(3) - cpuall(2)   )/3600d0 ; call msg_flush()


#ifdef HAVE_MPI
 if (jampi == 1) then
    write(msgbuf,'(a,i0,a,i0)') 'MPI    : yes.         #processes   : ', numranks, ', my_rank: ', my_rank; call msg_flush()
 else
    write(msgbuf,'(a)')         'MPI    : no.'         ; call msg_flush()
 end if
#else
    write(msgbuf,'(a)')         'MPI    : unavailable.'; call msg_flush()
#endif

#ifdef _OPENMP
 write(msgbuf,'(a,i0)')         'OpenMP : yes.         #threads max : ', omp_get_max_threads()           ; call msg_flush()
#else
 write(msgbuf,'(a)')            'OpenMP : unavailable.'; call msg_flush()
#endif

 do k = 1,3
    msgbuf = ' ' ; call msg_flush()
 enddo

 ! if (ti_xls > 0) then
    ! call wrirstfileold(time1)                        ! schrijf aan het einde     een ascii.rst-file weg
 call wrinumlimdt()                               ! number of limitating timesteps per node
 ! endif
 ! call unc_write_his(time1)                         ! schrijf aan het einde ook een .his-file weg
 ! call wrimap(time1)                                ! schrijf aan het einde ook een .map-file weg

!   call mba_final(time_user)
 if (ti_waqbal > 0) then
    call mba_final(time_user)
 endif

 if ( len_trim(md_subfile) > 0 ) then
    call fm_wq_processes_finalise()
 endif

 msgbuf = ' ' ; call msg_flush()

 if (mxls > 0 .and. ncrs>0) then
    write(msgbuf,'(a)')         'crosssection discharges (m3/s) : '  ; call msg_flush()
    do i = 1, ncrs
       write(msgbuf,'(F14.3)') crs(i)%sumvalcur(1) ; call msg_flush()
    enddo
    write(msgbuf,'(a)')         'crosssection areas (m2) : '         ; call msg_flush()
    do i = 1, ncrs
       write(msgbuf,'(F14.3)') crs(i)%sumvalcur(2) ; call msg_flush()
    enddo
 endif

 end subroutine writesomefinaloutput


 subroutine wrinumlimdt()
 use m_flowgeom, only : ndx, xz, yz
 use m_flow, only : numlimdt
 use unstruc_model, only : md_ident, getoutputdir
 implicit none
 integer :: mlim, k

 call newfil(mlim, trim(getoutputdir()) // trim(md_ident) // '_numlimdt.xyz')
 do k = 1, ndx
    if (numlimdt(k) > 0) then
       write(mlim, *) xz(k), yz(k), numlimdt(k)
    endif
 enddo
 call doclose(mlim)

 end subroutine wrinumlimdt

 subroutine reanumlimdt()
 use m_flowgeom
 use m_GlobalParameters, only: INDTP_ALL

 use m_flow
 use m_partitioninfo
 use m_samples
 implicit none
 character(len=256)   :: name, nams
 logical              :: jawel
 integer              :: mlim, k, numlimdtk, kk, jakdtree=1, jaoutside=0
 double precision     :: xdum, ydum
 integer, allocatable :: knum(:)

 if ( jampi.eq.0 ) then
    name = 'prev_numlimdt.xyz'
 else
    name = 'prev_numlimdt'//'_'//trim(sdmn)//'.xyz'
 endif
 inquire(file=name, exist = jawel)
 if (jawel) then

    call oldfil(mlim, trim(name))
    call increasesam(ndx)
    kk = 0
    do k = 1,ndx
       kk = kk + 1
       read(mlim, *, end=999) xs(kk), ys(kk), zs(kk)
    enddo
    999 continue
    call doclose(mlim)
    allocate(knum(ndx)) ; knum = 0
    kk = kk - 1
    call find_flownode(kk, xs, ys, nams, knum, jakdtree, jaoutside, INDTP_ALL)
    do k = 1,kk
       if (knum(k) > 0) then
          numlimdt(knum(k)) = zs(k)
       endif
    enddo

    deallocate(xs,ys,zs,knum)
 endif
 end subroutine reanumlimdt


 !subroutine wricir()
 !use m_sferic
 !use m_flow
 !use m_flowgeom
 !implicit none
 !integer :: mout, k
 !double precision :: phi, r0
 !
 !return
 !call inisferic()
 !call newfil(mout,'circ250.ldb')
 !write(mout,'(a)') 'L001'
 !write(mout,'(a)') '360 2'
 !r0 = 125000d0
 !do k = 0,360
 !   phi = dg2rd*k
 !   write(mout,*) r0*cos(phi), r0*sin(phi), r0, r0
 !enddo
 !call doclose(mout)
 !
 !end subroutine wricir


 subroutine zerowaterdepth()                         ! restart without water
 use m_flow
 use m_flowgeom
 implicit none
 s0 = bl
 s1 = bl
 u0 = 0d0
 u1 = 0d0
 end subroutine zerowaterdepth

 subroutine zerowaterlevel()                         ! restart without water
 use m_flow
 use m_flowgeom
 implicit none
 s0 = 0d0
 s0 = max(bl,s0)
 s1 = s0
 u0 = 0d0
 u1 = 0d0
 end subroutine zerowaterlevel


 !> Resets the current flow- and time-state, as well as all related (phys) parameters.
 !! To be called prior to loading a new MDU and upon program startup.
 subroutine resetFullFlowModel()
 use m_wind
 use m_physcoef
 use m_turbulence
 use m_flow
 use m_flowexternalforcings
 use m_flowparameters
 use m_flowgeom
 use m_flowtimes
 use m_samples
 use unstruc_netcdf
 use unstruc_model
 use unstruc_display
 use m_observations
 use m_monitoring_crosssections
 use m_thindams
 use m_fixedweirs
 use m_sediment
 use m_trachy
 use m_kml_parameters
 use m_structures
 use m_heatfluxes
 use m_ec_interpolationsettings
 use unstruc_channel_flow
 use m_sobekdfm
 use m_waves, only: default_waves
 use m_save_ugrid_state
 use  m_xbeach_avgoutput, only: default_xbeach_avgoutput
 use m_ship
 implicit none

    ! Only reset counters and other scalars, allocatables should be
    ! automatically reset elsewhere (e.g., allocateandset*, flow_geominit)

    call init_unstruc_netcdf()

    ! TODO: UNST-487: Add default_fourier + reset
    call resetModel()

    call default_kml_parameters()

    call default_physcoef()

    call default_grw()

    call default_wind()

    call default_waves()

    call default_sobekdfm()

    call dealloc(network) ! flow1d

    call default_heatfluxes()

    call default_sediment()  ! stm_included not defined yet

    call default_trachy()

    call default_fm_wq_processes()

    call default_turbulence()

    call default_flowgeom()

    call default_flowexternalforcings()

    call default_channel_flow()

    call default_structures()

    call default_flowtimes()

    call default_flowparameters()

    call default_flow()

    call default_interpolationsettings()

    call default_xbeach_avgoutput()

    call default_save_ugrid_state()

    !Reset samples:
    ns = 0

    ! Reset observations and cross sections
    call deleteObservations()
    call delCrossSections()
    call delThinDams()
    call delFixedWeirs()

 end subroutine resetFullFlowModel


 !> Resets the current flow- and time-state, but keeps al active parameter settings.
 !! To be called upon flow_modelinit().
 !! Upon program startup and loading of new model/MDU, call resetFullFlowModel() instead.
 subroutine resetFlow()
 use m_wind
 use m_flow
 use m_flowexternalforcings
 use m_flowparameters
 use m_statistics
 use m_flowgeom
 use m_flowtimes
 use waq
 use m_waves
 use m_sobekdfm
 use m_save_ugrid_state, only: reset_save_ugrid_state
 implicit none

    ! Only reset counters and other scalars, allocatables should be
    ! automatically reset elsewhere (e.g., allocateandset*, flow_geominit)

    call reset_wind()

    call reset_waves()

    call reset_sobekdfm()

    ! Reset some flow (rest is done in flow_geominit())
    call reset_flowgeom()

    call reset_flowexternalforcings()

    call reset_flowtimes()

    ! call reset_flowparameters()

    call reset_flow()

    call reset_waq()

    call reset_movobs()

    call reset_statistics()

    if ( jawave.eq.4 ) then
       call xbeach_reset()
    end if

    call reset_save_ugrid_state()

    call reset_sedtra()

 end subroutine resetFlow


 !> Reset moving observation stations.
 !! Necessary because moving stations are always reread from .ext file
 !! (i.e. *after* MDU read, as opposed to static stations
 subroutine reset_movobs()
    use m_observations
    implicit none

    integer :: i

    do i=numobs+1,numobs+nummovobs
        call deleteObservation(i)
    end do
    call purgeObservations()
 end subroutine reset_movobs


 subroutine flow_setstarttime()                      ! set flow starttime
 use m_flowtimes
 implicit none

 time_user = tstart_user + dt_user
 time0     = tstart_user
 time1     = tstart_user
 dts       = dt_init
 dtprev    = dts
 dnt       = 0
 dnt_user  = 1
 time_split0 = tstart_user
 time_split  = tstart_user
 end subroutine


 subroutine setcfuhi()                                 ! set friction coefficients g/C2 etc
 use m_flowtimes                                       ! sqrt(g/C2) in both in 2D and in 3D
 use m_flow
 use m_flowgeom
 use m_missing

 implicit none

 ! locals
 double precision ::  h0, dzb, cz, sixth = 1d0/6d0, frcn, z00, sqcf
 integer :: l, ll, n, kb, Lb, ifrctyp

 ! NOTE: When frcuni==0, the initial friction fields in frcu also become noneffective:
 if ( jatrt.eq.0 .and. (frcmax == 0d0 .or. ifrctypuni == -999) ) then
    cfuhi = 0 ; return
 endif
 if (jaconveyance2D >= 1 ) then ! .and. kmx <=1 ) then
    return
 endif

 if (kmx <= 1) then                                  ! 2D
    if (ifrctypuni == 4) then
       cfuhi = 0
    else

       !$OMP PARALLEL DO                             &
       !$OMP PRIVATE(L,h0,frcn,cz)
       do L = lnx1D+1,lnx
          if (hu(L) > 0) then
             if (jaconveyance2D == 0) then           ! original default
                h0 = max(epshs, 1d0 / huvli(L))
             else if (jaconveyance2D == -1) then     ! better for straight test
                h0 = max(epshs, hu(L)) ! does it whole not
             endif
             frcn = frcu(L)
             if ( frcn.gt.0d0 ) then
                call getcz(h0, frcn, ifrcutp(L), cz, L)
                cfuhi(L) = ag/(h0*cz*cz)
             else
                cfuhi(L) = 0d0
             end if
          endif
       enddo
       !$OMP END PARALLEL DO

    endif

 endif

 end subroutine setcfuhi

 subroutine getcz(h1, frcn, ifrctyp, cz, L)         ! basic get chezy coefficient,  this routine is not safe for frcn == 0
 use m_physcoef, only : sag, vonkar, ee
 use m_flow,     only : u1, v
 implicit none
 integer,          intent(in)  :: ifrctyp, L  !< friction type
 double precision              :: h0, h1      !< hydraulic radius
 double precision, intent(in)  :: frcn        !< friction coeff
 double precision, intent(out) :: cz          !< Computed Chezy coeff
 double precision :: hurou, sixth = 1d0/6d0, sqcf, z0, umod

 h0 = max(h1,1d-4)
 if (ifrctyp == 0) then                              ! Chezy type
     cz = frcn
 else if (ifrctyp == 1) then                         ! Manning type
     cz = ( h0**sixth ) / frcn
 else if (ifrctyp == 2) then                         ! White Colebrook Delft3
     z0   = min( frcn / 30d0 , h0*0.3d0)
     sqcf = vonkar/log( h0/(ee*z0) )
     cz   = sag/sqcf
 else if (ifrctyp == 3) then                         ! White Colebrook WAQUA
     hurou = max(0.5d0, h0/frcn)
     cz    = 18d0*log10(12d0*hurou)
 else if ( ifrctyp == 4 .or. ifrctyp == 5 .or. ifrctyp == 6 ) then   ! also manning, just testing implicitness in furu
     cz = ( h0**sixth ) / frcn
 else
     cz   = 60d0                                     ! dummy
     umod = sqrt(u1(L)*u1(L) + v(L)*v(L))
     call hydraulicallysmooth(umod,h0,sqcf)
     if (sqcf > 0d0) then
        Cz = sag/sqcf
     else
        Cz = 0d0
     endif
 endif
 end subroutine getcz

subroutine getczz0(h0, frcn, ifrctyp, cz, z0)       ! basic get z0 (m),  this routine is not safe for frcn == 0
 use m_physcoef, only : sag, vonkar, ee, ee9, c9of1
 implicit none
 integer          :: ifrctyp
 double precision :: h0, frcn, cz, z0, sqcf, hurou, z02  ! hydraulic radius, friction coeff, friction typ, chezy coeff
 double precision :: sixth = 1d0/6d0

 h0    = max(h0,1d-4)

 if (ifrctyp == 0) then                              ! Chezy type
     cz   = frcn
     ! z0   = h0 / ( exp (vonkar*cz/sag + 1d0) - c9of1) !
     z0   = h0*exp(-1d0 - vonkar*cz/sag)
 else if (ifrctyp == 1) then                         ! Manning type
     cz   = ( h0**sixth ) / frcn
     !z0  = h0 / ( exp (vonkar*cz/sag + 1d0) - c9of1)
     z0   = h0*exp(-1d0 - vonkar*cz/sag)
 else if (ifrctyp == 2) then                         ! White Colebrook Delft3D
     z0   = min( frcn / 30d0 , h0*0.3d0)
     sqcf = vonkar/log( h0/(ee*z0) )
     cz   = sag/sqcf
 else if (ifrctyp == 3) then                         ! White Colebrook WAQUA
     hurou = max(0.5d0, h0/frcn)
     cz    = 18d0*log10(12d0*hurou)
     !z0   = h0 / ( exp (vonkar*cz/sag + 1d0) - c9of1)
     z0    = h0*exp(-1d0 - vonkar*cz/sag)
 else
     cz  = 60d0                                      ! dummies for hydraulically smooth
     !z0 = h0 / ( exp (vonkar*cz/sag + 1d0) - c9of1)
     z0  = h0*exp(-1d0 - vonkar*cz/sag)
 endif
 end subroutine getczz0


 subroutine shipcoor(n,sx1,sy1,sx2,sy2)          ! get absolute shipcoordinates in sx2, sy2), input sx1, sy1 : ( 1, -1) = (bow  , portside )
 use m_ship                                      !                                                             (-1,  1) = (stern, starboard)
 implicit none
 double precision :: sx1,sx2,sy1,sy2,css,sns
 integer          :: n
 css = cos(shi(n))     ; sns = sin(shi(n))
 sx2 = shx(n) + sx1*shL(n)*css - sy1*shb(n)*sns  ! square ship
 sy2 = shy(n) + sx1*shL(n)*sns + sy1*shb(n)*css
 end subroutine shipcoor

subroutine copynetcellstonetnodes() ! for smooth plotting only
 use m_flowgeom
 use m_flow
 use m_netw
 implicit none
 integer           :: k, kk, kkk, n, nn, nn4, ierr, ja
 real, allocatable, save :: rn(:)
 double precision  :: znn
 double precision  :: znod

 ja = 0
 if (.not. allocated(rn) ) then
     ja = 1
 else if (size(rn) < numk) then
     deallocate(rn) ; ja = 1
 endif
 if (ja == 1) then
     allocate ( rn(numk) , stat = ierr)
     call aerr('rn(numk)', ierr , numk)
 endif

 rnod = 0d0; rn = 0d0
 do n = 1, ndx2d
    nn4  = netcell(n)%n

    znn  = rlin(n)

    do kk = 1, nn4
       kkk       = netcell(n)%nod(kk)
       rnod(kkk) = rnod(kkk) + znn*ba(n)
       rn  (kkk) = rn(kkk)   + ba(n)
    enddo
 enddo

 do k = 1,numk
    if (rn(k)  >  0) then
       rnod(k) = rnod(k)/rn(k)
    endif
 enddo

 end subroutine copynetcellstonetnodes !in afwachting van isosmoothflownodes

 subroutine copyznodtornod() ! for smooth plotting only
 use m_flowgeom
 use m_flow
 use m_netw
 implicit none
 integer           :: k, kk, kkk, n, nn, ierr, ja
 real, allocatable, save :: rn(:)
 double precision  :: znn
 double precision  :: znod

 ja = 0
 if (.not. allocated(rn)) then
     ja = 1
 else if (size(rn) < numk) then
     deallocate(rn) ; ja = 1
 endif
 if (ja == 1) then
     allocate ( rn(numk) , stat = ierr)
     call aerr('rn(numk)', ierr , numk); rn = 0d0
     do n = 1, ndx2d
        nn  = size(nd(n)%nod)
        do kk = 1, nn
           kkk       = nd(n)%nod(kk)
           rn  (kkk) = rn(kkk)   + ba(n)
        enddo
     enddo
 endif

 rnod = 0d0
 do n = 1, ndx2d
    znn = znod(n)
    if (znn .ne. 0d0) then
      nn    = size(nd(n)%nod)
      do kk = 1, nn
          kkk       = nd(n)%nod(kk)
          rnod(kkk) = rnod(kkk) + real(znn*ba(n))
       enddo
    endif
 enddo

 do k = 1,numk
    if (rn(k)  >  0) then
       rnod(k) = rnod(k)/rn(k)
    endif
 enddo

 end subroutine copyznodtornod



 subroutine copyzlintornod() ! for smooth plotting only
 use m_flowgeom
 use m_flow
 use m_netw
 implicit none
 integer           :: L, k, k1, k2, ierr, ja
 real, allocatable, save :: rn(:)
 double precision  :: zL, aL
 double precision  :: zlin

 ja = 0
 if (.not. allocated(rn) ) then
     ja = 1
 else if (size(rn) < numk) then
     deallocate(rn) ; ja = 1
 endif
 if (ja == 1) then
     allocate ( rn(numk) , stat = ierr)
     call aerr('rn(numk)', ierr , numk)
 endif

 rnod = 0d0; rn = 0d0
 do L   = lnx1D + 1, lnxi            ! regular 2D flow links
    k1  = lncn(1,L)                  ! netnode 1
    k2  = lncn(2,L)                  ! netnode 2
    zL  = zlin(L)
    aL  = dx(L)*wu(L)
    rnod(k1) = rnod(k1) + zL*aL
    rn  (k1) = rn  (k1) + aL
    rnod(k2) = rnod(k2) + zL*aL
    rn  (k2) = rn  (k2) + aL
 enddo

 do k = 1,numk
    if (rn(k)  >  0) then
       rnod(k) = rnod(k)/rn(k)
    endif
 enddo

 end subroutine copyzlintornod

 subroutine copywaterlevelstosamples()
 use m_samples
 use m_flowgeom
 use m_flow
 use unstruc_display, only: wetplot

 USE M_MISSING
 implicit none
 integer                    :: k, n
 double precision, external :: znod

 k = 0
 do n = 1,ndx
    if ( hs(n) >= wetplot ) then
       k = k + 1
       call increasesam(k)
       xs(k) = xz(n) ; ys(k) = yz(n) ; zs(k) = znod(n)
    endif
 enddo
 ns  = k
 end subroutine copywaterlevelstosamples

 !> copy values that are displayed at flowlinks to samples
 subroutine copyzlintosamples()
 use m_samples
 use m_flowgeom
 use m_flow

 USE M_MISSING
 implicit none
 integer                    :: k, L
 double precision, external :: zlin

 k = 0
 do L = 1,Lnx
    if ( hu(L) .gt. epshu ) then
       k = k + 1
       call increasesam(k)
       xs(k) = xu(L)
       ys(k) = yu(L)
       zs(k) = zlin(L)
    endif
 enddo
 Ns  = k

 end subroutine copyzlintosamples

 subroutine copycellcentrevaluestosamples()
 use m_samples
 use m_flowgeom

 implicit none

 integer                    :: k, n
 double precision, external :: znod

 k = 0
 do n = 1,ndx
       k = k + 1
       call increasesam(k)
       xs(k) = xz(n) ; ys(k) = yz(n) ; zs(k) = znod(n)
 enddo
 ns  = k

 end subroutine


 subroutine copyflowcellsizetosamples()
 use m_samples
 use m_netw
 use m_flowgeom
 USE M_MISSING
 implicit none
 integer :: k, n
 call flow_geominit(0)

 k = ns
 do n = 1,ndx
    k = k + 1
    call increasesam(k)
    xs(k) = xz(n) ; ys(k) = yz(n) ; zs(k) = sqrt(ba(n))
 enddo
 ns  = k
 ndx = 0
 end subroutine copyflowcellsizetosamples

 subroutine copynetnodestosam()

 use m_samples
 use m_netw
 use m_missing
 use m_polygon, only: NPL, xpl, ypl, zpl
 use geometry_module, only: dbpinpol

 implicit none
 integer :: in, k, n
 in = -1
 k  = ns

 KC = 0
 do n = 1,numk
    if (rnod(n) .ne. dmiss) then
       CALL DBPINPOL(XK(n), YK(n), IN, dmiss, JINS, NPL, xpl, ypl, zpl)
       IF (IN == 1) THEN
          KC(N) = 1
          K     = K + 1
       ENDIF
    ENDIF
 ENDDO

 CALL INCREASESAM(k)

 K = NS
 do n = 1,numk
    IF (KC(N) == 1) THEN
       k = k + 1
       xs(k) = xk(n) ; ys(k) = yk(n) ; zs(k) = rnod(n)
    endif
 enddo
 ns = k

end subroutine copynetnodestosam

subroutine copycellstosam()
use m_samples
use m_netw
use m_missing
use m_polygon, only: NPL, xpl, ypl, zpl
use geometry_module, only: dbpinpol


implicit none
integer                       :: in, k, c
double precision, external    :: znetcell
in = -1
k  = ns

!check if the netcells are included in the polygon
LC = 0
do c = 1,nump
    if (rlin(c) .ne. dmiss) then
        CALL DBPINPOL(xzw(c), yzw(c), IN,  dmiss, JINS, NPL, xpl, ypl, zpl)
        IF (IN == 1) THEN
            LC(c) = 1
            K     = K + 1
        ENDIF
    ENDIF
ENDDO

CALL INCREASESAM(k)

!assign the calculated value in rlin
K = NS
do c = 1,nump
    IF (LC(c) == 1) THEN
        k = k + 1
        xs(k) = xzw(c) ; ys(k) = yzw(c) ; zs(k) = znetcell(k)
    endif
enddo
ns = k

end subroutine copycellstosam

subroutine copynetlinkstosam()
use m_samples
use m_netw
use m_missing
use m_polygon, only: NPL, xpl, ypl, zpl
use geometry_module, only: dbpinpol

implicit none
integer :: in, k, l, K1, K2
in = -1
k  = ns

!need to compute the coordinates of the links
if (.not. allocated(xe)) then
    allocate(xe(numl))
endif
if (.not. allocated(ye)) then
    allocate(ye(numl))
endif

LC = 0
do l = 1,numl
    if (rlin(l) .ne. dmiss) then
        K1 = KN(1,L)
        K2 = KN(2,L)
        ! calculate the centre of the link
        xe(l) = .5d0*(xk(K1) + xk(K2)) ! TODO: LC: make this sferic+3D-safe
        ye(l) = .5d0*(yk(K1) + yk(K2))
        CALL DBPINPOL(xe(l), ye(l), IN, dmiss, JINS, NPL, xpl, ypl, zpl)
        IF (IN == 1) THEN
            LC(l) = 1
            K     = K + 1
        ENDIF
    ENDIF
ENDDO

CALL INCREASESAM(k)

!assign the calculated value in rlin
K = NS
do l = 1,numl
    IF (LC(l) == 1) THEN
        k = k + 1
        xs(k) = xe(l) ; ys(k) = ye(l) ; zs(k) = rlin(l)
    endif
enddo
ns = k

end subroutine copynetlinkstosam

!> Copy curvilinear grid to samples
 subroutine copygridtosam()
 use m_samples
 use m_grid
 USE M_MISSING
 implicit none
 integer :: in, k, m, n
 in = -1
 k  = MC*NC

 CALL INCREASESAM(k)

 K = 0
 MXSAM = MC
 MYSAM = NC
 xs = DMISS
 ys = DMISS
 zs = DMISS
 IPSTAT = IPSTAT_NOTOK
 do n=1,NC
    do m=1,MC
       k = k + 1
       if ( xc(m,n).ne.DMISS .and. yc(m,n).ne.DMISS ) then
         xs(k) = xc(m,n)
         ys(k) = yc(m,n)
         zs(k) = zc(m,n)
       end if
    end do
 enddo
 ns = k

 end subroutine copygridtosam

 subroutine copynetwtonetw()
 use M_MAPPROPARAMETERS
 use m_netw
 use m_missing
 use m_polygon, only: NPL, xpl, ypl, zpl
 use geometry_module, only: dbpinpol
 use gridoperations

 implicit none
 integer :: in, k, n, L, k0, L0, numkn, numLn, ja


 call savenet()

 call converparameters(ja)

 KC = 0 ; in = -1
 numkn = 0 ; numLn = 0
 do n  = 1,numk
    CALL DBPINPOL(XK(n), YK(n), IN, dmiss, JINS, NPL, xpl, ypl, zpl)
    IF (IN  == 1) THEN
       numkn = numkn + 1
       KC(n) = numkn
    ENDIF
 ENDDO

 do L = 1,numl
    if (kc(kn(1,L)) > 0 .and. kc(kn(2,L)) > 0) then
        numLn = numLn + 1
    endif
 enddo

 K0 = numk ; L0 = numL
 CALL INCREASENETW(K0+NUMKN, L0 + NUMLN)

 KC = 0 ; in = -1          ! redo kc after increasenetw
 numkn = 0 ; numLn = 0
 do n  = 1,numk
    CALL DBPINPOL(XK(n), YK(n), IN, dmiss, JINS, NPL, xpl, ypl, zpl)
    IF (IN  == 1) THEN
       numkn = numkn + 1
       KC(n) = numkn
    ENDIF
 ENDDO

 numLn = 0
 do L  = 1,numl
    if (kc(kn(1,L)) > 0 .and. kc(kn(2,L)) > 0) then
        numLn       = numLn + 1
        kn(1,numLn+L0) = kc( kn(1,L) ) + numk
        kn(2,numLn+L0) = kc( kn(2,L) ) + numk
        kn(3,numLn+L0) =     kn(3,L)
    endif
 enddo

 do n  = 1,numk
    IF (kc(n) > 0) THEN
       xk( kc(n) + numk ) = xk(n) + deltx
       yk( kc(n) + numk ) = yk(n) + delty
       zk( kc(n) + numk ) = zk(n)
    ENDIF
 ENDDO


 numL = L0 + numLn
 numk = K0 + NUMKN

 end subroutine copynetwtonetw

 subroutine samplestobl(key)
 use m_samples
 use m_flowgeom
 use m_GlobalParameters, only: INDTP_ALL
 use m_flow
 implicit none

 integer :: key

 integer :: k,n

 do n = 1,ns
    call inflowcell(xs(n), ys(n),k,1, INDTP_ALL)
    if (k > 0) then
       bl(k) = zs(n)
    endif
 enddo

 call setbobs()

 end subroutine samplestobl


 subroutine inflowcell(xp,yp,k,jaoutside, iLocTp)                      ! is this point in a flowcell

 use m_flowgeom
 use m_GlobalParameters, only: INDTP_1D, INDTP_2D, INDTP_ALL
 use m_flow
 use m_flowexternalforcings
 use geometry_module, only: pinpok
 use m_missing, only: jins, dmiss

 implicit none

 double precision  :: xp, yp
 integer           :: k, jaoutside
 integer,                         intent(in)     :: iLocTp      !< Node type, one of INDTP_1D/2D/ALL.

 ! locals
 integer           :: n, nn, in, kb, L, nstart, nend
 double precision  :: dxx, dyy, r

 ! define the searching range, this is especially for the purpose of snapping obs to 1D, 2D or 1D+2D flownodes.
 ! For other purpose it should stay as before
 select case(iLocTp)
   case (INDTP_ALL)
      nstart = 1
      nend   = ndxi
   case(INDTP_1D) ! 1d flownodes coordinates
      nstart = ndx2D+1
      nend   = ndxi
   case(INDTP_2D) ! 2d flownodes coordinates
      nstart = 1
      nend   = ndx2D
 end select

 k = 0
 do n = nstart,nend
     nn = size( nd(n)%x )
     IF (NN > 2) THEN
        call PINPOK (Xp, Yp, Nn, nd(n)%x, nd(n)%y, IN, jins, dmiss)
        if (in == 1) then
           k = n
           return
        endif
     ENDIF
 enddo

 if (jaoutside == -1) then ! do not look at open boundaries
    return
 endif

 do n   = 1, nbndz
    kb  = kbndz(1,n)
    L   = kbndz(3,n)
    dxx = xp - xz(kb)
    dyy = yp - yz(kb)
    r   = sqrt(dxx*dxx + dyy*dyy)
    if (r < 0.3d0*dx(L) ) then
       k = kb
       return
    endif
 enddo

   end subroutine inflowcell

 subroutine in2Dflowcell(xp,yp,k)                      ! is this point in a 2Dflowcell

 use m_flowgeom
 use m_flow
 use m_flowexternalforcings
 use geometry_module, only: pinpok
 use m_missing, only: jins, dmiss

 implicit none

 double precision  :: xp, yp
 integer           :: k

 ! locals
 integer           :: n, nn, in, kb, L
 double precision  :: dxx, dyy, r

 k = 0
 do n = 1,ndx2D
     nn = size( nd(n)%x )
     IF (NN > 2) THEN
        call PINPOK (Xp, Yp, Nn, nd(n)%x, nd(n)%y, IN, jins, dmiss)
        if (in == 1) then
           k = n
           return
        endif
     ENDIF
 enddo
 end subroutine in2Dflowcell


 !> Drop water *during* flow computation.
 !!
 !! Use idir=1 for adding water, -1 for lowering it.
 subroutine dropwater(xp,yp,idir)
 use m_polygon
 use m_flowgeom
 use m_flow
 use m_missing, only: dmiss, JINS
 use geometry_module, only: pinpok, dbpinpol

 implicit none
 double precision, intent(in)    :: xp, yp !< Clicked point, which flow node to drop. If a polygon is active, drop all contained points, independent of xp, yp.
 integer,          intent(in) :: idir !< direction (1 for up, -1 for down)

 ! locals
 integer           :: n, nn, in, ncol
 double precision :: dropstep, s10

 if (ndx == 0) return

 dropstep = idir*sdropstep

 if (npl > 2) then
    in   = -1
    do n = 1,ndxi
       CALL DBPINPOL( xz(n), yz(n), IN, dmiss, JINS, NPL, xpl, ypl, zpl)
       if (in == 1) then
          s10 = s1(n)
          s1(n) = max(bl(n), s1(n) + dropstep)
          vol0tot = vol0tot + (s1(n)-s10)*ba(n)

          call isocol(s1(n),ncol)
          nn = size( nd(n)%x )
          call pfiller(nd(n)%x, nd(n)%y, nn, ncol, 30)
       endif
    enddo
 else

    do n = ndxi,1,-1
       nn = size( nd(n)%x ) ; if (nn == 0) cycle
       call PINPOK(Xp, Yp, Nn, nd(n)%x, nd(n)%y, IN, jins, dmiss)
       if (in == 1) then
          s10 = s1(n)
          s1(n) = max(bl(n), s1(n) + dropstep)

          call isocol(s1(n),ncol)
          nn = size( nd(n)%x )
          call pfiller(nd(n)%x, nd(n)%y, nn, ncol, 30)
          exit
       endif
    enddo
 endif

 hs = s1-bl
 call volsur()           ! dropwater
 call flow_f0isf1()      ! dropwater
 volerr = 0; volerrcum = 0

 if (kmx > 0) then
    call setkbotktop(1) ! dropwater
 endif

 validateon = .false.

 end subroutine dropwater


 !> Drop land *during* flow computation.
 !!
 !! Use idir=1 for adding land, -1 for lowering it.
 !! The height change is performed on net node vertical zk
 !! With a polygon active: all masked net nodes,
 !! without polygon: all corner points of flow cell underneath mouse pointer.
 subroutine dropland(xp,yp, idir)
 use network_data
 use m_missing
 use m_polygon
 use m_flowgeom
 use m_flow
 use unstruc_display
 use m_sediment
 use geometry_module, only: pinpok, dbpinpol

 implicit none
 double precision, intent(in) :: xp, yp !< Clicked point, which flow node to drop. If a polygon is active, drop all contained points, independent of xp, yp.
 integer,          intent(in) :: idir   !< direction (1 for up, -1 for down)

 ! locals
 integer           :: kk, k, n, nn, in, ncol, j
 double precision :: dropstep !< Amount to add (in meters, may be negative)

 if (ndx == 0) return

 dropstep = idir*zkdropstep

 if (npl > 2) then
    in   = -1
    do k = 1,numk
       CALL DBPINPOL( xk(k), yk(k), IN, dmiss, JINS, NPL, xpl, ypl, zpl)
       if (in == 1 .and. zk(k) /= dmiss) then
          zk(k) = zk(k) + dropstep
          if (jaceneqtr == 2 .and. jased > 0) then
             do j = 1,mxgr
                grainlay(j, k ) = max(0d0, grainlay(j, k ) + dropstep/mxgr)
             enddo
          endif
          call isocol(zk(k),ncol)
          call movabs(xk(k),yk(k))
          call hlcir2(rcir,ncol,30)
       endif
    enddo
 else

    do n = ndxi,1,-1
       nn = size( nd(n)%x )
       call PINPOK(Xp, Yp, Nn, nd(n)%x, nd(n)%y, IN, jins, dmiss)
       if (in == 1) then
          do kk=1,nn
             k = nd(n)%nod(kk)
             zk(k) = zk(k) + dropstep
             if (jaceneqtr == 2 .and.jased > 0) then
                do j = 1,mxgr
                   grainlay(j, k ) = max(0d0, grainlay(j, k ) + dropstep/mxgr)
                enddo
             endif
             call isocol(zk(k),ncol)
             call movabs(xk(k),yk(k))
             call hlcir2(rcir,ncol,30)
          end do
          exit
       endif
    enddo
 endif

 call setbobs()
 s1 = max(bl,s1) ; s0=s1 ; s00 = s1

 hs = s1-bl
 call volsur()           ! dropland
 call flow_f0isf1()      ! dropland
 volerr = 0; volerrcum = 0

  if (kmx > 0) then
    call setkbotktop(1) ! dropland
 endif


 ! NOTE: vol1tot cumulation now contains an error: new bl's have not been accounted for...
 end subroutine dropland

 subroutine dropk(xp,yp,idir)
 use m_polygon
 use m_flowgeom
 use m_flow
 implicit none
 double precision, intent(in) :: xp, yp
 integer,          intent(in) :: idir

 ! locals
 integer          :: L, LL, Lb, Lt

 call isFLOWLINK(xp, yp, LL)
 if (LL > 0) then
    call getLbotLtop(LL,Lb,Lt)
    do L = Lb-1, Lt
       turkin0(L) = turkin0(L) + 1d0
       turkin1(L) = turkin0(L)
    enddo
 endif
 return
 end subroutine dropk

! updates zk value at specified net node index using diven delta
! TODO: extend it to multiple indices
subroutine update_land_nodes(node_index, new_zk)
  use network_data
  use m_missing
  use m_polygon
  use m_flowgeom
  use m_flow
  use unstruc_display
  use m_sediment
  implicit none
  integer, intent(in) :: node_index
  double precision, intent(in) :: new_zk

  ! locals
  integer :: kk, k, n, nn, ncol, j, i
  double precision :: old_zk

  if (ndx == 0) return

  k = node_index

  if (npl > 2) then
    old_zk = zk(k)
    zk(k) = new_zk
    if (jaceneqtr == 2 .and.jased > 0) then
        do j = 1,mxgr
            grainlay(j, k ) = max(0d0, grainlay(j, k ) + (old_zk - new_zk)/mxgr)
        enddo
    endif
    call isocol(zk(k), ncol)
    call movabs(xk(k), yk(k))
    call hlcir2(rcir, ncol, 30)
  else
    old_zk = zk(k)
    zk(k) = new_zk
    if (jaceneqtr == 2 .and.jased > 0) then
    do j = 1,mxgr
        grainlay(j, k ) = max(0d0, grainlay(j, k) + (old_zk - new_zk)/mxgr)
    enddo
    endif
    call isocol(zk(k),ncol)
    call movabs(xk(k),yk(k))
    call hlcir2(rcir,ncol,30)
  endif

  ! NOTE: update of bobs/bl/s1/hs is now in subroutine on_land_change().
  !       Should be called separately on call-site!

end subroutine update_land_nodes


!> Updates derived bathymetry arrays, after zk values have been changed.
!! This routine updates the entire grid, so call this once after a (series of) zk update(s).
subroutine land_change_callback()
   use m_flowgeom
   use m_flow
   implicit none

   hs = s1 - bl
   call setbobs()
   s1 = bl + hs; s0=s1; s00 = s1

   call volsur()           ! dropland_zk
   call flow_f0isf1()      ! dropland_zk
   volerr = 0; volerrcum = 0

   if (kmx > 0) then
      call setkbotktop(1) ! dropland_zk
   endif
end subroutine land_change_callback

 subroutine dropzout(idir)
 use m_polygon
 use m_flowgeom
 use m_flow
 use m_missing, only: dmiss, jins
 use geometry_module, only: dbpinpol
 implicit none
 integer,          intent(in) :: idir !< direction (1 for up, -1 for down)

 ! locals
 integer           :: n, nn, in, ncol, k, kb, kt
 double precision :: dropstep, s10

 if (ndx == 0) return

 dropstep = idir*sdropstep

 if (npl > 2) then
    in   = -1
    do n = 1,ndx
       CALL DBPINPOL( xz(n), yz(n), IN, dmiss, jins, NPL, xpl, ypl, zpl)
       if (in == 1) then
          call getkbotktop(n,kb,kt)
          if (idir == 1) then
             kb = kb + kplot - 1
          endif
          do k = kb,kt
             sam1tot = sam1tot - sa1(k)*vol0(k)
             sa1(k)  = max(0d0, sa1(k) + dropstep)
             sam1tot = sam1tot + sa1(k)*vol1(k)
             call isocol(sa1(n),ncol)
             nn = size( nd(n)%x )
             call pfiller(nd(n)%x, nd(n)%y, nn, ncol, 30)
          enddo
       endif
    enddo

 else

    n = nplot
    call getkbotktop(n,kb,kt)
    k = kb + kplot - 1
    sam1tot = sam1tot - sa1(k)*vol0(k)
    sa1(k)  = max(0d0, sa1(k) + dropstep)
    sam1tot = sam1tot + sa1(k)*vol1(k)
    call isocol(sa1(n),ncol)
    nn = size( nd(n)%x )
    call pfiller(nd(n)%x, nd(n)%y, nn, ncol, 30)
 endif

 if (kmx > 0) then
    call setkbotktop(1) ! drop
 endif

 end subroutine dropzout

 subroutine minmxsam()

 use m_samples
 use m_missing
 use m_isoscaleunit
 use gridoperations

 implicit none

 double precision :: rmin, rmax
 double precision :: VMAX,VMIN,DV,VAL(256)
 integer :: NCOLS(256),NIS,NIE,nv,JAAUTO
 character(len=256) :: buffer
 common /depmax2/ vmax,vmin,dv,val,ncols,nv,nis,nie,jaauto
 integer :: k, i

 if (jaauto .eq. 1) then
    rmin =  1d30
    rmax = -1d30

    do k = 1,ns
       if ( zs(k)==DMISS ) cycle
       if ( inview( xs(k), ys(k) ) ) then
           if (zs(k) < rmin) then
               rmin  = zs(k)
           endif
           if (zs(k) > rmax) then
               rmax  = zs(k)
           endif
       endif
    enddo
    vmax = rmax
    vmin = rmin
 endif

 dv   = vmax - vmin
 do i = 1,nv
    val(i) = vmin + (i-1)*dv/(nv-1)
 enddo

 !Samples have the same unit of the displayed values
 write(buffer, '(a,a)') 'Samples                              ',UNIT(1)
 CALL PARAMTEXT(buffer, 2 )

 end subroutine minmxsam


 subroutine minmxnds()
 use unstruc_display                                                    ! bepaal minimum en maximum van znod in viewing area
 use m_flowgeom
 use m_flow
 use m_missing
 use gridoperations

 implicit none
 integer :: i
 double precision :: rmin, rmax
 double precision, external :: znod
 double precision :: zn
 integer          :: n, ja2, ndraw
 double precision :: VMAX,VMIN,DV,VAL(256)
 integer :: NCOLS(256),NIS,NIE,nv,JAAUTO
 common /depmax/ vmax,vmin,dv,val,ncols,nv,nis,nie,jaauto
 COMMON /DRAWTHIS/ ndraw(50)

 if (jaauto .eq. 1) then
    rmin =  1d30; ndmin = 0
    rmax = -1d30; ndmax = 0


    do n = 1,ndx
       ja2 = 1
       if (wetplot > 0d0) then
          if (hs(n) < wetplot) then
             ja2 = 0
          endif
       endif
       if ( ja2 == 1 .or. ndraw(28) == 3) then        ! crash
          if ( inview( xz(n), yz(n) ) ) then
             zn = znod(n)
             if ( zn.eq.DMISS ) cycle
             if (zn < rmin) then
                 rmin = zn ; ndmin = n
             endif
             if (zn > rmax) then
                 rmax = zn ; ndmax = n
              endif
          endif
       endif
    enddo
    vmax = rmax
    vmin = rmin
 endif

 dv   = vmax - vmin
 do i = 1,nv
    val(i) = vmin + (i-1)*dv/(nv-1)
 enddo

 end subroutine minmxnds

 subroutine minmxlns()

 use m_flowgeom
 use m_flow
 use m_missing
 use gridoperations

 implicit none
 double precision :: zlin
 double precision :: zn
 double precision :: rmin, rmax
 integer          :: i, l, n, k1, k2
 double precision :: VMAX,VMIN,DV,VAL(256)
 integer :: NCOLS(256),NIS,NIE,nv,JAAUTO
 common /depmax2/ vmax,vmin,dv,val,ncols,nv,nis,nie,jaauto

 if (jaauto .eq. 1) then
    rmin =  1d30; lnmin = 0
    rmax = -1d30; lnmax = 0
    do L = 1,lnx
       k1 = ln(1,L)
       k2 = ln(2,L)
       if (inview( xz(k1), yz(k1) ) .or. inview( xz(k2), yz(k2) ) ) then
           zn   = zlin(L)
           if ( zn.eq.DMISS ) cycle
           if (zn < rmin) then
              rmin = zn ; lnmin = L
           endif
           if (zn > rmax) then
              rmax = zn ; lnmax = L
           endif
       endif
    enddo
    vmax = rmax
    vmin = rmin
 endif

 dv   = vmax - vmin
 do i = 1,nv
    val(i) = vmin + (i-1)*dv/(nv-1)
 enddo

 return
 end subroutine minmxlns

 double precision function zcorn(k)                  ! get various values at flow cell corners
 use m_flow
 use m_flowgeom
 implicit none

 common /drawthis/ ndraw(50)
 integer :: ndraw

 integer :: k, nodval

 nodval = ndraw(31)
 if (nodval == 2) then
    zcorn = ucnx(k)
 else if (nodval == 3) then
    zcorn = ucny(k)
 else if (nodval == 4) then
    zcorn = sqrt( ucnx(k)*ucnx(k) + ucny(k)*ucny(k) )
 endif
 end function zcorn


 double precision function znod(kk)                   ! get various values at flow nodes
 use m_flow
 use m_flowgeom
 use m_reduce
 use m_flowtimes ! for volerr
 use m_sediment
 use m_missing
 use m_partitioninfo
 use m_xbeach_data !, only: ee1, rr, ee1sum, H, Fx_cc, Fy_cc
 use m_transport, only: constituents, itemp, NUMCONST, ICONST_CUR
 use m_missing
 use m_observations
 use bedcomposition_module
 use precision
 use m_waves, only: waveparopt, numoptwav
 use m_flowparameters, only: ispirparopt
 use m_sferic, only:pi , rd2dg
 use m_wind, only: jawind


 implicit none

 common /drawthis/ ndraw(50)
 integer          :: ndraw

 integer          :: kk, k, nodval,N,L, k2
double precision :: uu, seq(mxgr), wse(mxgr),hsk, dum, czc, taucurc,ustw2,U10,FetchL,FetchD
 real(fp)       , dimension(:,:)   , pointer :: bedtmp
 integer :: istat

 nodval = ndraw(28)

 if ( kk.lt.1 ) then
    znod = DMISS
    return
 end if

 k = kk
 if (kmx > 0) then
    if (kplotordepthaveraged == 1) then
       call getktoplot(kk,k)
    endif
 endif

 znod = dmiss

 !if ( jampi.eq.1 ) then
 !   if ( idomain(k).ne.my_rank ) return
 !end if

 if (nodval == 2) then
    znod = s1(kk)
 else if (nodval == 3) then
    znod = bl(kk)
 else if (nodval == 4) then
    znod = ba(kk)
 else if (nodval == 5) then
    znod = a1(kk)
 else if (nodval == 6) then
    znod = vol1(k)
 else if (nodval == 7) then
    znod = s1(kk) - bl(kk)
 else if (nodval == 8) then
    znod = sqrt( ucx(k)*ucx(k) + ucy(k)*ucy(k) )
 else if (nodval == 9) then
    znod = ucx(k)
 else if (nodval == 10) then
   znod = ucy(k)
 else if (nodval == 11) then
    if (jasal > 0) znod = sa1(k)
 else if (nodval == 12) then
    if (jatem > 0) then
       if (jafahrenheit == 0) then
          znod = constituents(itemp,k)
       else
          znod = 32d0 + (9d0/5d0)*constituents(itemp,k)
       endif
    endif
 else if (nodval == 13) then
    if (jased > 0 .and. .not. stm_included) then
       znod = sed( jgrtek, k )
    else if (jagrw > 0) then
       znod = sgrw1( kk )
    endif
 else if (nodval == 14) then
    if (hs(k) > 0) then
       znod = sqrt( ucx(k)*ucx(k) + ucy(k)*ucy(k) ) / sqrt(ag*hs(k)) ! Froude
    else
       znod = 0d0
    endif
 else if (nodval == 15) then
    znod = k
 else if (nodval == 16) then
    znod = nd(kk)%lnx
 else if (nodval == 17) then
    znod = kcs(kk)  !  voldhu(kk) - vol1(kk)
 else if (nodval == 18) then
    znod = squ(k)
 else if (nodval == 19) then
    znod = sqi(k)
 else if (nodval == 20) then
    znod = sqi(k) - squ(k)
 else if (nodval == 21) then
    znod = qw(k)/a1(kk)
 else if (nodval == 22) then
    if (jased>0) then
       call getequilibriumtransportrates(kk, seq, wse, mxgr, hsk)
       znod = seq(jgrtek)
    endif
 else if (nodval == 23) then
    znod = qin(k) ! turkinepsws(1,k)
 else if (nodval == 24) then
    if (mxgr > 1 .and. jaceneqtr == 1) znod = grainlay(jgrtek,kk)
 else if (nodval == 25 .and. kmx > 0) then
    znod = ktop(kk) - kbot(kk) + 1
 else if (nodval == 26) then
    if (squ(k) > 0d0 .and. vol1(k) > 0d0 ) then
       znod = vol1(k) /squ(k)
     else
       znod = dmiss
     endif
else if (nodval == 27) then
    if (kmx>1) znod = vicwws(k)
 ! 28 = substi/cg
 else if (nodval == 29) then
    if ( allocated(tidep) ) then
       if ( ubound(tidep,1).eq.2 ) then
          znod = tidep(2,kk)
       else
          znod = tidep(1,kk)
       end if
   end if
!     znod = plotlin(kk)
 else if (nodval == 30) then
    znod = dt_max
    do k = kbot(kk), ktop(kk)
       znod = min(znod, vol1(k) / max( squ(k), eps10) )
    enddo
 else if (nodval == 31) then
    if (japatm > 0) znod = patm(kk)
 else if (nodval == 32) then
    if (numlimdt(kk) > 0) znod = numlimdt(kk)
 else if (nodval == 33) then
   ZNOD = ( ucx(k)*ucx(k) + ucy(k)*ucy(k) ) / (2d0*ag)
   znod = u1(min(k,lnx))*u1(min(k,lnx)) / (2d0*ag)
   znod = znod + s1(kk)

   plotlin(kk) = znod

 else if (nodval == 34) then
    znod = volerror(k)
    !if (abs(znod) > 1) then
    !   znod = 0d0
    !endif
 else if (nodval == 35) then

    znod = rho(k) ! sam0(k) !  kktop(kk) - kbot(kk) + 1

 else if (nodval == 36) then

    znod = dt_max
    do k = kbot(kk), ktop(kk)
       if (squ(k) > eps10) then
          znod = min(znod, cflmx*vol1(k)/squ(k))
       endif
    enddo

 else if (nodval == 37) then

    if (Soiltempthick > 0 .and. jatem > 0) then
       znod = tbed(kk)
    else
       znod = same(k)
    endif

 else if (nodval == 38) then

    znod = zws(k) - zws(k-1)

 else if (nodval == 39) then

    call gettau(kk, znod, czc)

 else if (nodval == 40) then

    znod = rain(kk)

 else if (nodval == 41 .and. jatem > 0) then
    znod = rhum(kk)
 else if (nodval == 42 .and. jatem > 0) then
    znod = tair(kk)
 else if (nodval == 43 .and. jatem > 0) then
    znod = clou(kk)
 else if (nodval == 44 .and. jatem > 0 .and. allocated(qrad)) then
    znod = qrad(kk)
 else if (nodval .eq. 45 .and. NUMCONST.gt.0 ) then
    if ( iconst_cur.gt.0 .and. iconst_cur.le.NUMCONST ) then
       znod = constituents(iconst_cur,k)
    end if
 else if (nodval == 46) then
    znod =  turkinepsws(1,k)
 else if (nodval == 47) then
    if (jagrw > 0) then
       if (infiltrationmodel == 1) then
          znod = sgrw1(k)
       else
          znod = pgrw(kk)
       endif
    endif
 else if (nodval == 48) then
   if (nonlin == 2) then
      znod = a1m(kk)
   endif
 else if (nodval == 49) then
    if (nshiptxy > 0) then
       znod = zsp(kk)
    endif
 else if (nodval == 50) then
    if (janudge > 0) then
       znod = 0d0
       if ( nudge_rate(kk).gt.0d0 ) then
         znod = 1d0/nudge_rate(kk)
       endif
    else if (nshiptxy > 0) then
       znod = v1ship(kk)
    endif

 else if (nodval == numoptwav .and. jawave > 0) then
    if (jawave == 1 .or. jawave == 2) then
      select case (waveparopt)
        case(1)
                znod = Hwav(kk)
        case(2)
                znod = Rlabda(kk)
        case(3) 
                znod = Twav(kk)
        case(4) 
                znod = Uorb(kk)
        case(5) 
                call gettau2(kk,taucurc,czc,ustw2)
                znod = sqrt(ustw2)            !ustw
        case(6) 
                call gettau2(kk,taucurc,czc,ustw2)
                znod = sqrt(taucurc/rhomean)  !ustw+c
        case(7) 
                call gettau2(kk,taucurc,czc,ustw2)
                znod = taucurc                ! taus to Delwaq
        case(8) 
                znod = ustk(kk)               ! Ustokes 
        case(9) 
                call getfetch(kk,U10,FetchL,FetchD)
                znod = FetchL              
        case(10) 
                call getfetch(kk,U10,FetchL,FetchD)
                znod = FetchD              
      end select

    else
     select case (waveparopt)
       case (1)
          if (jawave.ne.4) then
             znod = Hwav(kk) ! fwx%hrms(kk)
          else
             znod = H(kk)
          endif
       case (2)
          if (jawave.ne.4) then
             znod = Twav(kk) ! fwx%tp(kk)
          elseif (windmodel.eq.0) then
             znod = Trep
          else
             znod = tt1(itheta_view,kk)
          endif
       case (3)
          znod = taus(kk)
       case (4)
          znod = fwav_mag(kk)
       case (5)
          znod = ust_mag(k)
       case (6)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = Fx_cc(kk)
          endif
       case (7)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = Fy_cc(kk)
          endif
       case (8)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = taux_cc(kk)
          endif
       case (9)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = tauy_cc(kk)
          endif
       case (10)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = ustx_cc(kk)
          endif
       case (11)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = usty_cc(kk)
          endif
       case (12)
          znod = ee1(itheta_view,kk)
       case (13)
          znod = rr(itheta_view,kk)
       case (14)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = uorb(kk)
          endif
       case (15)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = D(kk)
          endif
       case (16)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = DR(kk)
          endif
       case (17)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = R(kk)
          endif
       case (18)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = Sxx(kk)
          endif
       case (19)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = Syy(kk)
          endif
       case (20)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = Sxy(kk)
          endif
       case (21)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = kwav(kk)
          endif
       case (22)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = mod(270d0 - phiwav(kk),360d0)
          endif
       case (23)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = dhsdx(kk)
          endif
       case (24)
          if (jawave.ne.4) then
             znod = dmiss
          else
             znod = dhsdy(kk)
          endif
       case(25)
          if (jawave .ne. 4) then
             znod = dmiss
          else if (jawind>0 .and. jawsource>0) then
             znod = wsorE(itheta_view, kk)
          end if
       case(26)
           if (jawave .ne. 4 ) then
               znod = dmiss
           else
               znod = sigt(itheta_view,kk)
           end if
       case(27)
           if (jawave .ne. 4 ) then
               znod = dmiss
           elseif (windmodel.eq.0) then
               znod = cgwav(kk)
           else
               znod = cgwavt(itheta_view,kk)
           end if
       case(28)
          if (jawave == 1 .or. jawave == 2) then
             znod = fetch(1,kk)
          else
             znod = dmiss
          end if
       case(29)
           if (jawave.ne.4) then
               znod = dmiss
           else
               znod = dtheta * egradcg(itheta_view,kk)
           endif
       case(30)
           if (jawave.ne.4) then
               znod = dmiss
           else
               znod = SwT(kk)
           endif
       case(31)
           if(jawave.ne.4) then
               znod = dmiss
           else
               znod = SwE(kk)
           endif
       case(32)
           if(jawave.ne.4) then
               znod = dmiss
           else
               znod = horadvec(itheta_view,kk)
           endif
       case(33)
           if(jawave.ne.4) then
               znod = dmiss
           else
               znod = horadvec2(itheta_view,kk)
           endif
       case(34)
           if(jawave.ne.4) then
               znod = dmiss
           else
               znod = ma(itheta_view,kk)
           endif


     end select

    endif

 else if (nodval == numoptsf .and. jasecflow > 0) then
    select case (ispirparopt)
       case (1)
          if ( jasecflow > 0 ) then
             znod = spircrv(kk)
          else
             znod = bz(kk)
          endif
       case (2)
          znod = spirint(kk)
       case (3)
          znod = sqrt( spirfx(kk) * spirfx(kk)+ spirfy(kk) * spirfy(kk) )
       end select
  else if (nodval == numoptsed .and. stm_included) then
      select case (sedparopt)
         case (1)
            znod = mtd%blchg(kk)
         case (2)
            dum = 0d0
            do l = 1, stmpar%lsedsus
               dum = dum + sedtra%sourse(kk,l)
            end do
            znod = dum
         case(3)
            dum = 0d0
            do l = 1, stmpar%lsedsus
               dum = dum + sedtra%sinkse(kk,l)
            end do
            znod = dum
      end select
 end if
 end function znod


 double precision function zlin(LL)                   ! get various values at flow links
 use m_flow
 use m_flowgeom
 use m_wind
 use m_sediment
 use m_reduce, only : ccr, lv2
 use m_sferic
 use m_missing
 implicit none

 common /drawthis/ ndraw(50)
 integer :: ndraw

 integer, intent(in) :: LL
 integer             :: L, L2,linval, ifrctyp, k1, k2, n1, n2, lll, ka, kb
 double precision    :: cosphiu, frcn, omega1, omega2, zb1, zb2, dum, alfa

 zlin = dmiss
 if ( LL.lt.1 ) then
    return
 end if

 L  = LL
 if (kmx > 0) then
    call getLtoplot(LL,L)
 endif

 linval = ndraw(29)
 if (       linval == 2) then
    zlin = abs(u1(L))
 else if (  linval == 3) then
    zlin = q1(L)*wui(LL)
 else if (  linval == 4) then
    zlin = q1(L)
 else if (  linval == 5) then
    zlin = au(L)
 else if (  linval == 6) then
    zlin = hu(L)
 else if (  linval == 7) then
    zlin = frcu(LL)

    if (LL <= lnx1D) then
       if (prof1D(1,LL) < 0 ) then ! profile interpolation
          ka    = -prof1D(1,LL); kb = -prof1D(2,LL)
          alfa  = prof1d(3,LL)
          if (profiles1D(ka)%frccf .ne. dmiss .and. profiles1D(kb)%frccf .ne. dmiss .and.  &
             profiles1D(ka)%frctp == profiles1D(kb)%frctp) then
             zlin = (1d0-alfa)*profiles1D(ka)%frccf  + alfa*profiles1D(kb)%frccf
          end if
       end if
    end if
 else if (  linval == 8) then
    zlin = dx(LL)
 else if (  linval == 9) then
    zlin = wu(LL)
 else if (  linval ==10) then                        ! rust aan de ogen
    zlin =  bob(1,LL)
 else if (  linval ==11) then
    zlin =  bob(2,LL)
 else if ( linval == 12) then
    zlin = dble(kcu(LL))
 else if ( linval == 13) then
    zlin = vicLu(L)
 else if ( linval == 14) then
    zlin =   teta(LL)
 else if ( linval == 15) then
 else if ( linval == 16) then
    zlin = u1(L)
 else if ( linval == 17) then
    zlin =  adve(L) !*csu(LL)
 else if ( linval == 18) then
    zlin =  advi(L)
 else if ( linval == 19) then
    zlin = Fu(L)
 else if ( linval == 20) then
    zlin = Ru(L) ! -ag*dxi(L)*( s0(ln(2,L)) - s0(ln(1,L)) ) -  adve(L)
 else if ( linval == 21) then
    zlin = suu(L)
 else if ( linval == 22) then
    if (javeg == 0) then
       zlin = aifu(LL) ! ccr(lv2(LL))
    else
        k1 = ln(1,L) ; k2 = ln(2,L)
        if (diaveg(k1) > 0 .and. diaveg(k2) > 0) then
           zlin = 0.5d0*( diaveg(k1) + diaveg(k2) )
        else
           zlin = max( diaveg(k1), diaveg(k2) )
        endif
    endif
 else if ( linval == 23) then
    if (javeg == 0) then
       zlin = (s1(ln(2,LL)) - s1(ln(1,LL)) ) * dxi(LL)
    else
       k1 = ln(1,L) ; k2 = ln(2,L)
       zlin = 0.5d0*( rnveg(k1) + rnveg(k2) )
    endif
 else if ( linval == 24) then
    if (javeg == 0) then
       zlin = cfuhi(LL)
    else
       k1 = ln(1,L) ; k2 = ln(2,L)
       if ( stemheight(k1) > 0 .and. stemheight(k2) > 0) then
           zlin = 0.5d0*( stemheight(k1) + stemheight(k2) )
        else
           zlin = max( stemheight(k1), stemheight(k2) )
        endif
    endif
 else if ( linval == 25) then
    zlin = wx(LL)
 else if ( linval == 26) then
    zlin = wy(LL)
 else if ( linval == 27) then
    zlin = wdsu(LL)
 else if ( linval == 28) then
    zlin = dabs(cosphiu(LL))
 else if ( linval == 29) then
    zlin = LL
 else if ( linval == 30) then
    zlin = v(L)
 else if ( linval == 31) then
    zlin = Fu(L)
 else if ( linval == 32) then
    zlin = Ru(L)
 else if ( linval == 33) then
    zlin = iadv(LL)
 else if ( linval == 34) then
    zlin = plotlin(L)
 else if ( linval == 35) then
    zlin = ln(1,L)
 else if ( linval == 36) then
    zlin = ln(2,L)
 else if ( linval == 37) then !
    zlin = plotlin(L)
 else if ( linval == 38) then
    zlin = plotlin(L)
 else if ( linval == 39) then
    zlin = dxi(LL)*( bl(ln(2,LL)) - bl(ln(1,LL)) )
 else if ( linval == 40) then
    zlin = ifrcutp(LL)
 else if ( linval == 41) then
    if (kmx > 0) then
       zlin = turkin0(L)
    else
       if (LL <= lnx1D) zlin = prof1D(1,LL)
    endif
 else if ( linval == 42) then
    if (kmx > 0) then
       zlin = tureps0(L)
    else
        if (LL <= lnx1D) zlin = prof1D(2,LL)
    endif
 else if ( linval == 43) then
    if (kmx > 0) then
       zlin = vicwwu(L)
    else
        if (LL <= lnx1D) zlin = prof1D(3,LL)
    endif
 else if ( linval == 44) then
    zlin = ustb(LL)
 else if ( linval == 45) then
    if (jawind > 0 .and. kmx > 0 ) then
       zlin = ustw(L)
    else if (L < ltop(LL) ) then
       k1 = ln(1,L)    ; k2  = ln(2,L)
       n1 = ln(1,LL)   ; zb1 = zws(kbot(n1)-1)
       n2 = ln(2,LL)   ; zb2 = zws(kbot(n2)-1)
       omega1 = qw(k1) / a1(ln(1,LL))
       omega2 = qw(k2) / a1(ln(2,LL))

       zlin   = 0.5d0*omega1 + 0.5d0*omega2 + 0.5d0*(u0(L)+u0(L+1))*( zws(k2)-zb2 - (zws(k1)-zb1) )*dxi(LL)
    else
       zlin   = -999
    endif
 else if ( linval == 46) then
    zlin = hu(L) - hu(L-1)
 else if ( linval == 47) then
    zlin = frculin(LL)
 else if (linval == 48 .and. stm_included) then
    select case (sedparopt)
       case (1)
          dum=0d0
          do lll = 1, stmpar%lsedtot
             dum = dum+sedtra%e_sbcn(LL,lll)
          end do
          zlin = dum
       case (2)
          dum=0d0
          do lll = 1, stmpar%lsedsus
             dum = dum+sedtra%e_ssn(LL,lll)
          end do
          zlin = dum
       case (3)
          dum=0d0
          do lll = 1, stmpar%lsedtot
             dum = dum+sedtra%e_sbwn(LL,lll)
          end do
          zlin = dum
       case (4)
          dum=0d0
          do lll = 1, stmpar%lsedtot
             dum = dum+sedtra%e_sswn(LL,lll)
          end do
          zlin = dum
       case (5)
          dum=0d0
          do lll = 1, stmpar%lsedsus
             dum = dum+sedtra%e_ssn(LL,lll)
          end do
          do lll = 1, stmpar%lsedtot
             dum = dum+sedtra%e_sswn(LL,lll)+sedtra%e_sbwn(LL,lll) +sedtra%e_sbcn(LL,lll)
          end do
          zlin = dum
    end select
 else if ( linval == 49) then
    zlin = Ltop(LL) - Lbot(LL) + 1 ; zlin=max(zlin,0d0)
 else if ( linval == 50) then
    zlin = kmxL(LL)
 else if ( linval == 51) then
    zlin = Lbot(LL)
 else if ( linval == 52) then
    zlin = Ltop(LL)
 else
    zlin = -999
 endif

 end function zlin

 subroutine clearflowmodelinputs()
 use m_flow
 implicit none
 nbndz = 0
 nbndu = 0
 nbnds = 0
 nbndtm = 0
 nbndt = 0
 nbnduxy = 0
 end subroutine clearflowmodelinputs


 !> Initialise flow model time dependent parameters
 !! @return Integer error status (0) if succesful.
 integer function flow_flowinit() result(iresult)
 use m_netw
 use m_flowgeom
 use m_flow
 use m_flowtimes
 use m_sferic
 use unstruc_model
 use unstruc_files
 use m_reduce, only : nodtot, lintot
 use m_samples
 use m_missing
 use m_fixedweirs
 use m_partitioninfo
 use m_sediment
 use m_xbeach_data, only: s1initial
 use m_transport
 use dfm_error
 use m_sobekdfm
 use m_monitoring_crosssections, only : crs, ReallocCrosssectionSums
 use string_module, only: str_lower
 use m_ship
 use geometry_module ! , only: dbdistance, normalout, half
 use m_physcoef, only: backgroundwatertemperature
 use m_alloc
 use unstruc_channel_flow, only: network
 use m_1d_structures, only: initialize_structures_actual_params, t_structure
 use m_oned_functions, only: updateFreeboard, set_max_volume_for_1d_nodes, updateDepthOnGround, updateVolOnGround, updateTotalInflow1d2d, updateTotalInflowLat
 implicit none

 ! locals
 integer :: k, L, k1, k2, n, jw, msam
 integer :: kb, kt, ki, LL

 double precision :: r,eer,r0,dep,Rossby,amp,csth, sqghi, ss, snth, x, y, uth
 double precision :: xx, yy, zz, ux, uy, pin, xli, atet, slope, cz, z00, cs
 double precision :: xx1, yy1, xx2, yy2, ux1, uy1, ux2, uy2, csl, snl
 double precision :: xzmin, xzmax, yzmin, yzmax, bobmin
 double precision :: fout, foutk, aa, blm, dis, dmu, var, rho1, hunsat, fac, zi, zido, ziup, saldo, salup
 double precision, external :: rho_Eckart
 double precision, allocatable:: u1_tmp(:)

 integer :: itest = 1, ispecials, ierr, mrst, kk, La, j, nq, ierror, N1, N2, Lb, Lt, nat, ntmp
 double precision :: psi, samp, ct, st, omeg, t, rr, rmx, x0, y0, dxx, dyy, blmn, blmx, dbl, bot, rms, ucmk, phi, dphi
 character(len=255) :: rstfile
 character(len=4)   :: EXT
 logical :: jawel, jawelrestart
 integer :: nstrucsg, L0, istru
 type(t_structure), pointer :: pstru
 integer, external :: flow_initexternalforcings
 double precision, external :: setrho

 double precision  :: xm, ym
 double precision  :: trshcorioi
 double precision  :: Ds
 double precision  :: hw,tw,csw,snw, uorbi,rkw,ustt,hh

 iresult = DFM_GENERICERROR

 if (ndx == 0) then
    iresult = DFM_MODELNOTINITIALIZED
    goto 888
 end if

 Lnmax = 0 ; Lnmin = 0
 ndmax = 0 ; ndmin = 0

 cpusteps = 0; cpusol = 0                            ! timing to zero
 call inisferic()                                    ! also set coriolis :<
 if (icorio > 0) then
    call inifcori()
 endif
 if (Corioadamsbashfordfac > 0) then 
    if (allocated(fvcoro) ) deallocate(fvcoro) 
    allocate ( fvcoro(lnkx), stat = ierr ) ; fvcoro = 0d0
    call aerr('fvcoro(lnkx)', ierr, lnkx  )
 endif 
 if (jsferic == 0) then
    if (jatidep > 0) then
       ! call qnerror('Tide generating potential only supported for sferical models ' ,' ',' ')
       jatidep = 0
    endif
    if (jaselfal > 0) then
       ! call qnerror('Self attraction and loading only supported for sferical models ' ,' ',' ')
       jaselfal = 0
    end if
 endif
 call inidensconstants()                             ! Some density parameters

if (ti_waq > 0d0 .and. max(limtypmom, limtypsa, limtypTM) <= 0) then
    call qnerror('DELWAQ requires at least one limiter (Numerical Parameters). DELWAQ output disabled for now.', ' ', ' ')
    ti_waq = 0d0
end if

 s1  = sini                                  ! initial values
 if (waterdepthini1D > 0) then
    do k = ndx2D+1, ndxi
       s1(k) = bl(k) + waterdepthini1D
    enddo
 endif

 u1  = uini
 if (jasal > 0) then
    sa1 = salini
 endif
 if (jatem > 0) then
    tem1 = temini
 endif

 ! spiral flow
 if (jasecflow > 0 ) then
    spirint = spirini
 endif

 if (jased > 0 .and. jased < 4) then
    do k = 1,ndkx
       do j = 1,mxgr
          sed(j,k) = sedini(j)
       enddo
    enddo
 endif

 if (jasal == 0 .and. jatem == 0 .and. jased == 0) then
    idensform = 0
 endif
 volerror = 0d0 ; squ = 0 ; sqi = 0

 ! nplot  = ndxi/2  ! vertical profile to be plotted at node nr


 ! so this is not yet time dependent...

 ! if (ndx .le. 100) s1(1) = s1(1) + 0.1d0

 ispecials = 1
 call str_lower(md_netfile) ! INTERACTOR!

 if (ispecials == 1) then

 CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)
 CALL DMINMAX(   xk, numk, xkmin, xkmax, numk)


 if (md_IDENT(1:6) == 'wetbed' .or. md_IDENT(1:6) == 'drybed') then  ! wetbed, drybed
    call setbobs()
    jw = 1
    if (md_IDENT(1:6) == 'drybed') then
       jw = 0
    endif

    do k = 1,ndx
       if (xz(k) .le. 0.5d0*(xzmin+xzmax) ) then
          s1(k)  = bl(k) + 2d0
       else if (jw == 1) then
          s1(k)  = bl(k) + hwetbed
       else
          s1(k)  = bl(k)
       endif
    enddo

    if (kmx > 0) then
       call setkbotktop(1)  ! wetbed
       if (jasal > 0) then
          do k = 1,ndx
             if (xz(k) .le. 0.5d0*(xzmin+xzmax) ) then
                call getkbotktop(k,kb,kt)
                do kk = kb,kt
                   sa1(kk) = 2d0
                enddo
             endif
          enddo
       endif
    endif

 else if (md_IDENT(1:7) == 'barocin') then  ! baroclinic instability

    xx1 = 0.5d0*(xzmin+xzmax) ; yy1 = 0.5d0*(xzmin+xzmax)
    call setkbotktop(1)  ! barocin

    do k = 1,ndx
       rr = dbdistance( xx1, yy1, xz(k), yz(k), jsferic, jasfer3D, dmiss)
       if (rr < 3000d0 ) then
           call getkbotktop(k,kb,kt)
           do kk = kb+kmx/2,kt
              !sa1(kk) = sa1(kk) + deltasalinity
              sa1(kk) = 1.1d0*(rr/3000d0)**8 + 33.75d0
           enddo
       endif
    enddo

 else if (md_IDENT(1:16) == 'internalseichexx') then  ! internal seiche hofmeister 2010

    call setkbotktop(1)  ! internalseichexx
    salup = 0d0 ; saldo = 30d0
    do k = 1,ndx
       zi = -10d0*( 1d0 - 0.2d0*sin( pi*xz(k)/(xkmax-xkmin) ) ) ; ziup = zi + 2d0 ; zido = zi - 2d0
       call getkbotktop(k,kb,kt)
       do kk = kb,kt
          zz = 0.5d0*( zws(kk) + zws(kk-1) )
          if (zz > ziup) then
             sa1(kk) = salup
          else if (zz < zido) then
             sa1(kk) = saldo
          else
             rr      = (zz - zido) / (ziup-zido)
             sa1(kk) = saldo*(1d0-rr) + salup*rr
          endif
       enddo
    enddo

 else if (md_IDENT  == 'hump' .or. md_IDENT  == 'humpc') then

    xx1 = 5000d0 ; yy1 = 5000d0
    var = 1d0    ; dmu = 0d0
    do k = 1,numk
       dis = dbdistance(xk(k), yk(k), xx1, yy1, jsferic, jasfer3D, dmiss)
       if (dis < 5d3) then
          xx = dis/1000d0
          yy = 5d0*1d0*sqrt(twopi*var)/sqrt(twopi*var)* exp( -(xx-dmu)**2/(2d0*var) )
          zk(k) = zk(k) + yy
       endif
    enddo
    call setbobs()

 else if (md_IDENT  == 'twohump') then

    xx1 = 5000d0 ; yy1 = 5000d0
    var = 1d0    ; dmu = 0d0

    do kk = 1,2
       if (kk == 1) then
           xx1 = 5000d0 ; yy1 = 6500d0
       else
           xx1 = 5000d0 ; yy1 = 3500d0
       endif

       do k = 1,numk
          dis = dbdistance(xk(k), yk(k), xx1, yy1, jsferic, jasfer3D, dmiss)
          if (dis < 5d3) then
             xx = dis/1000d0
             yy = 11d0*1d0*sqrt(twopi*var)/sqrt(twopi*var)* exp( -(xx-dmu)**2/(2d0*var) )
             zk(k) = zk(k) + yy
          endif
       enddo
    enddo

    call setbobs()

  else if (md_IDENT == '21' ) then

   s1(1) = s1(1) + 1d0

  else if (md_netfile(1:4) == 'rivs') then

    do k = 1,ndx
       if (xz(k) < 4.5d0 ) then
          s1(k) = s1(k) + 1d0
       endif
    enddo
    nplot = 450

 else if (md_netfile(1:4) == 'goot') then

    slope = 1d0/3004d0

    do k  = 1,ndx
       s1(k)  = -slope*( xz(k) - 1d0 )
    enddo

 else if (md_netfile(1:7) == 'evenaar') then

    bl = -5d0; s1 = 0
    ibedlevtyp   = 1 ; call setbobs()

 else if (index(md_ident,'saltwedge') > 0) then                   !


    call setkbotktop(1) ! inisaltwedge

    do k = 1,ndx
       if (xz(k) < 0.5*(xzmin+xzmax) ) then
           call getkbotktop(k,kb,kt)
           do kk = kb,kt
              sa1(kk) = 10d0
              rho1    = rho_Eckart(sa1(kk), backgroundwatertemperature)
           enddo
       else
           !s1(k) = bl(k) + 0.5d0*( s1(k)-bl(k) )*sqrt(rho1/998.200)   ! rho = 1020 etc
       endif
    enddo

 else if (index(md_ident,'salthori') > 0 .and. kmx > 0) then                   !

    call setkbotktop(1) ! ini vertical salinity gradient
     do k = 1,ndx
       call getkbotktop(k,kb,kt)
       do kk = kb,kt
          sa1(kk) = max(0d0, abs( 0.5d0*(zws(kk) + zws(kk-1))  )   )
       enddo
    enddo

 else if (index(md_ident,'lockexchange') > 0) then                   !

    CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)
    call setkbotktop(1) ! inisaltwedge

    do k = 1,ndx
       call getkbotktop(k,kb,kt)
       do kk = kb,kt
          if (xz(k) > 0.5*(xzmin+xzmax) ) then
              sa1(kk) = 6.5d0
          else
              sa1(kk) = 5.0d0
          endif
       enddo
    enddo
 else if (index(md_ident,'locxx') > 0 .or. index(md_ident,'t0st') > 0 .or. trim(md_specific) == 'lockexchange') then                   ! Commented: It triggers on mdu-names that just include 'loc' in the name
                                                            !            For instance: 'locationDelft.mdu',
    CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)             !                          'normalvelocities.mdu',   etc.

    if ( jampi.eq.1 ) then
       call reduce_double_min(xzmin)
       call reduce_double_max(xzmax)
    end if

    if ( index(md_ident,'locxxfix') > 0) then
       kplot = kmx-1
       do k = 1,ndx
          if (xz(k) < 0.5d0*(xzmin+xzmax) ) then
              s1 (k) = s1(k) - 6d0
          endif
       enddo
    else
        do k = 1,ndx
          if (xz(k) > 0.5d0*(xzmin+xzmax) ) then
              s1 (k) = s1(k) + hs(k)*.004d0*0.5d0
          endif
       enddo
    endif

    call setkbotktop(1) ! inisaltwedge

    do k = 1, ndx

       call getkbotktop(k,kb,kt)
       do kk = kb,kt
          if ( index(md_ident,'locxxfix') > 0) then
             if (kk == kb) then
                sa1(kk) = 1d0
             else
                sa1(kk) = 1d0
             endif
          else
             if (xz(k) > 0.5d0*(xzmin+xzmax) .and. (kk-kb+1) <= locsaltlev * kmx ) then
                sa1(kk) = locsaltmax
                if (jatem > 0) then
                   tem1(kk) = 5d0
                endif
                ! if (zws(kk) > -5d0) sa1(kk) = 5d0
             else
                sa1(kk) = locsaltmin
                if (jatem > 0) then
                   tem1(kk) = 10d0
                endif
          endif
          endif
          sa1(k)  = sa1(k) + vol1(kk)*sa1(kk)

          if (jatem > 0) then
             tem1(k)  = tem1(k) + vol1(kk)*tem1(kk)
          endif
       enddo
       sa1(k) = sa1(k) / vol1(k)
       if (jatem > 0) then
          tem1(k) = tem1(k) / vol1(k)
       endif
    enddo

  else if (trim(md_specific) == 'splitter') then
     jamodelspecific = 1
  else if (index(md_ident,'canal-lake') > 0 ) then

    call setkbotktop(1) ! inisaltwedge
    do k = 1, ndx

       call getkbotktop(k,kb,kt)
       do kk = kb,kt
          if (zws(kk) < -5d0 ) then
              sa1(kk) = 10d0
          endif
       enddo

    enddo

  else if (index(md_ident,'internalwave') > 0) then                   !

    CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)
    call setkbotktop(1) ! inisaltwedge

    do k = 1,ndx
       call getkbotktop(k,kb,kt)
       do kk = kb,kt
          sa1(kk) = 0.001d0*xz(k) - (0.5d0*(zws(kk) + zws(kk-1)) - zws(kb-1) ) + 11d0
       enddo
    enddo

 else if (index(md_ident,'slope1_5') > 0) then                   !

    CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)
    call setkbotktop(1) ! inisaltwedge
    sa1 = 5d0

    s1  = bl + 2d0

 else if (index(md_ident,'huump3d') > 0) then                         !

    CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)
    call setkbotktop(1) !inihump3D

    do k = 1,ndx
       if (xz(k) < 0.5*(xzmin+xzmax) ) then
           call getkbotktop(k,kb,kt)
           do kk = kb,kt
              sa1(kk) = 10d0
           enddo
       else
          ! s1(k) = -10d0 + 10d0*sqrt(1005.750/998.200)   ! rho = 1020 etc
       endif
     enddo
 

 else if (index(md_ident,'thacker1d')  > 0 ) then                        ! parab300.net

    call thacker1d(1,xz,yz,s1,bl,ndx,0d0)

    if (kmx > 0) then
       call setkbotktop(1) ! inisaltwedge

       do k = 1,ndx
          if (s1(k) > 0.5d0) then
             call getkbotktop(k,kb,kt)
             do kk = kb,kt
                sa1(kk) = 30d0
             enddo
          endif
       enddo
    endif

 else if (md_IDENT(1:12) == 'coriolistilt') then
     call coriolistilt(0d0 )
 else if (md_IDENT(1:14) == 'corioliskelvin') then
     call corioliskelvin(0d0)

 else if (index(md_ident,'checkerboard') > 0 ) then     ! v40.net, v100.net

    bl    = 0d0
    ibedlevtyp   = 1 ; call setbobs()

    CALL DMINMAX(   xk, numk, xkmin, xkmax, numk)

    n   = 2
    if (index(md_ident,'4') > 0 ) n = 4
    if (index(md_ident,'8') > 0 ) n = 8

    xli = 1d0/(xkmax-xkmin)
    amp = .01d0
    dep = .01d0

    pin = n*pi
    do L = 1,lnx
       k1 = ln(1,L) ; k2 = ln(2,L)
       xx = 0.5d0* ( xz(k1) + xz(k2) ) * xli
       yy = 0.5d0* ( yz(k1) + yz(k2) ) * xli
       !k1 = lncn(1,L) ; k2 = lncn(2,L)
       !xx1 = xk(k1) ; yy1 = yk(k1)
       !xx2 = xk(k2) ; yy2 = yk(k2)
        ux  = 0d0 ; uy = 0d0
       !do j = 1,10
       !   aa  = dble(j-1)/9d0
       !   xx  = (1d0-aa)*xx1 + aa*xx2
       !   yy  = (1d0-aa)*yy1 + aa*yy2
          ux  =  ux + amp*sin(pin*xx)*cos(pin*yy)          ! poisson
          uy  =  uy - amp*cos(pin*xx)*sin(pin*yy)
       !enddo
       !ux = 0.1d0*ux ; uy = 0.1d0*uy
       u1(L) = csu(L)*ux + snu(L)*uy
    enddo

    do k = 1,ndx
       xx = xz(k) * xli
       yy = yz(k) * xli
       s1(k) = dep + amp*amp*(cos(2*pin*xx)+cos(2*pin*yy))/(8*ag*pin*pin)
       if (jasal > 0) then
           if (yy > 0.20 .and. yy < 0.30) sa1(k) = 30.
       endif
           !if (xx < 0.5d0 .and. yy < 0.5d0) then
       !    xx = 2*xx
       !    yy = 2*yy
       !    xx = xx - 0.5d0
       !    yy = yy - 0.5d0
       !    rr = sqrt( xx*xx + yy*yy)
       !    sa1(k) = amp*( 1 + cos(2*pin*rr) )
       ! else
       !    sa1(k) = 0
       ! endif
    enddo

    !WIM s0 = s1
    do j = 1,300
       fout = 0d0
       call sethu(1)             ! was just call sethu()
       do k = 1,ndx
          sq(k) = 0d0
          do kk = 1,nd(k)%lnx
             L  = nd(k)%ln(kk)
             La = iabs(L)
             if (L > 0) then
                sq(k) = sq(k) + u1(La)*hu(La)
             else
                sq(k) = sq(k) - u1(La)*hu(La)
             endif
          enddo
          fout = fout + abs(sq(k))
       enddo

       do k = 1,ndx
          foutk = 0
          do kk = 1,nd(k)%lnx
             L  = nd(k)%ln(kk)
             La = iabs(L)
             if (L > 0) then
                foutk = foutk + sq(ln(2,La))
             endif
          enddo
          s0(k) = s0(k) - foutk*1d-1
       enddo

    enddo

    chkadvd = 0.0d0
    s1(ndx/2)   = s1(ndx/2) + 1d-5

 else if (index(md_netfile,'kelvin') > 0 ) then

    CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)
    CALL DMINMAX(   yz, ndx, yzmin, yzmax, ndx)
    r0  = 0.5d0* (xzmax - xzmin)
    x0  = 0.5d0* (xzmax + xzmin)
    y0  = 0.5d0* (yzmax + yzmin)

    amp    = 0.05d0
    dep    = 10d0
    call inisferic()
    Rossby = sqrt(ag*dep) / fcorio

    sqghi  = sqrt(ag/dep)
    bl     = -dep

    do k = 1,ndx
       xx     = xz(k) - x0 ; yy     = yz(k) - y0
       r      = sqrt(  xx*xx + yy*yy )
       csth   = xx/r ; snth = yy/r
       eer    = (r-r0) / Rossby
       s1(k)  = amp*exp(eer)*csth
       ucmk   = sqghi*s1(k)
       ucx(k) = -ucmk*snth
       ucy(k) =  ucmk*csth
    enddo

    do l  = 1, lnx
       k1    = ln(1,L)   ; k2 = ln(2,L)
       ux    = acl(L)*ucx(k1) + (1d0-acl(L))*ucx(k2)
       uy    = acl(L)*ucy(k1) + (1d0-acl(L))*ucy(k2)
       u1(L) =   ux*csu(L)    + uy*snu(L)
    enddo
 else if (index(md_netfile,'thacker2d') > 0 ) then

    call thacker2d(time0,1)

 else if (md_netfile == 'chan650.net') then

    bl = -5.d0 ; ibedlevtyp   = 1 ; call setbobs()
    s1 =  0.d0

    sa1(275:375) = 5d0
    ! u1  = 1d0
    ! if (lnx .ge. 651) u1(651) = -1d0*u1(651)         ! bnd always inflowing positive

 else if (md_netfile == '640x480.net') then

    bl = -5.d0 ; ibedlevtyp   = 1 ; call setbobs()
    s1 =  0.d0

 else if (md_netfile == 'rec10x10.net') then


    do n = 1,ndx
      if (xz(n) < 1) s1(n) = s1(n) + 1d0
    enddo

 else if (md_netfile == 'g04.net') then

 !   bl = -20.0
    s1 = max(0d0,bl)

 else if (md_netfile == 'sqhex.net' .or. md_netfile      == 'sqquad.net' .or.    &
          md_netfile == 'sqtri.net' .or. md_netfile(1:6) == 'sqcurv' ) then                   ! sqhex.net

    itest = 1
    if (itest == 1) then
       r0     = 250000d0                               ! basin width
       dep    = 5d0                                    ! depth

       x0 = -180 ; y0 = 0 ; rmx = 350
       do k = 1,ndx
          s1(k) = dep
          ! if (xz(k) > -251 .and. xz(k) < -50 .and. yz(k) > -100 .and. yz(k) < 100) then
          !if (xz(k) > -351 .and. xz(k) < -50 .and. yz(k) > -150 .and. yz(k) < 150) then
          !   sa1(k) = 10d0
          !endif
          dxx = xz(k) - x0 ; dyy = yz(k) - y0
          rr  = sqrt(dxx*dxx + dyy*dyy)
          if (rr < 0.5d0*rmx) then
             sa1(k) = 5d0 + 5d0*cos(twopi*rr/rmx)
             sa1(k) = 10d0
          endif
       enddo

       do l   = 1, lnx
          k1  = lncn(1,L) ; k2 = lncn(2,L)
          xx1 = xk(k1) ; yy1 =  yk(k1)
          ux1 = yy1    ; uy1 = -xx1
          xx2 = xk(k2) ; yy2 =  yk(k2)
          ux2 = yy1    ; uy2 = -xx1

          call normalout(xx1, yy1, xx2, yy2, csl, snl, jsferic, jasfer3D, dmiss, dxymis)

          ux  = 0.5d0*(ux1+ux2)
          uy  = 0.5d0*(uy1+uy2)

          k1  = ln(1,L) ; k2 = ln(2,L)
          xx  = 0.5d0*(xz(k1) + xz(k2))
          yy  = 0.5d0*(yz(k1) + yz(k2))
          ux  =  yy
          uy  = -xx

          u1(L) =  ux*csL + uy*snL
       enddo
       u0 = u1
    endif

 else if (md_ident == 'leveque') then

     do L   = 1, lnx
          k1  = lncn(1,L) ; k2 = lncn(2,L)
          xx1 = xk(k1) ; yy1 =  yk(k1)
          ux1 = yy1    ; uy1 = -xx1
          xx2 = xk(k2) ; yy2 =  yk(k2)

          ux2 = yy2    ; uy2 = -xx2

          ux  = 0.5d0*(ux1+ux2)/64d0
          uy  = 0.5d0*(uy1+uy2)/64d0
          u1(L) =  ux*csu(L) + uy*snu(L)
     enddo
     u0 = u1

     CALL DMINMAX(   xk, numk, xkmin, xkmax, numk)
     CALL DMINMAX(   yk, numk, ykmin, ykmax, numk)

     x0  = 0.50d0
     y0  = 0.75d0
     rmx = 0.15d0
     sa1 = 0d0
     do k = 1,ndx
        xx = ( xz(k) - xkmin ) / (xkmax-xkmin)
        yy = ( yz(k) - ykmin ) / (ykmax-ykmin)
        dxx = xx - x0
        dyy = yy - y0
        rr  = sqrt(dxx*dxx + dyy*dyy)

       if (xx > 0.4d0 .and. xx < 0.6d0 .and. yy > 0.7d0 .and. yy < 0.9d0 ) then
           sa1(k) = 10d0
       endif

     enddo

     itstep = 0
 else if (md_ident(1:6) == 'teacup') then

     CALL DMINMAX(   xk, numk, xkmin, xkmax, numk)
     CALL DMINMAX(   yk, numk, ykmin, ykmax, numk)

     call half(xkmin,ykmin,xkmax,ykmin, xx1,yy1,  jsferic, jasfer3D)
     call half(xkmin,ykmax,xkmax,ykmax, xx2,yy2,  jsferic, jasfer3D)
     rmx = 0.5d0*dbdistance(xx1,yy1,xx2,yy2, jsferic, jasfer3D, dmiss)
     ! rmx = 0.5d0*dbdistance(xkmin,ykmin,xkmax,ykmax, jsferic, jasfer3D, dmiss)
     call half(xx1,yy1,xx2,yy2,x0,y0,  jsferic, jasfer3D)

     do L   = 1, lnx
        k1  = lncn(1,L) ; k2 = lncn(2,L)
        xx1 = xk(k1)-x0 ; yy1 =  yk(k1)-y0
        ux1 = yy1       ; uy1 = -xx1
        xx2 = xk(k2)-x0 ; yy2 =  yk(k2)-y0
        ux2 = yy2       ; uy2 = -xx2

        ux    = 0.5d0*(ux1+ux2)/rmx
        uy    = 0.5d0*(uy1+uy2)/rmx

        u1(L) = ux*csu(L) + uy*snu(L)
        do LL = Lbot(L), Lbot(L) + kmxL(L) - 1
           u1(LL) = u1(L)
        enddo
     enddo
     u0 = u1

     do k = 1,numk
        rr    = dbdistance(xk(k),yk(k),x0,y0, jsferic, jasfer3D, dmiss)
        ux    = min(1d0, rr/rmx)
        zk(k) = zkuni*sqrt( 1d0 - ux**2)
     enddo

     npl = 401 ; dphi = 1d0/ (npl-1) ; phi = 0d0 ; k = 0
     k = k + 1 ; xpl(k) = x0 + 1.1*rmx ; ypl(k) = y0
     do L = 1,npl
        k      = k + 1
        xpl(k) = x0  + rmx*cos(phi)
        ypl(k) = y0  + rmx*sin(phi)
        phi    = phi + dphi*twopi
     enddo
     k = k + 1 ; xpl(k) = x0 + 1.1*rmx ; ypl(k) = y0
     k = k + 1 ; xpl(k) = x0 + 1.1*rmx ; ypl(k) = y0 - 1.1*rmx
     k = k + 1 ; xpl(k) = x0 - 1.1*rmx ; ypl(k) = y0 - 1.1*rmx
     k = k + 1 ; xpl(k) = x0 - 1.1*rmx ; ypl(k) = y0 + 1.1*rmx
     k = k + 1 ; xpl(k) = x0 + 1.1*rmx ; ypl(k) = y0 + 1.1*rmx
     npl = k
     call newfil(msam, 'teacup.pli')
     call wripol(msam)

 else if (index(md_ident,'horvic') > 0) then

    if (ibedlevtyp == 1) then
       bl = zkuni + xz*bedslope
    else
       zk = zkuni + xk*bedslope
    endif

    call setbobs()
    s1 = xz*bedslope  ! bl + 10d0

    call Poiseuille(1)

    do L = 1,-Lnx ! Lnx
       u1(L) = 3d0*csu(L)
    enddo

 else if (index(md_ident,'slope') > 0) then

    call setkbotktop(1)
    do LL = 1,Lnx
       Ltop(LL) = lbot(LL) + max(kmx,1) - 1
       hu(LL)   = 5d0 ; frcu(LL) = frcuni
       call getczz0(hu(LL), frcu(LL), ifrcutp(LL), cz, z00)
       ustb(LL) = sqrt(ag*5d0*5d-5)
       cs = csu(LL)
       Lb = Lbot(LL) ; Lt = Ltop(LL)
       do L = Lb,Lt
          zz    = 5d0*dble(L - Lb + 1 - 0.5d0) / dble(Lt-Lb+1)
          u1(L) = cs*ustb(LL)*log(c9of1 + zz/z00) / vonkar
       enddo
    enddo

 else if (md_ident == 'equator1d') then

    call equatorial(0d0)

 else if (md_ident == 'tank_1d') then

      bl = 0d0 ; s1 = -10d0
      do k = 1,ndx
          if      (xz(k) < 0.2d0) then   ! linkerwand
             bl(k) = 50d0
          else if (xz(k) < 20d0) then
             s1(k) = 30d0
             if (xz(k) > 19.8d0) then
                bl(k) = bl(k) + 0.01
             endif
          else if (xz(k) > 25d0 .and. xz(k) < 25.2d0 + 2) then
             bl(k) = 3.0
          else if (xz(k) > 30d0) then
             bl(k) = -20d0
             s1(k) = -4d0
          endif
      enddo
      ibedlevtyp    = 1 ; call setbobs()
 !else if (md_ident(1:6) == 'pillar') then
 !   u1 = csu
 !   if ( jampi.eq.1 ) then
 !      call update_ghosts(ITYPE_U, Lnx, u1, ierror)
 !   end if
 else if ( md_ident(1:3).eq.'lts' ) then
    if ( md_ident(4:6).eq.'rot' ) then
       xkmin =  huge(1d0)
       xkmax = -huge(1d0)
       ykmin =  huge(1d0)
       ykmax = -huge(1d0)
       do k=1,numk
          xkmin = min(xkmin,xk(k))
          xkmax = max(xkmax,xk(k))
          ykmin = min(ykmin,yk(k))
          ykmax = max(ykmax,yk(k))
       end do

       if ( jampi.eq.1 ) then
         call reduce_double_max(xkmax)
         call reduce_double_max(ykmax)
         call reduce_double_min(xkmin)
         call reduce_double_min(ykmin)
       end if

       xm = 0.5d0*(xkmin+xkmax)
       ym = 0.5d0*(ykmin+ykmax)
       R  = 0.5d0*max(xkmax-xkmin, ykmax-ykmin)
       if ( kmx.eq.0 ) then
          do L=1,Lnx
             u1(L) = (-(yu(L)-ym)*csu(L) + (xu(L)-xm)*snu(L))/R
!             u1(L) = (csu(L)+snu(L))
          end do
       else
          do LL=1,Lnx
             Ltop(LL) = Lbot(LL)+kmx-1
             do L=lbot(LL),ltop(LL)
                u1(L) = -yu(LL)*csu(LL) + xu(L)*snu(L)
             end do
          end do
       end if

    else
       if ( kmx.eq.0 ) then
          do L=1,Lnx
             u1(L) = csu(L)
          end do
       else
          do LL=1,Lnx
             Ltop(LL) = Lbot(LL)+kmx-1
             do L=lbot(LL),ltop(LL)
                u1(L) = csu(LL)
             end do
          end do
       end if
    end if

    itstep = 0
!    ja_timestep_auto=-123
!    dt_max = 5d0


! else if ( md_ident(1:4).eq.'pole' ) then
!    call inipole(1)
! else if ( md_ident(1:7).eq.'equator' ) then
!    call inipole(0)

 endif

 endif ! end ispecials

 call statisticsini()

 call setkbotktop(1)                                 ! prior to correctblforzlayerpoints, setting kbot

 call mess(LEVEL_INFO, 'Start initializing external forcings...')
 call klok(cpuiniext(1))
 iresult = flow_initexternalforcings()               ! this is the general hook-up to wind and boundary conditions
 call klok(cpuiniext(2)) ; cpuiniext(3) = cpuiniext(3) + cpuiniext(2) - cpuiniext(1)

 ! from hereon, the processes are in sync
 if (jampi == 1) then
    ! globally reduce the error
    call reduce_error(iresult)
 end if
 if (iresult /= DFM_NOERR) then
    call qnerror('Error occurred while initializing external forcings, please inspect your diagnostic output.',' ', ' ')
    if (jampi == 1) then
        call qnerror('Error occurs on one or more processes when initializing external forcings.',' ', ' ')
    end if
   goto 888
 end if
 call mess(LEVEL_INFO, 'Done initializing external forcings.')

 ! Set ihorvic related to horizontal viscosity
 ihorvic = 0
 if (vicouv > 0 .or. javiusp == 1 .or. Smagorinsky > 0 .or. Elder > 0) then
    ihorvic = 1
 endif

 ! If constituents have been added at this point, the sum-arrays in crs require redimensioning
 if (allocated(crs)) then
    call ReallocCrossSectionSums(crs)
 endif

 ! call setbobsongullies()

 if (isimplefixedweirs == 0) then
    call setbobs_fixedweirs()
 else
    call setfixedweirs()
 endif

 call delpol()

 if (Slopedrop2D > 0) then !todo, uitsluitende test maken
    do L  = lnx1D+1,lnxi
       k1 = ln(1,L) ; k2 = ln(2,L)
       if (.not. (iadv(L) >= 21 .and. iadv(L) <=25) .and. dxi(L)*abs(bl(k1) - bl(k2)) > Slopedrop2D) then ! Not for fixed weirs itself.
           iadv(L) = 8
       endif
    enddo
 endif

 do L  = 1,lnxi
    if (kcu(L) == 3) then         ! lateral overflow
       iadv(L) = 8
    else if (kcu(L) == 5 .or. kcu(L) == 7) then   ! pipe connection
       iadv(L) = 8
    endif
 enddo

! check if at most one structure claims a flowlink
 call check_structures_and_fixed_weirs()

 ! First call to setexternalforcingsonboundaries, here only for the structure timeseries (prior to adjust_bobs_for_dams_and_structs())
 call setzminmax()                                 ! our side of preparation for 3D ec module
 call setsigmabnds()
 call flow_setexternalforcingsonboundaries(tstart_user, iresult)  ! set structure (and bnd) external forcings. Error handling later in 2nd call for bnds.
 call initialize_structures_actual_params(network%sts)            ! After structure time series, and prior to adjust_bobs, to use proper crest levels.


 call adjust_bobs_for_dams_and_structs()

 ! Floodfill water levels based on sample file.
 if (len_trim(md_s1inifile) > 0) then
    call savesam()
    NS = 0
    call oldfil(msam, md_s1inifile)
    if (msam > 0) then
        call reasam(msam, 0)
        call flow_initfloodfill()
    end if
    call restoresam()
 end if

 if (allocated(ibot)) then
    deallocate(ibot)                                    ! after meteoiniti of ibedlevtype
 end if

 if (ndx > 800000) then
    if (allocated (zk) ) then
       ! deallocate(zk)
    endif
 endif

 do L = 1,lnx
    if (frcu(L) == dmiss) then
       if (L <= lnx1D) then
           if (kcu(L) == 3) then
              frcu(L)  = frcuni1d2d
           else if (kcu(L) == 5) then       ! 1D2D internal link pipe streetinlet
              frcu(L)  = frcunistreetinlet
           else if (kcu(L) == 7) then       ! 1D2D internal link pipe roofgutterpipe
              frcu(L)  = frcuniroofgutterpipe
           else
              frcu(L)  = frcuni1d
           endif
       else
           frcu(L) =  frcuni
       endif
    endif
    if (ifrcutp(L) == -999) then
        ifrcutp(L) = ifrctypuni
    endif
    if (frcu(L) > frcmax) then
        frcmax = frcu(L)
    endif
 enddo

 if (jafrculin == 1) then                           ! plus uniform value on not found
    do L = 1,lnx
       if (frculin(L) == dmiss) then
           frculin(L) =  frcunilin
       endif
    enddo
 endif

 if ( jaFrcInternalTides2D.eq.1 ) then
    do k=1,Ndx
       if ( frcInternalTides2D(k).eq.DMISS ) then
          frcInternalTides2D(k) = 0d0
       end if
    end do
 end if

 call setupwslopes()                                   ! set upwind slope pointers and weightfactors

 if (iuvfield > 0) call setvelocityfield()           ! only when testing

 ! remember initial water levels at the water level boundaries
 ! so that reading rst file won't influence it. This is used for restart a model with Riemann boundary conditions.
 do n=1,nbndz
    k2 = kbndz(2,n)
    zbndz0(n) = max(bl(k2), s1(k2)) ! NOTE: the s1=max(bl, s1) step can only be done later, so do it here as well.
 end do

 ! Load restart file (*_map.nc) assigned in the *.mdu file OR read a *.rst file
 jawel = .false.
 if (len_trim(md_restartfile) > 0 ) then
!    Find file extention based on first full stop symbol '.' at the back of the string.
     N1  = INDEX (md_restartfile,'.', .true.)
     N2  = len_trim(md_restartfile)
     EXT = ' '
     EXT = md_restartfile(N1:N2)
     ! Restart from *.rst:
     if ( index(md_restartfile, '.rst') > 0 .or. index(md_restartfile, '.RST') > 0) then
         INQUIRE(FILE = rstFILE, EXIST=JAWEL)
         IF (JAWEL) THEN
            call oldfil(mrst, rstfile)
            call rearst(mrst, jw)
            JAWEL = (jw == 1)
         endif
     else ! Restart from *_yyyymmdd_hhmmss_rst.nc or from *_map.nc
       call read_restart_from_map(md_restartfile, iresult) !TODO:JZ modify the name of this subroutine, since it also restarts from rst files.
       if (jampi == 1) then
          ! globally reduce the error
          call reduce_error(iresult)
       end if
       if (iresult /= DFM_NOERR) then
          if (jampi == 1) then
              call qnerror('Error occurs on one or more processes when reading the restart file.',' ', ' ')
          else
              call qnerror('Error occurs when reading the restart file.',' ', ' ')
          end if

          goto 888
       else
          JAWEL = .true.
       end if

       ntmp = size(u1)
       allocate(u1_tmp(ntmp))
       u1_tmp = u1
       u1     = u0
       hs     = s0 - bl
       call setucxucyucxuucyunew() !reconstruct cell-center velocities
       u1     = u1_tmp
       deallocate(u1_tmp)
     end if
 end if

 jawelrestart = jawel
 if (jawel) jarestart = 1                                       ! in the module

 call flow_setstarttime()                                       ! the flow time0 and time1 are managed by flow
                                                                ! this is the only function that a user can use to influence the flow times
                                                                ! TSTART MAY BE OVERWRITTEN IN REARST

 if (jased > 0 .and. stm_included) then
    if (stmpar%morpar%morft < eps10) then
        !
        ! if the morphological start time is not set to some positive value due
        ! to restart from trim-file, then make sure that the morphological start
        ! time corresponds to the hydrodynamic start time. This includes TStart!
        !
        stmpar%morpar%morft  = tstart_user/86400d0
        stmpar%morpar%morft0 = stmpar%morpar%morft
    endif
 endif

 call setkbotktop(1)                                            ! set sigmabnds for ec

 if ( janudge.eq.1 ) call setzcs()
 call flow_setexternalforcings(tstart_user, .true., iresult)             ! set field oriented external forcings, flag that the call is from the initialization phase

 if (iresult /= DFM_NOERR) then
    goto 888
 end if

 ! Actual boundary forcing (now that initial water levels, etc. are also known):
 call flow_setexternalforcingsonboundaries(tstart_user, iresult)         ! set bnd   oriented external forcings
 if (jampi == 1) then
    ! globally reduce the error
    call reduce_error(iresult)
 end if
 if (iresult /= DFM_NOERR) then
    if (jampi == 1) then
        call qnerror('Error occurs on one or more processes when setting external forcings on boundaries.',' ', ' ')
    end if
    goto 888
 end if
 tim1bnd = tstart_user
 tim1fld = tstart_user

if (.not. jawelrestart) then ! If one restarts a simulation, then s0 and s1 are read from the restart file (new version), no need to set them.
   call sets01zbnd(1)
else if (jaoldrstfile==1) then ! If the restart file is of old version (which does not have waterlevel etc info on boundaries), then need to set.
   call sets01zbnd(0)
   call sets01zbnd(1)
endif


 do n  = 1, nbndn                                  ! for normal velocity boundaries, also initialise velocity on link
    LL = kbndn(3,n)
    call getLbotLtop(LL,Lb,Lt)
    do L = Lb, Lt
       u1(L) = zbndn(n)
    enddo
 enddo

 do nq = 1,nqbnd                                    ! discharge boundaries
    nat = 0 ; bobmin = huge(1d0)
    do n   = L1qbnd(nq), L2qbnd(nq)                 ! initially only
       kb  = kbndu(1,n)
       k2  = kbndu(2,n)
       L   = kbndu(3,n)
       blm = min( bob(1,L), bob(2,L) )
       if (s1(k2) - blm > epshu) then
          nat = 1
       endif
       bobmin = min(bobmin,blm)
    enddo

!   boundary is dry: add 1 cm of water above lowest bed level
    if (nat == 0) then
       do n   = L1qbnd(nq), L2qbnd(nq)             ! initially only
          kb  = kbndu(1,n)
          k2  = kbndu(2,n)
          s1(k2) = max(s1(k2), bobmin + 0.01d0)
          s1(kb) = s1(k2)
       enddo
    else
       do n   = L1qbnd(nq), L2qbnd(nq)             ! initially only
          kb  = kbndu(1,n)
          k2  = kbndu(2,n)
          s1(kb) = s1(k2)
       enddo
    endif
 enddo


 Do L = Lnxi+1, Lnx   ! copy 1D bnd arrays to that of internal attached link
    if (kcu(L) == -1) then
        LL         = Lbnd1D(L)
        frcu(L)    = frcu(LL)
        ifrcutp(L) = ifrcutp(LL)
        IF (jaconveyance2D > 0) aifu(L)    = aifu(LL)
    endif
 enddo

 if (lnx > lnxi) then                               ! boundaries always implicit
    teta(lnxi+1:lnx) = 1d0
 endif

 if (nonlin1d == 2 .or. nonlin2D == 2) then
    if (allocated(s1mini) ) deallocate(s1mini)
    allocate  ( s1mini(ndx) , stat= ierr)
    call aerr ('s1mini(ndx)', ierr, ndx ) ; s1mini = bl
    do L = 1,lnx1D
       k1 = ln(1,L) ; k2 = ln(2,L)
       if ( abs(PROF1D(3,L)) == 1 ) then
          teta(L)    = 1d0                          ! closed pipes always implicit
          s1mini(k1) = max( s1mini(k1), bl(k1) + prof1D(1,L) )
          s1mini(k2) = max( s1mini(k2), bl(k2) + prof1D(1,L) )
       else if ( abs(PROF1D(3,L)) == 2 .or. abs(PROF1D(3,L)) == 3 ) then
          if ( prof1D(2,L) .ne. dmiss ) then
              teta(L) = 1d0
          endif
       endif
    enddo
    do LL = lnxi+1, lnx
       if (kcu(LL) == -1 ) then
          k1 = ln(1,LL) ; k2 = ln(2,LL)
          L  = LBND1D(LL)
          if ( abs(PROF1D(3,L)) == 1 ) then
             teta(LL)   = 1d0                          ! closed pipes always implicit
             s1mini(k1) = max( s1mini(k1), bl(k1) + prof1D(1,L) )
             s1mini(k2) = max( s1mini(k2), bl(k2) + prof1D(1,L) )
          else if ( abs(PROF1D(3,L)) == 2 .or. abs(PROF1D(3,L)) == 3 ) then
             if ( prof1D(2,L) .ne. dmiss ) then
                 teta(L) = 1d0
             endif
          endif
       endif
    enddo

 endif

! Set teta for all structure links to 1.0 (implicit)
 nstrucsg = network%sts%count
 do istru = 1, nstrucsg
    pstru => network%sts%struct(istru)
    do L0 = 1, pstru%numlinks
       L = iabs(pstru%linknumbers(L0))
       teta(L) = 1d0
    enddo
 enddo
 
          

 if (.not. jawelrestart) then
    if (japatm > 0 .and. PavIni > 0) then
       if ( trshcorio.gt.0d0 ) then
          trshcorioi = 1d0/trshcorio
       end if
       do k = 1,ndxi
!          ss    = min( 1d0,  max(s1(k),bl(k)) - bl(k) )        ! reduced correction values at low depths
          Ds = - ( patm(k) - PavIni ) / (ag*rhomean)
          s1(k) = s1(k) + Ds
       end do
    endif

    if  ( jaselfal.gt.0 .and. jaSELFALcorrectWLwithIni.eq.1 ) then
       do k=1,Ndxi
           s1init(k) = max(s1(k), bl(k))
       end do
    end if

    u0 = u1
 endif
 s1  = max(bl, s1) 
 s00 = s1

 nonlin = max(nonlin1D, nonlin2D)
 if (nonlin == 2) then
    if (allocated(s1m) ) deallocate (s1m, a1m)
    allocate ( s1m(ndx), a1m(ndx) , STAT=ierr) ; s1m = s1
    call aerr('s1m(ndx), a1m(ndx)', ierr, ndx)
 endif

 if (nshiptxy > 0) then
    call setship()                               ! in flowinit
    if (kmx > 0 .and. jasal > 0) then
       inquire(file = 'verticalsalinityprofile.pli', exist=success )
       call setkbotktop(1)
       if (success) then
          call setinitialverticalprofile(sa1 , ndkx, 'verticalsalinityprofile.pli') ; success = .true.
       endif
    endif
 endif
 
 call setkbotktop(1)
 
 if (.not. jawelrestart) then
    s0 = s1 
    hs = s1 - bl
 else ! If one restarts a simulation, then use s0 to compute hs
    s0 = max(s0,bl)    
    hs = s0 - bl
 endif

 if ( jaselfal.gt.0 ) then
!  with hs available: recompute SAL potential
   call flow_settidepotential(tstart_user/60d0)
 end if


 if (jagrw > 0) then
    do k = 1,ndx

       if (hs(k) > epshs) then
           sgrw1(k) = bl(k)
       else
           if (allocated(h_unsat) ) then
               sgrw1(k) = bl(k) - h_unsat(k)
           else if (infiltrationmodel == 1) then
               sgrw1(k) = bl(k) - Hinterceptionlayer
           else if (h_unsatini > 0d0) then
               sgrw1(k) = bl(k) - h_unsatini
           else
               sgrw1(k) = sgrwini
           endif
       endif
       sgrw1(k) = min( bl(k), sgrw1(k) )
       bgrw(k)  = min( bl(k), bgrw (k) )
       hunsat   = bl(k) - sgrw1(k)
       fac      = min ( 1d0, max(0d0,  hunsat / h_transfer  )  )      ! 0 at bed, 1 at sgrw
       pgrw(k)  = sgrw1(k)*fac + s1(k)*(1d0-fac)

    enddo

    if (allocated(h_unsat) ) deallocate(h_unsat)
    sgrw0 = sgrw1

 endif

 if (infiltrationmodel == 2 .or. infiltrationmodel == 3) then  ! set infiltcap=0 for closed links only
    call realloc(kcsini, ndx, keepExisting=.false., fill = 0)
    do L = 1,lnx  ! only one connected open profile will open surface runoff
       n1 = ln(1,L) ; n2 = ln(2,L)
       if (L <= lnx1D) then
          if (prof1D(3,L) < 0) then ! closed profile
          else
              kcsini(n1) = 1 ; kcsini(n2) = 1
          endif
       else
          kcsini(n1) = 1 ; kcsini(n2) = 1
       endif
    enddo
    do n = 1,ndx
       infiltcap(n) = infiltcap(n)*kcsini(n)  ! 0 for all links closed
    enddo
    if (allocated(kcsini)) deallocate(kcsini)
 endif

 call sethu(1)
 if (kmx > 0) then ! temporary fix for sepr 3D
    do L = 1,lnx
       if (abs(kcu(L)) == 1) then
          call addlink1D(L,1)
          if (hu(L) > 0d0) then
             wu(L) = au(L) / hu(L)
          endif
       endif
    enddo
 endif

 call volsur()          ! flowinit
 call a1vol1tot()
 vol0tot = vol1tot
 a0tot   = a1tot
 vol0    = vol1

 ! initial velocity in 3D (needs Lbot, Ltop)
 if ( inivel.eq.1 .and. kmx.gt.0 ) then
    do L=1,lnx
       call getLbotLtop(L,Lb,Lt)
       u1(Lb:Lt) = u1(L)
    end do
 end if

  if (jawave==3) then
    if( kmx == 0 ) then
       hs = s1-bl                                   ! safety
       hs = max(hs, 0d0)
       call wave_comp_stokes_velocities()
       call wave_uorbrlabda()                       ! hwav gets depth-limited here
       call tauwave()
       call setwavfu()
       call setwavmubnd()
    end if
 end if

 if (jawave==5) then
    if (kmx==0) then
       do L=1,lnx
          k1=ln(1,L); k2=ln(2,L)
          hh = hu(L); hw=0.5d0*(hwav(k1)+hwav(k2));tw=.5d0*(twav(k1)+twav(k2))
          csw = 0.5*(cos(phiwav(k1)*dg2rd)+cos(phiwav(k2)*dg2rd))
          snw = 0.5*(sin(phiwav(k1)*dg2rd)+sin(phiwav(k2)*dg2rd))
          call tauwavehk(hw, tw, hh, uorbi, rkw, ustt)
          ustokes(L) = ustt*(csu(L)*csw + snu(L)*snw)
       enddo
       do k=1,ndx
          call tauwavehk(hwav(k), twav(k), hs(k), uorbi, rkw, ustt)
          rlabda(k) = rkw; uorb(k) = uorbi
       enddo
       call tauwave()
    endif
 endif

 if (jasal > 0 .and. kmx > 0 .and. inisal2D > 0 .and. jarestart.eq.0 ) then
    do kk = 1,ndx
       call getkbotktop(kk,kb,kt)
       if (inisal2D == 1) then
          do k = kb, kt
             sa1(k) = sa1(kk)
          enddo
       else  if (inisal2D == 2) then
          do k = kb, kt
             if (kt == kb) then
                rr  = 1d0
             else
                rr  = dble(k-kb)/dble(kt-kb)
             endif
             sa1(k) = (1d0 - rr)*sa1(kk) + rr*satop(kk)
          enddo
       else if (inisal2D == 3) then          ! uniform below is specified
          do k = kb, kt
             zz = 0.5d0*( zws(k) + zws(k-1) )
             if (zz < uniformsalinitybelowz .and. sabot(kk) .ne. dmiss) then
                sa1(k) = sabot(kk)
             else
                sa1(k) = sa1(kk)
             endif
          enddo
       endif
       do k = kt+1, kb+kmxn(kk)-1
          sa1(k) = sa1(max(kt,kb))
       enddo
    enddo
    sa1 = max(0d0, sa1)
    if ( allocated(satop) ) then
       deallocate (satop)
    endif
    if ( allocated(sabot) ) then
       deallocate (sabot)
    endif

 endif

 if (kmx > 0 .and. initem2D > 0 ) then
    do kk = 1,ndx
       call getkbotktop(kk,kb,kt)
       do k = kb, kt
           tem1(k) = tem1(kk)
       enddo
    enddo
 endif

 if (kmx > 0 .and. inised2D > 0 ) then
    do kk = 1,ndx
       if (sedh(kk) .ne. dmiss) then
          call getkbotktop(kk,kb,kt)
          do k = kb, kt
              sed(1:mxgr,k) = sedh(kk)
          enddo
       endif
    enddo
    deallocate(sedh)
    inised2D = 0
 endif

 if (Sal0abovezlev .ne. dmiss) then
     do kk = 1,ndx
       call getkbotktop(kk,kb,kt)
       do k = kb, kt
          if (zws(k) > Sal0abovezlev) then
              sa1(k) = 0d0
          endif
       enddo
     enddo
 endif

 if (jasal > 0) then
    salmax = maxval(sa1)
 endif

  ! When restart, initialize salinity, temperature, sed on waterlevel boundaries
 ! NOTE: keep this identical to how it's done at the end of transport()
 ! hk: and, make sure this is done prior to fill constituents
 if (jarestart > 0) then
    do LL = lnxi + 1, lnx                           ! copy on outflow
        call getLbotLtop(LL,Lb,Lt)
        if (Lt < Lb) then
            cycle
        endif
        do L = Lb, Lt
           if (q1(L) < 0) then
              kb = ln(1,L) ; ki = ln(2,L)
              if (jasal > 0) then
                  sa1(kb)  = sa1(ki)
              endif
              if (jatem > 0) then
                  tem1(kb)  = tem1(ki)
              endif
              if (jased > 0) then
                 do j = 1,mxgr
                    sed(j,kb) = sed(j,ki)
                 enddo
              endif
           endif
        enddo
    enddo
 endif

 ! initialize constituents
 if ( NUMCONST.gt.0 ) then
     call fill_constituents(0)   ! called from initialise
     if (jatem > 0) then
         do k = 1,ndkx
            constituents(itemp,k) = tem1(k)
         enddo
        ! deallocate(tem1)
     endif
 endif

 if (jarestart == 1 .and. (jasal > 0 .or. jatem > 0  .or. jased > 0)) then
    jainirho = 1
 endif

 if (jainirho == 1) then
    do kk = 1,ndx  ! initialise rho's
       call getkbotktop(kk,kb,kt)
       do k = kb,kt
          rho(k)  = setrho(k)
       enddo
       do k = kt+1 , kb + kmxn(kk) - 1
          rho(k) = rho(kt)
       enddo
    enddo
 endif

 if (allocated (rho0))  then
    rho0 = rho
 endif


 if (jaFlowNetChanged == 1 .or. nodtot /= ndx .or. lintot /= lnx) then
       call reducept(Ndx,Ndxi,Lnx)                              ! also alloc arrays for reduce
       if (icgsolver == 10) then
          call alloc_jacobi(ndx,lnx)
       endif
 end if

 if ( jawave.eq.4 ) then   ! JRE: remember initial water level for Riemann boundary condition
    if ( allocated(s1initial) ) deallocate(s1initial)
    allocate(s1initial(Ndx))
    s1initial = s1
 end if

 if ( janudge.eq.1 ) then
    call set_nudgerate()
    if ( jainiwithnudge > 0 ) then
       call set_saltem_nudge()
       if (jainiwithnudge == 2) then
           janudge = 0
           deallocate (nudge_tem, nudge_sal, nudge_rate , nudge_time)
       endif
    end if
 end if

! BEGIN DEBUG
! if ( jampi.eq.1 ) then
!    call update_ghosts(ITYPE_U,Lnx,teta,ierr)
! endif
! END DEBUG

 if (kmx < 2) then                    ! in 2D, use 1
    if ( ja_timestep_auto.ne.-123 ) then
       ja_timestep_auto = 1
    else
       ja_timestep_auto = 0
    end if
 else if (ja_timestep_auto .ne. 5) then
    jalts = 1
 endif

 if ( jaimplicit.eq.1 ) then
    call inisolver_advec(ierror)
 end if

 call ini_filter(jafilter, filterorder, jacheckmonitor, ierror)

 if (jabarrieradvection == 3) then
    call setstruclink()
 endif

 if (japillar > 0) then
    call setpillars()
 endif

 ! for 1D only
 if (network%loaded .and. ndxi-ndx2d > 0) then
    if (jamapVolOnGround > 0) then 
       call set_max_volume_for_1d_nodes() ! set maximal volume, it will be used to update the volume on ground level for the output
    end if
 end if

 iresult = DFM_NOERR
 return

888 continue  ! Some error occurred, prevent further flow
 ndx = 0

 if (nonlin==2) then
    s1m = bl
 endif

 end function flow_flowinit


!> Fourier Analysis, copied from Delft3D:
!! Opens and reads .fou file (md_foufile, specified in the mdu)
!! and prepares the gd_fourier structure
subroutine flow_fourierinit()
use m_fourier_analysis
use m_transport, only: NUMCONST, ISALT, ITEMP
use unstruc_model, only: md_foufile, md_tunit, getoutputdir
use unstruc_files, only : defaultFilename
use m_flow, only: kmxd
use m_physcoef, only: ag
use m_flowtimes, only: tstart_user, tstop_user

implicit none
integer  :: minp, ierr
logical  :: success
call oldfil(minp, md_foufile)
call fouini(minp, success, ag, md_tunit,'S')
FouOutputFile = trim(getoutputdir()) // defaultFilename('fou')

call alloc_fourier_analysis_arrays()
call reafou(minp, md_foufile, kmxd, NUMCONST, ISALT, ITEMP, tstart_user, tstop_user, success)
call doclose(minp)

end subroutine flow_fourierinit


!> Sets initial water level based on a 'flood fill' that originates from
!! the active sample points.
!!
!! The active samples are used as starting points, with their z-values as
!! initial water level. This level spreads out to all surrounding cells,
!! until a higher bottom (shore) is encountered, or a flood front from one
!! of the other samples.
!! Also used by flow_flowinit() for the <tt>WaterLevIniFile</tt> from the MDU.
subroutine flow_initfloodfill()
use m_samples
use m_flow
use m_flowgeom
use m_GlobalParameters, only: INDTP_ALL
use m_alloc
use kdtree2Factory
implicit none

integer :: i, inod, iL, Lf, k, k2, nx
integer, allocatable :: kcsfill(:)
integer, allocatable :: ndroot(:)
integer, allocatable :: ndqueue(:)
integer, dimension(:), allocatable :: inodes
double precision, allocatable :: s1queue(:)
integer :: iqcur, iqtail
integer :: ierror, knew
integer :: jakdtree

jakdtree = 1

if (ndx <= 0) then
    return
end if

! Each node is visited at most once: work array size <= ndx.
nx = ns+ndx-1
call realloc(kcsfill, nx, fill = 0)
call realloc(ndqueue, nx, fill = 0)
call realloc(s1queue, nx, fill = 0d0)

iqcur = 0  !< Index of current node in queue.
iqtail = 0 !< Index of most recently added element in work queue.

!find flowcells
if ( jakdtree.eq.1 ) then
   allocate(inodes(Ns))
   call find_flowcells_kdtree(treeglob,Ns,xs,ys,inodes,1,INDTP_ALL, ierror)
end if

if ( ierror.ne.0 ) then
   if ( allocated(inodes) ) deallocate(inodes)
   jakdtree = 0
end if

! First associate all samples with a single flow node (1D or 2D) and put them in work queue.
do i = 1,NS
    if ( jakdtree.eq.1 ) then
       k = inodes(i)
    else
    call in_flowcell(xs(i), ys(i), k)
    end if

    if (k > 0  ) then
        if ( zs(i) > bl(k) ) then
           s1(k)      = zs(i)
           kcsfill(k) = 1

           iqtail          = iqtail+1
           ndqueue(iqtail) = k
           s1queue(iqtail) = zs(i)
        endif
    end if
end do

if ( iqtail.eq.0 ) return


! Loop over flow node queue: for each node, water level is already set,
! but now also visit its neighbouring flow nodes (this is the 'flood' step).
iqcur = 0
do
    iqcur = iqcur + 1
    k = ndqueue(iqcur)
    if (k == 0) then
       exit
    endif
    do iL=1,nd(k)%lnx
        Lf = abs(nd(k)%ln(iL))
        if (s1queue(iqcur) < minval(bob(:,Lf))) cycle ! Water level lower than link's bottom level, cannot flood across this link.
        k2 = ln(1,Lf)
        if (k2 == k) then
            k2 = ln(2, Lf)
        end if

        if (kcsfill(k2) == 1) then
        !   Two flood areas meet: average waterlevel on their interface
            s1(k2) = .5d0*(s1(k2) + s1queue(iqcur))
        else if (kcsfill(k2) == 0) then
        !   Newly flooded point: set waterlevel and enqueue it for further flooding.
            s1(k2) = s1queue(iqcur)
            kcsfill(k2) = 1
            iqtail = iqtail+1
            ndqueue(iqtail) = k2
            s1queue(iqtail) = s1queue(iqcur)
        end if
    end do
    ! All reachable nodes have been visited, rest (if any) remains unflooded at s1ini:
    if (iqcur==iqtail) exit
end do

! Update water depth explicitly here, for direct plotting.
! NOTE: all other quantities a1, hu, etc. need to be updated by flow_initimestep().
hs = s1-bl

deallocate(kcsfill,ndqueue,s1queue)

if ( allocated(inodes) ) deallocate(inodes)

end subroutine flow_initfloodfill


    subroutine thacker2dorg(t, ini, rms)
    use m_flowgeom
    use m_flow
    use m_sferic
    implicit none
    double precision :: t, rms
    integer          :: ini, k, L
    double precision :: xzmin, xzmax, yzmin, yzmax, s1k, x0, y0, r0, xx, yy, r, dep,omeg,psi,samp,st,ct,ux,uy
    CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)
    CALL DMINMAX(   yz, ndx, yzmin, yzmax, ndx)
    r0  = 0.5d0* (xzmax - xzmin)
    x0  = 0.5d0* (xzmax + xzmin)
    y0  = 0.5d0* (yzmax + yzmin)

    dep  = 10d0
    omeg = twopi/(12*3600)  ! period = 12 hrs
    r0   = sqrt( 2d0*ag*dep/ ( omeg*( omeg+fcorio) ) )  ! Casulli 2007 (19) mind you, no - sign in front of fcorio


!    r0   = sqrt( 2d0*ag*dep/ ( omeg*omeg ) )
!    omeg = 0.5d0*(-fcorio+ sqrt(fcorio*fcorio + 4d0*(2d0*ag*dep/(r0*r0) )  )  )
!    r0   = sqrt( 2d0*ag*dep/ ( omeg*( omeg+fcorio) ) )  ! to keep constant r0, irrespective of fcorio


    psi  = 0.15d0*r0
    samp = psi*dep/(r0*r0)
    st   = sin(omeg*t)
    ct   = cos(omeg*t)
    rms  = 0d0
    do k = 1,ndx
       xx     = xz(k) - x0 ; yy     = yz(k) - y0
       r     = sqrt(  xx*xx + yy*yy )
       bl(k) = -dep*( 1d0 - (r*r)/(r0*r0) )
       s1k   = max( bl(k), samp*(2d0*xx*ct  - 2d0*yy*st - psi) )
       if (ini == 1) then
          s1(k) = s1k
       else
          rms   = rms  + abs (s1k - s1(k))  ! **2
       endif
    enddo
    !rms = sqrt(rms)/ndx
    rms = rms/ndx


    if (ini == 1) then
       ux = -psi*omeg*st
       uy = -psi*omeg*ct
       do L = 1,lnx
          u1(L) = ux*csu(L) + uy*snu(L)
       enddo

       call setbobs()
    endif
    end subroutine thacker2dorg

    subroutine coriolistilt(tim) 
    use m_netw
    use m_flowgeom
    use m_flow
    use m_sferic
    use unstruc_display
    implicit none

    integer          :: k, L, k1, k2
    double precision :: s1k, xx, yy, samp, ux, uy, dif, alf, tim

    ux = 0.1d0; uy = 0d0;  samp = ux*fcorio/ag
    if (tim == 0d0) then 

       do k = 1,numk
          alf   = (yk(k)-ykmin)/(ykmax-ykmin) 
          zk(k) = -600d0 + 500d0*cos(pi*alf)
       enddo

       call setbobs()        
  
       do L = 1,lnx
          u1(L) = csu(L)*ux + snu(L)*uy 
       enddo    
     endif  

    call statisticsnewstep()
   
    do k   = 1,ndx
       yy  = yz(k)  
       s1k =  -samp*yy

       if (tim == 0d0) then
          s1(k)  = max( bl(k), s1k) ; s0(k) = s1(k)
       endif

       dif = abs(s1(k) - s1k)
       call statisticsonemorepoint(dif)
    enddo

    call statisticsfinalise()
    end subroutine coriolistilt

   subroutine corioliskelvin(tim) 
    use m_netw
    use m_flowgeom
    use m_flow
    use m_sferic
    use unstruc_display
    implicit none

    integer          :: k, L, k1, k2
    double precision :: tim,s1k, xx, yy, samp, ux, uy, dif, alf, cs, sn, aer, dep, r0, x0, y0, Rossby, rr, sgh 

    if (tim == 0d0) then
       call inisferic()
    endif
    
    dep    = sini-zkuni
    sgh    = sqrt(ag/dep) 
    Rossby = sqrt(ag*dep) / fcorio
    r0     = 0.5d0*(xkmax-xkmin) 
    x0     = 0.5d0*(xkmax+xkmin) 
    y0     = 0.5d0*(ykmax+ykmin) 
    samp   = 0.05d0
   
    call statisticsnewstep()
   
    do k   = 1,ndx
       yy  = yz(k)  - y0 
       xx  = xz(k)  - x0
       rr  = dsqrt(xx*xx + yy*yy)
       cs  = xx/rr  
       sn  = yy/rr          
 
       aer = samp*exp((rr-r0)/Rossby)
       s1k = aer*cs
     
       if (tim == 0) then
          s1(k)  = max( bl(k), s1k) ; s0(k) = s1(k)
          ucx(k)  = -s1k*sgh*sn 
          ucy(k)  =  s1k*sgh*cs  
       endif

       dif = abs(s1(k) - s1k)
       call statisticsonemorepoint(dif)
    enddo

    if (tim == 0) then
       do L  = 1,Lnx
          k1 = ln(1,L) ; k2 = ln(2,L) 
          u1(L) = 0.5d0*(ucx(k1) + ucx(k2))*csu(L) + 0.5d0*(ucy(k1) + ucy(k2))*snu(L)
          u0(L) = u1(L)   
       enddo
    endif

    call statisticsfinalise()
    end subroutine corioliskelvin

    subroutine thacker2d(t, ini)
    use m_netw, only  : xk, yk, zk, numk
    use m_flowgeom
    use m_flow
    use m_sferic
    implicit none
    double precision :: t, rms
    integer          :: ini, k, L, k1, k2
    double precision :: xzmin, xzmax, yzmin, yzmax, s1k, x0, y0, r0, xx, yy, r, dep,omeg,psi,samp,st,ct,ux,uy
    double precision :: h0, zz0, a, a1c, a12, sa12, rr0, ur, ut, cs, sn

    CALL DMINMAX(   xz, ndx, xzmin, xzmax, ndx)
    CALL DMINMAX(   yz, ndx, yzmin, yzmax, ndx)

    r0  = 0.5d0* (xzmax - xzmin)*0.85
    x0  = 0.5d0* (xzmax + xzmin)
    y0  = 0.5d0* (yzmax + yzmin)
    h0  = 10d0
    zz0 =  2d0


    omeg   = twopi/(12*3600)  ! period = 12 hrs
    omeg   = sqrt(8*ag*h0/(r0*r0))

    fcorio = 0d0 ! omeg/2

    a      = ( (h0+zz0)**2 - h0*h0 ) / ( (h0+zz0)**2 + h0*h0 )

    r0     = sqrt( 8d0*ag*h0 / ( omeg*omeg -fcorio*fcorio) )   ! Casulli 2008 (31) mind you, no - sign in front of fcorio

    st     = sin(omeg*t)
    ct     = cos(omeg*t)


    if (ibedlevtyp == 3) then
       do k = 1,numk
          xx    = xk(k) - x0 ; yy     = yk(k) - y0
          r     = sqrt(  xx*xx + yy*yy )
          rr0   = (r*r)/(r0*r0)
          zk(k) = -h0*( 1d0 -  rr0 )
       enddo
       call setbobs()
    endif

    rms    = 0d0
    do k = 1,ndx
       xx    = xz(k) - x0 ; yy     = yz(k) - y0
       r     = sqrt(  xx*xx + yy*yy )
       rr0   = (r*r)/(r0*r0)
       if (ibedlevtyp .ne. 3) then
          bl(k) = -h0*( 1d0 -  rr0 )
       endif

       a1c   = 1d0-a*ct
       a12   = 1d0-a*a
       sa12  = sqrt(a12)

       s1k   = h0*( sa12/a1c - 1d0 - rr0*( a12/(a1c*a1c) -1d0) )
       s1k   = max(bl(k), s1k)
       if (ini == 1) then
          s1(k) = s1k
          ur = omeg*r*a*st/(2d0*a1c)
          ut = ( fcorio*r/(2d0*a1c) )*(sa12 + a*ct -1d0)
          cs = xx/r ; sn = yy/r
          ucx(k) = ur*cs - ut*sn
          ucy(k) = ur*sn + ut*cs
       else
          rms   = rms  + abs (s1k - s1(k)) ! **2
       endif

    enddo
    ! rms = sqrt(rms)/ndx
    rms = rms/ndx


    if (ini == 1) then
       do L = 1,lnx
          k1 = ln(1,L) ; k2 = ln(2,L)
          u1(L) = ( acl(L)*ucx(k1) + (1d0-acl(L))*ucx(k2) ) *csu(L)  &
                + ( acl(L)*ucy(k1) + (1d0-acl(L))*ucy(k2) ) *snu(L)
       enddo

       call setbobs()
    endif

    end subroutine thacker2d


 subroutine thacker1d(ini,xz,yz,s1,bl,ndx,t)
 use m_netw
 use m_sferic
 use m_physcoef
 use m_flowparameters
 use gridoperations

 implicit none
 integer          :: ndx, ini
 double precision :: dep, xz(ndx), yz(ndx), s1(ndx), bl(ndx), t
 integer          :: is, k
 double precision :: omeg, r, r0, rr0, psi, samp, st, ct, ux, uy, s1k, dif, xx, yy, period

 dep    = 10d0
 fcorio = 0d0
 ! omeg   = twopi/(12*3600)  ! period = 12 hrs
 ! r0     = sqrt( 2d0*ag*dep/ ( omeg*( omeg+fcorio) ) )  ! Casulli 2007 (19) mind you, no - sign in front of fcorio

 r0     = 120d0
 omeg   = sqrt(2d0*ag*dep/(r0*r0))
 period = twopi / omeg

 if (ini == 1) then
    if ( ibedlevtyp == 3) then
       do k = 1,numk
          r     = xk(k) - 150D0
          rr0   = (r*r)/(r0*r0)
          zk(k) = -dep*( 1d0 -  rr0 )
       enddo
    else
       do k = 1,ndx
          r     = xz(k) - 150D0
          rr0   = (r*r)/(r0*r0)
          bl(k) = -dep*( 1d0 -  rr0 )
       enddo
    endif
    call setbobs()
 endif

 !psi    = 0.25d0*r0
 psi    = 0.23d0*r0
 samp   = psi*dep/(r0*r0)
 st     = sin(omeg*t)
 ct     = cos(omeg*t)
 is     = 0
 call statisticsnewstep()
 do k   = 1,ndx
!    r     = xz(k) - 150d0  ! sqrt(  xz(k)*xz(k) + yz(k)*yz(k) )
!    s1k   = samp*r*ct

    xx    = xz(k) - 150d0 ; yy = 0
    s1k   = samp*(2d0*xx*ct  - 2d0*yy*st - psi*ct*ct)

    if (ini == 1) then
       s1(k)  = max( bl(k), s1k)
    endif

    if ( s1k > bl(k) ) then
       dif = abs(s1(k) - s1k)
       if ( inview( xz(k), yz(k) )  ) then
          call statisticsonemorepoint(dif)
       endif
       if (is == 0) then
          call movabs(xz(k), s1k) ; is = 1
       else
          call lnabs (xz(k), s1k)
       endif
    endif
 enddo
 call statisticsfinalise()

 ux = -psi*omeg*st
 uy = -psi*omeg*ct

 end subroutine thacker1d

 subroutine statisticsnewstep()
 use m_statistics
 implicit none
 avedif = 0d0    ! for now only, cum dif with analytic sol
 sqadif = 0d0    ! for now only, cum dif with analytic sol
 dmxdif = 0d0    ! for now only, cum dif with analytic sol
 numdif = 0
 end subroutine statisticsnewstep

 subroutine statisticsini()
 use m_statistics
 implicit none
 call statisticsnewstep()
 cumavedif = 0d0    ! for now only, cum dif with analytic sol
 cumrmsdif = 0d0    ! for now only, cum dif with analytic sol
 cumdmxdif = 0d0    ! for now only, cum dif with analytic sol
 numcum    = 0
 end subroutine statisticsini

 subroutine statisticsonemorepoint(dif)
 use m_statistics
 implicit none

 double precision :: dif
 avedif = avedif + dif
 sqadif = sqadif + dif*dif
 dmxdif = max(dmxdif,dif)
 numdif = numdif + 1
 end subroutine statisticsonemorepoint

 subroutine statisticsfinalise()
 use m_statistics
 implicit none
 if (numdif .ne. 0) then
    avedif    = avedif/numdif
    cumavedif = cumavedif + avedif
    rmsdif    = sqrt( sqadif / numdif )
    cumrmsdif = cumrmsdif + rmsdif
    dmxdif    = max(cumdmxdif, dmxdif)
    numcum    = numcum + 1
 endif
 end subroutine statisticsfinalise

 subroutine inifcori()
 use m_flowgeom
 use m_flow
 use m_sferic
 implicit none
 integer :: ierr, L, k, i, LL, LLL, LLLL, k1, k2, k3, n, j

 if (jsferic > 0) then 
    if (allocated(fcori) ) then
       deallocate(fcori)
    endif
   
    if (icorio <= 6) then 
       allocate ( fcori(lnx), stat = ierr )
       call aerr('fcori(lnx)', ierr, lnx  )
       do L = 1,lnx
          fcori(L) = 2d0*omega*sin(yu(L)*dg2rd)
       enddo
    else 
       allocate ( fcori(ndx), stat = ierr )
       call aerr('fcori(ndx)', ierr, ndx  )
       do k = 1,ndx
          fcori(k) = 2d0*omega*sin(yz(k)*dg2rd)
       enddo
    endif
   
    if (jacorioconstant == 1) then
       fcori = 2d0*omega*sin(anglat*dg2rd)
    endif
 
    if ( jasecflow > 0 .and. kmx == 0 ) then
   
      ! Corilios in flow node, added by Nabi
       if (allocated(fcoris) ) then
          deallocate(fcoris)
       endif
       allocate ( fcoris(ndx), stat = ierr )
       call aerr('fcoris(ndx)', ierr, ndx  )
       do k = 1,ndx
          fcoris(k) = 2d0*omega*sin(yz(k)*dg2rd)
       enddo
    endif
 endif 

 if (icorio > 40) then 
    !if (allocated(LLkkk) ) then
    !   deallocate(LLkkk)
    !endif
    
    n = 0 
    do j = 1,2  ! 1=count, 2=allocate and use
       if (j == 2) then 
           allocate ( LLkkk(5,n) , stat = ierr ); LLkkk = 0
       endif
       n = 0
       do L = 1,lnx
          do i = 1,2
             k = ln(i,L) 
             do LL   = 1, nd(k)%lnx                            ! loop over all attached links  k1,L1,k2,L2,k3  
                LLL  = nd(k)%ln(LL)                            !                              ( 3  1  4  2  5, L) 
                LLLL = iabs(LLL)
                if (L < LLLL) then 
                   n = n + 1
                   if (j == 2) then 
                      if (i == 2) then 
                          k1 = ln(1,L) 
                          k2 = ln(2,L) 
                      else 
                          k1 = ln(2,L) 
                          k2 = ln(1,L) 
                      endif
                      k3 = ln(1,LLLL) + ln(2,LLLL) - k2 
                      LLkkk(1,n) = L
                      LLkkk(2,n) = LLLL
                      LLkkk(3,n) = k1
                      LLkkk(4,n) = k2
                      LLkkk(5,n) = k3
                   endif
                endif
             enddo
          enddo           
       enddo
    enddo
 endif

 end subroutine inifcori

!> set field oriented boundary conditions
subroutine flow_setexternalforcings(tim, l_initPhase, iresult)
   use m_timer
   use m_flowtimes
   use m_flowgeom
   use m_flow
   use m_sferic
   use timespace
   use m_missing
   use m_structures
   use m_meteo
   use m_trachy, only : itimtt
   use m_calbedform
   use m_bedform
   use dfm_error
   use m_calibration, only: calibration_backup_frcu
   use unstruc_channel_flow
   use m_pump
   use m_Dambreak
   use m_flowexternalforcings
   use m_partitioninfo
   use time_class
   use unstruc_messages

   implicit none

   double precision, intent(in)    :: tim !< Time in seconds
   type(c_time)                    :: ecTime !< Time in EC-module
   logical                         :: l_initPhase, first_time_wind
   integer,          intent(out)   :: iresult !< Integer error status: DFM_NOERR==0 if succesful.

   double precision :: timmin
   double precision :: ntrtsteps            !< variable to determine if trachytopes should be updated
   double precision :: tem_dif
   integer          :: k, L, i, k1, k2, iFirst, iLast
   logical          :: l_set_frcu_mor = .false.

   logical, external :: flow_initwaveforcings_runtime
   character(len=255) :: tmpstr
   type(tEcItem), pointer :: itemPtr !< Item under consideration, for right order of wind items

   ! variables for processing the pump with levels, SOBEK style
   integer                               :: n, ierr, istru, structInd
   double precision, allocatable         :: results(:,:)
   double precision, allocatable         :: waterLevelsLeft(:), waterLevelsRight(:),normalVelocity(:)

   iresult = DFM_EXTFORCERROR
   call klok(cpuext(1))

   timmin = tim/60d0   ! talking to Meteo1 is in minutes

   success = .true.

   if (allocated(patm)) then
      ! To prevent any pressure jumps at the boundary, set (initial) patm in interior to PavBnd.
      ! May of course be overridden later by spatially varying patm values.
      patm = PavBnd
   end if

   if (jawind == 1 .or. japatm > 0) then   ! setwind
      if (allocated(wx)) then
        wx = 0.d0
      end if
      if (allocated(wy)) then
        wy = 0.d0
      end if
      if (allocated(ec_pwxwy_x)) then
        ec_pwxwy_x = 0.d0
      end if
      if (allocated(ec_pwxwy_y)) then
        ec_pwxwy_y = 0.d0
      end if

      first_time_wind = (id_last_wind < 0)
      if (first_time_wind) then
         iFirst = 1
         iLast = ecInstancePtr%nItems
      else
         iFirst = id_first_wind
         iLast = id_last_wind
      endif
      do i=iFirst, iLast
         itemPtr => ecInstancePtr%ecItemsPtr(i)%ptr
         ! Retrieve wind's x- and y-component for ext-file quantity 'windxy'.
         if (itemPtr%id == item_windxy_x .and. item_windxy_y /= ec_undef_int) then
            success = ec_gettimespacevalue(ecInstancePtr, item_windxy_x, irefdate, tzone, tunit, tim)
         ! Retrieve wind's p-, x- and y-component for ext-file quantity 'airpressure_windx_windy'.
         else if (itemPtr%id == item_apwxwy_p .and. item_apwxwy_x /= ec_undef_int .and. item_apwxwy_y /= ec_undef_int) then
            if (item_apwxwy_c /= ec_undef_int) then
               success = ec_gettimespacevalue(ecInstancePtr, 'airpressure_windx_windy_charnock', tim)
            else
               success = ec_gettimespacevalue(ecInstancePtr, 'airpressure_windx_windy', tim)
            endif
            if (success) then
               ! FM performs an additional spatial interpolation:
               do L  = 1,lnx ! i
                  k1 = ln(1,L) ; k2 = ln(2,L)
                  wx(L) = 0.5d0*( ec_pwxwy_x(k1) + ec_pwxwy_x(k2) )
                  wy(L) = 0.5d0*( ec_pwxwy_y(k1) + ec_pwxwy_y(k2) )
                  if (allocated(ec_pwxwy_c)) then
                     wcharnock(L) = 0.5d0*( ec_pwxwy_c(k1) + ec_pwxwy_c(k2) )
                  endif
               enddo
            end if
         ! Retrieve wind's x-component for ext-file quantity 'windx'.
         else if (itemPtr%id == item_windx) then
            success = ec_gettimespacevalue(ecInstancePtr, item_windx, irefdate, tzone, tunit, tim)
         ! Retrieve wind's y-component for ext-file quantity 'windy'.
         else if (itemPtr%id == item_windy) then
            success = ec_gettimespacevalue(ecInstancePtr, item_windy, irefdate, tzone, tunit, tim)
         ! Retrieve wind's p-component for ext-file quantity 'atmosphericpressure'.
         else if (itemPtr%id == item_atmosphericpressure) then
            success = ec_gettimespacevalue(ecInstancePtr, item_atmosphericpressure, irefdate, tzone, tunit, tim)
         else
            cycle  ! avoid updating id_first_wind and id_last_wind
         endif
         if (.not. success) goto 888
         if (first_time_wind) then
            id_first_wind = min(i, id_first_wind)
            id_last_wind  = max(i, id_last_wind)
         endif
      enddo

      if (item_atmosphericpressure /= ec_undef_int) then
         do k = 1,ndx
            if (patm(k) == dmiss) patm(k) = 101325d0
         enddo
      endif

      if (jawave == 1 .or. jawave == 2) then
         call tauwavefetch(tim)
      endif
   endif

   if (jawind > 0) then
      if (jawindspeedfac > 0) then 
         do L = 1,lnx
            if (windspeedfac(L) .ne. dmiss) then
                wx(L) = wx(L) *windspeedfac(L)
                wy(L) = wy(L) *windspeedfac(L)
            endif
         enddo
      endif 
      call setwindstress()
   endif

!   !$OMP  PARALLEL SECTIONS   &
!   !$OMP REDUCTION(.AND.:success)


!   !$OMP SECTION

    if (jatem > 1) then
       success = .false.

       ! Update arrays rhum, tair and clou in a single method call.
       ! Nothing happens in case quantity 'humidity_airtemperature_cloudiness' has never been added through ec_addtimespacerelation.
       if (itempforcingtyp == 1) then

          success = success .or. ec_gettimespacevalue(ecInstancePtr, 'humidity_airtemperature_cloudiness', tim)

       else if (itempforcingtyp == 2) then

           success = success .or. ec_gettimespacevalue(ecInstancePtr, 'humidity_airtemperature_cloudiness_solarradiation', tim)

       else if (itempforcingtyp == 3) then

           success = success .or. ec_gettimespacevalue(ecInstancePtr, 'dewpoint_airtemperature_cloudiness', tim)

       else if (itempforcingtyp == 4) then

           success = success .or. ec_gettimespacevalue(ecInstancePtr, 'dewpoint_airtemperature_cloudiness_solarradiation', tim)

       else if (itempforcingtyp == 5) then

           success = success .or. ec_gettimespacevalue(ecInstancePtr, item_humidity, irefdate, tzone, tunit, tim) ! hk: En bedankt voor de rename he lekker dan
           success = success .or. ec_gettimespacevalue(ecInstancePtr, item_airtemperature, irefdate, tzone, tunit, tim)
           success = success .or. ec_gettimespacevalue(ecInstancePtr, item_solarradiation, irefdate, tzone, tunit, tim)

       else
            call mess(LEVEL_WARN,'No humidity, airtemperature and  cloudiness forcing found, setting temperature model [physics:Temperature] = 1 (Only transport)')
            jatem = 1
            success = .true.
       endif
   endif


!   !$OMP SECTION

   ! Get wave parameters within this parallel section:
   call ecTime%set(tim)
   if (jawave == 3) then
      !
      ! This part must be skipped during initialization
      if (.not.l_initPhase) then
         ! Finally the delayed external forcings can be initialized
         success = flow_initwaveforcings_runtime()
         if (allocated (hwavcom) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !hwav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_hrms, ecTime)
         endif
         if (allocated (twav) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !twav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_tp, ecTime)
         endif
         if (allocated (phiwav) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !phiwav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_dir, ecTime)
         endif
         if (allocated (sxwav) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !sxwav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_fx, ecTime)
         endif
         if (allocated (sywav) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !sywav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_fy, ecTime)
         endif
         if (allocated (sbxwav) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !sxwav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_wsbu, ecTime)
         endif
         if (allocated (sbywav) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !sywav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_wsbv, ecTime)
         endif
         if (allocated (mxwav) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !mxwav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_mx, ecTime)
         endif
         if (allocated (mywav) ) then
            ! Don't make them zero: ecGetValues might do nothing
            !mywav = 0.0
            success = success .and. ecGetValues(ecInstancePtr, item_my, ecTime)
         endif
         if (allocated (dsurf) ) then
            success = success .and. ecGetValues(ecInstancePtr, item_dissurf, ecTime)
         endif
         if (allocated (dwcap) ) then
            success = success .and. ecGetValues(ecInstancePtr, item_diswcap, ecTime)
         endif
         if (allocated (uorbwav) ) then
            success = success .and. ecGetValues(ecInstancePtr, item_ubot, ecTime)
         endif
      endif
      if (.not. success) then
         !
         ! success = .false. : Most commonly, WAVE data has not been written to the com-file yet:
         ! - Print a warning
         ! - Continue with the calculation
         ! - Just try it the next timestep again
         ! - success must be set to .true., otherwise the calculation is aborted
         !
         message = dumpECMessageStack(LEVEL_WARN,callback_msg)
         success=.true.
      end if
      !
      ! SWAN data used via module m_waves
      !    Data from FLOW 2 SWAN: s1 (water level), bl (bottom level), ucx (vel. x), ucy (vel. y), FlowElem_xcc, FlowElem_ycc, wx, wy
      !          NOTE: all variables defined @ cell circumcentre of unstructured grid
      !                different from Delft3D. There all variables are defined on the velocity points.
      !    Data from SWAN 2 FLOW:  wavefx, wavefy, hrms (or 0.5*sqrt(2)*hm0), rtp, tp/tps/rtp, phi (= wavedirmean), Uorb, wlen
      !          NOTE:
      !                not necessary are; tmean (Tm01), urms, wavedirpeak
      !
      !   JRE: moved this part to step_reduce, update needed at compu dt
      !
      !if( kmx == 0 ) then
      !   call wave_comp_stokes_velocities()
      !   call wave_uorbrlabda()                       ! hwav gets depth-limited here
      !   call tauwave()
      !   if ( jaGUI.eq.1 ) then                                          ! this part is for online visualisation
      !      if (ntek > 0) then
      !         if (mod(int(dnt_user),ntek) .eq. 0) then
      !            call wave_makeplotvars()
      !         end if
      !      endif
      !   endif
      !   ! wavfu: wave force at links, to be used in the advection equation
      !   call setwavfu()
      !   call setwavmubnd()
      !end if
   endif

!   !$OMP SECTION

!   !$OMP SECTION

   ! Retrieve rainfall for ext-file quantity 'rainfall'.
   if (jarain > 0) then
      if (item_rainfall /= ec_undef_int) then
         success = success .and. ec_gettimespacevalue(ecInstancePtr, 'rainfall', tim)
      endif
      if (item_rainfall_rate /= ec_undef_int) then
         success = success .and. ec_gettimespacevalue(ecInstancePtr, 'rainfall_rate', tim)
      endif
   endif

!   !$OMP SECTION

   if (ncdamsg > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_damlevel, irefdate, tzone, tunit, tim, zcdam)
   endif

!   !$OMP SECTION

   if (ncgensg > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_generalstructure, irefdate, tzone, tunit, tim, zcgen)
      call update_zcgen_widths_and_heights() ! TODO: replace by Jan's LineStructure from channel_flow
   endif

!   !$OMP SECTION

   if (npumpsg > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_pump, irefdate, tzone, tunit, tim, qpump)
   endif
   if (network%sts%numPumps > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_pump_capacity, irefdate, tzone, tunit, tim)
   endif

!   !$OMP SECTION

   if (network%sts%numWeirs > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_weir_crestLevel, irefdate, tzone, tunit, tim)
   endif

   !   !$OMP SECTION

   if (nvalv > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_valve1D, irefdate, tzone, tunit,tim)
   endif

!   !$OMP SECTION

   if (jatidep > 0 .or. jaselfal > 0) then
      call flow_settidepotential(timmin)
   endif

!   !$OMP SECTION

   if (numlatsg > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_lateraldischarge, irefdate, tzone, tunit, tim) ! 'lateral(_)discharge'
   endif

!   !$OMP END PARALLEL SECTIONS

   !Pump with levels, outside OpenMP region
   if (nPumpsWithLevels > 0) then
      call update_pumps_with_levels()
   endif

   if (numsrc > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_discharge_salinity_temperature_sorsin, irefdate, tzone, tunit, tim)
   endif

   call klok(cpuext(2)) ; cpuext(3) = cpuext(3) + cpuext(2) - cpuext(1)

   if (.not. success) then
      goto 888
   end if

   if (jatem > 1 .and. jaheat_eachstep == 0) then
      call heatu(timmin/60d0)                                  ! from externalforcings
   endif

   if (bfm_included) then
      if (bfmpar%lfbedfrm) then
          call fm_calbf()            ! JRE TODO: see with which timestep we update this?
       end if
   end if

   if (bfmpar%lfbedfrmrou)  then     ! .true. if van rijn 2004 or trachy contains ripple roughness
      call fm_calksc()
   end if

   if ((jacali == 1) .and. l_initphase) then
      ! Make backup of roughness factor after initialisation of frcu
      call calibration_backup_frcu()
   endif

   if (jatrt == 1) then
       ntrtsteps = (time1 - tstart_user)/dt_max/itimtt
       if (abs(ntrtsteps - floor(ntrtsteps)) .lt. 1e-6 ) then
           call flow_trachyupdate()                            ! perform a trachy update step
           l_set_frcu_mor = .true.
       end if
   end if

   if (jacali == 1) then
       ! update calibration definitions and factors on links
       call calibration_update()
       l_set_frcu_mor = .true.
   end if

   if (stm_included) then
       if ((jased>0) .and. l_set_frcu_mor) then
           if (jamd1dfile == 0) then
               call set_frcu_mor(1)     !otherwise frcu_mor is set in getprof_1d()
           endif
           call set_frcu_mor(2)
       endif
   endif

   ! Update nudging temperature (and salinity)
   if (item_nudge_tem /= ec_undef_int .and. janudge > 0 ) then ! .and. .not.l_initphase) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_nudge_tem, irefdate, tzone, tunit, tim)
!      tmpstr = dumpECMessageStack(LEVEL_INFO, callback_msg)
   endif

   iresult = DFM_NOERR
   return ! return with success

   ! Error handling:
888 continue
   iresult = DFM_EXTFORCERROR
   write(tmpstr,'(f22.11)') tim
   call mess(LEVEL_WARN, 'Error while updating meteo/structure forcing at time=' // trim(tmpstr))
   tmpstr = dumpECMessageStack(LEVEL_WARN,callback_msg)
end subroutine flow_setexternalforcings

subroutine update_pumps_with_levels()

   use m_flowgeom
   use m_flow
   use m_missing
   use m_structures
   use unstruc_channel_flow
   use m_pump
   use m_partitioninfo

   integer :: ierr, n, istru

   !Pump with levels, SOBEK style, outside OpenMP region
   ! TODO: merge water level calculations with dambreak
   if (nPumpsWithLevels > 0) then

      ! Initialize
      pumpAveraging        = 0.0d0
      waterLevelsPumpLeft  = 0.0d0
      waterLevelsPumpRight = 0.0d0

      ! Compute sumQuantitiesByWeight and sumWeights for the suction side
      !LC: TODO, do the average only over open links
      ierr = getAverageQuantityFromLinks(L1pumpsg, L2pumpsg, wu, kpump(3,:), s1, kpump(1,:), pumpAveraging, 0)
      if (ierr.ne.0) success=.false.

      do n = 1, npumpsg
         if (pumpAveraging(2,n)>0.0d0) then
            waterLevelsPumpLeft(n)  = pumpAveraging(1,n)/pumpAveraging(2,n)
         endif
      enddo

      ! Compute sumQuantitiesByWeight and sumWeights for the delivery side
      ierr = getAverageQuantityFromLinks(L1pumpsg, L2pumpsg, wu, kpump(3,:), s1, kpump(2,:), pumpAveraging, 0)
      if (ierr.ne.0) success=.false.

      do n = 1, npumpsg
         if (pumpAveraging(2,n)>0.0d0) then
            waterLevelsPumpRight(n)  = pumpAveraging(1,n)/pumpAveraging(2,n)
         endif
      enddo

      !TODO remove this code:
      !Compute pump discharges
      !do n = 1, npumpsg
      !   ! Retrive a valid index in the network%sts%struct
      !   istru = pumpsWithLevels(n)
      !   ! Do not use PrepareComputePump to compute the legacy pumps discharges
      !   if (istru.eq.-1) cycle
      !   if (associated(network%sts%struct(istru)%pump)) then
      !      !call PrepareComputePump(network%sts%struct(istru)%pump, waterLevelsPumpLeft(n), waterLevelsPumpRight(n))
      !      !qpump(n) = network%sts%struct(istru)%pump%discharge
      !   endif
      !enddo
   end if

end subroutine update_pumps_with_levels

subroutine update_dambreak_breach(startTime, deltaTime)

   use m_flowgeom
   use m_flow
   use m_missing
   use m_structures
   use unstruc_channel_flow
   use m_Dambreak
   use m_partitioninfo
   use m_meteo
   use m_flowexternalforcings
   use m_flowtimes

   implicit none

   !in-out
   double precision, intent(in)          :: startTime
   double precision, intent(in)          :: deltaTime

   !locals
   double precision                      :: tempValue, smax, smin, hmx, hmn
   integer                               :: indAverageUpStream(ndambreak)
   integer                               :: indAverageDownStream(ndambreak)
   integer                               :: nAverageUpStream, nAverageDownStream
   integer                               :: n, ierr, istru, indexLevelsAndWidths

   if (ndambreak > 0) then

      !
      ! Initialize
      !
      dambreakAveraging              = 0.0d0
      waterLevelsDambreakUpStream    = 0.0d0
      waterLevelsDambreakDownStream  = 0.0d0
      normalVelocityDambreak         = 0.0d0
      breachWidthDerivativeDambreak  = 0.0d0
      waterLevelJumpDambreak         = 0.0d0

      !
      ! Upstream water level
      !
      if (nDambreakLocationsUpstream > 0) then
         waterLevelsDambreakUpStream(dambreakLocationsUpstreamMapping(1:nDambreakLocationsUpstream)) = s1(dambreakLocationsUpstream(1:nDambreakLocationsUpstream))
      endif

      !call this code only if something has to be averaged
      if (nDambreakAveragingUpstream > 0) then

         ! Compute sumQuantitiesByWeight upstream
         ierr = getAverageQuantityFromLinks(L1dambreaksg(dambreakAverigingUpstreamMapping(1:nDambreakAveragingUpstream)), L2dambreaksg(dambreakAverigingUpstreamMapping(1:nDambreakAveragingUpstream)), wu, kdambreak(3,:), s1, kdambreak(1,:), dambreakAveraging, 0, &
                                            hu, dmiss, activeDambreakLinks, 0)

         if (ierr.ne.0) then
            success=.false.
            return
         endif

         do n = 1, nDambreakAveragingUpstream
            if (dambreakAveraging(2,n)>0.0d0) then
               waterLevelsDambreakUpStream(dambreakAverigingUpstreamMapping(n))  = dambreakAveraging(1,n)/dambreakAveraging(2,n)
            endif
         enddo
      endif

      !
      ! Downstream water level
      !
      if (nDambreakLocationsDownstream > 0) then
         waterLevelsDambreakDownStream(dambreakLocationsDownstreamMapping(1:nDambreakLocationsDownstream)) = s1(dambreakLocationsDownstream(1:nDambreakLocationsDownstream))
      endif


      !call this code only if something has to be averaged downstream
      if (nDambreakAveragingDownstream > 0) then

         ! Compute sumQuantitiesByWeight downstream
         ierr = getAverageQuantityFromLinks(L1dambreaksg(dambreakAverigingDownstreamMapping(1:nDambreakAveragingDownstream)), L2dambreaksg(dambreakAverigingDownstreamMapping(1:nDambreakAveragingDownstream)), wu, kdambreak(3,:), s1, kdambreak(2,:), dambreakAveraging, 0, &
                                            hu, dmiss, activeDambreakLinks, 0)

         if (ierr.ne.0) then
            success=.false.
            return
         endif

         do n = 1, nDambreakAveragingDownstream
            if (dambreakAveraging(2,n)>0.0d0) then
               waterLevelsDambreakDownStream(dambreakAverigingDownstreamMapping(n))  = dambreakAveraging(1,n)/dambreakAveraging(2,n)
            endif
         enddo
      endif

      !
      ! u0 velocity on the flowlinks (averaged by the wetted area). The mask is the water level itself
      !
      ierr = getAverageQuantityFromLinks(L1dambreaksg, L2dambreaksg, au, kdambreak(3,:), u1, kdambreak(3,:), dambreakAveraging, 1, &
                                        hu, dmiss, activeDambreakLinks, 0)
      if (ierr.ne.0) success=.false.

      do n = 1, ndambreaksg
         if (dambreakAveraging(2,n)>0.0d0) then
            normalVelocityDambreak(n)  = dambreakAveraging(1,n)/dambreakAveraging(2,n)
         endif
      enddo

      !Compute dambreak widths
      do n = 1, ndambreaksg
         istru = dambreaks(n)
         if (istru.ne.0) then
            if(network%sts%struct(istru)%dambreak%algorithm == 1 .or. network%sts%struct(istru)%dambreak%algorithm == 2) then
               ! Compute the breach width
               call prepareComputeDambreak(network%sts%struct(istru)%dambreak, waterLevelsDambreakUpStream(n), waterLevelsDambreakDownStream(n), normalVelocityDambreak(n), startTime, deltaTime, maximumDambreakWidths(n))
            endif
            if(network%sts%struct(istru)%dambreak%algorithm == 3 .and. startTime > network%sts%struct(istru)%dambreak%t0) then
               !Time in the tim file is relative to the start time
               success = ec_gettimespacevalue_by_itemID(ecInstancePtr, item_dambreakLevelsAndWidthsFromTable, irefdate, tzone, tunit, startTime-network%sts%struct(istru)%dambreak%t0)
               ! NOTE: AvD: the code above works correctly, but is dangerous:
               ! the addtimespace for dambreak has added each dambreak separately with a targetoffset.
               ! The gettimespace above, however, gets the values for *all* dambreaks, but with the relative time
               ! of the *current* dambreak #n.
               ! This means that if t0 values for all dambreaks are different, then the dambreakLevelsAndWidthsFromTable(1:n-1) have become obsolete now.
               ! It works, because in the previous loop iterations the values that were then still correct
               ! have already been set into the %crl and %width values.
               if (success)  then
                  indexLevelsAndWidths = (n - 1) * 2 + 1
                  network%sts%struct(istru)%dambreak%crl   = dambreakLevelsAndWidthsFromTable(indexLevelsAndWidths)
                  network%sts%struct(istru)%dambreak%width = dambreakLevelsAndWidthsFromTable(indexLevelsAndWidths + 1 )
               else
                   return
               endif
            endif
            ! Store breach width derivatives
            tempValue = network%sts%struct(istru)%dambreak%breachWidthDerivative
            if (tempValue>0) then
               breachWidthDerivativeDambreak(n) = tempValue
            else
               breachWidthDerivativeDambreak(n) = &
                  (network%sts%struct(istru)%dambreak%width - breachWidthDambreak(n)) / deltaTime
            endif

            ! Store the current dambreak width
            breachWidthDambreak(n) = network%sts%struct(istru)%dambreak%width
            ! Store the current dambreak crest level
            breachDepthDambreak(n) = network%sts%struct(istru)%dambreak%crl

            ! Store water level jump
            tempValue = network%sts%struct(istru)%dambreak%waterLevelJumpDambreak
            if (tempValue>0) then
               ! Algo 1 or 2: from prepareComputeDambreak
               waterLevelJumpDambreak(n) = tempValue
            else
               ! Algo 3 (timeseries), compute here:
               smax = max(waterLevelsDambreakUpStream(n), waterLevelsDambreakDownStream(n))
               smin = min(waterLevelsDambreakUpStream(n), waterLevelsDambreakDownStream(n))
               hmx  = max(0d0,smax - network%sts%struct(istru)%dambreak%crl)
               hmn  = max(0d0,smin - network%sts%struct(istru)%dambreak%crl)
               waterLevelJumpDambreak(n) = hmx - hmn
            endif

         endif
      enddo
   endif
end subroutine update_dambreak_breach


 !> Calculate the links affected by the dam break and sets bobs accordingly
subroutine adjust_bobs_on_dambreak_breach(width, crl, startingLink, L1, L2, strucid)

   use m_flowgeom
   use m_flowexternalforcings
   use MessageHandling

   implicit none

   !input
   double precision, intent(in) :: width, crl
   integer, intent(in)          :: startingLink, L1, L2
   character(len=*), intent(in) :: strucid
   !local variables
   integer                      :: k, Lf
   double precision             :: leftBreachWidth, rightBreachWidth

   !nothing is open
   if (width<=0) return;

   !something is open
   Lf = iabs(kdambreak(3,startingLink))
   bob(1,Lf) = max(bob0(1, Lf), crl)
   bob(2,Lf) = max(bob0(2, Lf), crl)
   activeDambreakLinks(startingLink) = 1
   if ((width - dambreakLinksEffectiveLength(startingLink))<= 0) then
      wu(Lf) = width
      return
   else
      !left from the breach point: the breach width is larger
      wu(Lf) = dambreakLinksEffectiveLength(startingLink)
      leftBreachWidth = (width - dambreakLinksEffectiveLength(startingLink))/2.0d0
      rightBreachWidth = leftBreachWidth
        do k = startingLink - 1, L1, -1
         Lf = iabs(kdambreak(3,k))
         if (leftBreachWidth>=dambreakLinksEffectiveLength(k)) then
            bob(1,Lf) = max(bob0(1, Lf), crl)
            bob(2,Lf) = max(bob0(2, Lf), crl)
            activeDambreakLinks(k) = 1
            wu(Lf) = dambreakLinksEffectiveLength(k)
            leftBreachWidth = leftBreachWidth - dambreakLinksEffectiveLength(k)
         else
            bob(1,Lf) = max(bob0(1, Lf), crl)
            bob(2,Lf) = max(bob0(2, Lf), crl)
            activeDambreakLinks(k) = 1
            wu(Lf) = leftBreachWidth
            leftBreachWidth = 0d0
            exit
         endif
      enddo
      !right from the breach point
      do k = startingLink + 1, L2
         Lf = iabs(kdambreak(3,k))
         if (rightBreachWidth>=dambreakLinksEffectiveLength(k)) then
            bob(1,Lf) = max(bob0(1, Lf), crl)
            bob(2,Lf) = max(bob0(2, Lf), crl)
            activeDambreakLinks(k) = 1
            wu(Lf) = dambreakLinksEffectiveLength(k)
            rightBreachWidth = rightBreachWidth - dambreakLinksEffectiveLength(k)
         else
            bob(1,Lf) = max(bob0(1, Lf), crl)
            bob(2,Lf) = max(bob0(2, Lf), crl)
            activeDambreakLinks(k) = 1
            wu(Lf) = rightBreachWidth
            rightBreachWidth = 0d0
            exit
         endif
      enddo
      if (leftBreachWidth /= 0d0 .or. rightBreachWidth /= 0d0) then
         write (msgbuf, '(3a)' ) 'The breach width of dam ''', trim(strucid), ''' is wider than the actual dam width.'
         call SetMessage(LEVEL_WARN, msgbuf)
      end if
   endif


end subroutine adjust_bobs_on_dambreak_breach

 subroutine setwindstress()
 use m_flowgeom
 use m_flow
 implicit none
 double precision :: uwi, cdw, tuwi, roro, wxL, wyL, uL, vL, uxL, uyL
 integer          :: L, numwav, k   ! windstuff

 windxav = 0d0
 windyav = 0d0

 if (jawindstressgiven == 1) then
    do L = 1, lnx
       wdsu(L) = ( wx(L)*csu(L) + wy(L)*snu(L) ) / rhomean
    enddo
    if (jamapwindstress > 0) then
       do L = 1, lnx
          wdsu_x(L) = wx(L) / rhomean
          wdsu_y(L) = wy(L) / rhomean
       enddo
    endif
    if (jatem == 5) then
       do L = 1, lnx
          cdwcof(L) = wdsu(L)
       enddo
    endif
 else
    roro = rhoair/rhomean
    wdsu   = 0d0
    numwav = 0
    do L = 1, lnx
       if ( wx(L) /= 0d0 .or. wy(L) /= 0d0 ) then ! only if some wind

          wxL = wx(L)
          wyL = wy(L)
          if (jarelativewind == 1) then
             uL  = U1(Ltop(L))
             vL  =  v(Ltop(L))
             uxL = uL*csu(L) - vL*snu(L)
             uyL = uL*snu(L) + vL*csu(L)
             wxL = wxL - uxL
             wyL = wyL - uyL
          endif
          uwi    = sqrt( wxL*wxL + wyL*wyL )
          if (jaspacevarcharn == 1) then
             cdb(1) = wcharnock(L)
          endif
          call setcdwcoefficient(uwi,cdw,L)
          if (jatem == 5) then
             cdwcof(L) = cdw
          endif
          if (jaroro > 0) then
             k = ln(2,L)
             if (jaroro == 1) then
                roro = rhoair   / rho(ktop(k))
             else
                roro = roair(k) / rho(ktop(k))
             endif
          endif
          tuwi    = roro*cdw*uwi
          if (kmx > 0) then
              ustw(L) = sqrt(roro*cdw)*uwi
          endif
          wdsu(L) = tuwi*( wxL*csu(L) + wyL*snu(L) )
          windxav = windxav + wxL
          windyav = windyav + wyL
          numwav  = numwav  + 1
          if (jamapwindstress > 0) then
             wdsu_x(L) = tuwi*wxL
             wdsu_y(L) = tuwi*wyL
          endif
       endif
    enddo
    if (numwav > 0) then
       windxav = windxav/numwav
       windyav = windyav/numwav
    endif
 endif
 end subroutine setwindstress

!> set boundary conditions
subroutine flow_setexternalforcingsonboundaries(tim, iresult)
   use m_flowtimes
   use m_flowgeom
   use m_flow
   use m_sferic
   use timespace
   use m_ship
   use m_observations
   use m_timer
   use m_partitioninfo
   use m_meteo
   use m_ec_parameters
   use dfm_error
   use m_sobekdfm


   implicit none

   double precision, intent(in)    :: tim ! (s)
   integer,          intent(out)   :: iresult !< Integer error status: DFM_NOERR==0 if succesful.

   integer :: i, n, k, k2, kb, kt, ki, L, itrac, isf
   double precision :: timmin
   character(maxMessageLen) :: message123

   iresult = DFM_EXTFORCERROR
   call klok(cpuextbnd(1))

   call setzminmax()                                   ! our side of preparation for 3D ec module
   call setsigmabnds()                                 ! our side of preparation for 3D ec module

   if (nzbnd > nqhbnd) then
      success = ec_gettimespacevalue(ecInstancePtr, item_waterlevelbnd, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      end if
   end if

   if (nqhbnd > 0) then
      ! loop over nqhbnd (per pli)
      do i = 1, nqhbnd
      !    prepare qtot array
         atqh_all(i) = 0d0
         do n   = L1qhbnd(i), L2qhbnd(i)
            kb  = kbndz(1,n)
            k2  = kbndz(2,n)
            L   = kbndz(3,n)
            if (jampi .eq. 0) then
               atqh_all(i) = atqh_all(i) - q1(L)     ! flow link always directed inwards
            else
               ! exclude ghost cells
               if ( idomain(k2).eq.my_rank ) then
                  atqh_all(i) = atqh_all(i) - q1(L)  ! flow link always directed inwards
               end if
            end if
         end do
      end do

      ! do communication between domains
      if ( jampi.eq.1 ) then
         if ( jatimer.eq.1 ) call starttimer(IMPIREDUCE)
         call reduce_atqh_all()
         if ( jatimer.eq.1 ) call stoptimer(IMPIREDUCE)
      end if

      success = ec_gettimespacevalue(ecInstancePtr, item_qhbnd, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      end if

      ! vind bijbehorende zbndz punten
      do i = 1,nqhbnd
         do n   = L1qhbnd(i), L2qhbnd(i)
            zbndz(n) = qhrelax*qhbndz(i) + (1d0-qhrelax)*max(s1( kbndz(1,n) ), bl( kbndz(1,n) ))
         end do
      end do
   endif

   if (nbndu > 0 ) then
       success = ec_gettimespacevalue(ecInstancePtr, item_velocitybnd, irefdate, tzone, tunit, tim)
       if (.not. success) then
          goto 888
       end if
   end if

   if (nbnds > 0) then
      success = ec_gettimespacevalue(ecInstancePtr, item_salinitybnd, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      endif
   endif

   if (nbndTM > 0) then
      success = ec_gettimespacevalue(ecInstancePtr, item_temperaturebnd, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      endif
   endif

   if (nbndsd > 0) then
       success = ec_gettimespacevalue(ecInstancePtr, item_sedimentbnd, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      end if
   end if

   do itrac=1,numtracers
      if (nbndtr(itrac) > 0) then
         success = ec_gettimespacevalue(ecInstancePtr, item_tracerbnd(itrac), irefdate, tzone, tunit, tim)
         if (.not. success) then
            goto 888
         end if
      end if
   end do

   if (stm_included) then
      do isf=1,numfracs          ! numfracs okay, is number of fractions with bc
         if (nbndsf(isf) > 0) then
            success = ec_gettimespacevalue(ecInstancePtr, item_sedfracbnd(isf), irefdate, tzone, tunit, tim)
            if (.not. success) then
               goto 888
            end if
         end if
      end do
   end if

   if (nbndt > 0) then
      success = ec_gettimespacevalue(ecInstancePtr, item_tangentialvelocitybnd, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      end if
   end if

   if (nbnduxy > 0) then
      success = ec_gettimespacevalue(ecInstancePtr, item_uxuyadvectionvelocitybnd, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      end if
   end if

   if (nbndn > 0) then
      success = ec_gettimespacevalue(ecInstancePtr, item_normalvelocitybnd, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      end if
   end if

   if (nbnd1d2d > 0 ) then
       ! NOTE: no gettimespacevalue is needed here: zbnd1d2d should be filled via BMI (forcing is REALTIME by coupler program)
   end if

   if (nshiptxy > 0) then
      success = ec_gettimespacevalue(ecInstancePtr, item_shiptxy, irefdate, tzone, tunit, tim)
      if (.not. success) then
         goto 888
      endif
   endif

   if (nummovobs > 0) then
      success = ec_gettimespacevalue(ecInstancePtr, item_movingstationtxy, irefdate, tzone, tunit, tim)
      if (success) then
          do i=1,nummovobs
              call updateObservationXY(numobs+i, xyobs(2*(i-1)+1), xyobs(2*(i-1)+2))
          end do
          call obs_on_flowgeom(1)
      else
         goto 888
      end if
   endif

   if(jatransportmodule>0 .and. allocated(threttim)) then
      call fm_thahbc()
   endif

   if (ngatesg > 0) then
      success = success .and. ec_gettimespacevalue(ecInstancePtr, item_gateloweredgelevel, irefdate, tzone, tunit, tim, zgate)
   endif

   !dambreak
   if (ndambreak > 0) then
      call update_dambreak_breach(tim, dts)
   endif

   call klok(cpuextbnd(2)) ; cpuextbnd(3) = cpuextbnd(3) + cpuextbnd(2) - cpuextbnd(1)

   iresult = DFM_NOERR

   return ! Return with success

   ! Error handling:
888 continue
   msgbuf = dumpECMessageStack(LEVEL_WARN, callback_msg)
   iresult = DFM_EXTFORCERROR
   write(msgbuf,'(a,f13.3)')  'Error while updating boundary forcing at time=', tim
   call mess(LEVEL_WARN, trim(msgbuf))

 end subroutine flow_setexternalforcingsonboundaries


 subroutine flow_settidepotential(timmin)
 use m_flow
 use m_flowgeom
 use m_flowtimes
 use timespace_data
 use m_sferic
 use unstruc_model
 use m_equatorial

 implicit none

 double precision :: timmin

 integer, save    :: ini = 0
 integer          :: ierr, kk

 double precision :: Omeg, tt

 call meteo_tidepotential( julrefdat, TIMmin , xz , yz , size(tidep,1), tidep, ndx, doodsonstart, doodsonstop , doodsoneps)

 if (md_ident == 'equator1d' ) then
    tt   = 60d0*(timmin-tstart_user)
    do kk = 1,ndx
       tidep(1,kk) = ZP*sin(om*tt - nmode*dg2rd*xz(kk) )
    enddo
 endif

 end subroutine flow_settidepotential

 subroutine setcdwcoefficient(uwi, cd10, L)
 use m_wind
 use m_flow     , only : ag, hs, jaCdwusp, Cdwusp
 use m_flowgeom , only : ln
 use m_sferic   , only: pi, twopi
 use m_waves    , only: twav
 use m_physcoef
 use m_missing

 implicit none
 integer, intent (in) :: L
 integer              :: k1, maxnit = 100, nit, jalightwind = 0
 double precision     :: uwi, cd10, rk, hsurf = 10d0
 double precision     :: omw, cdL2, dkpz0, s, sold, eps = 1d-4, awin
 double precision     :: p = -12d0, pinv = -0.083333d0, A, A10log, bvis, bfit, balf, r

 if (icdtyp == 1) then                       ! Constant

    cd10 = cdb(1)

    if (jaCdwusp == 1) then
       if  (Cdwusp(L) .ne. dmiss) then
          cd10 = Cdwusp(L)
       endif
    endif

 else if (icdtyp == 2 ) then                 ! Smith and Banks 2 breakpoints

    if      (uwi <= wdb(1) ) then
       cd10 = cdb(1)
    else if (uwi <= wdb(2) ) then
       cd10 = cdb(1) + (uwi - wdb(1)) * (cdb(2) - cdb(1) ) / (wdb(2) - wdb(1) )
    else
       cd10 = cdb(2)
    endif


 else if (icdtyp == 3 ) then                 ! Smith and Banks like 3 breakpoints

    if      (uwi <= wdb(1) ) then
       cd10 = cdb(1)
    else if (uwi <= wdb(2) ) then
       cd10 = cdb(1) + (uwi - wdb(1)) * (cdb(2) - cdb(1) ) / (wdb(2) - wdb(1) )
    else if (uwi <= wdb(3) ) then
       cd10 = cdb(2) + (uwi - wdb(2)) * (cdb(3) - cdb(2) ) / (wdb(3) - wdb(2))
    else
       cd10 = cdb(3)
    endif

 else if (icdtyp == 4) then                  ! Charnock 1955

  ! Charnock drag coefficient formulation, logarithmic wind velocity profile in the turbulent layer
  ! above the free surface:

  ! uwi      1        z            z=10 m, for U10
  ! ---- = ----- ln (---)
  ! u*      kappa    z0

  ! where u* is the friction velocity, kappa is the Von Karman constant
  ! z is the vertical height above the free surface and z0 is the roughness height:

  ! z0 = b * u*^2/g

  ! with b the dimensionless Charnock coefficient and g the gravity acceleration.
  ! Cd = u*^2/uwi^2, so we have an implicit relation between drag coefficient Cd and wind speed Ws.
  ! Newton-Raphson :

    nit  = 0
    s    = 19.6d0
    sold = 0d0

    do while ( abs(sold-s).gt.(eps*s) )

         nit  = nit + 1
         sold = s
         s    = sold*(log(hsurf*ag*sold*sold / (max(0.001,cdb(1)*uwi*uwi)))-2d0)/(vonkarw*sold-2d0)

         if ( nit.ge.maxnit ) then
            cd10 = 1d-3
            exit
         endif

    enddo

    if (s > 0d0) then
       cd10 = 1d0/(s*s)
    endif

 else if (icdtyp == 5) then                     ! Hwang 2005, wave frequency dependent

    ! (A.)=http://onlinelibrary.wiley.com/doi/10.1029/2005JC002912/full

    k1    = ln(1,L)
    if (uwi < 4d0) then
       awin  = max(0.1d0,uwi)
       cd10  = 0.0044d0 / awin**1.15d0
    else if (twav(k1) < 0.1d0) then
       cd10 = 0.00063d0 + 0.000066d0*uwi
    else
       omw   = twopi/max(0.1d0, twav(k1) )       ! wave frequency
       cdL2  = 0.001289d0*(omw*uwi/ag)**0.815d0 ! Cd at half wavelength above surface(11a)    (A7)

       dkpz0 = pi*exp(-vonkarw/sqrt(CdL2))      ! (5)                                         (A2)
       call getwavenr(hs(k1),twav(k1),rk)
       cd10  = (vonkarw / log(10d0*rk/dkpz0) )**2                                           ! (A4b)
     endif

 else if (icdtyp == 6) then                     ! Wuest 2003 & Smith en Banke, uit Rob's DPM

    if (uwi > 4d0) then
        cd10 = 0.00063d0 + 0.000066d0*uwi
    else
        awin = max(0.1d0,uwi)
        cd10 = 0.0044d0 / awin**1.15d0
    endif

 else if (icdtyp == 7) then                     ! Hans Hersbach, July 2010, ECMWF fit (CHarnock plus viscous term)
                                                ! https://journals.ametsoc.org/doi/full/10.1175/2010JPO4567.1
    A      = ( cdb(1)*(vonkarw*uwi)**2 ) / (ag*hsurf)
    A10log = log(A)                             ! (2) shows that log actually means: ln
    balf   = 2.65d0 - 1.44d0*A10log - 0.015d0*A10log*A10log
    R      = (hsurf*vonkarw*uwi)/(cdb(2)*viskinair)
    bvis   = -1.47d0 + 0.93d0*log(R)
    bfit   = (bvis**p + balf**p)**pinv
    cd10   = (vonkarw/bfit)**2

 endif

 if (jalightwind == 1 .and. icdtyp .ne. 7 .and. icdtyp .ne. 5) then
    if (uwi < 4d0) then     ! for wind < 4 m/s use wuest anyway
        awin = max(0.1d0,uwi)
        cd10 = max(cd10, 0.0044d0 / awin**1.15d0)
    endif
 endif
 end subroutine setcdwcoefficient

 subroutine writeCdcoeffs()
 use unstruc_model
 use m_wind
 use m_waves
 use m_flow,     only : jawave
 use m_flowgeom, only : ndx
 implicit none

 integer          :: msgbu, k
 double precision :: uwi, Cd10, fetchL, fetchD, hsig, tsig
 double precision, allocatable :: hwavsav(:), twavsav(:)

 call newfil(msgbu, trim(getoutputdir())//trim(md_ident)//'_Cdwcoeff.tek')

 write (msgbu, '(a)')    '* Wind Cdcoefficient relation : '
 if (icdtyp == 1) then
    write (msgbu, '(a)') '* Constant'
 else if (icdtyp == 2 ) then
    write (msgbu, '(a)') '* Smith and Banks 2 breakpoints'
 else if (icdtyp == 3 ) then
    write (msgbu, '(a)') '* Smith and Banks like 3 breakpoints'
 else if (icdtyp == 4) then
    write (msgbu, '(a)') '* Charnock 1955 (1 parameter)'
 else if (icdtyp == 5) then
    write (msgbu, '(a)') '* Hwang 2005, wave frequency dependent (fixed parameters + wave period)'
 else if (icdtyp == 6) then
    write (msgbu, '(a)') '* Wuest 2003 & Smith en Banke (fixed parameters)'
 else if (icdtyp == 7) then
    write (msgbu, '(a)') '* Hans Hersbach, July 2010, ECMWF fit (CHarnock plus viscous term), (e.g. Charnock=0.018 and alfvisc=0.11)'
 endif

 write (msgbu, '(a)')     '* column 1 : Wind speed               (m/s) '
 write (msgbu, '(a)')     '* column 2 : Resulting Cd coefficient (   ) '
 if (jawave > 0) then
    write (msgbu, '(a)')  '* column 3 : Hwav                     (m  ) '
    write (msgbu, '(a)')  '* column 4 : Twav                     (s  ) '
    write (msgbu, '(a)')  '61  4'
 else
    write (msgbu, '(a)')  '61  2'
 endif

 if (jawave > 0) then
    fetchL = 20000d0
    fetchD = 4d0
    allocate ( hwavsav(ndx), twavsav(ndx) )
    hwavsav = hwav ; twavsav = twav
 endif

 uwi = 0.1d0
 if (jawave > 0) then
    call hurdlestive (Uwi, fetchL, fetchD, Hsig, Tsig)
    hwav = hsig ; twav = tsig
 endif
 call setcdwcoefficient(uwi, Cd10, 1)
 if (jawave > 0) then
    write(msgbu, '(4F14.6)') uwi, Cd10, hsig, tsig
 else
    write(msgbu, '(2F14.6)') uwi, Cd10
 endif

 uwi = 0.2d0
 if (jawave > 0) then
    call hurdlestive (Uwi, fetchL, fetchD, Hsig, Tsig)
    hwav = hsig ; twav = tsig
 endif
 call setcdwcoefficient(uwi, Cd10, 1)
 if (jawave > 0) then
    write(msgbu, '(4F14.6)') uwi, Cd10, hsig, tsig
 else
    write(msgbu, '(2F14.6)') uwi, Cd10
 endif

 do k = 1, 28
    uwi = uwi + 0.2d0
    if (jawave > 0) then
       call hurdlestive (Uwi, fetchL, fetchD, Hsig, Tsig)
       hwav = hsig ; twav = tsig
    endif
    call setcdwcoefficient(uwi, Cd10, 1)
    if (jawave > 0) then
       write(msgbu, '(4F14.6)') uwi, Cd10, hsig, tsig
    else
       write(msgbu, '(2F14.6)') uwi, Cd10
    endif
 enddo

 do k = 1, 24
    uwi = uwi + 1.0d0
    if (jawave > 0) then
       call hurdlestive (Uwi, fetchL, fetchD, Hsig, Tsig)
       hwav = hsig ; twav = tsig
    endif
    call setcdwcoefficient(uwi, Cd10, 1)
    if (jawave > 0) then
       write(msgbu, '(4F14.6)') uwi, Cd10, hsig, tsig
    else
       write(msgbu, '(2F14.6)') uwi, Cd10
    endif
 enddo

 do k = 1, 7
    uwi = uwi + 10d0
    if (jawave > 0) then
       call hurdlestive (Uwi, fetchL, fetchD, Hsig, Tsig)
       hwav = hsig ; twav = tsig
    endif
    call setcdwcoefficient(uwi, Cd10, 1)
    if (jawave > 0) then
       write(msgbu, '(4F14.6)') uwi, Cd10, hsig, tsig
    else
       write(msgbu, '(2F14.6)') uwi, Cd10
    endif
 enddo

 call doclose(msgbu)

 if (jawave > 0) then
    hwav = hwavsav ; twav = twavsav
    deallocate (hwavsav, twavsav)
 endif

 end subroutine writeCdcoeffs

 subroutine flow_externalinput(tim)                  ! receive signals etc
 use m_flowtimes
 use m_flow
 implicit none

 double precision          :: tim

 end subroutine flow_externalinput

 !> Write solution data to output files (map/his/restart/waq).
 !! Each output type has its own interval (see m_flowtimes),
 !! and output is only written if the current time tim exceeds the last
 !! written interval.
 subroutine flow_externaloutput(tim)                 ! give signals etc, write map, his etc
 use m_flowtimes
 use m_flow
 use unstruc_model
 use unstruc_netcdf
 use unstruc_netcdf_map_class
 use m_xbeach_netcdf
 use waq
 use m_timer
 use m_reduce,        only : nocgiter
 use m_partitioninfo, only : ndomains, jampi, my_rank
 use m_flowparameters, only: jashp_crs, jashp_obs, jashp_weir, jashp_thd, jashp_gate, jashp_emb, jashp_fxw, jashp_src
 use m_flowgeom, only: ndx2d, ndxi, lnx1d
 use unstruc_channel_flow, only : network
 use m_oned_functions, only: updateFreeboard, updateDepthOnGround, updateVolOnGround, updateTotalInflow1d2d, updateTotalInflowLat, updateS1Gradient
 use m_structures, only: structure_parameters_rst
#ifdef _OPENMP
 use omp_lib
#endif
 implicit none

 double precision, intent(in) :: tim !< Current time, should in fact be time1, since all writers use s1, q1, etc.
 double precision             :: time_map_int, time_map_mpt
 double precision             :: runtime
 integer                      :: mpt_minval
 character(len=16)            :: filepostfix
 integer                      :: numomp
 double precision             :: tem_dif


   call inctime_split(tim)

   if (ti_his > 0) then
      if (comparereal(tim, time_his, eps10)>= 0) then
         if ( jampi.eq.0 .or. ( jampi.eq.1 .and. my_rank.eq.0 ) ) then
            call unc_write_his(tim)   ! wrihis
         endif
         if (comparereal(time_his, ti_hise, eps10) == 0) then
            time_his = tstop_user + 1
         else
            tem_dif  = (tim - ti_hiss)/ti_his
            time_his = max(ti_hiss + (floor(tem_dif + 0.001d0)+1)*ti_his,ti_hiss)
            if (comparereal(time_his, ti_hise, eps10) == 1) then
               ! next time_his would be beyond end of his-window, write one last his exactly at that end.
               time_his = ti_hise
            endif
         endif
      endif
   endif

   if (.not. allocated(ti_mpt) ) then
      allocate ( ti_mpt(1), ti_mpt_rel(1) ) ; ti_mpt(1) = 0 ; ti_mpt_rel(1) = 0
   endif

   if (ti_map > 0 .or. ti_mpt(1) > 0) then
     if (comparereal(tim, time_map, eps10) >= 0) then
        ! update for output, only for 1D
        if (network%loaded) then
           if (ndxi-ndx2d > 0) then
              if (jamapFreeboard > 0) then
                 call updateFreeboard(network)
              end if
              if (jamapDepthOnGround > 0) then
                 call updateDepthOnGround(network)
              end if
              if (jamapVolOnGround > 0) then
                 call updateVolOnGround(network)
              end if
              ! NOTE: updateTotalInflow1d2d, updateTotalInflowLat done in flow_finalizesingletimestep().
           end if
        end if
        if (lnx1d > 0) then
           if (jamapS1Gradient > 0) then
              call updateS1Gradient()
           end if
        end if

        call wrimap(tim)
!         if ( jatidep > 0 ) then
!            call writidep(tim)
!         end if
         if (comparereal(time_map, ti_mape, eps10) == 0) then
            time_map = tstop_user + 1
         else
            tem_dif = (tim - ti_maps)/ti_map
            time_map = max(ti_maps + (floor(tem_dif + 0.001d0) +1)*ti_map,ti_maps)
            ti_mpt_rel   = ti_mpt - tim
            time_map_mpt = tim + minval(ti_mpt_rel, mask=ti_mpt_rel.gt.0)
            if (comparereal (time_map, time_map_mpt, eps10) == 1 .and. comparereal(tim, time_map_mpt, eps10) == -1) then
               time_map = time_map_mpt
            endif

            if (comparereal(time_map, ti_mape, eps10) == 1) then
            ! next time_map would be beyond end of map-window, write one last map exactly at that end.
                time_map = ti_mape
            endif
         endif
     endif
   endif

    if (ti_classmap > 0) then
       if (comparereal(tim, time_classmap, eps10) >= 0) then
         call write_map_classes_ugrid(m_incids, tim)
         if (comparereal(time_classmap, ti_classmape, eps10) == 0) then
            time_classmap = tstop_user + 1
         else
            tem_dif = (tim - ti_classmaps)/ti_classmap
            time_classmap = max(ti_classmaps + (floor(tem_dif + 0.001d0) +1)*ti_classmap,ti_classmaps)

            if (comparereal(time_classmap, ti_classmape, eps10) == 1) then
            ! next time_classmap would be beyond end of incr-window, write one last incr exactly at that end.
                time_classmap = ti_classmape
            endif
         endif
       endif
    endif

   ! FM does not know whether the com-file for this time step will be used
   ! To be safe: always write the com-file at each user_timestep
   if (jawave==3 .and. (tim==tstart_user .or. tim>=time_user)) then
      call wricom(tim) ! TODO: AvD: disable during FM-MOR-WAVE-par testing
   endif

   if (ti_xls > 0) then
      if (tim >= time_xls) then
          call wrihistek(tim)           ! wrihis xls
          call wribal(tim)
          time_xls = tim + ti_xls
      endif
   endif

   if (ti_rst > 0) then
      if (comparereal(tim, time_rst, eps10) == 0) then
         ! Update structure parameters
         call structure_parameters_rst()
         call wrirst(tim)
         if (comparereal(time_rst, ti_rste, eps10) == 0) then
            time_rst = tstop_user + 1
         else
            tem_dif = (tim - ti_rsts)/ti_rst
            time_rst = max(ti_rsts + (floor(tem_dif + 0.001d0) +1)*ti_rst,ti_rsts)
            if (comparereal(time_rst, ti_rste, eps10) == 1) then
               ! We've come beyond the end time of restart window.
               ! Write just a last one exactly on that end time (i.e. not at tstop_user).
               time_rst = ti_rste
            endif
         endif
      endif
   endif

  if (ti_waq > 0) then
      if (comparereal(tim, time_waq, eps10) == 0) then

         if (comparereal(time_waq, ti_waqs, eps10) == 0) then
            call waq_wri_model_files()
            wrwaqon = .true.
         endif

         call waq_wri_couple_files(tim)
         if (comparereal(time_waq, ti_waqe, eps10) == 0) then
            time_waq = tstop_user + 1
         else
            tem_dif = (tim - ti_waqs)/ti_waq
            time_waq = max(ti_waqs + (floor(tem_dif + 0.001d0)+1)*ti_waq,ti_waqs)
         ! this is taken care of ! call volsur() ! TODO: move volsur in flow_initimestep to end of flow_singletimestep (is duplicate now)
            if (comparereal(time_waq, ti_waqe, eps10) == 1) then
               time_waq = ti_waqe
            endif
         endif
      endif
   endif


   if (ti_stat > 0) then
      if (tim >= time_stat) then
         call step_to_screen()     ; time_stat = tim + ti_stat
      endif
   else if ( ti_stat.lt.0d0 ) then
!     base statistics output on wallclock time, if available
      if (jatimer.gt.0 ) then
         runtime = gettimer(1,ITOTAL)
         if ( runtime.gt.time_stat ) then
            call step_to_screen
            time_stat = runtime + abs(ti_stat)
         end if
      end if
   endif

   !! Write shape files at the initialization
   if (abs(tim - tstart_user ) < 1d-10) then
#ifdef HAVE_SHAPELIB
      call unc_write_shp()
#else
      if (jashp_crs > 0 .or. jashp_obs > 0 .or. jashp_weir > 0 .or. jashp_thd > 0 .or. jashp_gate > 0 &
       .or. jashp_emb > 0 .or. jashp_fxw > 0 .or. jashp_src > 0) then
      call mess(LEVEL_WARN, 'Shapefile export is not supported yet on the current platform.')
      end if
#endif
   endif

   if ( (jatimer.eq.1) .and. (ti_timings.gt.0) ) then
      if ( tim.ge.time_timings ) then
!        output timings
         call makedir( trim(getoutputdir()) )  ! safety, no problem if it exists already.
         call print_timings(trim(getoutputdir())//trim(md_ident)//'_timings.txt', time1)


! the following code changes timings filename, which is unfortunate for post-processing
!         if (len_trim(md_timingsfile) == 0) then
!            filepostfix = ' '
!            if (jampi == 1) then
!               write(filepostfix, '(a,i0)') '_MPI', ndomains
!            end if
!#ifdef _OPENMP
!            numomp = omp_get_max_threads()
!            write(filepostfix, '(a,i0)') '_OMP', numomp
!#endif
!            md_timingsfile = trim(getoutputdir()) // trim(md_ident) // trim(filepostfix) // '_timings.txt'
!         end if
!         call print_timings(md_timingsfile, time1)


         time_timings = tim + ti_timings
!         call initimer()   ! reset timers
      end if
   end if

end subroutine flow_externaloutput


!> Writes current state immediately to files, typically used in
!! case of 'emergencies', without checking output intervals.
!!
!! Writes his/map/rst data to the (existing) files.
!! Note: no timings/waq output.
subroutine flow_externaloutput_direct()
   use m_flowtimes
   use unstruc_messages
   use time_module
   implicit none
   integer :: iyear, imonth, iday, ihour, imin, isec

   call mess(LEVEL_INFO, 'Performing direct write of solution state...')

   ! Compute current absolute date time, based on time1 since refdat
   call datetime_from_refdat(time1, iyear, imonth, iday, ihour, imin, isec)
   write (msgbuf, '(a,i0,a,f12.2,a,a,a,a)') 'Simulation current time: nt = ', int(dnt, 8), ', time1 = ', time1, 's ', &
                             '(', trim(datetime_to_string(iyear, imonth, iday, ihour, imin, isec)), ').'
   call msg_flush()

   call wrimap(time1)

   call unc_write_his(time1)

   call wrirst(time1)

   call mess(LEVEL_INFO, 'Done writing solution state.')

end subroutine flow_externaloutput_direct


!> Increment the time-splitting upcoming time, if input time argument lies on or beyond that time.
!! Each output file with name base_timesplit0_.. will contain output for time_split0 < time1 <= time_split.
!! (Only for time1=tstart_user, time_split0 <= time1, i.e. first map file in sequence will have one more snapshot.)
subroutine inctime_split(tim)
use m_flowtimes
use unstruc_messages
implicit none
double precision, intent(in) :: tim !< Current time, used to checked whether an increment is necessary at all.

integer :: iyear, imonth, iday, ihour, imin, isec, add_seconds

    ! Do nothing if time splitting is switched off
    if (ti_split <= 0d0) then
        return
    end if

    ! Do nothing if time is still before upcoming time_split.
    if (tim <= time_split) then
        return
    end if

    time_split0 = time_split

    do ! increment time_split until tim <= time_split
       ! First, get y/M/d/h/m/s values for current time_split since refdat:
       call datetime_from_refdat(time_split, iyear, imonth, iday, ihour, imin, isec)

       ! Second, add the ti_split increment to them, based on ti_split_unit
       add_seconds = 0
       select case (ti_split_unit)
       case ('Y')
           iyear = iyear + ti_split
       case ('M')
           imonth = imonth + ti_split
           if (imonth > 12) then
               iyear = iyear + floor(real(imonth)/12.0)
               imonth = mod(imonth, 12)
           end if
       case ('D')
           add_seconds = ti_split*24*3600
       case ('h')
           add_seconds = ti_split*3600
       case('m')
           add_seconds = ti_split*60
       case ('s')
           add_seconds = ti_split
       case default
           call mess(LEVEL_WARN, 'Invalid time partitioning unit: '//ti_split_unit) ! should not be possible, handled by readMDU
           return
       end select

       ! Finally convert the new absolute date time values to a time in seconds since refdat.
       call seconds_since_refdat(iyear, imonth, iday, ihour, imin, isec+add_seconds, time_split)

       if (tim <= time_split) then
          exit
       end if
    end do ! until tim <= time_split
end subroutine inctime_split


!> Write history data in NetCDF format.
subroutine unc_write_his(tim)            ! wrihis
    use m_flowtimes
    use m_flow
    use m_flowgeom
    use network_data, only: xk, yk
    use m_observations
    use m_monitoring_crosssections
    use m_missing
    use netcdf
    use unstruc_files, only: defaultFilename
    use unstruc_netcdf, only: unc_create, unc_close, unc_addcoordatts, unc_def_var_nonspatial, unc_write_flowgeom_filepointer
    use unstruc_messages
    use m_sferic, only: jsferic
    use m_partitioninfo
    use m_timer
    use unstruc_model, only: md_ident, getoutputdir
    use m_sediment
    use m_flowexternalforcings, only: numtracers, trnames
    use m_transport, only: NUMCONST_MDU, ITRA1, ITRAN, ISED1, ISEDN, const_names, const_units, NUMCONST, itemp, isalt
    use m_structures
    use m_particles, only: japart
    use m_fm_wq_processes
    use string_module
    use m_dad
    use m_filter, only: checkmonitor
    use m_alloc
    use unstruc_channel_flow, only: network

    implicit none

    double precision, intent(in) :: tim !< Current time, should in fact be time1, since the data written is always s1, ucx, etc.

    ! locals
    integer, save :: ihisfile = 0, id_laydim , id_laydimw, &
                     id_statdim, id_mstatdim, id_strlendim, id_crsdim, id_crslendim, id_crsptsdim, id_timedim, &
                     id_statx, id_staty, id_statid, id_statname, id_time, id_timestep, &
                     id_mstatx, id_mstaty, id_mstatname, &
                     id_crsx, id_crsy, id_crsname, &
                     id_vars, id_varucx, id_varucy, id_varucz, id_varsal, id_vartem, id_varsed, id_varrho, &
                     id_varQ, id_varQint, id_varb, & ! id_varQavg,
                     id_varAu,  & ! id_varAuavg,
                     id_varu,  id_varwx, id_varwy, id_varrain, id_varpatm, &!id_varuavg,
                     id_qsun, id_qeva, id_qcon, id_qlong, id_qfreva, id_qfrcon, id_qtot, &
                     id_turkin, id_tureps , id_vicwwu, id_rich, id_zcs, id_zws, &
                     id_wind, id_patm, id_tair, id_rhum, id_clou, &
                     id_R, id_WH, id_WD, id_WL, id_WT, id_WU, id_WTAU, id_hs, &
                     id_pumpdim,    id_pump_id,     id_pump_dis,     id_pump_cap,      id_pump_s1up,      id_pump_s1dn,     id_pump_head,      &
                     id_pump_xmid,  id_pump_ymid,   id_pump_struhead,id_pump_stage,    id_pump_redufact,  id_pump_s1del,    id_pump_s1suc,     id_pump_disdir, &
                     id_gatedim,    id_gatename,    id_gate_dis,    id_gate_edgel,     id_gate_s1up,      id_gate_s1dn,    &                              ! id_gate_head,
                     id_cdamdim,    id_cdamname,    id_cdam_dis,    id_cdam_crestl,    id_cdam_s1up,      id_cdam_s1dn,    &                              ! id_cdam_head,
                     id_weirgendim, id_weirgen_id, id_weirgen_dis, id_weirgen_crestl, id_weirgen_crestw, id_weirgen_s1up,  id_weirgen_s1dn,  &        ! id_weirgen_head,
                     id_weir_stat,  id_weirgen_vel, id_weirgen_au,  id_weirgen_head,   id_weirgen_forcedif, id_weirgen_s1crest,               &
                     id_gategendim, id_gategenname, id_gategen_dis, id_gategen_sillh,  id_gategen_sillw,  id_gategen_edgel, id_gategen_openw, &           ! id_gategen_head,
                     id_gategen_flowh, id_gategen_s1up, id_gategen_s1dn,                                                                      &
                     id_genstrudim, id_genstru_id, id_genstru_dis, id_genstru_crestl, id_genstru_crestw, id_genstru_edgel, id_genstru_openw, &           ! id_genstru_head,
                     id_genstru_s1up, id_genstru_s1dn, id_genstru_dis_gate_open, id_genstru_dis_gate_over, id_genstru_dis_gate_under, id_genstru_openh, id_genstru_uppl,  &
                     id_genstru_vel, id_genstru_au, id_genstru_au_open, id_genstru_au_over, id_genstru_au_under, id_genstru_stat, id_genstru_head,  id_genstru_velgateopen, &
                     id_genstru_velgateover, id_genstru_velgateunder, id_genstru_s1crest, id_genstru_forcedif, &
                     id_orifgendim, id_orifgen_id, id_orifgen_dis, id_orifgen_crestl, id_orifgen_crestw, id_orifgen_edgel, id_orifgen_stat,  &
                     id_orifgen_s1dn, id_orifgen_openh, id_orifgen_vel, id_orifgen_au, id_orifgen_s1up, id_orifgen_head, id_orifgen_s1crest, id_orifgen_forcedif,&
                     id_bridgedim, id_bridge_id, id_bridge_dis, id_bridge_s1up,  id_bridge_s1dn, id_bridge_vel, id_bridge_au,  id_bridge_head, &
                     id_bridge_blup, id_bridge_bldn, id_bridge_bl_act, &
                     id_culvertdim, id_culvert_id, id_culvert_dis, id_culvert_s1up,  id_culvert_s1dn, id_culvert_crestl, id_culvert_openh, &
                     id_culvert_edgel, id_culvert_vel, id_culvert_stat, id_culvert_au,  id_culvert_head, &
                     id_sedbtrans, id_sedstrans,&
                     id_srcdim, id_srclendim, id_srcname, id_qsrccur, id_vsrccum, id_qsrcavg, id_pred, id_presa, id_pretm, id_srcx, id_srcy, id_srcptsdim, &
                     id_partdim, id_parttime, id_partx, id_party, id_partz, &
                     id_dredlinkdim, id_dreddim, id_dumpdim, id_dredlink_dis, id_dred_dis, id_dump_dis, id_dred_tfrac, id_plough_tfrac, id_sedtotdim, id_dred_name, id_dump_name, id_frac_name, & !id_dump_dis_frac, id_dred_dis_frac, &
                     id_dambreakdim, id_dambreak_id, id_dambreak_s1up, id_dambreak_s1dn, id_dambreak_discharge, id_dambreak_cumulative_discharge, &
                     id_dambreak_au, id_dambreak_head, id_dambreak_cresth, id_dambreak_crestw, &
                     id_uniweirdim, id_uniweir_id, id_uniweir_dis, id_uniweir_s1up,  id_uniweir_s1dn, id_uniweir_crestl, &
                     id_uniweir_vel, id_uniweir_au, id_uniweir_head, &
                     id_dambreak_breach_width_time_derivative, id_dambreak_water_level_jump, id_dambreak_normal_velocity, id_checkmon, id_num_timesteps, id_comp_time, &
                     id_cmpstrudim, id_cmpstru_id, id_cmpstru_dis, id_cmpstru_s1up,  id_cmpstru_s1dn, &
                     id_cmpstru_vel, id_cmpstru_au, id_cmpstru_head, &
                     id_sscx, id_sscy, id_sswx, id_sswy, id_sbcx, id_sbcy, id_sbwx, id_sbwy, &
                     id_varucxq, id_varucyq, id_sf, id_ws, id_seddif, id_sink, id_sour, id_sedsusdim


    integer, allocatable, save :: id_tra(:)
    integer, allocatable, save :: id_hwq(:)
    integer, allocatable, save :: id_hwqb(:)
    integer, allocatable, save :: id_const(:), id_const_cum(:), id_voltot(:)
    double precision, allocatable, save :: valobsT(:,:)

    integer                      :: IP, num, ntmp, n

    double precision, save       :: curtime_split = 0d0 ! Current time-partition that the file writer has open.
    integer                      :: ntot, mobs, k, i, j, jj, i1, ierr, mnp, kk, kb, kt, klay, idims(3), LL,Lb,Lt,L, Lf, k3, k4
    logical                      :: jawel
    double precision             :: xp, yp, qsum, vals, valx, valy, valwx, valwy, valpatm, wind, cof0

    character(len=255)           :: filename
    character(len=25)            :: transpunit
    integer                      :: igen, istru
    integer                      :: ndims
    character(len=255)           :: tmpstr, tmpstr2, tmpstr3, unit1, unit2, unit3
    integer                      :: jawrizc = 0
    integer                      :: jawrizw = 0
    double precision             :: w1, pumplensum, pumplenmid, pumpxmid, pumpymid
    double precision             :: rhol
    double precision, allocatable:: toutputx(:,:), toutputy(:,:)
    double precision, allocatable:: toutput_cum, toutput_cur

    if (jahiszcor > 0) then
       jawrizc = 1
       jawrizw = 1
    endif

    ! Another time-partitioned file needs to start, reset iteration count (and file).
    if (ti_split > 0d0 .and. curtime_split /= time_split0) then
        it_his       = 0
        curtime_split = time_split0
    end if

    ! Close/reset any previous hisfile.
    if (ihisfile > 0 .and. it_his == 0) then
        ierr = unc_close(ihisfile)
        ihisfile = 0
    end if

    ! When no crs/obs present, return immediately.
    if (numobs+nummovobs <= 0 .and. ncrs <= 0 .and. jahisbal <= 0 .and. jahiscgen <= 0) then
        if (ihisfile == 0) then
            call mess(LEVEL_WARN, 'No observations nor cross sections defined. Will not produce a history file.')
        end if
        ihisfile = -1 ! -1 stands for: no file open, no obs/crs defined.
        return
    end if

    if (ihisfile == 0) then

        call realloc(id_tra, ITRAN-ITRA1+1, keepExisting = .false.)
        call realloc(id_const, NUMCONST_MDU, keepExisting = .false.)
        call realloc(id_const_cum, NUMCONST_MDU, keepExisting = .false.)

        call realloc(id_voltot, MAX_IDX, keepExisting = .false.)

        ! Possibly a different model, so make valobs transpose at correct size again.
        call realloc(valobsT, (/ size(valobs, 2), size(valobs, 1) /), keepExisting = .false.)

        if (ti_split > 0d0) then
            filename = defaultFilename('his', timestamp=time_split0)
        else
            filename = defaultFilename('his')
        end if

        ierr = unc_create(filename, 0, ihisfile)
        if (ierr /= nf90_noerr) then
            call mess(LEVEL_WARN, 'Could not create history file.')
        end if

        ierr = nf90_def_dim(ihisfile, 'time', nf90_unlimited, id_timedim)

        ierr = nf90_def_dim(ihisfile, 'name_len', 64, id_strlendim)

        if (kmx > 0) then
           ierr = nf90_def_dim(ihisfile, 'laydim', kmx, id_laydim)
           ierr = nf90_def_dim(ihisfile, 'laydimw', kmx+1, id_laydimw)
        end if

        if (numobs+nummovobs > 0) then
            call unc_write_flowgeom_filepointer(ihisfile, 1)
            ierr = nf90_def_dim(ihisfile, 'stations', numobs+nummovobs, id_statdim)

            if (nummovobs > 0) then
               ierr = nf90_def_var(ihisfile, 'station_x_coordinate', nf90_double, (/ id_statdim, id_timedim /), id_statx) ! TODO: AvD: decide on UNST-1606 (trajectory_id vs. timeseries_id)
               ierr = nf90_def_var(ihisfile, 'station_y_coordinate', nf90_double, (/ id_statdim, id_timedim /), id_staty)
            else
               ierr = nf90_def_var(ihisfile, 'station_x_coordinate', nf90_double, id_statdim, id_statx)
               ierr = nf90_def_var(ihisfile, 'station_y_coordinate', nf90_double, id_statdim, id_staty)
            endif
            ierr = unc_addcoordatts(ihisfile, id_statx, id_staty, jsferic)
            ierr = nf90_put_att(ihisfile, id_statx, 'long_name', 'original x-coordinate of station (non-snapped)')
            ierr = nf90_put_att(ihisfile, id_staty, 'long_name', 'original y-coordinate of station (non-snapped)')

            ierr = nf90_def_var(ihisfile, 'station_id',         nf90_char,   (/ id_strlendim, id_statdim /), id_statid)
            ierr = nf90_put_att(ihisfile, id_statid,  'long_name'    , 'observation station identifier') ! REF

            ierr = nf90_def_var(ihisfile, 'station_name',         nf90_char,   (/ id_strlendim, id_statdim /), id_statname)
            ierr = nf90_put_att(ihisfile, id_statname,  'cf_role', 'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_statname,  'long_name'    , 'observation station name') ! REF

            if ( jahiswatlev > 0 ) then
               ierr = nf90_def_var(ihisfile, 'waterlevel', nf90_double, (/ id_statdim, id_timedim /), id_vars)
               ierr = nf90_put_att(ihisfile, id_vars, 'standard_name', 'sea_surface_height') ! sorry for inland water people
               ierr = nf90_put_att(ihisfile, id_vars, 'long_name', 'water level')
               ierr = nf90_put_att(ihisfile, id_vars, 'units', 'm')
               ierr = nf90_put_att(ihisfile, id_vars, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_vars, '_FillValue', dmiss)
            endif

            if ( jahisbedlev > 0 ) then
               if( stm_included ) then
                  ierr = nf90_def_var(ihisfile, 'bedlevel', nf90_double, (/ id_statdim, id_timedim /), id_varb)
               else
                  ierr = nf90_def_var(ihisfile, 'bedlevel', nf90_double, (/ id_statdim /), id_varb)
               endif
               ierr = nf90_put_att(ihisfile, id_varb, 'long_name', 'bottom level')
               ierr = nf90_put_att(ihisfile, id_varb, 'units', 'm')
               ierr = nf90_put_att(ihisfile, id_varb, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_varb, '_FillValue', dmiss)
            endif

            idims(1) = id_statdim
            idims(2) = id_timedim
            if (jahiswatdep > 0) then
               call definencvar(ihisfile,id_hs, nf90_double, idims, 2, 'waterdepth'  , 'water depth', 'm', 'station_x_coordinate station_y_coordinate station_name')
            endif

            if( jahisvelvec > 0 ) then
               if ( kmx.gt.0 ) then
                  ierr = nf90_def_var(ihisfile, 'x_velocity', nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_varucx)
                  ierr = nf90_put_att(ihisfile, id_varucx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                  ierr = nf90_def_var(ihisfile, 'y_velocity', nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_varucy)
                  ierr = nf90_put_att(ihisfile, id_varucy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                  ierr = nf90_def_var(ihisfile, 'z_velocity', nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_varucz)
                  ierr = nf90_put_att(ihisfile, id_varucz, 'standard_name', 'upward_sea_water_velocity')
                  ierr = nf90_put_att(ihisfile, id_varucz, 'long_name', 'vertical/upward component of flow element center velocity vector') ! sorry for inland water people
                  ierr = nf90_put_att(ihisfile, id_varucz, 'units', 'm s-1')
                  ierr = nf90_put_att(ihisfile, id_varucz, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                  ierr = nf90_put_att(ihisfile, id_varucz, '_FillValue', dmiss)
                  jawrizc = 1
                  ierr = nf90_def_var(ihisfile, 'depth-averaged_x_velocity', nf90_double, (/ id_statdim, id_timedim /), id_varucxq)
                  ierr = nf90_put_att(ihisfile, id_varucxq, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  ierr = nf90_put_att(ihisfile, id_varucxq, 'standard_name', 'sea_water_depth-averaged_x_velocity')
                  ierr = nf90_put_att(ihisfile, id_varucxq, 'long_name', 'flow element depth-averaged center velocity vector, x-component')
                  ierr = nf90_put_att(ihisfile, id_varucxq, 'units', 'm s-1')
                  ierr = nf90_put_att(ihisfile, id_varucxq, '_FillValue', dmiss)

                  ierr = nf90_def_var(ihisfile, 'depth-averaged_y_velocity', nf90_double, (/ id_statdim, id_timedim /), id_varucyq)
                  ierr = nf90_put_att(ihisfile, id_varucyq, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  ierr = nf90_put_att(ihisfile, id_varucyq, 'standard_name', 'sea_water_depth-averaged_y_velocity')
                  ierr = nf90_put_att(ihisfile, id_varucyq, 'long_name', 'flow element depth-averaged center velocity vector, y-component')
                  ierr = nf90_put_att(ihisfile, id_varucyq, 'units', 'm s-1')
                  ierr = nf90_put_att(ihisfile, id_varucyq, '_FillValue', dmiss)
               else
                  ierr = nf90_def_var(ihisfile, 'x_velocity', nf90_double, (/ id_statdim, id_timedim /), id_varucx)
                  ierr = nf90_put_att(ihisfile, id_varucx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  ierr = nf90_def_var(ihisfile, 'y_velocity', nf90_double, (/ id_statdim, id_timedim /), id_varucy)
                  ierr = nf90_put_att(ihisfile, id_varucy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               end if
               ierr = nf90_put_att(ihisfile, id_varucx, 'standard_name', 'sea_water_x_velocity')
               ierr = nf90_put_att(ihisfile, id_varucx, 'long_name', 'x-component of flow element center velocity vector')
               ierr = nf90_put_att(ihisfile, id_varucx, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_varucx, '_FillValue', dmiss)
               ierr = nf90_put_att(ihisfile, id_varucy, 'standard_name', 'sea_water_y_velocity')
               ierr = nf90_put_att(ihisfile, id_varucy, 'long_name', 'y-component of flow element center velocity vector')
               ierr = nf90_put_att(ihisfile, id_varucy, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_varucy, '_FillValue', dmiss)
            endif

            if ( kmx.gt.0 ) then

               !idims(1) = id_laydim
               !idims(2) = id_statdim
               !idims(3) = id_timedim
               !call definencvar   (ihisfile, id_zcs, nf90_double, idims,3, 'zcoordinate_c' , 'vertical coordinate at center of flow element and layer'   , 'm',  'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
               !ierr = nf90_put_att(ihisfile, id_zcs, 'positive' , 'up')

               idims(1) = id_laydimw
               idims(2) = id_statdim
               idims(3) = id_timedim
               !call definencvar   (ihisfile, id_zws, nf90_double, idims,3, 'zcoordinate_w' , 'vertical coordinate at center of flow element and at layer interface'   , 'm',  'station_x_coordinate station_y_coordinate station_name zcoordinate_w')
               !ierr = nf90_put_att(ihisfile, id_zws, 'positive' , 'up')

               if (iturbulencemodel >= 3 .and. jahistur > 0) then
                  call definencvar(ihisfile,id_turkin,nf90_double, idims,3, 'tke'   , 'turbulent kinetic energy'   , 'm2 s-2',  'station_x_coordinate station_y_coordinate station_name zcoordinate_w')
                  jawrizw = 1
               endif
               if (iturbulencemodel > 1 .and. jahistur > 0 ) then
                  call definencvar(ihisfile,id_vicwwu,nf90_double, idims,3, 'vicww' , 'turbulent vertical eddy viscosity'    , 'm2 s-1' ,  'station_x_coordinate station_y_coordinate station_name zcoordinate_w')
                  ierr = nf90_put_att(ihisfile, id_turkin, 'standard_name', 'specific_turbulent_kinetic_energy_of_sea_water')
                  jawrizw = 1
               endif
               if (iturbulencemodel == 3 .and. jahistur > 0) then
                  call definencvar(ihisfile,id_tureps,nf90_double, idims,3, 'eps'   , 'turbulent energy dissipation', 'm2 s-3'  ,  'station_x_coordinate station_y_coordinate station_name zcoordinate_w')
                  ierr = nf90_put_att(ihisfile, id_tureps, 'standard_name', 'specific_turbulent_kinetic_energy_dissipation_in_sea_water')
                  jawrizw = 1
               else if (iturbulencemodel == 4 .and. jahistur > 0) then
                  call definencvar(ihisfile,id_tureps,nf90_double, idims,3, 'tau'   , 'turbulent time scale', 's-1'  ,  'station_x_coordinate station_y_coordinate station_name zcoordinate_w')
                  jawrizw = 1
               endif

               if (jarichardsononoutput > 0) then
                  call definencvar(ihisfile,id_rich,nf90_double, idims,3, 'rich' , 'Richardson Nr'    , '  ' ,  'station_x_coordinate station_y_coordinate station_name zcoordinate_w')
                  jawrizw = 1
               end if

            end if
            if (jsferic == 0) then
               ierr = nf90_put_att(ihisfile, id_varucx, 'standard_name', 'sea_water_x_velocity')
               ierr = nf90_put_att(ihisfile, id_varucy, 'standard_name', 'sea_water_y_velocity')
            else
               ierr = nf90_put_att(ihisfile, id_varucx, 'standard_name', 'eastward_sea_water_velocity')
               ierr = nf90_put_att(ihisfile, id_varucy, 'standard_name', 'northward_sea_water_velocity')
            end if

            if (jaeulervel==0) then
               ierr = nf90_put_att(ihisfile, id_varucx, 'long_name', 'flow element center velocity vector, x-component') 
               ierr = nf90_put_att(ihisfile, id_varucy, 'long_name', 'flow element center velocity vector, y-component') 

            else
               ierr = nf90_put_att(ihisfile, id_varucx, 'long_name', 'flow element center Eulerian velocity vector, x-component') 
               ierr = nf90_put_att(ihisfile, id_varucy, 'long_name', 'flow element center Eulerian velocity vector, y-component') 
            endif
            ierr = nf90_put_att(ihisfile, id_varucx, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_varucy, 'units', 'm s-1')

            if (kmx > 0) then
               ierr = nf90_put_att(ihisfile, id_varucx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
               ierr = nf90_put_att(ihisfile, id_varucy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
            else
               ierr = nf90_put_att(ihisfile, id_varucx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_varucy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
            end if

            ierr = nf90_put_att(ihisfile, id_varucx, '_FillValue', dmiss)
            ierr = nf90_put_att(ihisfile, id_varucy, '_FillValue', dmiss)


            if (jasal > 0 .and. jahissal > 0) then
               if ( kmx.gt.0 ) then
                  ierr = nf90_def_var(ihisfile, 'salinity', nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_varsal)
                  ierr = nf90_put_att(ihisfile, id_varsal, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                  jawrizc = 1
               else
                  ierr = nf90_def_var(ihisfile, 'salinity', nf90_double, (/ id_statdim, id_timedim /), id_varsal)
                  ierr = nf90_put_att(ihisfile, id_varsal, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               end if
               ierr = nf90_put_att(ihisfile, id_varsal, 'units', '1e-3')
               ierr = nf90_put_att(ihisfile, id_varsal, '_FillValue', dmiss)
               ierr = nf90_put_att(ihisfile, id_varsal, 'standard_name', 'salinity')
            endif

!           JRE surfbeat
            if (jawave .eq. 4) then

               ierr = nf90_def_var(ihisfile, 'R',  nf90_double, ((/ id_statdim, id_timedim /)) , id_R)
               ierr = nf90_put_att(ihisfile, id_R,   'coordinates'  , 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_R,   'standard_name', 'sea_surface_bulk_roller_energy')                          ! not CF
               ierr = nf90_put_att(ihisfile, id_R,   'long_name'    , 'roller energy per square meter')
               ierr = nf90_put_att(ihisfile, id_R,   'units'        , 'J m-2')
               ierr = nf90_put_att(ihisfile, id_R, '_FillValue', dmiss)

            end if

            if (jawave > 0 .and. jahiswav > 0) then
               ierr = nf90_def_var(ihisfile, 'hwav',  nf90_double, ((/ id_statdim, id_timedim /)) , id_WH)
               ierr = nf90_put_att(ihisfile, id_WH,   'coordinates'  , 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_WH,   'standard_name', 'sea_surface_wave_significant_wave_height')     ! Default behaviour
               ierr = nf90_put_att(ihisfile, id_WH,   'long_name'    , 'Significant wave height')
               if (jahissigwav==0) then
                  ierr = nf90_put_att(ihisfile, id_WH,   'standard_name', 'sea_surface_wave_rms_height')
                  ierr = nf90_put_att(ihisfile, id_WH,   'long_name'    , 'Root mean square wave height based on wave energy')
               end  if
               ierr = nf90_put_att(ihisfile, id_WH,   'units'        , 'm')
               ierr = nf90_put_att(ihisfile, id_WH, '_FillValue', dmiss)

               ierr = nf90_def_var(ihisfile, 'twav',  nf90_double, ((/ id_statdim, id_timedim /)) , id_WT)
               ierr = nf90_put_att(ihisfile, id_WT,   'coordinates'  , 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_WT,   'standard_name', 'sea_surface_wave_period')
               ierr = nf90_put_att(ihisfile, id_WT,   'long_name'    , 'Wave period')
               ierr = nf90_put_att(ihisfile, id_WT,   'units'        , 's')
               ierr = nf90_put_att(ihisfile, id_WT, '_FillValue', dmiss)

               ierr = nf90_def_var(ihisfile, 'phiwav',  nf90_double, ((/ id_statdim, id_timedim /)) , id_WD)
               ierr = nf90_put_att(ihisfile, id_WD,   'coordinates'  , 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_WD,   'standard_name', 'sea_surface_wave_from_direction')
               ierr = nf90_put_att(ihisfile, id_WD,   'long_name'    , 'Wave from direction')
               ierr = nf90_put_att(ihisfile, id_WD,   'units'        , 'deg from N')
               ierr = nf90_put_att(ihisfile, id_WD, '_FillValue', dmiss)

               ierr = nf90_def_var(ihisfile, 'rlabda',  nf90_double, ((/ id_statdim, id_timedim /)) , id_WL)
               ierr = nf90_put_att(ihisfile, id_WL,   'coordinates'  , 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_WL,   'standard_name', 'sea_surface_wave_length')
               ierr = nf90_put_att(ihisfile, id_WL,   'long_name'    , 'Wave length')
               ierr = nf90_put_att(ihisfile, id_WL,   'units'        , 'm')
               ierr = nf90_put_att(ihisfile, id_WL, '_FillValue', dmiss)

               ierr = nf90_def_var(ihisfile, 'uorb',  nf90_double, ((/ id_statdim, id_timedim /)) , id_WU)
               ierr = nf90_put_att(ihisfile, id_WU,   'coordinates'  , 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_WU,   'standard_name', 'sea_surface_wave_orbital_velocity')
               ierr = nf90_put_att(ihisfile, id_WU,   'long_name'    , 'Orbital velocity')
               ierr = nf90_put_att(ihisfile, id_WU,   'units'        , 'm/s')
               ierr = nf90_put_att(ihisfile, id_WU, '_FillValue', dmiss)

               ierr = nf90_def_var(ihisfile, 'tauwav',  nf90_double, ((/ id_statdim, id_timedim /)) , id_WTAU)
               ierr = nf90_put_att(ihisfile, id_WTAU,   'coordinates'  , 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_WTAU,   'standard_name', 'sea_surface_wave_bottom_shear_stress')
               ierr = nf90_put_att(ihisfile, id_WTAU,   'long_name'    , 'Wave induced bottom shear stress')
               ierr = nf90_put_att(ihisfile, id_WTAU,   'units'        , 'Pa')
               ierr = nf90_put_att(ihisfile, id_WTAU, '_FillValue', dmiss)
            endif

            if (jatem > 0 .and. jahistem > 0) then
               if ( kmx.gt.0 ) then
                  ierr = nf90_def_var(ihisfile, 'temperature', nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_vartem)
                  ierr = nf90_put_att(ihisfile, id_vartem, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                  jawrizc = 1
               else
                  ierr = nf90_def_var(ihisfile, 'temperature', nf90_double, (/ id_statdim, id_timedim /), id_vartem)
                  ierr = nf90_put_att(ihisfile, id_vartem, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               end if
               ierr = nf90_put_att(ihisfile, id_vartem, 'units', 'degC')
               ierr = nf90_put_att(ihisfile, id_vartem, '_FillValue', dmiss)
               ierr = nf90_put_att(ihisfile, id_vartem, 'standard_name', 'sea_water_temperature')

               if (jatem > 1 .and. jahisheatflux > 0) then ! here less verbose
                  idims(1) = id_statdim
                  idims(2) = id_timedim
                  call definencvar(ihisfile,id_wind   ,nf90_double,idims,2, 'wind'  , 'windspeed', 'm s-1', 'station_x_coordinate station_y_coordinate station_name')
                  call definencvar(ihisfile,id_tair   ,nf90_double,idims,2, 'Tair'  , 'air temperature', 'degC', 'station_x_coordinate station_y_coordinate station_name')
                  if (jatem == 5) then
                     call definencvar(ihisfile,id_rhum   ,nf90_double,idims,2, 'rhum'  , 'relative humidity', ' ','station_x_coordinate station_y_coordinate station_name')
                     call definencvar(ihisfile,id_clou   ,nf90_double,idims,2, 'clou'  , 'cloudiness', ' ', 'station_x_coordinate station_y_coordinate station_name')

                     call definencvar(ihisfile,id_qsun   ,nf90_double,idims,2, 'Qsun'  , 'solar influx', 'W m-2', 'station_x_coordinate station_y_coordinate station_name')
                     call definencvar(ihisfile,id_Qeva   ,nf90_double,idims,2, 'Qeva'  , 'evaporative heat flux', 'W m-2', 'station_x_coordinate station_y_coordinate station_name')
                     call definencvar(ihisfile,id_Qcon   ,nf90_double,idims,2, 'Qcon'  , 'sensible heat flux', 'W m-2', 'station_x_coordinate station_y_coordinate station_name')
                     call definencvar(ihisfile,id_Qlong  ,nf90_double,idims,2, 'Qlong' , 'long wave back radiation', 'W m-2', 'station_x_coordinate station_y_coordinate station_name')
                     call definencvar(ihisfile,id_Qfreva ,nf90_double,idims,2, 'Qfreva', 'free convection evaporative heat flux', 'W m-2', 'station_x_coordinate station_y_coordinate station_name')
                     call definencvar(ihisfile,id_Qfrcon ,nf90_double,idims,2, 'Qfrcon', 'free convection sensible heat flux', 'W m-2', 'station_x_coordinate station_y_coordinate station_name')
                  endif
                  if (jatem > 1) then
                     call definencvar(ihisfile,id_Qtot   ,nf90_double,idims,2, 'Qtot'  , 'total heat flux', 'W m-2', 'station_x_coordinate station_y_coordinate station_name')
                  end if
               endif
            endif

            if ((jasal > 0 .or. jatem > 0 .or. jased > 0) .and. jahisrho > 0) then
               if ( kmx.gt.0 ) then
                  ierr = nf90_def_var(ihisfile, 'density', nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_varrho)
                  ierr = nf90_put_att(ihisfile, id_varrho, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                  jawrizc = 1
               else
                  ierr = nf90_def_var(ihisfile, 'density', nf90_double, (/ id_statdim, id_timedim /), id_varrho)
                  ierr = nf90_put_att(ihisfile, id_varrho, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               end if
               ierr = nf90_put_att(ihisfile, id_varrho, 'units', 'kg m-3')
               ierr = nf90_put_att(ihisfile, id_varrho, '_FillValue', dmiss)
               ierr = nf90_put_att(ihisfile, id_varrho, 'standard_name', 'density')
            endif

            if (ITRA1 > 0 .and. jahisconst > 0) then
               do j=ITRA1,ITRAN
                  i = j-ITRA1+1  ! tracer nr

                  tmpstr = const_names(j)
                  ! Forbidden chars in NetCDF names: space, /, and more.
                  call replace_char(tmpstr,32,95)

                  if ( kmx > 0 ) then
                     ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_tra(i))
                     ierr = nf90_put_att(ihisfile, id_tra(i), 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                     jawrizc = 1
                  else
                     ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_statdim, id_timedim /), id_tra(i))
                     ierr = nf90_put_att(ihisfile, id_tra(i), 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  end if
                  if (const_units(j).ne.' ') then
                     tmpstr = const_units(j)
                  else
                     tmpstr = '1e-3'
                  endif
                  ierr = nf90_put_att(ihisfile, id_tra(i), 'units', tmpstr)
                  ierr = nf90_put_att(ihisfile, id_tra(i), '_FillValue', dmiss)
                  ierr = nf90_put_att(ihisfile, id_tra(i), 'long_name', const_names(j))
               enddo
            endif

            if (numwqbots > 0) then
               call realloc(id_hwqb, numwqbots, keepExisting = .false.)
               do i=1,numwqbots
                  tmpstr = wqbotnames(i)
                  ! Forbidden chars in NetCDF names: space, /, and more.
                  call replace_char(tmpstr,32,95)

                  ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_statdim, id_timedim /), id_hwqb(i))
                  ierr = nf90_put_att(ihisfile, id_hwqb(i), 'coordinates', 'station_x_coordinate station_y_coordinate station_name')

                  tmpstr = wqbotunits(i)
                  ierr = nf90_put_att(ihisfile, id_hwqb(i), 'units', tmpstr)
                  ierr = nf90_put_att(ihisfile, id_hwqb(i), '_FillValue', dmiss)
                  ierr = nf90_put_att(ihisfile, id_hwqb(i), 'long_name', wqbotnames(i))
               enddo
            endif

!          waq output
             if(jawaqproc > 0) then
               if (noout_user > 0) then
                  call realloc(id_hwq, noout_user, keepExisting = .false.)
                  do j=1,noout_user
                     tmpstr = ' '
                     write (tmpstr, "('water_quality_output_',I0)") j
                     if ( kmx > 0 ) then  !        3D
                        ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_hwq(j))
                        ierr = nf90_put_att(ihisfile, id_hwq(j), 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                     else
                        ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_statdim, id_timedim /), id_hwq(j))
                        ierr = nf90_put_att(ihisfile, id_hwq(j), 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                     end if
                     tmpstr = trim(outputs%names(j))//' - '//trim(outputs%descrs(j))//' in flow element'
                     call replace_multiple_spaces_by_single_spaces(tmpstr)
                     ierr = nf90_put_att(ihisfile, id_hwq(j), '_FillValue', dmiss)
                     ierr = nf90_put_att(ihisfile, id_hwq(j), 'long_name', trim(outputs%names(j)))
                     ierr = nf90_put_att(ihisfile, id_hwq(j), 'units', trim(outputs%units(j)))
                     ierr = nf90_put_att(ihisfile, id_hwq(j), 'description', tmpstr)
                  enddo
               endif
               if (noout_statt > 0) then
                  call realloc(id_hwq, noout_user + noout_statt, keepExisting = .true.)
                  do j=1,noout_statt
                     jj = noout_user + j
                     tmpstr = ' '
                     write (tmpstr, "('water_quality_stat_',I0)") j
                     if ( kmx > 0 ) then  !        3D
                        ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_hwq(jj))
                        ierr = nf90_put_att(ihisfile, id_hwq(jj), 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                     else
                        ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_statdim, id_timedim /), id_hwq(jj))
                        ierr = nf90_put_att(ihisfile, id_hwq(jj), 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                     end if
                     tmpstr = trim(outputs%names(jj))//' - '//trim(outputs%descrs(jj))//' in flow element'
                     call replace_multiple_spaces_by_single_spaces(tmpstr)
                     ierr = nf90_put_att(ihisfile, id_hwq(jj), '_FillValue', dmiss)
                     ierr = nf90_put_att(ihisfile, id_hwq(jj), 'long_name', trim(outputs%names(jj)))
                     ierr = nf90_put_att(ihisfile, id_hwq(jj), 'units', trim(outputs%units(jj)))
                     ierr = nf90_put_att(ihisfile, id_hwq(jj), 'description', tmpstr)
                  enddo
               endif
               if (noout_state> 0) then
                  call realloc(id_hwq, noout, keepExisting = .true.)
                  do j=1,noout_state
                     jj = noout_user + noout_statt + j
                     tmpstr = ' '
                     write (tmpstr, "('water_quality_stat_',I0)") noout_statt + j
                     if ( kmx > 0 ) then  !        3D
                        ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_laydim, id_statdim /), id_hwq(jj))
                        ierr = nf90_put_att(ihisfile, id_hwq(jj), 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                     else
                        ierr = nf90_def_var(ihisfile, trim(tmpstr), nf90_double, (/ id_statdim /), id_hwq(jj))
                        ierr = nf90_put_att(ihisfile, id_hwq(jj), 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                     end if
                     tmpstr = trim(outputs%names(jj))//' - '//trim(outputs%descrs(jj))//' in flow element'
                     call replace_multiple_spaces_by_single_spaces(tmpstr)
                     ierr = nf90_put_att(ihisfile, id_hwq(jj), '_FillValue', dmiss)
                     ierr = nf90_put_att(ihisfile, id_hwq(jj), 'long_name', trim(outputs%names(jj)))
                     ierr = nf90_put_att(ihisfile, id_hwq(jj), 'units', trim(outputs%units(jj)))
                     ierr = nf90_put_att(ihisfile, id_hwq(jj), 'description', tmpstr)
                  enddo
               endif
            endif

            if (stm_included .and. ISED1 > 0 .and. jahissed > 0) then
               ! New implementation, sedsus fraction is additional dimension
               ierr = nf90_def_dim(ihisfile, 'nSedTot', stmpar%lsedtot, id_sedtotdim)
               ierr = nf90_def_dim(ihisfile, 'nSedSus', stmpar%lsedsus, id_sedsusdim)
               !
               ierr = nf90_def_var(ihisfile, 'sedfrac_name', nf90_char, (/ id_strlendim, id_sedtotdim /), id_frac_name)
               ierr = nf90_put_att(ihisfile, id_frac_name,'long_name', 'sediment fraction identifier')
               !
               if (kmx>0) then
                  ierr = nf90_def_var(ihisfile, 'Sediment concentration', nf90_double, (/  id_laydim, id_statdim, id_sedsusdim, id_timedim /), id_sf)
                  ierr = nf90_def_var(ihisfile, 'Sediment settling velocity', nf90_double, (/  id_laydimw, id_statdim, id_sedsusdim, id_timedim /), id_ws)
                  ierr = nf90_def_var(ihisfile, 'Sediment vertical diffusivity', nf90_double, (/  id_laydimw, id_statdim, id_sedsusdim, id_timedim /), id_seddif)
                  ierr = nf90_put_att(ihisfile, id_seddif, 'long_name', 'Sediment vertical diffusion')
                  ierr = nf90_put_att(ihisfile, id_seddif, 'units', 'm2 s-1')
                  ierr = nf90_put_att(ihisfile, id_seddif, '_FillValue', dmiss)
                  ierr = nf90_put_att(ihisfile, id_seddif, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  !
                  jawrizc = 1
                  jawrizw = 1
               else
                  ierr = nf90_def_var(ihisfile, 'Sediment concentration', nf90_double, (/  id_statdim, id_sedsusdim, id_timedim /), id_sf)
                  ierr = nf90_def_var(ihisfile, 'Sediment settling velocity', nf90_double, (/ id_statdim, id_sedsusdim, id_timedim /), id_ws)
               endif
               !
               ierr = nf90_put_att(ihisfile, id_sf, 'long_name', 'Sediment mass concentration')
               ierr = nf90_put_att(ihisfile, id_sf, 'units', 'kg m-3')
               ierr = nf90_put_att(ihisfile, id_sf, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               !
               ierr = nf90_put_att(ihisfile, id_ws, 'long_name', 'Sediment settling velocity')
               ierr = nf90_put_att(ihisfile, id_ws, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_ws, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               !            
            endif
            !
            ! Sediment transports
            !
            if (jased > 0 .and. stm_included .and. jahissed > 0) then
               !
               select case(stmpar%morpar%moroutput%transptype)
                  case (0)
                     transpunit = 'kg s-1 m-1'
                  case (1)
                     transpunit = 'm3 s-1 m-1'
                  case (2)
                     transpunit = 'm3 s-1 m-1'
               end select
               !
               if (stmpar%morpar%moroutput%sbcuv) then
                  ierr = nf90_def_var(ihisfile, 'Current related bedload transport, x-component', nf90_double, (/  id_statdim, id_sedtotdim, id_timedim /), id_sbcx)
                  ierr = nf90_put_att(ihisfile, id_sbcx, 'long_name', 'Current related bedload transport, x-component')
                  ierr = nf90_put_att(ihisfile, id_sbcx, 'units', transpunit)
                  ierr = nf90_put_att(ihisfile, id_sbcx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  ierr = nf90_def_var(ihisfile, 'Current related bedload transport, y-component', nf90_double, (/ id_statdim, id_sedtotdim, id_timedim /), id_sbcy)
                  ierr = nf90_put_att(ihisfile, id_sbcy, 'long_name', 'Current related bedload transport, y-component')
                  ierr = nf90_put_att(ihisfile, id_sbcy, 'units', transpunit)
                  ierr = nf90_put_att(ihisfile, id_sbcy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               endif
               if (stmpar%morpar%moroutput%sbwuv .and. jawave>0) then
                  ierr = nf90_def_var(ihisfile, 'Wave related bedload transport, x-component', nf90_double, (/ id_statdim, id_sedtotdim, id_timedim /), id_sbwx)
                  ierr = nf90_put_att(ihisfile, id_sbwx, 'long_name', 'Wave related bedload transport, x-component')
                  ierr = nf90_put_att(ihisfile, id_sbwx, 'units', transpunit)
                  ierr = nf90_put_att(ihisfile, id_sbwx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  ierr = nf90_def_var(ihisfile, 'Wave related bedload transport, y-component', nf90_double, (/ id_statdim, id_sedtotdim, id_timedim /), id_sbwy)
                  ierr = nf90_put_att(ihisfile, id_sbwy, 'long_name', 'Wave related bedload transport, y-component')
                  ierr = nf90_put_att(ihisfile, id_sbwy, 'units', transpunit)
                  ierr = nf90_put_att(ihisfile, id_sbwy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               endif
               if (stmpar%morpar%moroutput%sswuv .and. jawave>0) then
                  ierr = nf90_def_var(ihisfile, 'Wave related suspended transport, x-component', nf90_double, (/ id_statdim, id_sedtotdim, id_timedim /), id_sswx)
                  ierr = nf90_put_att(ihisfile, id_sswx, 'long_name', 'Wave related suspended transport, x-component')
                  ierr = nf90_put_att(ihisfile, id_sswx, 'units', transpunit)
                  ierr = nf90_put_att(ihisfile, id_sswx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  ierr = nf90_def_var(ihisfile, 'Wave related suspended transport, y-component', nf90_double, (/ id_statdim, id_sedtotdim, id_timedim /), id_sswy)
                  ierr = nf90_put_att(ihisfile, id_sswy, 'long_name', 'Wave related suspended transport, y-component')
                  ierr = nf90_put_att(ihisfile, id_sswy, 'units', transpunit)
                  ierr = nf90_put_att(ihisfile, id_sswy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               end if
               if (stmpar%morpar%moroutput%sscuv) then
                  ierr = nf90_def_var(ihisfile, 'Current related suspended transport, x-component', nf90_double, (/ id_statdim, id_sedtotdim, id_timedim /), id_sscx)
                  ierr = nf90_put_att(ihisfile, id_sscx, 'long_name', 'Current related suspended transport, x-component')
                  ierr = nf90_put_att(ihisfile, id_sscx, 'units', transpunit)
                  ierr = nf90_put_att(ihisfile, id_sscx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
                  ierr = nf90_def_var(ihisfile, 'Current related suspended transport, y-component', nf90_double, (/ id_statdim, id_sedtotdim, id_timedim /), id_sscy)
                  ierr = nf90_put_att(ihisfile, id_sscy, 'long_name', 'Current related suspended transport, y-component')
                  ierr = nf90_put_att(ihisfile, id_sscy, 'units', transpunit)
                  ierr = nf90_put_att(ihisfile, id_sscy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               endif
               !
               ! Source and sink terms
               ! 
               if (stmpar%morpar%moroutput%sourcesink) then
                  ierr = nf90_def_var(ihisfile, 'Source term suspended sediment transport', nf90_double, (/ id_statdim, id_sedsusdim, id_timedim /), id_sour)
                  ierr = nf90_put_att(ihisfile, id_sour, 'long_name', 'Source term suspended sediment transport')
                  ierr = nf90_put_att(ihisfile, id_sour, 'units', 'kg m-3 s-1')
                  ierr = nf90_put_att(ihisfile, id_sour, 'coordinates', 'station_x_coordinate station_y_coordinate station_name') 
                  
                  ierr = nf90_def_var(ihisfile, 'Sink term suspended sediment transport', nf90_double, (/ id_statdim, id_sedsusdim, id_timedim /), id_sink)
                  ierr = nf90_put_att(ihisfile, id_sink, 'long_name', 'Sink term suspended sediment transport')
                  ierr = nf90_put_att(ihisfile, id_sink, 'units', 's-1')
                  ierr = nf90_put_att(ihisfile, id_sink, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               endif
            endif
            !
            if (jased > 0 .and. .not. stm_included .and. jahissed > 0) then
               if ( kmx.gt.0 ) then
                  ierr = nf90_def_var(ihisfile, 'sediment_concentration', nf90_double, (/ id_laydim, id_statdim, id_timedim /), id_varsed)
                  ierr = nf90_put_att(ihisfile, id_varsed, 'coordinates', 'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
                  jawrizc = 1
               else
                  ierr = nf90_def_var(ihisfile, 'sediment_concentration', nf90_double, (/ id_statdim, id_timedim /), id_varsed)
                  ierr = nf90_put_att(ihisfile, id_varsed, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               end if
               ierr = nf90_put_att(ihisfile, id_varsed, 'units', 'kg m-3')
               ierr = nf90_put_att(ihisfile, id_varsed, '_FillValue', dmiss)
               ierr = nf90_put_att(ihisfile, id_varsed, 'long_name', 'sediment_concentration')
            endif

            if (japatm > 0 .and. jahiswind > 0) then
               call definencvar(ihisfile,id_varpatm   ,nf90_double,(/ id_statdim, id_timedim /),2, 'patm'  , 'atmospheric pressure', 'N m-2', 'station_x_coordinate station_y_coordinate station_name')
            endif

            if (jawind > 0 .and. jahiswind > 0) then
               ierr = nf90_def_var(ihisfile, 'windx', nf90_double, (/ id_statdim, id_timedim /), id_varwx)
               ierr = nf90_put_att(ihisfile, id_varwx, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_varwx, '_FillValue', dmiss)
               ierr = nf90_put_att(ihisfile, id_varwx, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_def_var(ihisfile, 'windy', nf90_double, (/ id_statdim, id_timedim /), id_varwy)
               ierr = nf90_put_att(ihisfile, id_varwy, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_varwy, '_FillValue', dmiss)
               ierr = nf90_put_att(ihisfile, id_varwy, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               if (jsferic == 0) then
                  ierr = nf90_put_att(ihisfile, id_varwx, 'standard_name', 'x_wind')
                  ierr = nf90_put_att(ihisfile, id_varwy, 'standard_name', 'y_wind')
               else
                  ierr = nf90_put_att(ihisfile, id_varwx, 'standard_name', 'eastward_wind')
                  ierr = nf90_put_att(ihisfile, id_varwy, 'standard_name', 'northward_wind')
               end if
               ierr = nf90_put_att(ihisfile, id_varwx, 'long_name', 'velocity of air on flow element center, x-component')
               ierr = nf90_put_att(ihisfile, id_varwy, 'long_name', 'velocity of air on flow element center, y-component')
            endif

            if (jarain > 0 .and. jahisrain > 0) then
               ierr = nf90_def_var(ihisfile, 'rain', nf90_double, (/ id_statdim, id_timedim /), id_varrain)
               ierr = nf90_put_att(ihisfile, id_varrain, 'units', 'mm day-1')
               ierr = nf90_put_att(ihisfile, id_varrain, '_FillValue', dmiss)
               ierr = nf90_put_att(ihisfile, id_varrain, 'coordinates', 'station_x_coordinate station_y_coordinate station_name')
               ierr = nf90_put_att(ihisfile, id_varrain, 'standard_name', 'precipitation_flux')
               ierr = nf90_put_att(ihisfile, id_varrain, 'long_name', 'precipitation depth per time unit')
            endif

            if (kmx.gt.0 .and. jawrizc == 1) then
               idims(1) = id_laydim
               idims(2) = id_statdim
               idims(3) = id_timedim
               call definencvar   (ihisfile, id_zcs, nf90_double, idims,3, 'zcoordinate_c' , 'vertical coordinate at center of flow element and layer'   , 'm',  'station_x_coordinate station_y_coordinate station_name zcoordinate_c')
               ierr = nf90_put_att(ihisfile, id_zcs, 'positive' , 'up')
            endif
            if (kmx.gt.0 .and. jawrizw == 1) then
               idims(1) = id_laydimw
               idims(2) = id_statdim
               idims(3) = id_timedim
               call definencvar   (ihisfile, id_zws, nf90_double, idims,3, 'zcoordinate_w' , 'vertical coordinate at edge of flow element and at layer interface'   , 'm',  'station_x_coordinate station_y_coordinate station_name zcoordinate_w')
               ierr = nf90_put_att(ihisfile, id_zws, 'positive' , 'up')
            endif
        end if

        if (ncrs > 0) then
            mnp = 0
            do i=1,ncrs
                mnp = max(mnp, crs(i)%path%np)
            end do
            ierr = nf90_def_dim(ihisfile, 'cross_section', ncrs, id_crsdim)
            ierr = nf90_def_dim(ihisfile, 'cross_section_name_len', 64, id_crslendim)
            ierr = nf90_def_dim(ihisfile, 'cross_section_pts', mnp+1, id_crsptsdim)

            ierr = nf90_def_var(ihisfile, 'cross_section_x_coordinate', nf90_double, (/ id_crsptsdim, id_crsdim /), id_crsx)
            ierr = nf90_def_var(ihisfile, 'cross_section_y_coordinate', nf90_double, (/ id_crsptsdim, id_crsdim /), id_crsy)
            ierr = nf90_def_var(ihisfile, 'cross_section_name',         nf90_char,   (/ id_crslendim, id_crsdim /), id_crsname)
            ierr = nf90_put_att(ihisfile, id_crsname,  'cf_role', 'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_crsname,  'long_name', 'cross section name'    )
            ierr = unc_addcoordatts(ihisfile, id_crsx, id_crsy, jsferic)

            ierr = nf90_def_var(ihisfile, 'cross_section_discharge',     nf90_double, (/ id_crsdim, id_timedim /), id_varQ)
            ierr = nf90_put_att(ihisfile, id_varQ,    'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_varQ,    'coordinates', 'cross_section_name')
            ierr = nf90_def_var(ihisfile, 'cross_section_cumulative_discharge', nf90_double, (/ id_crsdim, id_timedim /), id_varQint)
            ierr = nf90_put_att(ihisfile, id_varQint, 'units', 'm3')
            ierr = nf90_put_att(ihisfile, id_varQint, 'coordinates', 'cross_section_name')
            !ierr = nf90_def_var(ihisfile, 'cross_section_discharge_avg', nf90_double, (/ id_crsdim, id_timedim /), id_varQavg)
            !ierr = nf90_put_att(ihisfile, id_varQavg, 'units', 'm3 s-1')
            !ierr = nf90_put_att(ihisfile, id_varQavg, 'coordinates', 'cross_section_name')

            ierr = nf90_def_var(ihisfile, 'cross_section_area',     nf90_double, (/ id_crsdim, id_timedim /), id_varAu)
            ierr = nf90_put_att(ihisfile, id_varAu,    'units', 'm2')
            ierr = nf90_put_att(ihisfile, id_varAu,    'coordinates', 'cross_section_name')
            !ierr = nf90_def_var(ihisfile, 'cross_section_area_avg', nf90_double, (/ id_crsdim, id_timedim /), id_varAuavg)
            !ierr = nf90_put_att(ihisfile, id_varAuavg, 'units', 'm2')
            !ierr = nf90_put_att(ihisfile, id_varAuavg, 'coordinates', 'cross_section_name')

            ierr = nf90_def_var(ihisfile, 'cross_section_velocity',     nf90_double, (/ id_crsdim, id_timedim /), id_varu)
            ierr = nf90_put_att(ihisfile, id_varu,    'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_varu,    'coordinates', 'cross_section_name')
            ! Disable writing cross_section_velocity_avg (see UNST-1148), because in a parallel run, it is impossible to compute
            ! summation of area (denominator) at each computational time step in a cheap way, i.e. without communication between
            ! partitions. @see subroutines: sumvalueOnCrossSections, updateValuesOnCrossSections
            !ierr = nf90_def_var(ihisfile, 'cross_section_velocity_avg', nf90_double, (/ id_crsdim, id_timedim /), id_varuavg)
            !ierr = nf90_put_att(ihisfile, id_varuavg, 'units', 'm s-1')
            !ierr = nf90_put_att(ihisfile, id_varuavg, 'coordinates', 'cross_section_name')

            if( jatransportmodule /= 0 ) then
               do num = 1,NUMCONST_MDU
                  tmpstr = const_names(num)
                  ! Forbidden chars in NetCDF names: space, /, and more.
                  call replace_char(tmpstr,32,95)
                  call replace_char(tmpstr,47,95)
                  ierr = nf90_def_var(ihisfile, 'cross_section_cumulative_'//trim(tmpstr), nf90_double, (/ id_crsdim, id_timedim /), id_const_cum(num))
                  ierr = nf90_put_att(ihisfile, id_const_cum(num), 'long_name', 'cumulative flux (based on upwind flow element) for '//trim(tmpstr)//'.')

                  ierr = nf90_def_var(ihisfile, 'cross_section_'//trim(tmpstr), nf90_double, (/ id_crsdim, id_timedim /), id_const(num))
                  ierr = nf90_put_att(ihisfile, id_const(num), 'long_name', 'flux (based on upwind flow element) for '//trim(tmpstr)//'.')
                  
                  if (num >= ISED1 .and. num <= ISEDN) then    ! if the constituent is sediment
                     select case(stmpar%morpar%moroutput%transptype)
                     case (0)
                        tmpstr = 'kg'
                     case (1, 2)
                        tmpstr = 'm3'
                     end select
                  else
                     if (const_units(num) /= ' ') then
                        tmpstr = trim(const_units(num)) // ' m3'
                     else
                        tmpstr = '-'
                     endif
                  endif
                  ierr = nf90_put_att(ihisfile, id_const_cum(num), 'units', tmpstr)
                  ierr = nf90_put_att(ihisfile, id_const_cum(num), 'coordinates', 'cross_section_name')

                  if (num >= ISED1 .and. num <= ISEDN) then    ! if the constituent is sediment
                     select case(stmpar%morpar%moroutput%transptype)
                     case (0)
                        tmpstr = 'kg/s'
                     case (1, 2)
                        tmpstr = 'm3/s'
                     end select
                  else
                     if (const_units(num) /= ' ') then
                        tmpstr = trim(const_units(num)) // ' m3/s'
                     else
                        tmpstr = '-'
                     endif
                  endif
                  ierr = nf90_put_att(ihisfile, id_const(num), 'units', tmpstr)
                  ierr = nf90_put_att(ihisfile, id_const(num), 'coordinates', 'cross_section_name')
               enddo
            endif

            if( jased == 4 .and. stmpar%lsedtot > 0 ) then
               ierr = nf90_def_var(ihisfile, 'cross_section_bedload_sediment_transport', nf90_double, (/ id_crsdim, id_timedim /), id_sedbtrans)
               ierr = nf90_put_att(ihisfile, id_sedbtrans, 'long_name', 'cumulative bed load sediment transport')
               ierr = nf90_put_att(ihisfile, id_sedbtrans, 'units', 'kg')
               ierr = nf90_put_att(ihisfile, id_sedbtrans, 'coordinates', 'cross_section_name')
               if( stmpar%lsedsus > 0 ) then
                  ierr = nf90_def_var(ihisfile, 'cross_section_suspended_sediment_transport', nf90_double, (/ id_crsdim, id_timedim /), id_sedstrans)
                  ierr = nf90_put_att(ihisfile, id_sedstrans, 'long_name', 'cumulative suspended load sediment transport')
                  ierr = nf90_put_att(ihisfile, id_sedstrans, 'units', 'kg')
                  ierr = nf90_put_att(ihisfile, id_sedstrans, 'coordinates', 'cross_section_name')
               endif

            endif
        end if

        if (jahissourcesink > 0 .and. numsrc > 0) then
           ierr = nf90_def_dim(ihisfile, 'source_sink', numsrc, id_srcdim)
           ierr = nf90_def_dim(ihisfile, 'source_sink_name_len', 64, id_srclendim)
           ierr = nf90_def_dim(ihisfile, 'source_sink_pts', msrc, id_srcptsdim)

           ierr = nf90_def_var(ihisfile, 'source_sink_name', nf90_char, (/ id_srclendim, id_srcdim/), id_srcname)
           ierr = nf90_put_att(ihisfile, id_srcname,  'cf_role', 'timeseries_id')
           ierr = nf90_put_att(ihisfile, id_srcname,  'long_name', 'source and sink name'    )

           ierr = nf90_def_var(ihisfile, 'source_sink_x_coordinate', nf90_double, (/ id_srcdim, id_srcptsdim  /), id_srcx)
           ierr = nf90_def_var(ihisfile, 'source_sink_y_coordinate', nf90_double, (/ id_srcdim, id_srcptsdim /), id_srcy)
           ierr = unc_addcoordatts(ihisfile, id_srcx, id_srcy, jsferic)
           ierr = nf90_put_att(ihisfile, id_srcx, '_FillValue', dmiss)
           ierr = nf90_put_att(ihisfile, id_srcy, '_FillValue', dmiss)

           ierr = nf90_def_var(ihisfile, 'source_sink_prescribed_discharge', nf90_double, (/ id_srcdim, id_timedim /), id_pred)
           ierr = nf90_put_att(ihisfile, id_pred,    'units', 'm3 s-1')
           ierr = nf90_put_att(ihisfile, id_pred,    'coordinates', 'source_sink_name')
           ierr = nf90_def_var(ihisfile, 'source_sink_prescribed_salinity_increment', nf90_double, (/ id_srcdim, id_timedim /), id_presa)
           ierr = nf90_put_att(ihisfile, id_presa,    'units', '1e-3')
           ierr = nf90_put_att(ihisfile, id_presa,    'coordinates', 'source_sink_name')
           ierr = nf90_def_var(ihisfile, 'source_sink_prescribed_temperature_increment', nf90_double, (/ id_srcdim, id_timedim /), id_pretm)
           ierr = nf90_put_att(ihisfile, id_pretm,    'units', 'degC')
           ierr = nf90_put_att(ihisfile, id_pretm,    'coordinates', 'source_sink_name')

           ierr = nf90_def_var(ihisfile, 'source_sink_current_discharge', nf90_double, (/ id_srcdim, id_timedim /), id_qsrccur)
           ierr = nf90_put_att(ihisfile, id_qsrccur,    'units', 'm3 s-1')
           ierr = nf90_put_att(ihisfile, id_qsrccur,    'coordinates', 'source_sink_name')
           ierr = nf90_def_var(ihisfile, 'source_sink_cumulative_volume', nf90_double, (/ id_srcdim, id_timedim /), id_vsrccum)
           ierr = nf90_put_att(ihisfile, id_vsrccum,    'long_name', 'Cumulative volume from the start time until current time at each source/sink')
           ierr = nf90_put_att(ihisfile, id_vsrccum,    'units', 'm3')
           ierr = nf90_put_att(ihisfile, id_vsrccum,    'coordinates', 'source_sink_name')
           ierr = nf90_def_var(ihisfile, 'source_sink_discharge_average', nf90_double, (/ id_srcdim, id_timedim /), id_qsrcavg)
           ierr = nf90_put_att(ihisfile, id_qsrcavg,    'long_name', 'Average discharge in the past his-file output-interval at each source/sink')
           ierr = nf90_put_att(ihisfile, id_qsrcavg,    'units', 'm3 s-1')
           ierr = nf90_put_att(ihisfile, id_qsrcavg,    'coordinates', 'source_sink_name')
        endif

        if (jahisbal > 0) then
           do num = 1,MAX_IDX
              if ( num.eq.IDX_InternalTidesDissipation ) then
                 if ( jaFrcInternalTides2D.eq.1 ) then
                    ierr = nf90_def_var(ihisfile, trim(voltotname(num)), nf90_double, (/ id_timedim /), id_voltot(num))
                    ierr = nf90_put_att(ihisfile, id_voltot(num), 'units', 'TJ')
                 end if
              else if ( num.eq.IDX_GravInput ) then
                 if ( jatidep.eq.1 ) then
                    ierr = nf90_def_var(ihisfile, trim(voltotname(num)), nf90_double, (/ id_timedim /), id_voltot(num))
                    ierr = nf90_put_att(ihisfile, id_voltot(num), 'units', 'TJ')
                 end if
              else if ( num.eq.IDX_SALInput .or. num.eq.IDX_SALInput2 ) then
                 if ( jaselfal.gt.0 ) then
                    ierr = nf90_def_var(ihisfile, trim(voltotname(num)), nf90_double, (/ id_timedim /), id_voltot(num))
                    ierr = nf90_put_att(ihisfile, id_voltot(num), 'units', 'TJ')
                 end if
              else
                 ierr = nf90_def_var(ihisfile, 'water_balance_'//trim(voltotname(num)), nf90_double, (/ id_timedim /), id_voltot(num))
                 ierr = nf90_put_att(ihisfile, id_voltot(num), 'units', 'm3')
              end if
           enddo
        end if

        if (jaoldstr == 1) then
           ntmp = ncgensg
        else
           ntmp = ngenstru
        end if
        if(jahiscgen > 0 .and. ntmp > 0) then

            ierr = nf90_def_dim(ihisfile, 'general_structures', ntmp, id_genstrudim)
            ierr = nf90_def_var(ihisfile, 'general_structure_id',  nf90_char,   (/ id_strlendim, id_genstrudim /), id_genstru_id)
            ierr = nf90_put_att(ihisfile, id_genstru_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_genstru_id,  'long_name', 'Id of general structure'    )

            ierr = nf90_def_var(ihisfile, 'general_structure_discharge',     nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_dis)
            !ierr = nf90_put_att(ihisfile, id_genstru_dis, 'standard_name', 'integral_of_discharge_wrt_time') ! TODO: introduce time windows in nc
            ierr = nf90_put_att(ihisfile, id_genstru_dis, 'long_name', 'Total discharge through general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_genstru_dis, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_crest_level', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_crestl)
            !ierr = nf90_put_att(ihisfile, id_genstru_crestl, 'standard_name', 'cgen_crest_level')
            ierr = nf90_put_att(ihisfile, id_genstru_crestl, 'long_name', 'Crest level of general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_crestl, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_genstru_crestl, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_crest_width', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_crestw)
            !ierr = nf90_put_att(ihisfile, id_genstru_crestw, 'standard_name', 'genstru_crest_width')
            ierr = nf90_put_att(ihisfile, id_genstru_crestw, 'long_name', 'Crest width of general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_crestw, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_genstru_crestw, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_gate_lower_edge_level', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_edgel)
            ierr = nf90_put_att(ihisfile, id_genstru_edgel, 'long_name', 'Gate lower edge level of general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_edgel, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_genstru_edgel, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_gate_opening_width', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_openw)
            ierr = nf90_put_att(ihisfile, id_genstru_openw, 'long_name', 'Gate opening width of general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_openw, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_genstru_openw, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_s1up',     nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_s1up)
            ierr = nf90_put_att(ihisfile, id_genstru_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_genstru_s1up, 'long_name', 'Water level upstream of general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_genstru_s1up, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_s1dn',     nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_s1dn)
            ierr = nf90_put_att(ihisfile, id_genstru_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_genstru_s1dn, 'long_name', 'Water level downstream of general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_genstru_s1dn, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_head', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_head)
            ierr = nf90_put_att(ihisfile, id_genstru_head, 'long_name', 'Head difference across general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_head, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_genstru_head, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_flow_area ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_au)
            ierr = nf90_put_att(ihisfile, id_genstru_au, 'long_name', 'Flow area at general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_au, 'units', 'm2')
            ierr = nf90_put_att(ihisfile, id_genstru_au, 'coordinates', 'general_structure_id')

            ierr = nf90_def_var(ihisfile, 'general_structure_velocity ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_vel)
            ierr = nf90_put_att(ihisfile, id_genstru_vel, 'long_name', 'Velocity through general structure')
            ierr = nf90_put_att(ihisfile, id_genstru_vel, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_genstru_vel, 'coordinates', 'general_structure_id')

            if (network%sts%numGeneralStructures > 0) then ! write extra fields for new general structure
               ierr = nf90_def_var(ihisfile, 'general_structure_discharge_through_gate_opening', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_dis_gate_open)
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_open, 'long_name', 'Discharge through gate opening of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_open, 'units', 'm3 s-1')
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_open, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_discharge_over_gate', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_dis_gate_over)
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_over, 'long_name', 'Discharge over gate of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_over, 'units', 'm3 s-1')
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_over, 'coordinates', 'general_structure_id')
               
               ierr = nf90_def_var(ihisfile, 'general_structure_discharge_under_gate', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_dis_gate_under)
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_under, 'long_name', 'Discharge under gate of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_under, 'units', 'm3 s-1')
               ierr = nf90_put_att(ihisfile, id_genstru_dis_gate_under, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_gate_opening_height', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_openh)
               ierr = nf90_put_att(ihisfile, id_genstru_openh, 'long_name', 'Gate opening height of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_openh, 'units', 'm')
               ierr = nf90_put_att(ihisfile, id_genstru_openh, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_gate_upper_edge_level', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_uppl)
               ierr = nf90_put_att(ihisfile, id_genstru_uppl, 'long_name', 'Gate upper edge level of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_uppl, 'units', 'm')
               ierr = nf90_put_att(ihisfile, id_genstru_uppl, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_velocity_through_gate_opening', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_velgateopen)
               ierr = nf90_put_att(ihisfile, id_genstru_velgateopen, 'long_name', 'Velocity through gate opening of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_velgateopen, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_genstru_velgateopen, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_velocity_over_gate ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_velgateover)
               ierr = nf90_put_att(ihisfile, id_genstru_velgateover, 'long_name', 'Velocity over gate of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_velgateover, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_genstru_velgateover, 'coordinates', 'general_structure_id')
               
               ierr = nf90_def_var(ihisfile, 'general_structure_velocity_under_gate ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_velgateunder)
               ierr = nf90_put_att(ihisfile, id_genstru_velgateunder, 'long_name', 'Velocity under gate of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_velgateunder, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_genstru_velgateunder, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_flow_area_in_gate_opening ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_au_open)
               ierr = nf90_put_att(ihisfile, id_genstru_au_open, 'long_name', 'Flow area in gate opening of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_au_open, 'units', 'm2')
               ierr = nf90_put_att(ihisfile, id_genstru_au_open, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_flow_area_over_gate ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_au_over)
               ierr = nf90_put_att(ihisfile, id_genstru_au_over, 'long_name', 'Flow area over gate of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_au_over, 'units', 'm2')
               ierr = nf90_put_att(ihisfile, id_genstru_au_over, 'coordinates', 'general_structure_id')
               
               ierr = nf90_def_var(ihisfile, 'general_structure_flow_area_under_gate ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_au_under)
               ierr = nf90_put_att(ihisfile, id_genstru_au_under, 'long_name', 'Flow area under gate of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_au_under, 'units', 'm2')
               ierr = nf90_put_att(ihisfile, id_genstru_au_under, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_state ', nf90_int, (/ id_genstrudim, id_timedim /), id_genstru_stat)
               ierr = nf90_put_att(ihisfile, id_genstru_stat, 'long_name', 'Flow state at general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_stat, 'units', '-')
               ierr = nf90_put_att(ihisfile, id_genstru_stat, 'units', '-')
               ierr = nf90_put_att(ihisfile, id_genstru_stat, 'coordinates', 'general_structure_id')
               ierr = nf90_put_att(ihisfile, id_genstru_stat, 'flag_values', (/ 0, 1, 2, 3, 4 /))
               ierr = nf90_put_att(ihisfile, id_genstru_stat, 'flag_meanings', 'no_flow weir_free weir_submerged gate_free gate_submerged')
               ierr = nf90_put_att(ihisfile, id_genstru_stat, 'valid_range', (/ 0, 4 /))
               ierr = nf90_put_att(ihisfile, id_genstru_stat, '_FillValue', int(dmiss))

               ierr = nf90_def_var(ihisfile, 'general_structure_s1_on_crest ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_s1crest)
               ierr = nf90_put_att(ihisfile, id_genstru_s1crest, 'long_name', 'Water level on crest of general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_s1crest, 'units', 'm')
               ierr = nf90_put_att(ihisfile, id_genstru_s1crest, 'coordinates', 'general_structure_id')

               ierr = nf90_def_var(ihisfile, 'general_structure_force_difference ', nf90_double, (/ id_genstrudim, id_timedim /), id_genstru_forcedif)
               ierr = nf90_put_att(ihisfile, id_genstru_forcedif, 'long_name', 'Force difference per unit at general structure')
               ierr = nf90_put_att(ihisfile, id_genstru_forcedif, 'units', 'N m-1')
               ierr = nf90_put_att(ihisfile, id_genstru_forcedif, 'coordinates', 'general_structure_id')
            end if
        endif

        if(jahispump > 0 .and. npumpsg > 0) then
            ierr = nf90_def_dim(ihisfile, 'pumps', npumpsg, id_pumpdim)
            ierr = nf90_def_var(ihisfile, 'pump_id',  nf90_char,   (/ id_strlendim, id_pumpdim /), id_pump_id)
            ierr = nf90_put_att(ihisfile, id_pump_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_pump_id,  'long_name', 'Id of pump'    )

            ierr = nf90_def_var(ihisfile, 'pump_xmid', nf90_double, (/ id_pumpdim /), id_pump_xmid)
            ierr = nf90_def_var(ihisfile, 'pump_ymid', nf90_double, (/ id_pumpdim /), id_pump_ymid)
            ierr = unc_addcoordatts(ihisfile, id_pump_xmid, id_pump_ymid, jsferic)
            ierr = nf90_put_att(ihisfile, id_pump_xmid, 'long_name', 'x-coordinate of representative mid point of pump location (snapped polyline)')
            ierr = nf90_put_att(ihisfile, id_pump_ymid, 'long_name', 'y-coordinate of representative mid point of pump location (snapped polyline)')

            ierr = nf90_def_var(ihisfile, 'pump_structure_discharge', nf90_double, (/ id_pumpdim, id_timedim /), id_pump_dis)
            ierr = nf90_put_att(ihisfile, id_pump_dis, 'long_name', 'Discharge through pump')
            ierr = nf90_put_att(ihisfile, id_pump_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_pump_dis, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_capacity', nf90_double, (/ id_pumpdim, id_timedim /), id_pump_cap)
            ierr = nf90_put_att(ihisfile, id_pump_cap, 'long_name', 'Capacity of pump')
            ierr = nf90_put_att(ihisfile, id_pump_cap, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_pump_cap, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_discharge_dir', nf90_double, (/ id_pumpdim, id_timedim /), id_pump_disdir)
            ierr = nf90_put_att(ihisfile, id_pump_disdir, 'long_name', 'Discharge of pump w.r.t. pump orientation')
            ierr = nf90_put_att(ihisfile, id_pump_disdir, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_pump_disdir, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_s1up',     nf90_double, (/ id_pumpdim, id_timedim /), id_pump_s1up)    ! Nabi
            ierr = nf90_put_att(ihisfile, id_pump_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_pump_s1up, 'long_name', 'Water level upstream of pump')
            ierr = nf90_put_att(ihisfile, id_pump_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_pump_s1up, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_s1dn',     nf90_double, (/ id_pumpdim, id_timedim /), id_pump_s1dn)
            ierr = nf90_put_att(ihisfile, id_pump_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_pump_s1dn, 'long_name', 'Water level downstream of pump')
            ierr = nf90_put_att(ihisfile, id_pump_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_pump_s1dn, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_structure_head', nf90_double, (/ id_pumpdim, id_timedim /), id_pump_struhead)
            ierr = nf90_put_att(ihisfile, id_pump_struhead, 'long_name', 'Head difference across pump structure')
            ierr = nf90_put_att(ihisfile, id_pump_struhead, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_pump_struhead, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_actual_stage',    nf90_int, (/ id_pumpdim, id_timedim /), id_pump_stage)
            ierr = nf90_put_att(ihisfile, id_pump_stage, 'long_name', 'Actual stage of pump')
            ierr = nf90_put_att(ihisfile, id_pump_stage, 'units', '-')
            ierr = nf90_put_att(ihisfile, id_pump_stage, 'coordinates', 'pump_id')
            ierr = nf90_put_att(ihisfile, id_pump_stage, '_FillValue', int(dmiss))

            ierr = nf90_def_var(ihisfile, 'pump_head', nf90_double, (/ id_pumpdim, id_timedim /), id_pump_head)
            ierr = nf90_put_att(ihisfile, id_pump_head, 'long_name', 'Head difference in pumping direction')
            ierr = nf90_put_att(ihisfile, id_pump_head, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_pump_head, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_reduction_factor',    nf90_double, (/ id_pumpdim, id_timedim /), id_pump_redufact)
            ierr = nf90_put_att(ihisfile, id_pump_redufact, 'long_name', 'Reduction factor of pump')
            ierr = nf90_put_att(ihisfile, id_pump_redufact, 'units', '-')
            ierr = nf90_put_att(ihisfile, id_pump_redufact, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_s1_delivery_side', nf90_double, (/ id_pumpdim, id_timedim /), id_pump_s1del)
            ierr = nf90_put_att(ihisfile, id_pump_s1del, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_pump_s1del, 'long_name', 'Water level at delivery side of pump')
            ierr = nf90_put_att(ihisfile, id_pump_s1del, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_pump_s1del, 'coordinates', 'pump_id')

            ierr = nf90_def_var(ihisfile, 'pump_s1_suction_side', nf90_double, (/ id_pumpdim, id_timedim /), id_pump_s1suc)
            ierr = nf90_put_att(ihisfile, id_pump_s1suc, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_pump_s1suc, 'long_name', 'Water level at suction side of pump')
            ierr = nf90_put_att(ihisfile, id_pump_s1suc, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_pump_s1suc, 'coordinates', 'pump_id')
        endif

        if(jahisgate > 0 .and. ngatesg > 0 ) then
            ierr = nf90_def_dim(ihisfile, 'gates', ngatesg, id_gatedim)
            ierr = nf90_def_var(ihisfile, 'gate_name',  nf90_char,   (/ id_strlendim, id_gatedim /), id_gatename)
            ierr = nf90_put_att(ihisfile, id_gatename,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_gatename,  'long_name', 'gate name'    )

            ierr = nf90_def_var(ihisfile, 'gate_discharge', nf90_double, (/ id_gatedim, id_timedim /), id_gate_dis)
            !ierr = nf90_put_att(ihisfile, id_gate_dis, 'standard_name', 'gate_discharge')
            ierr = nf90_put_att(ihisfile, id_gate_dis, 'long_name', 'gate discharge')
            ierr = nf90_put_att(ihisfile, id_gate_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_gate_dis, 'coordinates', 'gate_name')

            ierr = nf90_def_var(ihisfile, 'gate_lower_edge_level', nf90_double, (/ id_gatedim, id_timedim /), id_gate_edgel)
            ierr = nf90_put_att(ihisfile, id_gate_edgel, 'standard_name', 'gate_lower_edge_level')
            ierr = nf90_put_att(ihisfile, id_gate_edgel, 'long_name', 'gate lower edge level')
            ierr = nf90_put_att(ihisfile, id_gate_edgel, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gate_edgel, 'coordinates', 'gate_name')

            ierr = nf90_def_var(ihisfile, 'gate_s1up',     nf90_double, (/ id_gatedim, id_timedim /), id_gate_s1up)
            ierr = nf90_put_att(ihisfile, id_gate_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_gate_s1up, 'long_name', 'gate water level up')
            ierr = nf90_put_att(ihisfile, id_gate_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gate_s1up, 'coordinates', 'gate_name')

            ierr = nf90_def_var(ihisfile, 'gate_s1dn',     nf90_double, (/ id_gatedim, id_timedim /), id_gate_s1dn)
            ierr = nf90_put_att(ihisfile, id_gate_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_gate_s1dn, 'long_name', 'gate water level down')
            ierr = nf90_put_att(ihisfile, id_gate_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gate_s1dn, 'coordinates', 'gate_name')
        endif

         if(jahisgate > 0 .and. ngategen > 0 ) then
            ierr = nf90_def_dim(ihisfile, 'gategens', ngategen, id_gategendim)
            ierr = nf90_def_var(ihisfile, 'gategen_name',  nf90_char,   (/ id_strlendim, id_gategendim /), id_gategenname)
            ierr = nf90_put_att(ihisfile, id_gategenname,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_gategenname,  'long_name', 'gate name'    )

            ierr = nf90_def_var(ihisfile, 'gategen_discharge',     nf90_double, (/ id_gategendim, id_timedim /), id_gategen_dis)
            !ierr = nf90_put_att(ihisfile, id_gategen_dis, 'standard_name', 'integral_of_discharge_wrt_time') ! TODO: introduce time windows in nc
            ierr = nf90_put_att(ihisfile, id_gategen_dis, 'long_name', 'gate discharge (via general structure)')
            ierr = nf90_put_att(ihisfile, id_gategen_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_gategen_dis, 'coordinates', 'gategen_name')

            ierr = nf90_def_var(ihisfile, 'gategen_crest_level', nf90_double, (/ id_gategendim, id_timedim /), id_gategen_sillh)
            ierr = nf90_put_att(ihisfile, id_gategen_sillh, 'long_name', 'gate crest level (via general structure)')
            ierr = nf90_put_att(ihisfile, id_gategen_sillh, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gategen_sillh, 'coordinates', 'gategen_name')

            ierr = nf90_def_var(ihisfile, 'gategen_crest_width', nf90_double, (/ id_gategendim, id_timedim /), id_gategen_sillw)
            ierr = nf90_put_att(ihisfile, id_gategen_sillw, 'long_name', 'gate crest width (via general structure)')
            ierr = nf90_put_att(ihisfile, id_gategen_sillw, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gategen_sillw, 'coordinates', 'gategen_name')

            ierr = nf90_def_var(ihisfile, 'gategen_gate_lower_edge_level', nf90_double, (/ id_gategendim, id_timedim /), id_gategen_edgel)
            ierr = nf90_put_att(ihisfile, id_gategen_edgel, 'long_name', 'gate lower edge level (via general structure)')
            ierr = nf90_put_att(ihisfile, id_gategen_edgel, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gategen_edgel, 'coordinates', 'gategen_name')

            ierr = nf90_def_var(ihisfile, 'gategen_flow_through_height', nf90_double, (/ id_gategendim, id_timedim /), id_gategen_flowh)
            ierr = nf90_put_att(ihisfile, id_gategen_flowh, 'standard_name', 'gategen_flow_through_height')
            ierr = nf90_put_att(ihisfile, id_gategen_flowh, 'long_name', 'gate flow through height (via general structure)')
            ierr = nf90_put_att(ihisfile, id_gategen_flowh, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gategen_flowh, 'coordinates', 'gategen_name')

            ierr = nf90_def_var(ihisfile, 'gategen_gate_opening_width', nf90_double, (/ id_gategendim, id_timedim /), id_gategen_openw)
            ierr = nf90_put_att(ihisfile, id_gategen_openw, 'long_name', 'gate opening width (via general structure)')
            ierr = nf90_put_att(ihisfile, id_gategen_openw, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gategen_openw, 'coordinates', 'gategen_name')

            ierr = nf90_def_var(ihisfile, 'gategen_s1up',     nf90_double, (/ id_gategendim, id_timedim /), id_gategen_s1up)
            ierr = nf90_put_att(ihisfile, id_gategen_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_gategen_s1up, 'long_name', 'gate water level up (via general structure)')
            ierr = nf90_put_att(ihisfile, id_gategen_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gategen_s1up, 'coordinates', 'gategen_name')

            ierr = nf90_def_var(ihisfile, 'gategen_s1dn',     nf90_double, (/ id_gategendim, id_timedim /), id_gategen_s1dn)
            ierr = nf90_put_att(ihisfile, id_gategen_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_gategen_s1dn, 'long_name', 'gate water level down (via general structure)')
            ierr = nf90_put_att(ihisfile, id_gategen_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_gategen_s1dn, 'coordinates', 'gategen_name')
        endif

        if(jahiscdam > 0 .and. ncdamsg > 0 ) then
            ierr = nf90_def_dim(ihisfile, 'dams', ncdamsg, id_cdamdim)
            !ierr = nf90_def_dim(ihisfile, 'cdam_name_len', 64, id_cdamlendim)
            ierr = nf90_def_var(ihisfile, 'cdam_name',  nf90_char,   (/ id_strlendim, id_cdamdim /), id_cdamname)
            ierr = nf90_put_att(ihisfile, id_cdamname,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_cdamname,  'long_name', 'controllable dam name'    )

            ierr = nf90_def_var(ihisfile, 'cdam_discharge',     nf90_double, (/ id_cdamdim, id_timedim /), id_cdam_dis)
            !ierr = nf90_put_att(ihisfile, id_cdam_dis, 'standard_name', 'cdam_discharge')
            ierr = nf90_put_att(ihisfile, id_cdam_dis, 'long_name', 'controllable dam discharge')
            ierr = nf90_put_att(ihisfile, id_cdam_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_cdam_dis, 'coordinates', 'cdam_name')

            ierr = nf90_def_var(ihisfile, 'cdam_crest_level',     nf90_double, (/ id_cdamdim, id_timedim /), id_cdam_crestl)
            !ierr = nf90_put_att(ihisfile, id_cdam_crestl, 'standard_name', 'cdam_crest_level')
            ierr = nf90_put_att(ihisfile, id_cdam_crestl, 'long_name', 'controllable dam crest level')
            ierr = nf90_put_att(ihisfile, id_cdam_crestl, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_cdam_crestl, 'coordinates', 'cdam_name')

            ierr = nf90_def_var(ihisfile, 'cdam_s1up',     nf90_double, (/ id_cdamdim, id_timedim /), id_cdam_s1up)
            ierr = nf90_put_att(ihisfile, id_cdam_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_cdam_s1up, 'long_name', 'controllable dam water level up')
            ierr = nf90_put_att(ihisfile, id_cdam_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_cdam_s1up, 'coordinates', 'cdam_name')

            ierr = nf90_def_var(ihisfile, 'cdam_s1dn',     nf90_double, (/ id_cdamdim, id_timedim /), id_cdam_s1dn)
            ierr = nf90_put_att(ihisfile, id_cdam_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_cdam_s1dn, 'long_name', 'controllable dam water level down')
            ierr = nf90_put_att(ihisfile, id_cdam_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_cdam_s1dn, 'coordinates', 'cdam_name')
        endif

        if(jahisweir > 0 .and. nweirgen > 0 ) then
            ierr = nf90_def_dim(ihisfile, 'weirgens', nweirgen, id_weirgendim)
            ierr = nf90_def_var(ihisfile, 'weirgen_id',  nf90_char,   (/ id_strlendim, id_weirgendim /), id_weirgen_id)
            ierr = nf90_put_att(ihisfile, id_weirgen_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_weirgen_id,  'long_name', 'Id of weir'    )

            ierr = nf90_def_var(ihisfile, 'weirgen_discharge',     nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_dis)
            !ierr = nf90_put_att(ihisfile, id_weirgen_dis, 'standard_name', 'integral_of_discharge_wrt_time') ! TODO: introduce time windows in nc
            ierr = nf90_put_att(ihisfile, id_weirgen_dis, 'long_name', 'Discharge through weir')
            ierr = nf90_put_att(ihisfile, id_weirgen_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_weirgen_dis, 'coordinates', 'weirgen_id')

            ierr = nf90_def_var(ihisfile, 'weirgen_crest_level', nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_crestl)
            !ierr = nf90_put_att(ihisfile, id_weirgen_crestl, 'standard_name', 'weirgen_crest_level')
            ierr = nf90_put_att(ihisfile, id_weirgen_crestl, 'long_name', 'Crest level of weir')
            ierr = nf90_put_att(ihisfile, id_weirgen_crestl, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_weirgen_crestl, 'coordinates', 'weirgen_id')

            ierr = nf90_def_var(ihisfile, 'weirgen_crest_width', nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_crestw)
            !ierr = nf90_put_att(ihisfile, id_weirgen_crestw, 'standard_name', 'weirgen_crest_width')
            ierr = nf90_put_att(ihisfile, id_weirgen_crestw, 'long_name', 'Crest width of weir')
            ierr = nf90_put_att(ihisfile, id_weirgen_crestw, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_weirgen_crestw, 'coordinates', 'weirgen_id')

            ierr = nf90_def_var(ihisfile, 'weirgen_s1up',     nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_s1up)
            ierr = nf90_put_att(ihisfile, id_weirgen_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_weirgen_s1up, 'long_name', 'Water level upstream of weir')
            ierr = nf90_put_att(ihisfile, id_weirgen_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_weirgen_s1up, 'coordinates', 'weirgen_id')

            ierr = nf90_def_var(ihisfile, 'weirgen_s1dn',     nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_s1dn)
            ierr = nf90_put_att(ihisfile, id_weirgen_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_weirgen_s1dn, 'long_name', 'Water level downstream of weir')
            ierr = nf90_put_att(ihisfile, id_weirgen_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_weirgen_s1dn, 'coordinates', 'weirgen_id')

            if (network%sts%numWeirs > 0) then ! write extra files for new weirs
               ierr = nf90_def_var(ihisfile, 'weirgen_structure_head', nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_head)
               ierr = nf90_put_att(ihisfile, id_weirgen_head, 'long_name', 'Head difference across weir')
               ierr = nf90_put_att(ihisfile, id_weirgen_head, 'units', 'm')
               ierr = nf90_put_att(ihisfile, id_weirgen_head, 'coordinates', 'weirgen_id')

               ierr = nf90_def_var(ihisfile, 'weirgen_velocity', nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_vel)
               ierr = nf90_put_att(ihisfile, id_weirgen_vel, 'long_name', 'Velocity through weir')
               ierr = nf90_put_att(ihisfile, id_weirgen_vel, 'units', 'm s-1')
               ierr = nf90_put_att(ihisfile, id_weirgen_vel, 'coordinates', 'weirgen_id')

               ierr = nf90_def_var(ihisfile, 'weirgen_flow_area', nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_au)
               ierr = nf90_put_att(ihisfile, id_weirgen_au, 'long_name', 'Flow area at weir')
               ierr = nf90_put_att(ihisfile, id_weirgen_au, 'units', 'm2')
               ierr = nf90_put_att(ihisfile, id_weirgen_au, 'coordinates', 'weirgen_id')

               ierr = nf90_def_var(ihisfile, 'weirgen_state', nf90_int, (/ id_weirgendim, id_timedim /), id_weir_stat)
               ierr = nf90_put_att(ihisfile, id_weir_stat, 'long_name', 'Flow state at weir')
               ierr = nf90_put_att(ihisfile, id_weir_stat, 'units', '-')
               ierr = nf90_put_att(ihisfile, id_weir_stat, 'coordinates', 'weirgen_id')
               ierr = nf90_put_att(ihisfile, id_weir_stat, 'flag_values', (/ 0, 1, 2 /))
               ierr = nf90_put_att(ihisfile, id_weir_stat, 'flag_meanings', 'no_flow weir_free weir_submerged')
               ierr = nf90_put_att(ihisfile, id_weir_stat, 'valid_range', (/ 0, 2 /))
               ierr = nf90_put_att(ihisfile, id_weir_stat, '_FillValue', int(dmiss))

               ierr = nf90_def_var(ihisfile, 'weirgen_force_difference', nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_forcedif)
               ierr = nf90_put_att(ihisfile, id_weirgen_forcedif, 'long_name', 'Force difference per unit width at weir')
               ierr = nf90_put_att(ihisfile, id_weirgen_forcedif, 'units', 'N m-1')
               ierr = nf90_put_att(ihisfile, id_weirgen_forcedif, 'coordinates', 'weirgen_id')

               ierr = nf90_def_var(ihisfile, 'weirgen_s1_on_crest', nf90_double, (/ id_weirgendim, id_timedim /), id_weirgen_s1crest)
               ierr = nf90_put_att(ihisfile, id_weirgen_s1crest, 'long_name', 'Water level on crest of weir')
               ierr = nf90_put_att(ihisfile, id_weirgen_s1crest, 'units', 'm')
               ierr = nf90_put_att(ihisfile, id_weirgen_s1crest, 'coordinates', 'weirgen_id')
            end if
        endif

        ! Orifice
        if(jahisorif > 0 .and. network%sts%numOrifices > 0) then
            ierr = nf90_def_dim(ihisfile, 'orifice', network%sts%numOrifices, id_orifgendim)
            ierr = nf90_def_var(ihisfile, 'orifice_id',  nf90_char,   (/ id_strlendim, id_orifgendim /), id_orifgen_id)
            ierr = nf90_put_att(ihisfile, id_orifgen_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_orifgen_id,  'long_name', 'Id of orifice')

            ierr = nf90_def_var(ihisfile, 'orifice_discharge',     nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_dis)
            ierr = nf90_put_att(ihisfile, id_orifgen_dis, 'long_name', 'Discharge through orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_orifgen_dis, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_crest_level', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_crestl)
            ierr = nf90_put_att(ihisfile, id_orifgen_crestl, 'long_name', 'Crest level of orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_crestl, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_orifgen_crestl, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_crest_width', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_crestw)
            ierr = nf90_put_att(ihisfile, id_orifgen_crestw, 'long_name', 'Crest width of orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_crestw, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_orifgen_crestw, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_gate_lower_edge_level', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_edgel)
            ierr = nf90_put_att(ihisfile, id_orifgen_edgel, 'long_name', 'Gate lower edge level of orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_edgel, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_orifgen_edgel, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_s1up',     nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_s1up)
            ierr = nf90_put_att(ihisfile, id_orifgen_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_orifgen_s1up, 'long_name', 'Water level upstream of orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_orifgen_s1up, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_s1dn',     nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_s1dn)
            ierr = nf90_put_att(ihisfile, id_orifgen_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_orifgen_s1dn, 'long_name', 'Water level downstream of orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_orifgen_s1dn, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_gate_opening_height', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_openh)
            ierr = nf90_put_att(ihisfile, id_orifgen_openh, 'long_name', 'Gate opening height of orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_openh, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_orifgen_openh, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_head', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_head)
            ierr = nf90_put_att(ihisfile, id_orifgen_head, 'long_name', 'Head difference across orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_head, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_orifgen_head, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_flow_area ', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_au)
            ierr = nf90_put_att(ihisfile, id_orifgen_au, 'long_name', 'Flow area at orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_au, 'units', 'm2')
            ierr = nf90_put_att(ihisfile, id_orifgen_au, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_state ', nf90_int, (/ id_orifgendim, id_timedim /), id_orifgen_stat)
            ierr = nf90_put_att(ihisfile, id_orifgen_stat, 'long_name', 'Flow state at orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_stat, 'units', '-')
            ierr = nf90_put_att(ihisfile, id_orifgen_stat, 'units', '-')
            ierr = nf90_put_att(ihisfile, id_orifgen_stat, 'coordinates', 'orifice_id')
            ierr = nf90_put_att(ihisfile, id_orifgen_stat, 'flag_values', (/ 0, 1, 2, 3, 4 /))
            ierr = nf90_put_att(ihisfile, id_orifgen_stat, 'flag_meanings', 'no_flow weir_free weir_submerged gate_free gate_submerged')
            ierr = nf90_put_att(ihisfile, id_orifgen_stat, 'valid_range', (/ 0, 4 /))
            ierr = nf90_put_att(ihisfile, id_orifgen_stat, '_FillValue', int(dmiss))

            ierr = nf90_def_var(ihisfile, 'orifice_s1_on_crest ', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_s1crest)
            ierr = nf90_put_att(ihisfile, id_orifgen_s1crest, 'long_name', 'Water level on crest of orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_s1crest, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_orifgen_s1crest, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_velocity ', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_vel)
            ierr = nf90_put_att(ihisfile, id_orifgen_vel, 'long_name', 'Velocity through orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_vel, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_orifgen_vel, 'coordinates', 'orifice_id')

            ierr = nf90_def_var(ihisfile, 'orifice_force_difference ', nf90_double, (/ id_orifgendim, id_timedim /), id_orifgen_forcedif)
            ierr = nf90_put_att(ihisfile, id_orifgen_forcedif, 'long_name', 'Force difference per unit width at orifice')
            ierr = nf90_put_att(ihisfile, id_orifgen_forcedif, 'units', 'N m-1')
            ierr = nf90_put_att(ihisfile, id_orifgen_forcedif, 'coordinates', 'orifice_id')
        endif

        ! Bridge
        if(jahisbridge > 0 .and. network%sts%numBridges > 0) then
            ierr = nf90_def_dim(ihisfile, 'bridge', network%sts%numbridges, id_bridgedim)
            ierr = nf90_def_var(ihisfile, 'bridge_id',  nf90_char,   (/ id_strlendim, id_bridgedim /), id_bridge_id)
            ierr = nf90_put_att(ihisfile, id_bridge_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_bridge_id,  'long_name', 'Id of bridge')

            ierr = nf90_def_var(ihisfile, 'bridge_discharge',     nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_dis)
            ierr = nf90_put_att(ihisfile, id_bridge_dis, 'long_name', 'Discharge through bridge')
            ierr = nf90_put_att(ihisfile, id_bridge_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_bridge_dis, 'coordinates', 'bridge_id')

            ierr = nf90_def_var(ihisfile, 'bridge_s1up',     nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_s1up)
            ierr = nf90_put_att(ihisfile, id_bridge_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_bridge_s1up, 'long_name', 'Water level upstream of bridge')
            ierr = nf90_put_att(ihisfile, id_bridge_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_bridge_s1up, 'coordinates', 'bridge_id')

            ierr = nf90_def_var(ihisfile, 'bridge_s1dn',     nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_s1dn)
            ierr = nf90_put_att(ihisfile, id_bridge_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_bridge_s1dn, 'long_name', 'Water level downstream of bridge')
            ierr = nf90_put_att(ihisfile, id_bridge_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_bridge_s1dn, 'coordinates', 'bridge_id')

            ierr = nf90_def_var(ihisfile, 'bridge_head', nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_head)
            ierr = nf90_put_att(ihisfile, id_bridge_head, 'long_name', 'Head difference across bridge')
            ierr = nf90_put_att(ihisfile, id_bridge_head, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_bridge_head, 'coordinates', 'bridge_id')

            ierr = nf90_def_var(ihisfile, 'bridge_flow_area ', nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_au)
            ierr = nf90_put_att(ihisfile, id_bridge_au, 'long_name', 'Flow area at bridge')
            ierr = nf90_put_att(ihisfile, id_bridge_au, 'units', 'm2')
            ierr = nf90_put_att(ihisfile, id_bridge_au, 'coordinates', 'bridge_id')

            ierr = nf90_def_var(ihisfile, 'bridge_velocity ', nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_vel)
            ierr = nf90_put_att(ihisfile, id_bridge_vel, 'long_name', 'Velocity through bridge')
            ierr = nf90_put_att(ihisfile, id_bridge_vel, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_bridge_vel, 'coordinates', 'bridge_id')

            ierr = nf90_def_var(ihisfile, 'bridge_blup',  nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_blup)
            ierr = nf90_put_att(ihisfile, id_bridge_blup, 'standard_name', 'altitude')
            ierr = nf90_put_att(ihisfile, id_bridge_blup, 'long_name', 'Bed level at upstream of bridge')
            ierr = nf90_put_att(ihisfile, id_bridge_blup, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_bridge_blup, 'coordinates', 'bridge_id')

            ierr = nf90_def_var(ihisfile, 'bridge_bldn',  nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_bldn)
            ierr = nf90_put_att(ihisfile, id_bridge_bldn, 'standard_name', 'altitude')
            ierr = nf90_put_att(ihisfile, id_bridge_bldn, 'long_name', 'Bed level at downstream of bridge')
            ierr = nf90_put_att(ihisfile, id_bridge_bldn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_bridge_bldn, 'coordinates', 'bridge_id')

            ierr = nf90_def_var(ihisfile, 'bridge_bl_actual',  nf90_double, (/ id_bridgedim, id_timedim /), id_bridge_bl_act)
            ierr = nf90_put_att(ihisfile, id_bridge_bl_act, 'standard_name', 'altitude')
            ierr = nf90_put_att(ihisfile, id_bridge_bl_act, 'long_name', 'Actual bed level of bridge (crest)')
            ierr = nf90_put_att(ihisfile, id_bridge_bl_act, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_bridge_bl_act, 'coordinates', 'bridge_id')
        endif

        ! Culvert
        if(jahisculv > 0 .and. network%sts%numculverts > 0) then
            ierr = nf90_def_dim(ihisfile, 'culvert', network%sts%numculverts, id_culvertdim)
            ierr = nf90_def_var(ihisfile, 'culvert_id',  nf90_char,   (/ id_strlendim, id_culvertdim /), id_culvert_id)
            ierr = nf90_put_att(ihisfile, id_culvert_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_culvert_id,  'long_name', 'Id of culvert'    )

            ierr = nf90_def_var(ihisfile, 'culvert_discharge',     nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_dis)
            ierr = nf90_put_att(ihisfile, id_culvert_dis, 'long_name', 'Discharge through culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_culvert_dis, 'coordinates', 'culvert_id')

            ierr = nf90_def_var(ihisfile, 'culvert_crest_level', nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_crestl)
            ierr = nf90_put_att(ihisfile, id_culvert_crestl, 'long_name', 'Crest level of culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_crestl, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_culvert_crestl, 'coordinates', 'culvert_id')

            ierr = nf90_def_var(ihisfile, 'culvert_gate_lower_edge_level', nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_edgel)
            ierr = nf90_put_att(ihisfile, id_culvert_edgel, 'long_name', 'Gate lower edge level of culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_edgel, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_culvert_edgel, 'coordinates', 'culvert_id')

            ierr = nf90_def_var(ihisfile, 'culvert_s1up',     nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_s1up)
            ierr = nf90_put_att(ihisfile, id_culvert_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_culvert_s1up, 'long_name', 'Water level upstream of culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_culvert_s1up, 'coordinates', 'culvert_id')

            ierr = nf90_def_var(ihisfile, 'culvert_s1dn',     nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_s1dn)
            ierr = nf90_put_att(ihisfile, id_culvert_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_culvert_s1dn, 'long_name', 'Water level downstream of culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_culvert_s1dn, 'coordinates', 'culvert_id')

            ierr = nf90_def_var(ihisfile, 'culvert_gate_opening_height', nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_openh)
            ierr = nf90_put_att(ihisfile, id_culvert_openh, 'long_name', 'Gate opening height of culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_openh, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_culvert_openh, 'coordinates', 'culvert_id')

            ierr = nf90_def_var(ihisfile, 'culvert_head', nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_head)
            ierr = nf90_put_att(ihisfile, id_culvert_head, 'long_name', 'Head difference across culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_head, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_culvert_head, 'coordinates', 'culvert_id')

            ierr = nf90_def_var(ihisfile, 'culvert_flow_area ', nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_au)
            ierr = nf90_put_att(ihisfile, id_culvert_au, 'long_name', 'Flow area in culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_au, 'units', 'm2')
            ierr = nf90_put_att(ihisfile, id_culvert_au, 'coordinates', 'culvert_id')

            ierr = nf90_def_var(ihisfile, 'culvert_state ', nf90_int, (/ id_culvertdim, id_timedim /), id_culvert_stat)
            ierr = nf90_put_att(ihisfile, id_culvert_stat, 'long_name', 'Flow state in culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_stat, 'units', '-')
            ierr = nf90_put_att(ihisfile, id_culvert_stat, 'coordinates', 'culvert_id')
            ierr = nf90_put_att(ihisfile, id_culvert_stat, 'flag_values', (/ 0, 1, 2/))
            ierr = nf90_put_att(ihisfile, id_culvert_stat, 'flag_meanings', 'no_flow culvert_free culvert_submerged')
            ierr = nf90_put_att(ihisfile, id_culvert_stat, 'valid_range', (/ 0, 2 /))
            ierr = nf90_put_att(ihisfile, id_culvert_stat, '_FillValue', int(dmiss))

            ierr = nf90_def_var(ihisfile, 'culvert_velocity ', nf90_double, (/ id_culvertdim, id_timedim /), id_culvert_vel)
            ierr = nf90_put_att(ihisfile, id_culvert_vel, 'long_name', 'Velocity in culvert')
            ierr = nf90_put_att(ihisfile, id_culvert_vel, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_culvert_vel, 'coordinates', 'culvert_id')
        endif


        ! Dambreak
        if (jahisdambreak > 0 .and. ndambreaksg > 0 ) then
            ierr = nf90_def_dim(ihisfile, 'dambreaks', ndambreaksg, id_dambreakdim)
            ierr = nf90_def_var(ihisfile, 'dambreak_id',  nf90_char,   (/ id_strlendim, id_dambreakdim /), id_dambreak_id)
            ierr = nf90_put_att(ihisfile, id_dambreak_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_dambreak_id,  'long_name', 'Id of dambreak')

            ierr = nf90_def_var(ihisfile, 'dambreak_s1up', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_s1up)
            ierr = nf90_put_att(ihisfile, id_dambreak_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_dambreak_s1up, 'long_name', 'Water level upstream of dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_dambreak_s1up, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_s1dn',     nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_s1dn)
            ierr = nf90_put_att(ihisfile, id_dambreak_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_dambreak_s1dn, 'long_name', 'Water level downstream of dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_dambreak_s1dn, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_discharge', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_discharge)
            ierr = nf90_put_att(ihisfile, id_dambreak_discharge, 'long_name', 'Instantaneous discharge through dambreaks')
            ierr = nf90_put_att(ihisfile, id_dambreak_discharge, 'units', 'm3 s-1') !link_sum
            ierr = nf90_put_att(ihisfile, id_dambreak_discharge, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_cumulative_discharge', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_cumulative_discharge)
            ierr = nf90_put_att(ihisfile, id_dambreak_cumulative_discharge, 'long_name', 'Cumulative discharge through dambreaks')
            ierr = nf90_put_att(ihisfile, id_dambreak_cumulative_discharge, 'units', 'm3') !link_sum
            ierr = nf90_put_att(ihisfile, id_dambreak_cumulative_discharge, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_breach_width_time_derivative', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_breach_width_time_derivative)
            ierr = nf90_put_att(ihisfile, id_dambreak_breach_width_time_derivative, 'long_name', 'Breach width time derivative of dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_breach_width_time_derivative, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_dambreak_breach_width_time_derivative, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_water_level_jump', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_water_level_jump)
            ierr = nf90_put_att(ihisfile, id_dambreak_water_level_jump, 'long_name', 'Breach water level jump of dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_water_level_jump, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_dambreak_water_level_jump, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_normal_velocity', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_normal_velocity)
            ierr = nf90_put_att(ihisfile, id_dambreak_normal_velocity, 'long_name', 'Normal velocity through dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_normal_velocity, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_dambreak_normal_velocity, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_structure_head', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_head)
            ierr = nf90_put_att(ihisfile, id_dambreak_head, 'long_name', 'Head difference across dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_head, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_dambreak_head, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_flow_area ', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_au)
            ierr = nf90_put_att(ihisfile, id_dambreak_au, 'long_name', 'Flow area at dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_au, 'units', 'm2')
            ierr = nf90_put_att(ihisfile, id_dambreak_au, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_crest_level', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_cresth)
            ierr = nf90_put_att(ihisfile, id_dambreak_cresth, 'long_name', 'Crest level of dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_cresth, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_dambreak_cresth, 'coordinates', 'dambreak_id')

            ierr = nf90_def_var(ihisfile, 'dambreak_crest_width', nf90_double, (/ id_dambreakdim, id_timedim /), id_dambreak_crestw)
            ierr = nf90_put_att(ihisfile, id_dambreak_crestw, 'long_name', 'Crest width of dambreak')
            ierr = nf90_put_att(ihisfile, id_dambreak_crestw, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_dambreak_crestw, 'coordinates', 'dambreak_id')
        endif

        ! Universal weir
        if(jahisuniweir > 0 .and. network%sts%numuniweirs > 0) then
            ierr = nf90_def_dim(ihisfile, 'universalWeirs', network%sts%numuniweirs, id_uniweirdim)
            ierr = nf90_def_var(ihisfile, 'uniweir_id',  nf90_char,   (/ id_strlendim, id_uniweirdim /), id_uniweir_id)
            ierr = nf90_put_att(ihisfile, id_uniweir_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_uniweir_id,  'long_name', 'Id of universal weir'    )

            ierr = nf90_def_var(ihisfile, 'uniweir_discharge',     nf90_double, (/ id_uniweirdim, id_timedim /), id_uniweir_dis)
            ierr = nf90_put_att(ihisfile, id_uniweir_dis, 'long_name', 'Discharge through universal weir')
            ierr = nf90_put_att(ihisfile, id_uniweir_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_uniweir_dis, 'coordinates', 'uniweir_id')

            ierr = nf90_def_var(ihisfile, 'uniweir_crest_level', nf90_double, (/ id_uniweirdim, id_timedim /), id_uniweir_crestl)
            ierr = nf90_put_att(ihisfile, id_uniweir_crestl, 'long_name', 'Crest level of universal weir')
            ierr = nf90_put_att(ihisfile, id_uniweir_crestl, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_uniweir_crestl, 'coordinates', 'uniweir_id')

            ierr = nf90_def_var(ihisfile, 'uniweir_s1up',     nf90_double, (/ id_uniweirdim, id_timedim /), id_uniweir_s1up)
            ierr = nf90_put_att(ihisfile, id_uniweir_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_uniweir_s1up, 'long_name', 'Water level upstream of universal weir')
            ierr = nf90_put_att(ihisfile, id_uniweir_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_uniweir_s1up, 'coordinates', 'uniweir_id')

            ierr = nf90_def_var(ihisfile, 'uniweir_s1dn',     nf90_double, (/ id_uniweirdim, id_timedim /), id_uniweir_s1dn)
            ierr = nf90_put_att(ihisfile, id_uniweir_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_uniweir_s1dn, 'long_name', 'Water level downstream of universal weir')
            ierr = nf90_put_att(ihisfile, id_uniweir_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_uniweir_s1dn, 'coordinates', 'uniweir_id')

            ierr = nf90_def_var(ihisfile, 'uniweir_head', nf90_double, (/ id_uniweirdim, id_timedim /), id_uniweir_head)
            ierr = nf90_put_att(ihisfile, id_uniweir_head, 'long_name', 'Head difference across universal weir')
            ierr = nf90_put_att(ihisfile, id_uniweir_head, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_uniweir_head, 'coordinates', 'uniweir_id')

            ierr = nf90_def_var(ihisfile, 'uniweir_flow_area ', nf90_double, (/ id_uniweirdim, id_timedim /), id_uniweir_au)
            ierr = nf90_put_att(ihisfile, id_uniweir_au, 'long_name', 'Flow area in universal weir')
            ierr = nf90_put_att(ihisfile, id_uniweir_au, 'units', 'm2')
            ierr = nf90_put_att(ihisfile, id_uniweir_au, 'coordinates', 'uniweir_id')

            ierr = nf90_def_var(ihisfile, 'uniweir_velocity ', nf90_double, (/ id_uniweirdim, id_timedim /), id_uniweir_vel)
            ierr = nf90_put_att(ihisfile, id_uniweir_vel, 'long_name', 'Velocity through universal weir')
            ierr = nf90_put_att(ihisfile, id_uniweir_vel, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_uniweir_vel, 'coordinates', 'uniweir_id')
        endif

        ! compound structure
        if(jahiscmpstru > 0 .and. network%cmps%count > 0) then
            ierr = nf90_def_dim(ihisfile, 'compoundStructures', network%cmps%count, id_cmpstrudim)
            ierr = nf90_def_var(ihisfile, 'cmpstru_id',  nf90_char,   (/ id_strlendim, id_cmpstrudim /), id_cmpstru_id)
            ierr = nf90_put_att(ihisfile, id_cmpstru_id,  'cf_role',   'timeseries_id')
            ierr = nf90_put_att(ihisfile, id_cmpstru_id,  'long_name', 'Id of compound structure')

            ierr = nf90_def_var(ihisfile, 'cmpstru_discharge',     nf90_double, (/ id_cmpstrudim, id_timedim /), id_cmpstru_dis)
            ierr = nf90_put_att(ihisfile, id_cmpstru_dis, 'long_name', 'Discharge through compound structure')
            ierr = nf90_put_att(ihisfile, id_cmpstru_dis, 'units', 'm3 s-1')
            ierr = nf90_put_att(ihisfile, id_cmpstru_dis, 'coordinates', 'cmpstru_id')

            ierr = nf90_def_var(ihisfile, 'cmpstru_s1up',     nf90_double, (/ id_cmpstrudim, id_timedim /), id_cmpstru_s1up)
            ierr = nf90_put_att(ihisfile, id_cmpstru_s1up, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_cmpstru_s1up, 'long_name', 'Water level upstream of compound structure')
            ierr = nf90_put_att(ihisfile, id_cmpstru_s1up, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_cmpstru_s1up, 'coordinates', 'cmpstru_id')

            ierr = nf90_def_var(ihisfile, 'cmpstru_s1dn',     nf90_double, (/ id_cmpstrudim, id_timedim /), id_cmpstru_s1dn)
            ierr = nf90_put_att(ihisfile, id_cmpstru_s1dn, 'standard_name', 'sea_surface_height')
            ierr = nf90_put_att(ihisfile, id_cmpstru_s1dn, 'long_name', 'Water level downstream of compound structure')
            ierr = nf90_put_att(ihisfile, id_cmpstru_s1dn, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_cmpstru_s1dn, 'coordinates', 'cmpstru_id')

            ierr = nf90_def_var(ihisfile, 'cmpstru_head', nf90_double, (/ id_cmpstrudim, id_timedim /), id_cmpstru_head)
            ierr = nf90_put_att(ihisfile, id_cmpstru_head, 'long_name', 'Head difference across compound structure')
            ierr = nf90_put_att(ihisfile, id_cmpstru_head, 'units', 'm')
            ierr = nf90_put_att(ihisfile, id_cmpstru_head, 'coordinates', 'cmpstru_id')

            ierr = nf90_def_var(ihisfile, 'cmpstru_flow_area ', nf90_double, (/ id_cmpstrudim, id_timedim /), id_cmpstru_au)
            ierr = nf90_put_att(ihisfile, id_cmpstru_au, 'long_name', 'Flow area in compound structure')
            ierr = nf90_put_att(ihisfile, id_cmpstru_au, 'units', 'm2')
            ierr = nf90_put_att(ihisfile, id_cmpstru_au, 'coordinates', 'cmpstru_id')

            ierr = nf90_def_var(ihisfile, 'cmpstru_velocity ', nf90_double, (/ id_cmpstrudim, id_timedim /), id_cmpstru_vel)
            ierr = nf90_put_att(ihisfile, id_cmpstru_vel, 'long_name', 'Velocity through compound structure')
            ierr = nf90_put_att(ihisfile, id_cmpstru_vel, 'units', 'm s-1')
            ierr = nf90_put_att(ihisfile, id_cmpstru_vel, 'coordinates', 'cmpstru_id')
        endif

        if(dad_included) then  ! Output for dredging and dumping
            ierr = nf90_def_dim(ihisfile, 'ndredlink', dadpar%nalink, id_dredlinkdim)
            ierr = nf90_def_dim(ihisfile, 'ndred', dadpar%nadred+dadpar%nasupl, id_dreddim)
            ierr = nf90_def_dim(ihisfile, 'ndump', dadpar%nadump, id_dumpdim)

            ierr = nf90_def_var(ihisfile, 'dredge_area_name',         nf90_char,   (/ id_strlendim, id_dreddim /), id_dred_name)
            ierr = nf90_put_att(ihisfile, id_dred_name,  'long_name'    , 'dredge area identifier')

            ierr = nf90_def_var(ihisfile, 'dump_area_name',         nf90_char,   (/ id_strlendim, id_dumpdim /), id_dump_name)
            ierr = nf90_put_att(ihisfile, id_dump_name,  'long_name'    , 'dump area identifier')

            ierr = nf90_def_var(ihisfile, 'dred_link_discharge',     nf90_double, (/ id_dredlinkdim, id_sedtotdim, id_timedim /), id_dredlink_dis)
            ierr = nf90_put_att(ihisfile, id_dredlink_dis, 'long_name', 'Cumulative dredged material transported via links per fraction')
            ierr = nf90_put_att(ihisfile, id_dredlink_dis, 'units', 'm3') !link_sum

            ierr = nf90_def_var(ihisfile, 'dred_discharge',     nf90_double, (/ id_dreddim, id_timedim /), id_dred_dis)
            ierr = nf90_put_att(ihisfile, id_dred_dis, 'long_name', 'Cumulative dredged material for dredge areas')
            ierr = nf90_put_att(ihisfile, id_dred_dis, 'units', 'm3') !totvoldred

            ierr = nf90_def_var(ihisfile, 'dump_discharge',     nf90_double, (/ id_dumpdim, id_timedim /), id_dump_dis)
            ierr = nf90_put_att(ihisfile, id_dump_dis, 'long_name', 'Cumulative dredged material for dump areas')
            ierr = nf90_put_att(ihisfile, id_dump_dis, 'units', 'm3') !totvoldump

            !ierr = nf90_def_var(ihisfile, 'dred_discharge_frac',     nf90_double, (/ id_dreddim, id_sedtotdim, id_timedim /), id_dred_dis_frac)
            !ierr = nf90_put_att(ihisfile, id_dred_dis_frac, 'long_name', 'Cumulative dredged material per fraction for dredge areas')
            !ierr = nf90_put_att(ihisfile, id_dred_dis_frac, 'units', 'm3') !totvoldred

            !ierr = nf90_def_var(ihisfile, 'dump_discharge_frac',     nf90_double, (/ id_dumpdim, id_sedtotdim, id_timedim /), id_dump_dis_frac)
            !ierr = nf90_put_att(ihisfile, id_dump_dis_frac, 'long_name', 'Cumulative dumped material per fraction for dump areas')
            !ierr = nf90_put_att(ihisfile, id_dump_dis_frac, 'units', 'm3') !totvoldump

            ierr = nf90_def_var(ihisfile, 'dred_time_frac',     nf90_double, (/ id_dreddim, id_timedim /), id_dred_tfrac)
            ierr = nf90_put_att(ihisfile, id_dred_tfrac, 'long_name', 'Time fraction spent dredging')
            ierr = nf90_put_att(ihisfile, id_dred_tfrac, 'units', '-') !ndredged

            ierr = nf90_def_var(ihisfile, 'plough_time_frac',   nf90_double, (/ id_dreddim, id_timedim /), id_plough_tfrac)
            ierr = nf90_put_att(ihisfile, id_plough_tfrac, 'long_name', 'Time fraction spent ploughing')
            ierr = nf90_put_att(ihisfile, id_plough_tfrac, 'units', '-') !nploughed
        endif

        if ( jacheckmonitor.eq.1 ) then
           ierr = nf90_def_var(ihisfile, 'checkerboard_monitor', nf90_double, (/ id_laydim, id_timedim /), id_checkmon)
           ierr = nf90_put_att(ihisfile, id_checkmon, 'long_name', 'Checkerboard mode monitor')
           ierr = nf90_put_att(ihisfile, id_checkmon, 'unit', 'm s-1')

           ierr = nf90_def_var(ihisfile, 'num_timesteps', nf90_int, id_timedim, id_num_timesteps)
           ierr = nf90_def_var(ihisfile, 'comp_time', nf90_double, id_timedim, id_comp_time)
        end if

        ierr = nf90_def_var(ihisfile, 'time', nf90_double, id_timedim, id_time)
        ierr = nf90_put_att(ihisfile, id_time,  'units'        , 'seconds since '//refdat(1:4)//'-'//refdat(5:6)//'-'//refdat(7:8)//' 00:00:00')
        ierr = nf90_put_att(ihisfile, id_time,  'standard_name', 'time')

        ! Size of latest timestep
        ierr = unc_def_var_nonspatial(ihisfile, id_timestep, nf90_double, (/ id_timedim /), 'timestep', '',     'latest computational timestep size in each output interval', 's')

        if ( japart.gt.0 ) then
!          write partiles header to hisfile
           call unc_write_part_header(ihisfile,id_timedim,id_partdim,id_parttime,id_partx,id_party,id_partz)
        end if

        ierr = nf90_enddef(ihisfile)

        do i=1,numobs+nummovobs
!           ierr = nf90_put_var(ihisfile, id_statx,    xobs(i),         (/ i /))
!           ierr = nf90_put_var(ihisfile, id_staty,    yobs(i),         (/ i /))
           ierr = nf90_put_var(ihisfile, id_statid, trim(namobs(i)), (/ 1, i /)) ! Extra for OpenDA-wrapper
           ierr = nf90_put_var(ihisfile, id_statname, trim(namobs(i)), (/ 1, i /))
        end do

        if (ncrs > 0) then
            do i=1,ncrs
                ierr = nf90_put_var(ihisfile, id_crsx,     crs(i)%path%xp(1:crs(i)%path%np), (/ 1, i /))
                ierr = nf90_put_var(ihisfile, id_crsy,     crs(i)%path%yp(1:crs(i)%path%np), (/ 1, i /))
                ierr = nf90_put_var(ihisfile, id_crsname,  trim(crs(i)%name),      (/ 1, i /))
            end do
        end if

        if (jahiscgen > 0 .and. ntmp > 0) then
            do i=1,ntmp
               if (jaoldstr == 1) then
                  igen = i
               else
                  if (network%sts%numGeneralStructures > 0) then
                     istru = network%sts%generalStructureIndices(i)
                     ierr = nf90_put_var(ihisfile, id_genstru_id,  trim(network%sts%struct(istru)%id),  (/ 1, i /))
                     cycle
                  else
                     igen = genstru2cgen(i)
                  end if
               end if

               ierr = nf90_put_var(ihisfile, id_genstru_id,  trim(cgen_ids(igen)), (/ 1, i /))
            end do
        end if

        if (jahisorif > 0 .and. network%sts%numOrifices > 0) then
           do i = 1, network%sts%numOrifices
              istru = network%sts%orificeIndices(i)
              ierr = nf90_put_var(ihisfile, id_orifgen_id,  trim(network%sts%struct(istru)%id),  (/ 1, i /))
           end do
        end if

        if (jahisbridge > 0 .and. network%sts%numBridges > 0) then
           do i = 1, network%sts%numBridges
              istru = network%sts%bridgeIndices(i)
              ierr = nf90_put_var(ihisfile, id_bridge_id,  trim(network%sts%struct(istru)%id),  (/ 1, i /))
           end do
        end if

        if (jahisculv > 0 .and. network%sts%numCulverts > 0) then
           do i = 1, network%sts%numCulverts
              istru = network%sts%culvertIndices(i)
              ierr = nf90_put_var(ihisfile, id_culvert_id,  trim(network%sts%struct(istru)%id),  (/ 1, i /))
           end do
        end if

        if (jahisuniweir > 0 .and. network%sts%numuniweirs > 0) then
           do i = 1, network%sts%numuniweirs
              istru = network%sts%uniweirIndices(i)
              ierr = nf90_put_var(ihisfile, id_uniweir_id,  trim(network%sts%struct(istru)%id),  (/ 1, i /))
           end do
        end if

        if (jahiscmpstru > 0 .and. network%cmps%count > 0) then
           do i = 1, network%cmps%count
              ierr = nf90_put_var(ihisfile, id_cmpstru_id,  trim(network%cmps%compound(i)%id),  (/ 1, i /))
           end do
        end if

        if (jahispump > 0 .and. npumpsg > 0) then
            do i=1,npumpsg
               ierr = nf90_put_var(ihisfile, id_pump_id,  trim(pump_ids(i)),      (/ 1, i /))

               ! NOTE: the code below is now only active for pumps (DELFT3D-36341). Should be
               ! generalized for all structure locations that are polyline based.
               !
               ! Store one single representative x/y point for each pump in the time series file,
               ! because CF conventions require that for variables on discrete geometries.
               ! Computed at half the total length of the snapped flow links
               ! (so, it lies on an edge, not per se on the input pump pli)).
               pumplensum = 0d0
               do k = L1pumpsg(i), L2pumpsg(i)
                  Lf = abs(kpump(3,k))
                  pumplensum = pumplensum + wu(Lf)
               end do
               pumplenmid = pumplensum / 2

               ! Find the mid point on the snapped flow link path
               pumplensum = 0d0
               do k = L1pumpsg(i), L2pumpsg(i)
                  Lf = abs(kpump(3,k))
                  if (pumplensum + wu(Lf) >= pumplenmid) then
                     if (kcu(Lf) == 2) then ! 2D
                        if (kpump(3,k) > 0) then
                           k3 = lncn(1,Lf)
                           k4 = lncn(2,Lf)
                        else
                           k3 = lncn(2,Lf)
                           k4 = lncn(1,Lf)
                        end if
                        w1 = (pumplenmid-pumplensum)/wu(Lf)
                        pumpxmid = w1*xk(k3) + (1d0-w1)*xk(k4)
                        pumpymid = w1*yk(k3) + (1d0-w1)*yk(k4)
                     else                   ! 1D
                        pumpxmid = xu(Lf)
                        pumpymid = yu(Lf)
                     end if
                     exit ! mid point was found
                  else
                     pumplensum = pumplensum + wu(Lf)
                  end if
               end do

               ierr = nf90_put_var(ihisfile, id_pump_xmid,  pumpxmid,      (/ i /))
               ierr = nf90_put_var(ihisfile, id_pump_ymid,  pumpymid,      (/ i /))
            end do
        end if
        if (jahisgate > 0 .and. ngatesg > 0) then
            do i=1,ngatesg
               ierr = nf90_put_var(ihisfile, id_gatename,  trim(gate_ids(i)),      (/ 1, i /))
            end do
        end if
        if (jahisgate > 0 .and. ngategen > 0) then
           do i=1,ngategen
              igen = gate2cgen(i)
              ierr = nf90_put_var(ihisfile, id_gategenname,  trim(cgen_ids(igen)),      (/ 1, i /))
           end do
        end if
        if (jahiscdam > 0 .and. ncdamsg > 0) then
            do i=1,ncdamsg
               ierr = nf90_put_var(ihisfile, id_cdamname,  trim(cdam_ids(i)),      (/ 1, i /))
            end do
        end if
        if (jahisweir > 0 .and. nweirgen > 0 ) then
           if (allocated(weir2cgen)) then
              do i=1,nweirgen
                 igen = weir2cgen(i)
                 ierr = nf90_put_var(ihisfile, id_weirgen_id,  trim(cgen_ids(igen)),      (/ 1, i /))
              end do
           else if (network%sts%numWeirs > 0) then
              do i=1,nweirgen
                 istru = network%sts%weirIndices(i)
                 ierr = nf90_put_var(ihisfile, id_weirgen_id,  trim(network%sts%struct(istru)%id),      (/ 1, i /))
              end do
           end if
        end if

        if (jahisdambreak > 0 .and. ndambreak > 0) then
            do i = 1,ndambreaksg
               ierr = nf90_put_var(ihisfile, id_dambreak_id, trim(dambreak_ids(i)),(/ 1, i /))
            end do
        end if

        if (jased>0 .and. stm_included .and. jahissed>0) then
           do i=1,stmpar%lsedtot
              ierr = nf90_put_var(ihisfile, id_frac_name, trim(stmpar%sedpar%namsed(i)), (/ 1, i /))
           enddo
        end if

        if (dad_included) then
           !
           !do i=1,stmpar%lsedtot
           !   ierr = nf90_put_var(ihisfile, id_frac_name, trim(stmpar%sedpar%namsed(i)), (/ 1, i /))
           !enddo
           !ierr = nf90_put_var(ihisfile, id_frac_name, 'subsoil sediment', (/ 1, stmpar%lsedtot+1 /))        ! rest category
           !
           do i=1,(dadpar%nadred+dadpar%nasupl)
              ierr = nf90_put_var(ihisfile, id_dred_name, trim(dadpar%dredge_areas(i)), (/ 1, i /))
           enddo
           !
           do i=1,dadpar%nadump
              ierr = nf90_put_var(ihisfile, id_dump_name, trim(dadpar%dump_areas(i)), (/ 1, i /))
           enddo
        endif
    endif
    ! Increment output counters in m_flowtimes.
    time_his = tim
    it_his   = it_his + 1
    ierr = nf90_put_var(ihisfile, id_time, time_his, (/ it_his /))
    ierr = nf90_put_var(ihisfile, id_timestep, dts, (/ it_his /))

!   write particles to hisfile (for now)
    if ( japart.gt.0 ) then
       call unc_write_part(ihisfile,it_his,id_parttime,id_partx,id_party,id_partz)
    end if

!   Observation points (fixed+moving)

    valobsT = transpose(valobs)
    ntot = numobs + nummovobs
    if (ntot > 0) then
       ierr = nf90_put_var(ihisfile,    id_vars,   valobsT(:,IPNT_S1),    start = (/ 1, it_his /), count = (/ ntot, 1 /))
       ierr = nf90_put_var(ihisfile,    id_hs  ,   valobsT(:,IPNT_HS),    start = (/ 1, it_his /), count = (/ ntot, 1 /))
       if( stm_included ) then
          ierr = nf90_put_var(ihisfile,    id_varb,   valobsT(:,IPNT_BL),    start = (/ 1, it_his /), count = (/ ntot, 1 /))
       else
          ierr = nf90_put_var(ihisfile,    id_varb,   valobsT(:,IPNT_BL),    start = (/ 1 /) )
       endif

       if ( nummovobs > 0 ) then
          ierr = nf90_put_var(ihisfile,    id_statx,  xobs(:),            start = (/ 1, it_his /), count = (/ ntot, 1 /))
          ierr = nf90_put_var(ihisfile,    id_staty,  yobs(:),            start = (/ 1, it_his /), count = (/ ntot, 1 /))
       else
          ierr = nf90_put_var(ihisfile,    id_statx,  xobs(:),            start = (/ 1 /), count = (/ ntot /))
          ierr = nf90_put_var(ihisfile,    id_staty,  yobs(:),            start = (/ 1 /), count = (/ ntot /))
       endif
    endif

    if ( jawave.eq.4 ) then
       ierr = nf90_put_var(ihisfile, id_R,      valobsT(:,IPNT_WAVER), start = (/ 1, it_his /), count = (/ ntot, 1 /))
    end if

    if (jawave>0) then
       ierr = nf90_put_var(ihisfile, id_WH,      valobsT(:,IPNT_WAVEH),   start = (/ 1, it_his /), count = (/ ntot, 1 /))
       ierr = nf90_put_var(ihisfile, id_WD,      valobsT(:,IPNT_WAVED),   start = (/ 1, it_his /), count = (/ ntot, 1 /))
       ierr = nf90_put_var(ihisfile, id_WL,      valobsT(:,IPNT_WAVEL),   start = (/ 1, it_his /), count = (/ ntot, 1 /))
       ierr = nf90_put_var(ihisfile, id_WT,      valobsT(:,IPNT_WAVET),   start = (/ 1, it_his /), count = (/ ntot, 1 /))
       ierr = nf90_put_var(ihisfile, id_WU,      valobsT(:,IPNT_WAVEU),   start = (/ 1, it_his /), count = (/ ntot, 1 /))
       ierr = nf90_put_var(ihisfile, id_WTAU,    valobsT(:,IPNT_WAVETAU), start = (/ 1, it_his /), count = (/ ntot, 1 /))
    endif

    if (japatm > 0) then
       ierr = nf90_put_var(ihisfile, id_varpatm, valobsT(:,IPNT_patm), start = (/ 1, it_his /), count = (/ ntot, 1 /))
    endif

    if (jawind > 0) then
       ierr = nf90_put_var(ihisfile, id_varwx,  valobsT(:,IPNT_wx),    start = (/ 1, it_his /), count = (/ ntot, 1 /))
       ierr = nf90_put_var(ihisfile, id_varwy,  valobsT(:,IPNT_wy),    start = (/ 1, it_his /), count = (/ ntot, 1 /))
    endif

    if ((jarain > 0) .and. (jahisrain > 0)) then
       ierr = nf90_put_var(ihisfile, id_varrain,  valobsT(:,IPNT_rain),    start = (/ 1, it_his /), count = (/ ntot, 1 /))
    endif

    if (numobs+nummovobs > 0) then
      if ( kmx>0 ) then
!      3D
       ierr = nf90_put_var(ihisfile,    id_varucxq, valobsT(:,IPNT_UCXQ),  start = (/ 1, it_his /), count = (/ ntot, 1 /)) ! depth-averaged velocity
       ierr = nf90_put_var(ihisfile,    id_varucyq, valobsT(:,IPNT_UCYQ),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       !
       do kk = 1,kmx
          ierr = nf90_put_var(ihisfile,    id_varucx, valobsT(:,IPNT_UCX+kk-1),  start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1 /))
          ierr = nf90_put_var(ihisfile,    id_varucy, valobsT(:,IPNT_UCY+kk-1),  start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1 /))
          ierr = nf90_put_var(ihisfile,    id_varucz, valobsT(:,IPNT_UCZ+kk-1),  start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1 /))
          if (jasal > 0) then
             ierr = nf90_put_var(ihisfile, id_varsal, valobsT(:,IPNT_SA1 +kk-1), start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1 /))
          end if
          if (jatem > 0) then
             ierr = nf90_put_var(ihisfile, id_vartem, valobsT(:,IPNT_TEM1+kk-1), start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1 /))
          end if
          if (jasal > 0 .or. jatem > 0 .or. jased > 0) then
             ierr = nf90_put_var(ihisfile, id_varrho, valobsT(:,IPNT_RHO +kk-1), start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1 /))
          end if
          if (jased > 0 .and. .not. stm_included) then
             ierr = nf90_put_var(ihisfile, id_varsed, valobsT(:,IPNT_SED +kk-1), start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1 /))
          end if
          if (IVAL_TRA1 > 0) then
             do j = IVAL_TRA1,IVAL_TRAN   ! enumerators of tracers in valobs array (not the pointer)
               i = j - IVAL_TRA1 + 1
               ierr = nf90_put_var(ihisfile, id_tra(i), valobsT(:,IPNT_TRA1 + (i-1)*kmx+kk-1), start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1/))
             enddo
          end if
          if (IVAL_HWQ1 > 0) then
             do j = IVAL_HWQ1,IVAL_HWQN   ! enumerators of tracers in valobs array (not the pointer)
               i = j - IVAL_HWQ1 + 1
               if (i .le. noout_user + noout_statt) then
                  ierr = nf90_put_var(ihisfile, id_hwq(i), valobsT(:,IPNT_HWQ1 + (i-1)*kmx+kk-1), start = (/ kk, 1, it_his /), count = (/ 1, ntot, 1/))
               else if (comparereal(tim, ti_mape, eps10) == 0) then
                  ierr = nf90_put_var(ihisfile, id_hwq(i), valobsT(:,IPNT_HWQ1 + (i-1)*kmx+kk-1), start = (/ kk, 1 /), count = (/ 1, ntot, 1/))
               endif
             enddo
          end if
          if (IVAL_SF1 > 0) then
             call realloc(toutputx, (/ntot, stmpar%lsedsus /), keepExisting=.false., fill = dmiss)
             do j = IVAL_SF1,IVAL_SFN
               i = j - IVAL_SF1 + 1
               toutputx(:,i) = valobsT(:,IPNT_SF1 + (i-1)*(kmx+1)+kk-1)
             enddo
             ierr = nf90_put_var(ihisfile, id_sf, toutputx, start = (/ kk, 1, 1, it_his /), count = (/ 1, ntot, stmpar%lsedsus, 1/))
          end if
       enddo
     else
!      2D
       ierr = nf90_put_var(ihisfile,    id_varucx, valobsT(:,IPNT_UCX),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       ierr = nf90_put_var(ihisfile,    id_varucy, valobsT(:,IPNT_UCY),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       if (jasal > 0) then
          ierr = nf90_put_var(ihisfile, id_varsal, valobsT(:,IPNT_SA1),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       endif
       if (jatem > 0) then
          ierr = nf90_put_var(ihisfile, id_vartem, valobsT(:,IPNT_TEM1), start = (/ 1, it_his /), count = (/ ntot, 1 /))
       end if
       if(jasal > 0 .or. jatem > 0 .or. jased > 0 ) then
          ierr = nf90_put_var(ihisfile, id_varrho, valobsT(:,IPNT_RHO),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       end if
       if (IVAL_TRA1 > 0) then
          do j = IVAL_TRA1,IVAL_TRAN   ! enumerators of tracers in valobs array (not the pointer)
            i = j - IVAL_TRA1 + 1
            ierr = nf90_put_var(ihisfile, id_tra(i), valobsT(:,IPNT_TRA1 + i-1), start = (/ 1, it_his /), count = (/ ntot, 1/))
          end do
       end if
       if (IVAL_HWQ1 > 0) then
          do j = IVAL_HWQ1,IVAL_HWQN   ! enumerators of tracers in valobs array (not the pointer)
            i = j - IVAL_HWQ1 + 1
            ierr = nf90_put_var(ihisfile, id_hwq(i), valobsT(:,IPNT_HWQ1 + i-1), start = (/ 1, it_his /), count = (/ ntot, 1/))
          end do
       end if
       if (IVAL_SF1 > 0) then
          call realloc(toutputx, (/ntot, stmpar%lsedsus /), keepExisting=.false., fill = dmiss)
          do j = IVAL_SF1,IVAL_SFN  
            i = j - IVAL_SF1 + 1
            toutputx(:,i) = valobsT(:,IPNT_SF1 + i-1)
          end do
          ierr = nf90_put_var(ihisfile, id_sf, toutputx, start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedsus, 1/))
       end if
       if (IVAL_WS1 > 0) then
          call realloc(toutputx, (/ntot, stmpar%lsedsus /), keepExisting=.false., fill = dmiss)
          do j = IVAL_WS1,IVAL_WSN
            i = j - IVAL_WS1 + 1
            toutputx(:,i) = valobsT(:,IPNT_WS1 + i-1)
            ierr = nf90_put_var(ihisfile, id_ws, toutputx, start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedsus, 1/))
          enddo
       end if
       if (jased > 0 .and. .not. stm_included) then
          ierr = nf90_put_var(ihisfile, id_varsed, valobsT(:,IPNT_SED),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       end if
     endif

!    waq bottom variables are always 2D
     if (IVAL_WQB1 > 0) then
       do j = IVAL_WQB1,IVAL_WQBN   ! enumerators of tracers in valobs array (not the pointer)
         i = j - IVAL_WQB1 + 1
         ierr = nf90_put_var(ihisfile, id_hwqb(i), valobsT(:,IPNT_WQB1 + i-1), start = (/ 1, it_his /), count = (/ ntot, 1/))
       end do
     endif
    endif

    if (jatem > 1 .and. jahisheatflux > 0) then
       ierr = nf90_put_var(ihisfile,    id_Wind   , valobsT(:,IPNT_WIND),  start = (/ 1, it_his /), count = (/ ntot, 1 /))

       if ( jatem.gt.1 ) then   ! also heat modelling involved
          ierr = nf90_put_var(ihisfile, id_Tair   , valobsT(:,IPNT_TAIR),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       end if

       if (jatem == 5 .and. allocated(Rhum) .and. allocated(Clou) ) then
           ierr = nf90_put_var(ihisfile, id_Rhum   , valobsT(:,IPNT_RHUM),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
           ierr = nf90_put_var(ihisfile, id_Clou   , valobsT(:,IPNT_CLOU),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       end if

       if (jatem == 5 ) then
          ierr = nf90_put_var(ihisfile, id_Qsun   , valobsT(:,IPNT_QSUN),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
          ierr = nf90_put_var(ihisfile, id_Qeva   , valobsT(:,IPNT_QEVA),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
          ierr = nf90_put_var(ihisfile, id_Qcon   , valobsT(:,IPNT_QCON),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
          ierr = nf90_put_var(ihisfile, id_Qlong  , valobsT(:,IPNT_QLON),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
          ierr = nf90_put_var(ihisfile, id_Qfreva , valobsT(:,IPNT_QFRE),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
          ierr = nf90_put_var(ihisfile, id_Qfrcon , valobsT(:,IPNT_QFRC),  start = (/ 1, it_his /), count = (/ ntot, 1 /))
       endif

       ierr = nf90_put_var(ihisfile,    id_Qtot   , valobsT(:,IPNT_QTOT),  start = (/ 1, it_his /), count = (/ ntot, 1 /))

    end if ! jamapheatflux > 0! jatem > 0


    if (kmx > 0 ) then
       do kk = 1, kmx+1
          ierr = nf90_put_var(ihisfile,    id_zws,    valobsT(:,IPNT_ZWS+kk-1),   start = (/ kk,  1, it_his /), count = (/ 1, ntot, 1 /))
          if (kk > 1) then
             ierr = nf90_put_var(ihisfile, id_zcs,    valobsT(:,IPNT_ZCS+kk-2),   start = (/ kk-1,1, it_his /), count = (/ 1, ntot, 1 /))
          endif
          if (iturbulencemodel >= 3 .and. jahistur > 0) then
             ierr = nf90_put_var(ihisfile, id_turkin, valobsT(:,IPNT_TKIN +kk-1), start = (/ kk,  1, it_his /), count = (/ 1, ntot, 1 /))
             ierr = nf90_put_var(ihisfile, id_tureps, valobsT(:,IPNT_TEPS +kk-1), start = (/ kk,  1, it_his /), count = (/ 1, ntot, 1 /))
          endif
          if (iturbulencemodel > 1) then
             ierr = nf90_put_var(ihisfile, id_vicwwu, valobsT(:,IPNT_VICWW+kk-1), start = (/ kk,  1, it_his /), count = (/ 1, ntot, 1 /))
          endif
          if (idensform > 0 .and. jaRichardsononoutput > 0) then
             ierr = nf90_put_var(ihisfile, id_rich,   valobsT(:,IPNT_RICH +kk-1), start = (/ kk,  1, it_his /), count = (/ 1, ntot, 1 /))
          endif
          !
          if (IVAL_WS1 > 0) then
             call realloc(toutputx, (/ntot, stmpar%lsedsus /), keepExisting=.false., fill = dmiss)
             do j = IVAL_WS1,IVAL_WSN
               i = j - IVAL_WS1 + 1
               toutputx(:,i) = valobsT(:,IPNT_WS1 + (i-1)*(kmx+1)+kk-1)
             enddo
             ierr = nf90_put_var(ihisfile, id_ws, toutputx, start = (/ kk, 1, 1, it_his /), count = (/ 1, ntot, stmpar%lsedsus, 1/))
          end if
          !
          if (IVAL_SEDDIF1 > 0) then
             call realloc(toutputx, (/ntot, stmpar%lsedsus /), keepExisting=.false., fill = dmiss)
             do j = IVAL_SEDDIF1,IVAL_SEDDIFN
               i = j - IVAL_SEDDIF1 + 1
               toutputx(:,i) = valobsT(:,IPNT_SEDDIF1 + (i-1)*(kmx+1)+kk-1)
             enddo
             ierr = nf90_put_var(ihisfile, id_seddif, toutputx, start = (/ kk, 1, 1, it_his /), count = (/ 1, ntot, stmpar%lsedsus, 1/))
          end if
          !
       enddo
    endif
    !
    ! Cross sections
    if (ncrs > 0) then
       do i=1,ncrs
          ! Discharges Q
          ierr = nf90_put_var(ihisfile, id_varQ,    crs(i)%sumvalcur(IPNT_Q1C), (/ i, it_his /))
          ierr = nf90_put_var(ihisfile, id_varQint, crs(i)%sumvalcum(IPNT_Q1C), (/ i, it_his /))
!          ierr = nf90_put_var(ihisfile, id_varQavg, crs(i)%sumvalavg(IPNT_Q1C), (/ i, it_his /))

          ! Cross sectional areas A*u
          ierr = nf90_put_var(ihisfile, id_varAu,    crs(i)%sumvalcur(IPNT_AUC), (/ i, it_his /))
!          ierr = nf90_put_var(ihisfile, id_varAuavg, crs(i)%sumvalavg(IPNT_AUC), (/ i, it_his /))

          ! Average velocity Q/Au
          ierr = nf90_put_var(ihisfile, id_varu,    crs(i)%sumvalcur(IPNT_U1A), (/ i, it_his /))
!          ierr = nf90_put_var(ihisfile, id_varuavg, crs(i)%sumvalavg(IPNT_U1A), (/ i, it_his /))

          if( jatransportmodule /= 0 ) then
             IP = IPNT_HUA
             do num = 1,NUMCONST_MDU
                IP = IP + 1
                if (num >= ISED1 .and. num <= ISEDN) then
                   l = sedtot2sedsus(num-ISED1+1)
                   select case(stmpar%morpar%moroutput%transptype)
                   case (0)
                      rhol = 1d0
                   case (1)
                      rhol = stmpar%sedpar%cdryb(l)
                   case (2)
                      rhol = stmpar%sedpar%rhosol(l)
                   end select
                   toutput_cum = crs(i)%sumvalcum(IP)/rhol
                   toutput_cur = crs(i)%sumvalcur(IP)/rhol
                else
                  toutput_cum = crs(i)%sumvalcum(IP)
                  toutput_cur = crs(i)%sumvalcur(IP)
                endif
                ierr = nf90_put_var(ihisfile, id_const_cum(num), toutput_cum, (/ i, it_his /))
                ierr = nf90_put_var(ihisfile, id_const(num),     toutput_cur, (/ i, it_his /))
             end do
          endif

          if( jased == 4 .and. stmpar%lsedtot > 0 ) then
             IP = IPNT_HUA + NUMCONST_MDU + 1
             ierr = nf90_put_var(ihisfile, id_sedbtrans, crs(i)%sumvalcum(IP), (/ i, it_his /))
             if( stmpar%lsedsus > 0 ) then
                IP = IP + 1
                ierr = nf90_put_var(ihisfile, id_sedstrans, crs(i)%sumvalcum(IP), (/ i, it_his /))
             endif
          endif
       end do
    end if

    if (jahissourcesink > 0 .and. numsrc > 0) then
      if (tim == tstart_user) then
        do i = 1, numsrc
          ierr = nf90_put_var(ihisfile, id_srcname, trim(srcname(i)), (/ 1, i/) )
          ierr = nf90_put_var(ihisfile, id_qsrccur, qstss((numconst+1)*(i-1)+1), (/ i, it_his /))
        enddo
        ierr = nf90_put_var(ihisfile, id_srcx, xsrc)
        ierr = nf90_put_var(ihisfile, id_srcy, ysrc)
      else
         ierr = nf90_put_var(ihisfile, id_qsrccur, qsrc, (/ 1, it_his /))
      endif
      ierr = nf90_put_var(ihisfile, id_vsrccum, vsrccum, (/ 1, it_his /))
      ierr = nf90_put_var(ihisfile, id_qsrcavg, qsrcavg, (/ 1, it_his /))
      do i = 1, numsrc
        ierr = nf90_put_var(ihisfile, id_pred,  qstss((numconst+1)*(i-1) + 1), (/ i, it_his /))
        j = 1
        if (isalt > 0) then
           j = j + 1
           ierr = nf90_put_var(ihisfile, id_presa, qstss((numconst+1)*(i-1) + j), (/ i, it_his /))
        endif
        if (itemp > 0) then
           j = j + 1
           ierr = nf90_put_var(ihisfile, id_pretm, qstss((numconst+1)*(i-1) + j), (/ i, it_his /))
        endif
      enddo
    endif

      if (jahiscgen > 0 ) then
         if (ncgensg > 0) then
            do i = 1,ncgensg
               igen = i
               ierr = nf90_put_var(ihisfile, id_genstru_dis   , valcgen(2,i)   , (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_crestl, zcgen(3*igen-2), (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_edgel , zcgen(3*igen-1), (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_openw , zcgen(3*igen  ), (/ i, it_his /)) ! TODO: AvD: this part seems not entirely correct, double check with block below and duplication with gategen, etc.
               ierr = nf90_put_var(ihisfile, id_genstru_s1up  , valcgen(3,i)   , (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_s1dn  , valcgen(4,i)   , (/ i, it_his /))
            enddo
         end if
         if (ngenstru > 0) then
            do i=1,ngenstru
               !igen = genstru2cgen(i)
               ierr = nf90_put_var(ihisfile, id_genstru_dis   , valgenstru(2,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_crestl, valgenstru(9,i),  (/ i, it_his /)) ! changed
               ierr = nf90_put_var(ihisfile, id_genstru_edgel , valgenstru(14,i), (/ i, it_his /)) ! changed
               ierr = nf90_put_var(ihisfile, id_genstru_openw , valgenstru(13,i), (/ i, it_his /)) ! changed
               ierr = nf90_put_var(ihisfile, id_genstru_s1up  , valgenstru(3,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_s1dn  , valgenstru(4,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_head,          valgenstru(5,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_au,            valgenstru(6,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_genstru_vel,           valgenstru(7,i),  (/ i, it_his /))
               if (network%sts%numGeneralStructures > 0) then
                  ierr = nf90_put_var(ihisfile, id_genstru_s1crest,       valgenstru(8,i),  (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_crestw,        valgenstru(10,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_stat,     int(valgenstru(11,i)), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_forcedif,      valgenstru(12,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_openh,         valgenstru(15,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_uppl,          valgenstru(16,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_dis_gate_open, valgenstru(17,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_dis_gate_over, valgenstru(18,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_dis_gate_under,valgenstru(19,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_au_open,       valgenstru(20,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_au_over,        valgenstru(21,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_au_under,      valgenstru(22,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_velgateopen,   valgenstru(23,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_velgateover,   valgenstru(24,i), (/ i, it_his /))
                  ierr = nf90_put_var(ihisfile, id_genstru_velgateunder,  valgenstru(25,i), (/ i, it_his /))
               end if
            enddo
         endif
      endif

      if (jahispump > 0 .and. npumpsg > 0) then
         do i=1,npumpsg
            ierr = nf90_put_var(ihisfile, id_pump_dis,     valpump(2,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_s1up,    valpump(3,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_s1dn,    valpump(4,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_struhead,valpump(5,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_cap,     valpump(6,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_disdir,  valpump(12,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_stage,int(valpump(7,i)),(/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_head,    valpump(8,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_redufact,valpump(9,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_s1del,   valpump(10,i),(/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_pump_s1suc,   valpump(11,i),(/ i, it_his /))
         end do
      end if

      if (jahisorif > 0 .and. network%sts%numOrifices > 0) then
         do i=1,network%sts%numOrifices
            ierr = nf90_put_var(ihisfile, id_orifgen_dis   ,        valorifgen(2,i),   (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_s1up  ,        valorifgen(3,i),   (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_s1dn  ,        valorifgen(4,i),   (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_head,          valorifgen(5,i),   (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_au,            valorifgen(6,i),   (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_vel,           valorifgen(7,i),   (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_s1crest,       valorifgen(8,i),   (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_crestl,        valorifgen(9,i),   (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_crestw,        valorifgen(10,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_stat,      int(valorifgen(11,i)), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_forcedif,      valorifgen(12,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_edgel ,        valorifgen(14,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_orifgen_openh,         valorifgen(15,i),  (/ i, it_his /))
         enddo
      end if

      if (jahisbridge > 0 .and. network%sts%numBridges > 0) then
         do i=1,network%sts%numBridges
            ierr = nf90_put_var(ihisfile, id_bridge_dis,   valbridge(2,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_bridge_s1up,  valbridge(3,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_bridge_s1dn,  valbridge(4,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_bridge_head,  valbridge(5,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_bridge_au,    valbridge(6,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_bridge_vel,   valbridge(7,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_bridge_blup,  valbridge(8,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_bridge_bldn,  valbridge(9,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_bridge_bl_act,valbridge(10,i),(/ i, it_his /))
         enddo
      end if

      if (jahisculv > 0 .and. network%sts%numCulverts > 0) then
         do i=1,network%sts%numCulverts
            ierr = nf90_put_var(ihisfile, id_culvert_dis,    valculvert(2,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_s1up,   valculvert(3,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_s1dn,   valculvert(4,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_head,   valculvert(5,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_au,     valculvert(6,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_vel,    valculvert(7,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_crestl, valculvert(8,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_stat,  int(valculvert(9,i)),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_edgel , valculvert(10,i),     (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_culvert_openh,  valculvert(11,i),     (/ i, it_his /))
         enddo
      end if

      if (jahisuniweir > 0 .and. network%sts%numuniweirs > 0) then
         do i=1,network%sts%numuniweirs
            ierr = nf90_put_var(ihisfile, id_uniweir_dis,    valuniweir(2,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_uniweir_s1up,   valuniweir(3,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_uniweir_s1dn,   valuniweir(4,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_uniweir_head,   valuniweir(5,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_uniweir_au,     valuniweir(6,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_uniweir_vel,    valuniweir(7,i),      (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_uniweir_crestl, valuniweir(8,i),      (/ i, it_his /))
         enddo
      end if

      if (jahiscmpstru > 0 .and. network%cmps%count > 0) then
         do i=1,network%cmps%count
            ierr = nf90_put_var(ihisfile, id_cmpstru_dis,            valcmpstru(2,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_cmpstru_s1up,           valcmpstru(3,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_cmpstru_s1dn,           valcmpstru(4,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_cmpstru_head,           valcmpstru(5,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_cmpstru_au,             valcmpstru(6,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_cmpstru_vel,            valcmpstru(7,i), (/ i, it_his /))
         enddo
      end if

      if (jahisgate > 0 .and. ngatesg > 0) then
         do i=1,ngatesg
            ierr = nf90_put_var(ihisfile, id_gate_dis  , valgate(2,i) , (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_gate_edgel, zgate(i)     , (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_gate_s1up , valgate(3,i) , (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_gate_s1dn , valgate(4,i) , (/ i, it_his /))
         end do
      end if

      if (jahisgate > 0 .and. ngategen > 0) then
         do i=1,ngategen
            igen = gate2cgen(i)
            ierr = nf90_put_var(ihisfile, id_gategen_dis  , valgategen(2,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_gategen_sillh, valgategen(9,i), (/ i, it_his /))   ! changed
            ierr = nf90_put_var(ihisfile, id_gategen_edgel, valgategen(8,i), (/ i, it_his /))   ! changed
            ierr = nf90_put_var(ihisfile, id_gategen_flowh, valgategen(5,i), (/ i, it_his /))   ! TODO: AvD sillw
            ierr = nf90_put_var(ihisfile, id_gategen_openw, valgategen(7,i), (/ i, it_his /))   ! changed
            ierr = nf90_put_var(ihisfile, id_gategen_s1up , valgategen(3,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_gategen_s1dn , valgategen(4,i), (/ i, it_his /))
         end do
      end if

      if (jahiscdam > 0 .and. ncdamsg > 0) then
         do i = 1,ncdamsg
            ierr = nf90_put_var(ihisfile, id_cdam_dis   , valcdam(2,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_cdam_crestl, zcdam(i)    , (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_cdam_s1up  , valcdam(3,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_cdam_s1dn  , valcdam(4,i), (/ i, it_his /))
         end do
      end if

      if (jahisweir > 0 .and. nweirgen > 0) then
         do i = 1,nweirgen
            ierr = nf90_put_var(ihisfile, id_weirgen_dis   , valweirgen(2,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_weirgen_s1up  , valweirgen(3,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_weirgen_s1dn  , valweirgen(4,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_weirgen_crestl, valweirgen(9,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_weirgen_crestw, valweirgen(10,i),(/ i, it_his /))
            if (network%sts%numWeirs > 0) then ! write extra files for new weirs
               ierr = nf90_put_var(ihisfile, id_weirgen_head  , valweirgen(5,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_weirgen_au    , valweirgen(6,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_weirgen_vel   , valweirgen(7,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_weirgen_s1crest,valweirgen(8,i),  (/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_weir_stat, int(valweirgen(11,i)),(/ i, it_his /))
               ierr = nf90_put_var(ihisfile, id_weirgen_forcedif,valweirgen(12,i),(/i, it_his /))
            end if
         end do
      end if

      if (jahisdambreak > 0 .and. ndambreak > 0) then
         do i = 1,ndambreaksg
            ierr = nf90_put_var(ihisfile, id_dambreak_discharge,                    valdambreak(2,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_s1up,                         valdambreak(3,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_s1dn,                         valdambreak(4,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_head,                         valdambreak(5,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_au,                           valdambreak(6,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_normal_velocity,              valdambreak(7,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_cresth,                       valdambreak(8,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_crestw,                       valdambreak(9,i),  (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_water_level_jump,             valdambreak(10,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_breach_width_time_derivative, valdambreak(11,i), (/ i, it_his /))
            ierr = nf90_put_var(ihisfile, id_dambreak_cumulative_discharge,         valdambreak(12,i), (/ i, it_his /))
         end do
      end if
      !
      if (jased>0 .and. stm_included .and. jahissed>0 .and. stmpar%lsedtot>0) then
         if (stmpar%morpar%moroutput%sbcuv) then
            call realloc(toutputx, (/ntot, stmpar%lsedtot /), keepExisting=.false., fill = dmiss)
            call realloc(toutputy, (/ntot, stmpar%lsedtot /), keepExisting=.false., fill = dmiss)
            do l = 1, stmpar%lsedtot
               select case(stmpar%morpar%moroutput%transptype)
               case (0)
                  rhol = 1d0
               case (1)
                  rhol = stmpar%sedpar%cdryb(l)
               case (2)
                  rhol = stmpar%sedpar%rhosol(l)
               end select
               toutputy(:,l) = valobsT(:,IPNT_SBCY1+l-1)/rhol
               toutputx(:,l) = valobsT(:,IPNT_SBCX1+l-1)/rhol
            end do
            ierr = nf90_put_var(ihisfile, id_sbcx, toutputx  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedtot, 1 /))
            ierr = nf90_put_var(ihisfile, id_sbcy, toutputy  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedtot, 1 /))
         endif
         !
         if (stmpar%morpar%moroutput%sscuv) then
            call realloc(toutputx, (/ntot, stmpar%lsedtot /), keepExisting=.false., fill = dmiss)
            call realloc(toutputy, (/ntot, stmpar%lsedtot /), keepExisting=.false., fill = dmiss)
            do l = 1, stmpar%lsedtot
               select case(stmpar%morpar%moroutput%transptype)
               case (0)
                  rhol = 1d0
               case (1)
                  rhol = stmpar%sedpar%cdryb(l)
               case (2)
                  rhol = stmpar%sedpar%rhosol(l)
               end select
               toutputy(:,l) = valobsT(:,IPNT_SSCY1+l-1)/rhol
               toutputx(:,l) = valobsT(:,IPNT_SSCX1+l-1)/rhol
            end do
            ierr = nf90_put_var(ihisfile, id_sscx, toutputx  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedtot, 1 /))
            ierr = nf90_put_var(ihisfile, id_sscy, toutputy  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedtot, 1 /))
         endif
         !
         if (stmpar%morpar%moroutput%sbwuv .and. jawave>0) then
            call realloc(toutputx, (/ntot, stmpar%lsedtot /), keepExisting=.false., fill = dmiss)
            call realloc(toutputy, (/ntot, stmpar%lsedtot /), keepExisting=.false., fill = dmiss)
            do l = 1, stmpar%lsedtot
               select case(stmpar%morpar%moroutput%transptype)
               case (0)
                  rhol = 1d0
               case (1)
                  rhol = stmpar%sedpar%cdryb(l)
               case (2)
                  rhol = stmpar%sedpar%rhosol(l)
               end select
               toutputy(:,l) = valobsT(:,IPNT_SBWY1+l-1)/rhol
               toutputx(:,l) = valobsT(:,IPNT_SBWX1+l-1)/rhol
            end do
            ierr = nf90_put_var(ihisfile, id_sbwx, toutputx  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedtot, 1 /))
            ierr = nf90_put_var(ihisfile, id_sbwy, toutputy  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedtot, 1 /))
         endif
         !
         if (stmpar%morpar%moroutput%sswuv .and. jawave>0) then
            call realloc(toutputx, (/ntot, stmpar%lsedtot /), keepExisting=.false., fill = dmiss)
            call realloc(toutputy, (/ntot, stmpar%lsedtot /), keepExisting=.false., fill = dmiss)
            do l = 1, stmpar%lsedtot
               select case(stmpar%morpar%moroutput%transptype)
               case (0)
                  rhol = 1d0
               case (1)
                  rhol = stmpar%sedpar%cdryb(l)
               case (2)
                  rhol = stmpar%sedpar%rhosol(l)
               end select
               toutputy(:,l) = valobsT(:,IPNT_SSWY1+l-1)/rhol
               toutputx(:,l) = valobsT(:,IPNT_SSWX1+l-1)/rhol
            end do
            ierr = nf90_put_var(ihisfile, id_sswx, toutputx  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedtot, 1 /))
            ierr = nf90_put_var(ihisfile, id_sswy, toutputy  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedtot, 1 /))
         endif
         !
         !
         if (stmpar%morpar%moroutput%sourcesink .and. IVAL_SOUR1>0) then
            call realloc(toutputx, (/ntot, stmpar%lsedsus /), keepExisting=.false., fill = dmiss)
            call realloc(toutputy, (/ntot, stmpar%lsedsus /), keepExisting=.false., fill = dmiss)
            do l = 1, stmpar%lsedsus
               toutputx(:,l) = valobsT(:,IPNT_SOUR1+l-1)
               toutputy(:,l) = valobsT(:,IPNT_SINK1+l-1)
            end do
            ierr = nf90_put_var(ihisfile, id_sour, toutputx  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedsus, 1 /))
            ierr = nf90_put_var(ihisfile, id_sink, toutputy  , start = (/ 1, 1, it_his /), count = (/ ntot, stmpar%lsedsus, 1 /))
         endif
      endif

    if ( dad_included ) then  ! Output for dredging and dumping
       ierr = nf90_put_var(ihisfile, id_dredlink_dis, dadpar%link_sum  , start = (/ 1, 1, it_his /), count = (/ dadpar%nalink, stmpar%lsedtot, 1 /))
       ierr = nf90_put_var(ihisfile, id_dred_dis    , dadpar%totvoldred, start = (/ 1, it_his /), count = (/ dadpar%nadred+dadpar%nasupl, 1 /))
       ierr = nf90_put_var(ihisfile, id_dump_dis    , dadpar%totvoldump, start = (/ 1, it_his /), count = (/ dadpar%nadump, 1 /))
       !ierr = nf90_put_var(ihisfile, id_dred_dis_frac    , dadpar%totvoldredfrac, start = (/ 1, 1, it_his /), count = (/ dadpar%nadred+dadpar%nasupl, stmpar%lsedtot+1, 1 /))
       !ierr = nf90_put_var(ihisfile, id_dump_dis_frac    , dadpar%totvoldumpfrac, start = (/ 1, 1, it_his /), count = (/ dadpar%nadump, stmpar%lsedtot, 1 /))

       cof0 = 1d0 ; if( time_his > 0d0 ) cof0 = time_his
       ierr = nf90_put_var(ihisfile, id_dred_tfrac  , dadpar%ndredged/cof0  , start = (/ 1, it_his /), count = (/ dadpar%nadred+dadpar%nasupl, 1 /))
       ierr = nf90_put_var(ihisfile, id_plough_tfrac, dadpar%nploughed/cof0 , start = (/ 1, it_his /), count = (/ dadpar%nadred+dadpar%nasupl, 1 /))
    endif

    do num = 1,MAX_IDX
       if ( num.eq.IDX_InternalTidesDissipation ) then
          if ( jaFrcInternalTides2D.eq.1 ) then
             ierr = nf90_put_var(ihisfile, id_voltot(num), 1d-12*voltot(num),  start=(/ it_his /))
          end if
       else if ( num.eq.IDX_GravInput ) then
          if ( jatidep.eq.1 .or. jaselfal.gt.0 ) then
             ierr = nf90_put_var(ihisfile, id_voltot(num), 1d-12*voltot(num),  start=(/ it_his /))
          end if
       else if ( num.eq.IDX_SALInput .or. num.eq.IDX_SALInput2 ) then
          if ( jaselfal.gt.0 ) then
             ierr = nf90_put_var(ihisfile, id_voltot(num), 1d-12*voltot(num),  start=(/ it_his /))
          end if
       else
          ierr = nf90_put_var(ihisfile, id_voltot(num), voltot(num),  start=(/ it_his /))
       end if
    enddo


    if( jahisgate > 0 .and. ngatesg+ngategen > 0) then
       ! todo: remove all do loops
       ! ngatesg ! Old-fashioned gates 'gateloweredgelevel'
       ! Actual discharge:
       !ierr = nf90_put_var(ihisfile, id_gatedisch, gatedisch(1:ngatesg+ngategen),  start=(/ 1, it_his /), count = (/ ngatesg+ngategen, 1 /))

       !'pump_discharge_pumpA'
       !'pump_discharge_pumpB' (1:ntimes)

       !'pump_names' (1:npumps)
       !'pump_discharge'  (1:ntimes, 1:npumps)

       ! Door lower edge level
      ! ierr = nf90_put_var(ihisfile, id_zgate,     work ... (1:ngatesg+ngategen),  start=(/ 1, it_his /), count = (/ ngatesg+ngategen, 1 /))

       ! id_gatesill: not for old style gates, they are just at bed level, so leave empty value in the file on columns 1:ngatesg
!       ierr = nf90_put_var(ihisfile, id_gatesill, gatesill(ngatesg+1:ngatesg+ngategen),  start=(/ ngatesg+1, it_his /), count = (/ ngategen, 1 /))

!       ierr = nf90_put_var(ihisfile, id_zgate(num)    , zgate(num)    ,  start=(/ it_his /))

!       do num=1,ngategen ! New-style gate, via generalstructure
!          igen=gate2cgen(num)
!          ipos = ! Just add new style gates at the back of the old style gates
!          ierr = nf90_put_var(ihisfile, id_gatedisch,      gatedisch(ipos),  start=(/ it_his /))
!          ierr = nf90_put_var(ihisfile, id_zgate(num)    , zgate(num)    ,  start=(/ it_his /))
    endif
        if( jahiscdam > 0 .and. ncdamsg + nweirgen > 0) then
           ! see gates
       do num = 1,ncdamsg
!          ierr = nf90_put_var(ihisfile, id_cdamdisch(num), cdamdisch(num),  start=(/ it_his /))
!          ierr = nf90_put_var(ihisfile, id_zcdam(num)    , zcdam(num)    ,  start=(/ it_his /))
       enddo
    endif

    if ( jacheckmonitor.eq.1 ) then
      ierr = nf90_put_var(ihisfile, id_checkmon, checkmonitor, start=(/ 1, it_his /))

      ierr = nf90_put_var(ihisfile, id_num_timesteps, int(dnt), start=(/ it_his /))
      ierr = nf90_put_var(ihisfile, id_comp_time, cpusteps(3), start=(/ it_his /))
    end if

    ierr = nf90_sync(ihisfile) ! Flush file

end subroutine unc_write_his

!> write particles header to netcdf file
subroutine unc_write_part_header(ifile,id_timedim,id_partdim,id_parttime,id_partx,id_party,id_partz)
   use m_particles
   use netcdf
    use unstruc_netcdf, only: unc_addcoordatts, check_error
   use m_flow, only: kmx
   use m_sferic, only: jsferic
   use unstruc_messages
   use m_missing
   implicit none

   integer, intent(in)    :: ifile  !< output file identifier
   integer, intent(in)    :: id_timedim
   integer, intent(inout) :: id_partdim, id_parttime, id_partx, id_party, id_partz

   character(len=128)     :: mesg

   integer                :: ierr
   integer                :: jaInDefine

   if ( japart.eq.0 ) then
      return
   end if

   ! Put dataset in define mode (possibly again) to add dimensions and variables.
   ierr = nf90_redef(ifile)
   if (ierr == nf90_eindefine) jaInDefine = 1 ! Was still in define mode.
   if (ierr /= nf90_noerr .and. ierr /= nf90_eindefine) then
       call mess(LEVEL_ERROR, 'Could not put header in flow geometry file.')
       call check_error(ierr)
       return
   end if

   ierr = nf90_def_dim(ifile, 'particles', Nglob, id_partdim)

   ierr = nf90_def_var(ifile, 'particles_time', nf90_double, id_timedim, id_parttime)
   ierr = nf90_put_att(ifile, id_parttime, 'long_name', 'particles time')

   ierr = nf90_def_var(ifile, 'particles_x_coordinate', nf90_double, (/ id_partdim, id_timedim /), id_partx)
   ierr = nf90_def_var(ifile, 'particles_y_coordinate', nf90_double, (/ id_partdim, id_timedim /), id_party)
   ierr = unc_addcoordatts(ifile, id_partx, id_party, jsferic)
   ierr = nf90_put_att(ifile, id_partx, 'long_name', 'x-coordinate of particles')
   ierr = nf90_put_att(ifile, id_party, 'long_name', 'y-coordinate of particles')
   ierr = nf90_put_att(ifile, id_partx, '_FillValue', dmiss)
   ierr = nf90_put_att(ifile, id_party, '_FillValue', dmiss)


   if ( kmx.gt.0 ) then
      ierr = nf90_def_var(ifile, 'particle_z_coordinate', nf90_double, (/ id_partdim, id_timedim /), id_partz)
      ierr = nf90_put_att(ifile, id_partz, 'long_name', 'z-coordinate of particle')
   end if

   ! Leave the dataset in the same mode as we got it.
   if (jaInDefine == 1) then
       ierr = nf90_redef(ifile)
   end if

   return
end subroutine unc_write_part_header

!> write particles to netcdf file
subroutine unc_write_part(ifile,itime,id_parttime,id_partx,id_party,id_partz)
   use m_particles
   use netcdf
   use m_sferic
   use m_flow, only: kmx
   use geometry_module, only: cart3Dtospher
   use m_missing
   use unstruc_messages
   implicit none

   integer,                        intent(in)  :: ifile  !< output file identifier
   integer,                        intent(in)  :: itime
   integer,                        intent(in)  :: id_parttime, id_partx, id_party, id_partz

   double precision, dimension(:), allocatable :: xx, yy

   integer,          dimension(:), allocatable :: iperm

   double precision                            :: dis2

   integer                                     :: i, i0, ii, iglb
   integer                                     :: ierr, ierror

   double precision,                 parameter :: dtol = 1d-8

   integer, save :: icount=0

   ierror = 1

   icount = icount+1

   if ( icount.ge.24 ) then
      continue
   end if

!  allocate
   allocate(iperm(Nglob))
   iperm = 0
   allocate(xx(Nglob))
   xx = dmiss
   allocate(yy(Nglob))
   yy = dmiss

!  order particles
   ierr = 0
   do i=1,Npart
      if ( kpart(i).eq.0 ) cycle

      iglb = iglob(i)
!     check if this global number already occured
      i0 = iperm(iglb)
      if ( i0.ne.0 ) then
!        check coordinates
         dis2 = (xpart(i)-xpart(i0))**2 + (ypart(i)-ypart(i0))**2
         if ( jsferic.ne.0 ) then
            dis2 = dis2 + (zpart(i)-zpart(i0))**2
         end if
         if ( dis2.gt.dtol ) then
            write(6,"('particle error: ', I0)") iglb
            ierr = 1
         end if
      end if
      iperm(iglb) = i
   end do
   if ( ierr.ne.0 ) goto 1234

   if ( jsferic.eq.1 ) then
      do ii=1,Npart
         i = iperm(ii)
         if ( i.gt.0 ) then
            call Cart3Dtospher(xpart(i),ypart(i),zpart(i),xx(ii),yy(ii),0d0)
         end if
      end do
   else
      do ii=1,Nglob
         i = iperm(ii)
         if ( i.gt.0 ) then
            xx(ii) = xpart(i)
            yy(ii) = ypart(i)
         end if
      end do
   end if

   ierr = nf90_put_var(ifile, id_parttime, timepart, (/ itime /))
   if ( ierr.ne.0 ) goto 1234
   ierr = nf90_put_var(ifile, id_partx, xx, start=(/ 1,itime /), count=(/ Nglob,1 /) )
   if ( ierr.ne.0 ) goto 1234
   ierr = nf90_put_var(ifile, id_party, yy, start=(/ 1,itime /), count=(/ Nglob,1 /) )
   if ( ierr.ne.0 ) goto 1234

   if ( kmx.gt.0 ) then
!     particle vertical coordinate
   end if

   if ( japart.eq.1 ) call restore_particles()

   ierror = 0
1234 continue

!  deallocate
   if ( allocated(iperm) ) deallocate(iperm)
   if ( allocated(xx) ) deallocate(xx)
   if ( allocated(yy) ) deallocate(yy)

!  error handling
   if ( ierror.ne.0 ) then
      call mess(LEVEL_ERROR, 'particles output error')
   end if

   return
end subroutine unc_write_part


! fill observation stations array
subroutine fill_valobs()
   use m_flow
   use m_transport
   use m_fm_wq_processes, only: kbx, wqbot, waqoutputs
   use m_flowgeom
   use m_observations
   use m_sediment
   use m_waves, only: hwav, twav, phiwav, rlabda, uorb
   use m_xbeach_data, only: R
   use m_ship

   implicit none

   integer :: i, ii, j, kk, k, kb, kt, klay, L, LL, Lb, Lt, LLL, k1, k2, k3, LLa
   integer :: ipoint, ival, klayt, kmx_const
   double precision :: wavfac

   kmx_const = kmx
   if (jaeulervel==1 .and. jawave > 0) then
      call getucxucyeuler(ndkx, workx, worky)
   endif

   if (jawave>0) then
      if (jahissigwav==0) then
         wavfac = 1d0
      else
         wavfac = sqrt(2d0)
      end  if
   endif

   valobs = DMISS
   do i = 1,numobs+nummovobs
      k = max(kobs(i),1)
      if ( kobs(i).gt.0 ) then  ! rely on reduce_kobs to have selected the right global flow nodes

         if ( kmx.gt.0 ) then
            call getkbotktop(k,kb,kt)
            call reconstructucz(k)
         else
            kb = k
            kt = k
         end if


!        store values in valobs work array
         valobs(:,i)        = 0d0   ! should not be DMISS, as DMISS is used to mark observation stations outside subdomain in reduce_valobs
         valobs(IPNT_S1,i)  = s1(k)
         if (nshiptxy > 0) then
             if ( allocated(zsp) ) then
                valobs(IPNT_S1,i)  = valobs(IPNT_S1,i) + zsp(k)
             endif
         endif

         valobs(IPNT_HS,i)  = s1(k) - bl(k)

         valobs(IPNT_BL,i)  = bl(k)

         valobs(IPNT_CMX,i) = cmxobs(i)
         if (jawind > 0) then
            valobs(IPNT_wx,i) = 0d0
            valobs(IPNT_wy,i) = 0d0
            do LL=1,nd(k)%lnx
               LLL = iabs(nd(k)%ln(LL))
               k1 = ln(1,LLL) ; k2 = ln(2,LLL)
               k3 = 1 ; if( nd(k)%ln(LL) > 0 ) k3 = 2
               valobs(IPNT_wx,i) = valobs(IPNT_wx,i) + wx(LLL) * wcL(k3,LLL)
               valobs(IPNT_wy,i) = valobs(IPNT_wy,i) + wy(LLL) * wcL(k3,LLL)
            enddo
            !LL = iabs(nd(k)%ln(1))
            !valobs(IPNT_wx,i)  = wx(LL)
            !valobs(IPNT_wy,i)  = wy(LL)
         endif
         if (jaPATM > 0 .and. allocated(patm)) then
            valobs(IPNT_PATM,i)  = PATM(k)
         ENDIF

         if ( jawave.eq.4 .and. allocated(R) ) then
            valobs(IPNT_WAVER,i) = R(k)
         end if

         if (jawave>0 .and. allocated(hwav)) then
            valobs(IPNT_WAVEH,i) = hwav(k)*wavfac
            valobs(IPNT_WAVET,i) = twav(k)
            valobs(IPNT_WAVED,i) = 270d0-phiwav(k)  ! Direction from
            valobs(IPNT_WAVEL,i) = rlabda(k)
            valobs(IPNT_WAVEU,i) = uorb(k)
            valobs(IPNT_WAVETAU,i) = taus(k)
         endif

         if (stm_included .and. jased>0) then
            do j = IVAL_SBCX1, IVAL_SBCXN
               ii = j-IVAL_SBCX1+1
               valobs(IPNT_SBCX1+ii-1,i)=sedtra%sbcx(k,ii)
            enddo
            do j = IVAL_SBCY1, IVAL_SBCYN
               ii = j-IVAL_SBCY1+1
               valobs(IPNT_SBCY1+ii-1,i)=sedtra%sbcy(k,ii)
            enddo
            do j = IVAL_SSCX1, IVAL_SSCXN
               ii = j-IVAL_SSCX1+1
               valobs(IPNT_SSCX1+ii-1,i)=sedtra%sscx(k,ii)
            enddo
            do j = IVAL_SSCY1, IVAL_SSCYN
               ii = j-IVAL_SSCY1+1
               valobs(IPNT_SSCY1+ii-1,i)=sedtra%sscy(k,ii)
            enddo
            if (jawave>0) then
               do j = IVAL_SBWX1, IVAL_SBWXN
                  ii = j-IVAL_SBWX1+1
                  valobs(IPNT_SBWX1+ii-1,i)=sedtra%sbwx(k,ii)
               enddo
               do j = IVAL_SBWY1, IVAL_SBWYN
                  ii = j-IVAL_SBWY1+1
                  valobs(IPNT_SBWY1+ii-1,i)=sedtra%sbwy(k,ii)
               enddo
               do j = IVAL_SSWX1, IVAL_SSWXN
                  ii = j-IVAL_SSWX1+1
                  valobs(IPNT_SSWX1+ii-1,i)=sedtra%sswx(k,ii)
               enddo
               do j = IVAL_SSWY1, IVAL_SSWYN
                  ii = j-IVAL_SSWY1+1
                  valobs(IPNT_SSWY1+ii-1,i)=sedtra%sswy(k,ii)
               enddo
            endif
            do j = IVAL_SOUR1, IVAL_SOURN
               ii = j-IVAL_SOUR1+1
               valobs(IPNT_SOUR1+ii-1,i)=sedtra%sourse(k,ii)
            enddo
            do j = IVAL_SINK1, IVAL_SINKN
               ii = j-IVAL_SINK1+1
               valobs(IPNT_SINK1+ii-1,i)=sedtra%sinkse(k,ii)
            enddo
         endif

         if ( IVAL_WQB1.gt.0 ) then
            do j=IVAL_WQB1,IVAL_WQBN
               ii = j-IVAL_WQB1+1
               valobs(IPNT_WQB1+ii-1,i) = wqbot(ii,k)
            end do
         end if

         if (kmx>0) then
            valobs(IPNT_UCXQ,i) = ucxq(k)
            valobs(IPNT_UCYQ,i) = ucyq(k)
         endif

         do kk=kb,kt
            klay = kk-kb+1

            if (kmx > 0) then
               valobs(IPNT_ZCS+klay-1,i) = 0.5d0*( zws(kk)+zws(kk-1) )
            endif

            valobs(IPNT_UCX+klay-1,i) = ucx(kk)
            valobs(IPNT_UCY+klay-1,i) = ucy(kk)
            if (jaeulervel==1 .and. hs(k) > epshu .and. jawave>0) then
               valobs(IPNT_UCX+klay-1,i) = workx(kk)
               valobs(IPNT_UCY+klay-1,i) = worky(kk)
            endif
            if ( kmx>0 ) then
               valobs(IPNT_UCZ+klay-1,i)  = ucz(kk)
            end if
            if ( jasal.gt.0 ) then
               valobs(IPNT_SA1+klay-1,i) = sa1(kk)
            end if
            if ( jatem.gt.0 ) then
               valobs(IPNT_TEM1+klay-1,i) = constituents(itemp, kk)
            end if
            if( jasal > 0 .or. jatem > 0 .or. jased > 0 ) then
               valobs(IPNT_RHO+klay-1,i) = rho(kk)
            end if

            if (kmx==0) then
               kmx_const = 1     ! to make numbering below work
            end if

            if ( IVAL_TRA1.gt.0 ) then
               !do j=IPNT_TRA1,IPNT_TRAN
               !   valobs(j+klay-1,i) = constituents(ITRA1+j-IPNT_TRA1, kk)
               !end do

               do j=IVAL_TRA1,IVAL_TRAN
                  ii = j-IVAL_TRA1+1
                  valobs(IPNT_TRA1+(ii-1)*kmx_const+klay-1,i) = constituents(ITRA1+ii-1, kk)
               end do
            end if

            if ( IVAL_HWQ1.gt.0 ) then
               do j=IVAL_HWQ1,IVAL_HWQN
                  ii = j-IVAL_HWQ1+1
                  valobs(IPNT_HWQ1+(ii-1)*kmx_const+klay-1,i) = waqoutputs(ii,kk-kbx+1)
               end do
            end if

            if ( IVAL_SF1.gt.0 ) then
               do j=IVAL_SF1,IVAL_SFN
                  ii = j-IVAL_SF1+1
                  valobs(IPNT_SF1+(ii-1)*kmx_const+klay-1,i) = constituents(ISED1+ii-1, kk)
               end do
            end if

            if (kmx==0 .and. IVAL_WS1 .gt. 0) then
               do j=IVAL_WS1,IVAL_WSN
                  ii = j-IVAL_WS1+1
                  valobs(IPNT_WS1+(ii-1)*kmx_const+klay-1,i) = mtd%ws(kk, ii)   ! 1:lsedsus
               end do
            end if

            if ( jased.gt.0 .and. .not. stm_included) then
               valobs(IPNT_SED+klay-1,i) = sed(1, kk)
            end if
            valobs(IPNT_CMX,i) = max( valobs(IPNT_UCX,i), sqrt( ucx(kk)**2 + ucy(kk)**2 )  )
         end do
         valobs(IPNT_SMX,i) = max( smxobs(i), s1(k) )

!         if ( kmx.gt.0 ) then
!            LL = iabs(nd(k)%ln(1))
!            call getLbotLtop(LL,Lb,Lt)
!            do L = Lb-1, Lt
!               klay = L-Lb+2
!               valobs(IPNT_ZWS+klay-1,i) = zws(kb + L-Lb)
!!               if (klay > 1) then
!!                  valobs(IPNT_ZCS+klay-2,i) = 0.5d0*(zws(kb + klay-2)+zws(kb + klay-3))
!!               endif
!               if ( iturbulencemodel.ge.2 ) then
!                  valobs(IPNT_VICWW + klay-1,i) = vicwwu (L)
!               end if
!               if ( iturbulencemodel.ge.3 ) then
!                  valobs(IPNT_TKIN  + klay-1,i) = turkin1(L)
!                  valobs(IPNT_TEPS  + klay-1,i) = tureps1(L)
!               endif
!               if (idensform > 0 .and. jaRichardsononoutput > 0) then
!                  valobs(IPNT_RICH + klay-1,i) = rich(L)
!               endif
!            enddo
!         end if

         if ( kmx.gt.0 ) then
            call getlink1(k,LL)
            call getLbotLtop(LL,Lb,Lt)
            do L = Lb-1, Lt
               klay = L-Lb+2
               if (layertype == 2) then
                  valobs(IPNT_ZWS+klay-1,i) = zws(kb + L-Lb)
               else
                  valobs(IPNT_ZWS+klay-1,i) = min(bob(1,LL),bob(2,LL)) + hu(L)
               end if

               if ( IVAL_WS1.gt.0 ) then
                  do j=IVAL_WS1,IVAL_WSN
                     ii = j-IVAL_WS1+1
                     valobs(IPNT_WS1+(ii-1)*(kmx+1)+klay-1,i) =mtd%ws(kb+klay-2, ii)
                  end do
               end if

               if ( IVAL_SEDDIF1.gt.0 ) then
                  do j=IVAL_SEDDIF1,IVAL_SEDDIFN
                     ii = j-IVAL_SEDDIF1+1
                     valobs(IPNT_SEDDIF1+(ii-1)*(kmx+1)+klay-1,i) =mtd%seddif(ii, kb+klay-2)
                  end do
               end if
            enddo
            if ( iturbulencemodel.ge.2 ) then
               valobs(IPNT_VICWW:IPNT_VICWW+kmx,i) = 0d0
            endif
            if ( iturbulencemodel.ge.3 ) then
               valobs(IPNT_TKIN:IPNT_TKIN+kmx,i) = 0d0
               valobs(IPNT_TEPS:IPNT_TEPS+kmx,i) = 0d0
            endif
            if (idensform > 0 .and. jaRichardsononoutput > 0) then
               valobs(IPNT_RICH:IPNT_RICH+kmx,i) = 0d0
            endif
            do LL = 1,nd(k)%lnx
               LLa = iabs(nd(k)%ln(LL))
               call getLbotLtop(LLa,Lb,Lt)
               k1 = ln0(1,LLa) ; k2 = ln0(2,LLa)
               k3 = 1 ; if( nd(k)%ln(LL) > 0 ) k3 = 2
               do L = Lb-1,Lt
                  klay = L-Lb+2
                  if ( iturbulencemodel.ge.2 ) then
                     valobs(IPNT_VICWW + klay-1,i) = valobs(IPNT_VICWW + klay-1,i) + vicwwu(L) * wcL(k3,LLa)
                  end if
                  if ( iturbulencemodel.ge.3 ) then
                     valobs(IPNT_TKIN  + klay-1,i) = valobs(IPNT_TKIN  + klay-1,i) + turkin1(L) * wcL(k3,LLa)
                     valobs(IPNT_TEPS  + klay-1,i) = valobs(IPNT_TEPS  + klay-1,i) + tureps1(L) * wcL(k3,LLa)
                  endif
                  if (idensform > 0 .and. jaRichardsononoutput > 0) then
                     valobs(IPNT_RICH + klay-1,i) = valobs(IPNT_RICH + klay-1,i) + rich(L) * wcL(k3,LLa)
                  endif
               enddo
            enddo
         endif

!        Rainfall
         if (jarain > 0 .and. jahisrain > 0) then
            valobs(IPNT_RAIN,i) = rain(k)
         end if

!        Heatflux
         if (jatem > 0 .and. jahisheatflux > 0) then
            call getlink1(k,LL)
            if ( jawind.gt.0 ) then
               valobs(IPNT_WIND,i) = sqrt(wx(LL)*wx(LL) + wy(LL)*wy(LL))
            end if

            if ( jatem.gt.1 ) then   ! also heat modelling involved
               valobs(IPNT_TAIR,i) = Tair(k)
            end if

            if (jatem == 5 .and. allocated(Rhum) .and. allocated(Clou) ) then
               valobs(IPNT_RHUM,i) = Rhum(k)
               valobs(IPNT_CLOU,i) = Clou(k)
            endif

            if (jatem == 5) then
               valobs(IPNT_QSUN,i) = Qsunmap(k)
               valobs(IPNT_QEVA,i) = Qevamap(k)
               valobs(IPNT_QCON,i) = Qconmap(k)
               valobs(IPNT_QLON,i) = Qlongmap(k)
               valobs(IPNT_QFRE,i) = Qfrevamap(k)
               valobs(IPNT_QFRC,i) = Qfrconmap(k)
            endif

            if (jatem > 1) then
               valobs(IPNT_QTOT,i) = Qtotmap(k)
            end if
         end if
      else
         valobs(:,i) = DMISS
      end if
   end do

!  copy empty layers from top
   if ( kmx.gt.0 ) then
      do i = 1,numobs+nummovobs
         k = max(kobs(i),1)
         if ( kobs(i).gt.0 ) then  ! rely on reduce_kobs to have selected the right global flow nodes

            call getkbotktop(k,kb,kt)

            if ( kt.lt.kb ) cycle

            do ival=MAXNUMVALOBS2D+1,MAXNUMVALOBS2D+MAXNUMVALOBS3D
               ipoint = ivalpoint(ival, kmx)
               klayt = kt-kb+1
               do k=kt+1,kb+kmx-1
                  klay = k-kb+1
                  valobs(ipoint+klay-1,i) = valobs(ipoint+klayt-1,i)
               end do
            end do
         end if
      end do
   end if


   return
   end subroutine fill_valobs

subroutine getlink1(k,LL)
use m_flowgeom
integer :: k, LL
if (nd(k)%lnx == 0) then
    LL = 1
else
    LL = iabs(nd(k)%ln(1))
endif
end subroutine

!> update observation station data
subroutine updateValuesOnObervationStations()
   use m_observations
   use m_partitioninfo
   use m_timer
   use m_flowtimes, only: time1
   implicit none

   ! This routine can now be called any time, but will only do the update
   ! of valobs when necessary:
   if (tlastupd_valobs == time1) then
      return
   end if
   tlastupd_valobs = time1

   call fill_valobs()

   if ( jampi.eq.1 ) then
      if ( jatimer.eq.1 ) call starttimer(IOUTPUTMPI)
      call reduce_valobs(IPNT_NUM,numobs+nummovobs,valobs,valobs_all)
      if ( jatimer.eq.1 ) call stoptimer(IOUTPUTMPI)
   end if

   return
end subroutine updateValuesOnObervationStations

subroutine definencvar(ncid, idq, itype, idims, n, name, desc, unit, namecoord)
use netcdf
use unstruc_netcdf
use m_sferic
implicit none

integer,          intent(in)     :: ncid  ! file unit
integer,          intent(inout)  :: idq   ! quantity id
integer,          intent(in)     :: itype ! double or integer etc
integer,          intent(in)     :: n     ! dim of idim
integer,          intent(in)     :: idims(n)
character(len=*), intent(in)     :: name, desc, unit, namecoord

integer                          :: ierr
ierr = 0
ierr = nf90_def_var(ncid, name , itype, idims , idq)
ierr = nf90_put_att(ncid, idq  , 'coordinates'  , namecoord)
ierr = nf90_put_att(ncid, idq  , 'long_name'    , desc)
ierr = nf90_put_att(ncid, idq  , 'units'        , unit)

ierr = unc_add_gridmapping_att(ncid, (/idq/), jsferic)

end subroutine definencvar

subroutine putncvarflownode( ncid, idq, fnod, kx, nx, itim, jint)
use netcdf
use unstruc_netcdf
use m_flow, only: work1
implicit none

double precision, intent(in)     :: fnod(*)
integer,          intent(in)     :: ncid  ! file unit
integer,          intent(in)     :: idq   ! quantity id
integer,          intent(in)     :: kx, nx, itim, jint


integer                          :: ierr, kb, kt, k, kk

if (kx > 0) then
   do kk=1,nx
      call getkbotktop(kk,kb,kt)
      if (jint == 1) kb = kb - 1
      do k = kb,kt
         work1(k-kb+1,kk) = fnod(k)
      enddo
   enddo
   ierr = nf90_put_var(ncid, idq, work1(1:kx,1:nx), start=(/ 1, 1, itim /), count=(/ kx, nx, 1 /))
else
   ierr = nf90_put_var(ncid, idq, work1(1:kx,1:nx), start=(/ 1, 1, itim /), count=(/ kx, nx, 1 /))
endif
end subroutine putncvarflownode

subroutine wrirst(tim)
    use m_flow
    use m_flowtimes
    use m_observations
    use unstruc_netcdf
    use unstruc_model
    use unstruc_files , only: defaultFilename
    implicit none
    double precision, intent(in) :: tim

    ! locals
    integer, save      :: irstfile = 0
    integer            :: ierr
    character(len=256) :: filnam

    if (irstfile == 0) then
        filnam = defaultFilename('rst', timestamp=tim ) ! dble(floor(tim+.5d0)))
        ierr   = unc_create(filnam , 0, irstfile)
        if (ierr /= nf90_noerr) then
            call mess(LEVEL_WARN, 'Could not create rst file.')
            irstfile = 0
        end if
    endif

    if (irstfile .ne. 0) then
        call unc_write_rst_filepointer(irstfile,tim)
    endif

    ierr = unc_close(irstfile) ! Do more than flushing: close the file, it is not needed anymore

 end subroutine wrirst




subroutine wrimap(tim)
    use m_flow
    use m_flowtimes
    use m_observations
    use unstruc_netcdf
    use unstruc_model
    use unstruc_files , only: defaultFilename
    implicit none
    double precision, intent(in) :: tim

    ! locals
    type(t_unc_mapids), save :: mapids ! TODO: AvD: move this to global state (so that it can be reset as well, just like old it_map)
    integer            :: ierr
    integer            :: i
    integer            :: len
    integer, save      :: mtecfil = 0
    integer, external  :: numuni
    character(len=256) :: filnam
    logical            :: unitused
    double precision, save :: curtime_split = 0d0 ! Current time-partition that the file writer has open.

    ! Another time-partitioned file needs to start, reset iteration count (and file).
    if (ti_split > 0d0 .and. curtime_split /= time_split0) then
        mapids%id_tsp%idx_curtime = 0
        it_map       = 0
        it_map_tec   = 0
        curtime_split = time_split0
    end if

     if ( md_mapformat.eq.IFORMAT_NETCDF .or. md_mapformat.eq.IFORMAT_NETCDF_AND_TECPLOT .or. md_mapformat == IFORMAT_UGRID) then   !   NetCDF output
       if (mapids%ncid /= 0 .and. ((md_unc_conv == UNC_CONV_UGRID .and. mapids%id_tsp%idx_curtime == 0) .or. (md_unc_conv == UNC_CONV_CFOLD .and. it_map == 0))) then
           ierr = unc_close(mapids%ncid)
           mapids%ncid = 0
       end if

        if (mapids%ncid == 0) then
            if (ti_split > 0d0) then
                filnam = defaultFilename('map', timestamp=time_split0)
            else
                filnam = defaultFilename('map')
            end if
            ierr = unc_create(filnam , 0, mapids%ncid)
            if (ierr /= nf90_noerr) then
                call mess(LEVEL_WARN, 'Could not create map file.')
                mapids%ncid = 0
            end if
        endif

       if (mapids%ncid .ne. 0) then
          if (md_unc_conv == UNC_CONV_UGRID) then
             call unc_write_map_filepointer_ugrid(mapids,tim)  ! wrimap
          else
             call unc_write_map_filepointer(mapids%ncid,tim)  ! wrimap
          endif
       endif

       ierr = nf90_sync(mapids%ncid) ! Flush file
    end if

    if ( md_mapformat.eq.IFORMAT_TECPLOT .or. md_mapformat.eq.IFORMAT_NETCDF_AND_TECPLOT ) then      ! TecPlot output
       !if (mtecfil /= 0 .and. it_map_tec == 0) then
       !   call doclose(mtecfil)
       !end if

       !if (it_map_tec == 0) then
       !     if (ti_split > 0d0) then
       !         filnam = defaultFilename('tec', timestamp=time_split0)
       !     else
       !         filnam = defaultFilename('tec')
       !     end if
       !   call newfil(mtecfil, filnam)
       !endif

       !call tecplot_out(mtecfil, tim, it_map_tec==0)

!      write grid in Tecplot format only once
       if ( it_map_tec.eq.0 ) then
          filnam = defaultFilename('net.plt')
          call wrinet_tecplot(filnam)   ! do not call findcells
       end if

!      write solution in Tecplot format
       filnam = defaultFilename('map.plt', timestamp=tim)
       call wrimap_tecplot(filnam)

       it_map_tec = it_map_tec+1
    end if
 end subroutine wrimap






subroutine wricom(tim)
    use m_flow
    use m_flowtimes
    use m_observations
    use unstruc_netcdf
    use unstruc_model
    use unstruc_files , only: defaultFilename
    implicit none
    double precision, intent(in) :: tim

    ! locals

    type(t_unc_mapids), save :: comids
    integer                  :: ierr
    character(len=256), save :: filnam
    character(len=256)       :: msg
    logical                  :: file_exists

    ! When leaving netcdf-file open and using nf90_sync:
    ! Data did not appear during debugging
    ! This problem was solved by closing/opening the file everytime
    !
    if (comids%ncid/=0 .and. jawave==3) then
       !
       ! Existing/ongoing communication via com file:
       ! com file already exists
       !
       ierr = nf90_open(filnam, NF90_WRITE, comids%ncid)
    elseif (comids%ncid==0 .and. jawave==3) then
        !
        ! No communication yet via com file:
        ! Check whether com file exists
        !
        filnam = defaultFilename('com')
        md_wavefile = filnam
        inquire(file=filnam,exist=file_exists)
        if ( file_exists ) then
            write(msg,'(3a)') "File '",trim(filnam), "' already exists. Assuming that it contains valid WAVE information. FLOW data will be added."
            call mess(LEVEL_WARN, trim(msg))
            ierr = nf90_open(filnam, NF90_WRITE, comids%ncid)
        else
            ! No com file yet. Create a new one and write FLOW parameters
            !
            ierr = unc_create(filnam , 0, comids%ncid)
            if (ierr /= nf90_noerr) then
                call mess(LEVEL_WARN, 'Could not create com file.')
                comids%ncid = 0
            endif
        endif
    endif

    if (comids%ncid /= 0) then
        call unc_write_map_filepointer(comids%ncid,tim, 2)
    endif

    ierr = nf90_close(comids%ncid) ! Flush file
 end subroutine wricom






!> Writes the current water balance quantities to file.
!! File format is ascii, one time per line, all quantities in columns.
subroutine wribal(tim)
    use m_flowtimes
    use m_flow
    use unstruc_files, only: defaultFilename

    implicit none

    double precision   :: tim

    ! locals
    integer, save      :: ibal = 0
    integer            :: ierr, ntbal
    character(len=256) :: nam

    if (ibal /= 0 .and. dnt == 1) then  ! volerr, volerrcum
        call doclose(ibal)
        ibal = 0
    end if

    if (ibal == 0) then
        nam  = defaultFilename('bal')
        call newfil(ibal, nam)

        write(ibal,'(a)') '* column 1  : Time (min) '
        write(ibal,'(a)') '* column 2  : Volume rain in       (m3) '
        write(ibal,'(a)') '* column 3  : Volume evap out      (m3) '
        write(ibal,'(a)') '* column 4  : Volume bnd  in       (m3) '
        write(ibal,'(a)') '* column 5  : Volume bnd  out      (m3) '
        write(ibal,'(a)') '* column 6  : Volume grw  in       (m3) '
        write(ibal,'(a)') '* column 7  : Volume grw  out      (m3) '
        write(ibal,'(a)') '* column 8  : Volume flow          (m3) '
        write(ibal,'(a)') '* column 9  : Volume flow ini      (m3) '
        write(ibal,'(a)') '* column 10 : Volume grw           (m3) '
        write(ibal,'(a)') '* column 11 : Volume grw  ini      (m3) '
        write(ibal,'(a)') '* column 12 : Flux rain in         (m3/s)'
        write(ibal,'(a)') '* column 13 : Flux evap out        (m3/s)'
        write(ibal,'(a)') '* column 14 : Flux bnd  in         (m3/s)'
        write(ibal,'(a)') '* column 15 : Flux bnd  out        (m3/s)'
        write(ibal,'(a)') '* column 16 : Flux grw  in         (m3/s)'
        write(ibal,'(a)') '* column 17 : Flux grw  out        (m3/s)'
        write(ibal,'(a)') '* in means into surface water, out means out of surface water'

        write(ibal,'(a)') 'BL01'
        ntbal = 1 + int(Tstop_user - Tstart_user) / Ti_xls
        write(ibal,'(i0, a)') ntbal, '   17'

    end if

    write(ibal,'(100(F20.4))') time1/60d0,                                                                          &
    vinraincum, voutevacum, vinbndcum, voutbndcum, vingrwcum, voutgrwcum, vol1tot, vol1ini, volgrw, volgrwini,      &
    qinrain   , qouteva   , qinbnd   , qoutbnd   , qingrw   , qoutgrw

end subroutine wribal

 !> Writes shapefiles, these shapefiles can be visulaized in geographic information system (GIS) software
#ifdef HAVE_SHAPELIB
subroutine unc_write_shp()
    use m_flowparameters, only: jashp_crs, jashp_obs, jashp_weir, jashp_thd, jashp_gate, jashp_emb, jashp_fxw, jashp_src, jashp_pump, jashp_dry, jashp_genstruc
    use unstruc_shapefile
    use m_monitoring_crosssections, only: ncrs, crs
    use m_observations, only: numobs, kobs
    use m_flowexternalforcings, only: nweirgen, ngategen, numsrc, ksrc, gate2cgen, L1cgensg, L2cgensg, npumpsg, L1pumpsg, L2pumpsg, ngenstru, genstru2cgen, weir2cgen
    use m_thindams
    use m_sobekdfm, only: nbnd1d2d
    use m_fixedweirs, only: nfxw
    use unstruc_messages
    use m_partitioninfo, only: jampi, my_rank
    use unstruc_model  , only: md_dryptsfile
    implicit none
    integer :: jawrite, igen, n

    ! cross sections
    if (jashp_crs > 0) then
       if (jampi .eq. 0) then
          if (ncrs > 0) then
             call unc_write_shp_crs()
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for cross sections is written because no cross section is found.')
          endif
       else
          if (ncrs > 0) then
             jawrite = ncrs
             do n = 1, ncrs
                if (crs(n)%PATH%LNX < 1) then
                   jawrite = jawrite - 1
                endif
             enddo
             if (jawrite > 0) then
                call unc_write_shp_crs()
             else
                call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for cross sections is written because no cross section is found on subdomain:', my_rank)
             endif
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for cross sections is written because no cross section is found on subdomain:', my_rank)
          endif
       endif
    endif
    ! observation stations
    if (jashp_obs > 0) then
      if (jampi .eq. 0) then
          if (NUMOBS > 0) then
             call unc_write_shp_obs()
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for observation stations is written because no observation station is found.')
          endif
       else
          if (NUMOBS > 0) then
             jawrite = NUMOBS
             do n = 1, NUMOBS
                if (kobs(n) <= 0) then
                   jawrite = jawrite - 1
                endif
             enddo
             if (jawrite > 0) then
                call unc_write_shp_obs()
             else
                call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for observation stations is written because no observation station is found on subdomain:', my_rank)
             endif
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for observation stations is written because no observation station is found on subdomain:', my_rank)
          endif
       endif
    endif
    ! weirs
     if (jashp_weir > 0) then
       if (jampi .eq. 0) then
          if (nweirgen > 0 .and. allocated(weir2cgen)) then
             call unc_write_shp_weir()
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for weirs is written because no weir is found.')
          endif
       else
          if (nweirgen > 0 .and. allocated(weir2cgen)) then
             jawrite = nweirgen
             do n = 1, nweirgen
                if (L1cgensg(n) > L2cgensg(n)) then
                   jawrite = jawrite - 1
                endif
             enddo
             if (jawrite > 0) then
                call unc_write_shp_weir()
             else
                call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for weirs is written because no weir is found on subdomain:', my_rank)
             endif
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for weirs is written because no weir is found on subdomain:', my_rank)
          endif
       endif
    endif
    ! thin dams
    if (jashp_thd > 0) then
       if (jampi .eq. 0) then
          if (nthd > 0) then
             call unc_write_shp_thd()
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for thin dams is written because no thin dam is found.')
          endif
       else
          if (nthd > 0) then
             jawrite = nthd
             do n = 1, nthd
                if (thd(n)%LNX < 1) then
                   jawrite = jawrite - 1
                endif
             enddo
             if (jawrite > 0) then
                call unc_write_shp_thd()
             else
                call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for thin dams is written because no thin dam is found on subdomain:', my_rank)
             endif
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for thin dams is written because no thin dam is found on subdomain:', my_rank)
          endif
       endif
    endif
    ! gates
    if (jashp_gate > 0) then
       if (jampi .eq. 0) then
          if (ngategen > 0) then
             call unc_write_shp_gate()
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for gates is written because no gate is found.')
          endif
       else
          if (ngategen > 0) then
             jawrite = ngategen
             do n = 1, ngategen
                igen = gate2cgen(n)
                if (L1cgensg(igen) > L2cgensg(igen)) then
                   jawrite = jawrite - 1
                endif
             enddo
             if (jawrite > 0) then
                call unc_write_shp_gate()
             else
                call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for gates is written because no gate is found on subdomain:', my_rank)
             endif
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for gates is written because no gate is found on subdomain:', my_rank)
          endif
       endif
    endif
    ! embankments
    if (jashp_emb > 0) then
       if (nbnd1d2d > 0) then
          call unc_write_shp_emb()
       else
          if (jampi .eq. 0) then
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for embankments is written because no embankment is found.')
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for embankments is written because no embankment is found on subdomain:', my_rank)
          endif
       endif
    endif
    ! fixed weirs
    if (jashp_fxw > 0) then
       if (nfxw > 0) then
          call unc_write_shp_fxw()
       else
          if (jampi .eq. 0) then
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for fixed weirs is written because no fixed weir is found.')
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for fixed weirs is written because no fixed weir is found on subdomain:', my_rank)
          endif
       endif
    endif
    ! source-sinks
     if (jashp_src > 0) then
       if (jampi .eq. 0) then
          if (numsrc > 0) then
             call unc_write_shp_src()
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for source-sinks is written because no source-sink is found.')
          endif
       else
          if (numsrc > 0) then
             jawrite = numsrc
             do n = 1, numsrc
                if (ksrc(1,n) <= 0 .and. ksrc(4,n) <= 0) then
                   jawrite = jawrite - 1
                endif
             enddo
             if (jawrite > 0) then
                call unc_write_shp_src()
             else
                call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for source-sinks is written because no source-sink is found on subdomain:', my_rank)
             endif
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for source-sinks is written because no source-sink is found on subdomain:', my_rank)
          endif
       endif
     endif

     ! pumps
    if (jashp_pump > 0) then
       if (jampi .eq. 0) then
          if (npumpsg > 0) then
             call unc_write_shp_pump()
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for pumps is written because no pump is found.')
          endif
       else
          if (npumpsg > 0) then
             jawrite = npumpsg
             do n = 1, npumpsg
                if (L1pumpsg(n) > L2pumpsg(n)) then
                   jawrite = jawrite - 1
                endif
             enddo
             if (jawrite > 0) then
                call unc_write_shp_pump()
             else
                call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for pumps is written because no pump is found on subdomain:', my_rank)
             endif
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for pumps is written because no pump is found on subdomain:', my_rank)
          endif
       endif
    endif

    ! dry area
    if (jashp_dry > 0) then
       if (len_trim(md_dryptsfile) > 0) then
          call get_netlinks_of_dryarea()
          call unc_write_shp_dry()
       else
          if (jampi .eq. 0) then
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for dry areas is written because no dry area is found.')
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for dry areas is written because no dry area is found on subdomain:', my_rank)
          endif
       endif
    endif

    ! general structures
    if (jashp_genstruc > 0) then
       if (jampi .eq. 0) then
          if (ngenstru > 0 .and. allocated(genstru2cgen)) then
             call unc_write_shp_genstruc()
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for general structures is written because no gate is found.')
          endif
       else
          if (ngenstru > 0 .and. allocated(genstru2cgen)) then
             jawrite = ngenstru
             do n = 1, ngenstru
                igen = genstru2cgen(n)
                if (L1cgensg(igen) > L2cgensg(igen)) then
                   jawrite = jawrite - 1
                endif
             enddo
             if (jawrite > 0) then
                call unc_write_shp_genstruc()
             else
                call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for general structures is written because no general structure is found on subdomain:', my_rank)
             endif
          else
             call mess(LEVEL_WARN, 'SHAPEFILE: No shape file for general structures is written because no general structure is found on subdomain:', my_rank)
          endif
       endif
    endif



end subroutine unc_write_shp
#endif

!> Given time in seconds from refdat, fill dateandtime string
 !! NOTE: maketime and maketimeinverse are not compatible, because of minutes versus seconds, and different format string.
 subroutine maketime(dateandtime,tim)
 use m_flowtimes
 implicit none

 character,        intent(out) :: dateandtime*(*) !< Output datetime string, format '20000101_000000', note: includes seconds.
 double precision, intent(in)  :: tim             !< Input time in seconds since refdat.

 integer          :: iday, imonth, iyear, ihour, imin, isec

 dateandtime = '20000101_000000'
 ! TODO: AvD: maketime and maketimeinverse are now inconsistent since the addition of this '_'

 call datetime_from_refdat(tim, iyear, imonth, iday, ihour, imin, isec)

 write(dateandtime( 1:4 ),'(i4)')   iyear
 write(dateandtime( 5:6 ),'(i2.2)') imonth
 write(dateandtime( 7:8 ),'(i2.2)') iday
 write(dateandtime(10:11),'(i2.2)') ihour
 write(dateandtime(12:13),'(i2.2)') imin
 write(dateandtime(14:15),'(i2.2)') isec

 return
 end subroutine maketime

 SUBROUTINE MAKETIMEjul0(TEX,TNr) ! maketime with jul0 already in module
 use m_flowtimes
 implicit none
 double precision :: tnr          ! time in hours
 CHARACTER TEX*(*)

 double precision :: Tuur, Tmin
 integer          :: nuur, nmin, nsec, iyyy,mm,id,ndag, jul0

 TEX  = '20010101 000000'
 JUL0 = julrefdat
 NDAG = TNR / 24.0
 CALL CALDAT(JUL0+NDAG,MM,ID,IYYY)

 TUUR = TNR - NDAG*24
 NUUR = TUUR
 TMIN = (TUUR - NUUR)*60
 NMIN = TMIN
 NSEC = (TMIN - NMIN)*60

 WRITE(TEX(1:4),'(I4.4)') IYYY
 WRITE(TEX(5:6),'(I2.2)') MM
 WRITE(TEX(7:8),'(I2.2)') ID

 WRITE(TEX(10:11),'(I2.2)') NUUR
 WRITE(TEX(12:13),'(I2.2)') NMIN
 WRITE(TEX(14:15),'(I2.2)') NSEC
 END  SUBROUTINE MAKETIMEjul0


 !> Given datetime string, compute time in seconds from refdat
 subroutine maketimeinverse(dateandtime,timsec,stat)
 use m_flowtimes
 implicit none

 character, intent(in)         :: dateandtime*(*) !< Input datetime string, format '201201010000', note that seconds are ignored.
 integer, intent(out)          :: stat

 double precision  :: timmin
 double precision, intent(out) :: timsec

 integer          :: iday ,imonth ,iyear ,ihour , imin, isec
 integer          :: iostat

 ! dateandtime = '20120101000000'

 stat = 0
 read(dateandtime( 1:4 ),'(i4)',err=666,iostat=iostat)   iyear
 read(dateandtime( 5:6 ),'(i2.2)',err=666,iostat=iostat) imonth
 read(dateandtime( 7:8 ),'(i2.2)',err=666,iostat=iostat) iday
 read(dateandtime( 9:10),'(i2.2)',err=666,iostat=iostat) ihour
 read(dateandtime(11:12),'(i2.2)',err=666,iostat=iostat) imin
 read(dateandtime(13:14),'(i2.2)',err=666,iostat=iostat) isec

666 if (iostat/=0) then
       stat=iostat
       return
    endif

 call seconds_since_refdat(iyear, imonth, iday, ihour, imin, isec, timsec)

 timmin  = timsec/60d0
 !timmin = (jul - jul0)*24d0*60d0      + ihour*60d0      + imin

 return
 end subroutine maketimeinverse


 !> Calculates the relative time in seconds since refdat, given an absolute datetime.
 !! The input datetime is in separate year/month/../seconds values.
 !! \see maketimeinverse
 subroutine seconds_since_refdat(iyear, imonth, iday, ihour, imin, isec, timsec)
 use m_flowtimes
 implicit none
 integer,          intent(in)  :: iyear, iday, imonth, ihour, imin, isec !< Input absolute date time components
 double precision, intent(out) :: timsec !< Output seconds since refdate for the specified input datetime.

 integer :: jul, jul0, iyear0, imonth0, iday0
 integer, external :: julday

     read(refdat(1:4),*) iyear0
     read(refdat(5:6),*) imonth0
     read(refdat(7:8),*) iday0

     jul0 = julday(imonth0,iday0,iyear0)
     jul  = julday(imonth ,iday ,iyear )

     timsec = (jul - jul0)*24d0*3600d0      + ihour*3600d0      + imin*60d0 + isec
 end subroutine seconds_since_refdat


 !> Calculate absolute date time values, given a time in seconds since refdat.
 !! \see maketime
 subroutine datetime_from_refdat(timsec, iyear, imonth, iday, ihour, imin, isec)
 use m_flowtimes
 implicit none
 double precision, intent(in)  :: timsec !< Time in seconds since refdate
 integer,          intent(out) :: iyear, imonth, iday, ihour, imin, isec !< Actual date, split up in year/month, etc.

 integer :: jul, jul0, iyear0, imonth0, iday0
 double precision :: tnr, tsec
 integer :: ndag

 integer, external :: julday

 read(refdat(1:4),*) iyear0
 read(refdat(5:6),*) imonth0
 read(refdat(7:8),*) iday0

 jul0  = julday(imonth0,iday0,iyear0)
 tnr   = timsec / 3600d0
 ndag  = tnr / 24d0

 call caldat(jul0+ndag,imonth,iday,iyear)

 tsec  =  timsec - ndag*24d0*3600d0
 ihour =   tsec/3600d0
 imin  =  (tsec - ihour*3600d0)/60d0
 isec  =  (tsec - ihour*3600d0 - imin*60d0)

 end subroutine datetime_from_refdat

 integer function julday(mm,id,iyyy)
 implicit none
 integer :: igreg
 integer :: mm, id, iyyy
 integer :: jy, jm, ja
 parameter (igreg=15+31*(10+12*1582))
 !     if (iyyy.eq.0) pause 'there is no year zero.'
 if (iyyy.lt.0) iyyy=iyyy+1
 if (mm.gt.2) then
   jy=iyyy
   jm=mm+1
 else
   jy=iyyy-1
   jm=mm+13
 endif
 julday=int(365.25*jy)+int(30.6001*jm)+id+1720995
 if (id+31*(mm+12*iyyy).ge.igreg) then
   ja=int(0.01*jy)
   julday=julday+2-ja+int(0.25*ja)
 endif
 return
 end function julday

 subroutine caldat(julian,mm,id,iyyy)
 implicit none
 integer :: julian,mm,id,iyyy
 integer :: igreg
 parameter (igreg=2299161)
 integer :: jalpha, ja, jb, jc, jd, je
 if(julian.ge.igreg)then
   jalpha=int(((julian-1867216)-0.25)/36524.25)
   ja=julian+1+jalpha-int(0.25*jalpha)
 else
   ja=julian
 endif
 jb=ja+1524
 jc=int(6680.+((jb-2439870)-122.1)/365.25)
 jd=365*jc+int(0.25*jc)
 je=int((jb-jd)/30.6001)
 id=jb-jd-int(30.6001*je)
 mm=je-1
 if(mm.gt.12)mm=mm-12
 iyyy=jc-4715
 if(mm.gt.2)iyyy=iyyy-1
 if(iyyy.le.0)iyyy=iyyy-1
 return
 end subroutine caldat


 subroutine getnumknuml(k,L)
 use m_netw
 implicit none

 integer :: k
 integer :: L
 k = NUMK
 L = NUML
 end subroutine getnumknuml


 subroutine iadvecini()
 use m_flowgeom
 use m_flow
 use unstruc_messages
 implicit none
 integer :: L, jado

 jado = 0
 if (jado == 1) then
 if (cflmx > 0.9d0 )  then
    if (iadvec == 3) then
        iadvec = 5
    else if (iadvec == 4) then
        iadvec = 6
    else
        iadvec = 5
    endif
    call mess(LEVEL_INFO, 'CFLMax > 0.9, Advectype switched to semi implicit Piaczek&Williams ')
 else if (cflmx < 0.71d0) then
    if (iadvec == 5) then
        iadvec = 3
        call mess(LEVEL_INFO, 'CFLMax < 0.71 Advectype switched to explicit ')
    else if (iadvec == 6) then
        iadvec = 4
        call mess(LEVEL_INFO, 'CFLMax < 0.71 Advectype switched to explicit ')
    endif
 endif
 endif


 if (kmx > 0 .or. iadvec == 0) iadvec1D = iadvec                  ! for now, same if 3D
 do L = 1,lnx
    if (iadv(L) .ne. -1) then
       iadv(L) = iadvec
       if (L <= Lnx1D) then
          if ( iadvec .ne. 0) iadv(L) = iadvec1D ! voorlopig altijd piacz impl 4 voor 1D
       endif
    endif
 enddo

 end subroutine iadvecini


 subroutine wricells(mout)                       ! write flow cell surrounding netnodes
 use m_netw
 use m_flowgeom

 implicit none
 integer :: mout, n, j

 write(mout,'(A,I12)') 'NR of NETNODES           = ', numk    ! nump = ndx
 write(mout,'(A,I12)') 'NR of NETLINKS           = ', numL    ! nump = ndx
 write(mout,'(A,I12)') 'NR of internal FLOWCELLS = ', nump    ! nump = ndx
 do n = 1,nump
    write(mout,'(10I10)') netcell(n)%n, (netcell(n)%NOD(j), j=1,netcell(n)%n )
 enddo

 end subroutine wricells


 subroutine checkcellfile(mout)                      ! check first two lines for consistency
 use m_netw
 use m_flowgeom

 implicit none
 integer             :: mout, numkr, numlr, L1
 character (len=256) :: rec

 read(mout,'(A)',end = 999) rec
 L1 = index(rec,'=') + 1
 read (rec(L1:), *, err = 888) numkr
 if (numkr .ne. numk) then
    call doclose(mout) ; mout = 0 ; return
 endif

 read(mout,'(A)',end = 999) rec
 L1 = index(rec,'=') + 1
 read (rec(L1:), *, err = 777) numlr
 if (numLr .ne. numL) then
    call doclose(mout) ; mout = 0 ; return
 endif
 return

 999 call    eoferror(mout)
 888 call qnreaderror('trying to read nr of net nodes but getting',rec,mout)
 777 call qnreaderror('trying to read nr of net links but getting',rec,mout)

 end subroutine checkcellfile

   
   !> Reads custom parameters for 1D2D links from a *.ini file,
   !! and assigns them to the correct flow links.
   subroutine load1D2DLinkFile(filename)
      use m_missing, only: dmiss
      use string_module, only: strcmpi
      use m_flowgeom, only: lnx1d, kcu, wu1D2D, hh1D2D, xz, yz, ndx, ln, lnx, lnx1D
      use m_inquire_flowgeom
      use properties
      use unstruc_messages
      use timespace
      use unstruc_model, only: File1D2DLinkMajorVersion, File1D2DLinkMinorVersion      

      implicit none

      character(len=*), intent(in)    :: filename !< Name of *.ini file containing 1D2D link parameters.

      integer, external :: linkTypeToInt

      type(tree_data), pointer :: md_ptr 
      type(tree_data), pointer :: node_ptr
      integer                  :: istat
      integer                  :: numblocks
      integer                  :: i
                            
      character(len=IdLen)     :: contactId
      character(len=IdLen)     :: contactType
      integer                  :: icontactType
                            
      logical :: success       
      integer                  :: major, minor, ierr
      integer                  :: numcoordinates
      double precision, allocatable :: xcoordinates(:), ycoordinates(:)
      integer                  :: loc_spec_type

      integer                  :: numcontactblocks, numok
      character(len=IdLen)     :: buf
      integer, allocatable     :: ke1d2dprops(:)
      integer                  :: num1d2dprops
      integer                  :: LL, Lf
      double precision         :: wu1D2Dread, hh1D2Dread

      call tree_create(trim(filename), md_ptr)
      call prop_file('ini',trim(filename),md_ptr, istat)
      
      ! check FileVersion
      ierr = 0
      major = 0
      minor = 0
      call prop_get_version_number(md_ptr, major = major, minor = minor, success = success)
      if (.not. success .or. major < File1D2DLinkMajorVersion) then
         write (msgbuf, '(a,i0,".",i2.2,a,i0,".",i2.2,a)') 'Unsupported format of 1D2DLinkFile detected in '''//trim(filename)//''': v', major, minor, '. Current format: v',File1D2DLinkMajorVersion,File1D2DLinkMinorVersion,'. Ignoring this file.'
         call warn_flush()
         ierr = 1
      end if
      
      if (ierr /= 0) then
         goto 999
      end if

      allocate(ke1d2dprops(lnx1D))

      numblocks = 0
      if (associated(md_ptr%child_nodes)) then
         numblocks = size(md_ptr%child_nodes)
      end if

      numcontactblocks = 0
      numok = 0
      do i = 1, numblocks
         node_ptr => md_ptr%child_nodes(i)%node_ptr

         if (strcmpi(tree_get_name(node_ptr), 'MeshContactParams')) then
            numcontactblocks = numcontactblocks + 1

            ! Read Data
            contactType = 'all'
            call prop_get_string(node_ptr, '', 'contactType', contactType, success)
            icontactType = linkTypeToInt(contactType)
            if (icontactType < 0) then
               write (msgbuf, '(a,i0,a)') 'Error reading mesh contact parameters from block #', numcontactblocks, ' in file ''' // &
                                             trim(filename)//'''. Invalid contactType '''//trim(contactType)//''' given.'
               call err_flush()
               success = .false.
               cycle
            end if

            call prop_get_string(node_ptr, '', 'contactId', contactID, success)
            if (success) then ! the contact is defined by contactId
               loc_spec_type = LOCTP_UNKNOWN ! TODO: AVD: LOCTP_CONTACT_ID
            else ! the contact is defined by x, y coordinates and contactType
               call prop_get(node_ptr, '', 'numCoordinates',   numcoordinates, success)
               if (success .and. numcoordinates > 0) then
                  allocate(xcoordinates(numcoordinates), stat=ierr)
                  allocate(ycoordinates(numcoordinates), stat=ierr)
                  call prop_get_doubles(node_ptr, '', 'xCoordinates',     xcoordinates, numcoordinates, success)
                  if (success) then
                     call prop_get_doubles(node_ptr, '', 'yCoordinates',     ycoordinates, numcoordinates, success)
                  end if
                  if (success) then
                     loc_spec_type = LOCTP_POLYGON_XY
                  end if
               end if

               if (.not. success) then
                  write (msgbuf, '(a,i0,a)') 'Error Reading mesh contact parameters from block #', numcontactblocks, ' in file ''' // &
                                              trim(filename)//'''. No contactId or coordinates specified.'
                  call err_flush()
                  cycle
               end if

               num1d2dprops = 0
               call selectelset_internal_links( xz, yz, ndx, ln, lnx, ke1d2dprops(1:lnx1D), num1d2dprops, &
                                                loc_spec_type, nump = numcoordinates, xpin = xcoordinates, ypin = ycoordinates, &
                                                linktype = icontactType)

               
               select case (icontactType)
               case (IFLTP_1D2D_STREET)
                  call prop_get(node_ptr, '', 'openingWidth',  wu1D2Dread, success)
                  if (.not. success) then
                     write (msgbuf, '(a,i0,a)') 'Error Reading mesh contact parameters from block #', numcontactblocks, ' in file ''' // &
                                                 trim(filename)//'''. No openingWidth specified.'
                     call err_flush()
                     cycle
                  end if

                  call prop_get(node_ptr, '', 'openingHeight', hh1D2Dread, success)
                  if (.not. success) then
                     write (msgbuf, '(a,i0,a)') 'Error Reading mesh contact parameters from block #', numcontactblocks, ' in file ''' // &
                                                 trim(filename)//'''. No openingHeight specified.'
                     call err_flush()
                     cycle
                  end if
               end select

               do LL=1,num1d2dprops
                  Lf = ke1d2dprops(LL)
                  wu1D2D(Lf) = wu1D2Dread
                  hh1D2D(Lf) = hh1D2Dread
               end do

            end if
            numok = numok + 1
         endif
      end do
      
      write(msgbuf,'(i0,a,i0,2a)') numok, ' of ', numcontactblocks, ' mesh contact parameter blocks have been read from file ', trim(filename)
      call msg_flush()
      
   999   continue
      call tree_destroy(md_ptr)

   end subroutine load1D2DLinkFile


   !> Parses a link type/mesh contact's type string into an integer
   !! that can be used to compare agains kn(3,:) codes.
   !!
   !! Currently supported names: internal, lateral, embedded, longitudinal, streetInlet, roofGutterPipe, all.
   function linkTypeToInt(linkTypeString) result (res)
   use string_module, only: str_tolower
   use m_inquire_flowgeom
      character(len=*), intent(in) :: linkTypeString  !< Type value as given in input file.
      integer                      :: res             !< The returned link type integer code. (3/4/5/7). -1 for unknown type.

      select case(str_tolower(trim(linkTypeString)))
      case('internal', 'lateral', 'embedded')
         res = IFLTP_1D2D_INT
      case('longitudinal')
         res = IFLTP_1D2D_LONG
      case('streetinlet')
         res = IFLTP_1D2D_STREET
      case('roofgutterpipe')
         res = IFLTP_1D2D_ROOF
      case('all') ! Special type to support selecting any link type
         res = IFLTP_ALL
      case default
         res = -1
      end select
      
   end function linkTypeToInt


 subroutine flow_geominit(iphase)                          ! initialise flow geometry
 use m_netw
 use m_flowgeom
 use m_GlobalParameters, only: INDTP_2D
 use unstruc_model
 use m_flowexternalforcings
 use m_physcoef
 use m_flowparameters
 use m_flowtimes, only : ti_waq
 use m_sferic
 use m_missing
 use m_alloc
 use unstruc_files, only : basename
 use m_orthosettings
 use m_xbeach_data, only: swave, Lwave, itheta_view
 use m_heatfluxes
 use unstruc_boundaries
 use m_partitioninfo
 use dfm_error
 use m_ship
 use kdtree2Factory
 use unstruc_display, only: jagui
 use unstruc_messages
 use string_module
 use m_plotdots
 use geometry_module, only: getdx, getdy, dbdistance, normalin, normalout, half, duitpl, dlinedis
 use sorting_algorithms, only: indexx
 use m_flowtimes, only: ti_waq
 use gridoperations
 use m_flow, only : numlimdt, numlimdt_baorg, a1ini
 use m_oned_functions
 use unstruc_channel_flow, only : network

 implicit none

 integer,     intent(in) :: iphase   ! phase in geominit, 0 (all), 1 (first) or 2 (second)

 character(len=100)      :: fnam

 ! locals
 integer                 :: m,n,k,k1,k2,k3,k4,L,Lf,LL,LLL,ierr,i12,nn,ja,kh, numswap, Li, n12, kk, La
 integer                 :: n1, n2, n1a, n2a, jaslopes, ja1D, ka, kb, k1n, k2n
 integer                 :: mcel                     ! unit nr Cells And Links file
 integer                 :: jarcinfo  = 1
 integer                 :: makecelfile, nc1, nc2, nex
 double precision        :: zzz, sig                 ! for bottom level help
 double precision        :: dxn1e                    ! node 1 - edge distance
 double precision        :: dxn2e                    ! node 2 - edge distance
 double precision        :: x12, y12                 ! link center coordinates
 double precision        :: x34, y34                 ! face center coordinates
 double precision        :: rn,rt                    ! for link L, normal and tangent base vectors
 double precision        :: rnl,rtl                  ! for other links LL, normal and tangent base vectors
 double precision        :: fi,fix,fiy               ! weight factor inverse area (m2)
 double precision        :: fil                      ! distance center to edge times edge width (m2)
 double precision        :: si, prodin               ! sign to make all links either incoming or outgoing, see down
 double precision        :: ortho, avortho           ! inner product of link and face
 double precision        :: af, csza                 ! only for subr readyy
 double precision        :: askew, aflat, triskew,triflat, bla, xza, yza, xx(6), yy(6), zz(2)          ! for skewness
 logical                 :: jawel                    ! filecheck
 logical                 :: isbadlink                ! Bad link (e.g. too short)
 character(len=5)        :: txt

 integer                 :: nw, L1, L2, LLA , nw11   ! wall stuff
 integer                 :: icn                      ! corner stuff
 integer                 :: kk1,kk2,kk3 , mout       ! banf stuff
 double precision        :: dlength, dlenmx, dxorgL
 double precision        :: dxx, dyy, rrr, cs, sn, dis, c11, c22, c12, xn, yn, xt, yt, rl, sf, hdx, alfa, dxlim, dxlink
 double precision        :: atpf_org, circumormasscenter_org, phase, zkk
 double precision        :: xref, yref
 integer                 :: itatp_org, jaend ! , jarerun=0
 
 double precision, allocatable :: banh(:) , rr(:)       ! temp
 integer         , allocatable :: nbanh(:,:) , nr(:)    ! temp

! character(len=200), dimension(:), allocatable :: fnames
! integer                                       :: ifil

 double precision        :: xh, yh

 integer                 :: jaidomain, jaiglobal_s

 double precision, external    :: cosphiu
 integer :: ndraw
 COMMON /DRAWTHIS/ ndraw(50)

 if (numk <= 2 .or. numl <= 1 ) return               ! only do this for sufficient network

 do L = 1, numL   ! isolated 1D netlink not allowed for now, crash in parallel, please check and repair
    k1 = kn(1,L) ; k2 = kn(2,L) ; k3 = kn(3,L)
    if (k3 == 1 .or. k3 == 6) then
       if (nmk(k1) == 1 .and. nmk(k2) == 1) then
           call dumpnetlink('isolated_1Dnetlink ',L)
       endif
    endif
 enddo

 call readyy ('geominit',0d0)

 if (jsferic == 0) then
     jasfer3D = 0
 endif

 if ( iphase.eq.2 ) then
 !  skip to start of second phase
    goto 9002
 end if

 call inisferic()                                    ! initialise spherical parameters

 if (bedslope .ne. 0d0 .or. bedwaveamplitude .ne. 0d0) then
    do k = 1,numk
       if (zk(K) == dmiss) then
          zk(k) = zkuni + xk(k)*bedslope
          if (bedwavelength .ne. 0d0) then
             phase = twopi*xk(k)/bedwavelength
             zk(k) = zk(k) + bedwaveamplitude*cos(phase)
          endif
       endif
    enddo
 endif

 do k = 1,numk
    if (kc(k) .ne. 0) kc(k) = 1                      ! all active grid nodes are now kc = 1 : only to cure old net files
 enddo

!see if subomain numbers should be read from file
 jaidomain = 0
 jaiglobal_s = 0
 if ( jampi.eq.1 .and. npartition_pol.lt.1 ) then
    jaidomain = 1
    jaiglobal_s = 1
 end if

 ierr = DFM_GENERICERROR   ! no error if cell information was read from file
 if (md_findcells == 0 .or. jaidomain.eq.1 .or. jaiglobal_s.eq.1) then
    ! read cells from file, to avoid find cells
    ! and, ONLY read idomain from file if MPI is on AND no polygon enforced.
!    call preparecells(md_netfile, min(jampi, 1-md_genpolygon), ierr)
    call preparecells(md_netfile, jaidomain, jaiglobal_s, ierr)
 end if

 if (md_findcells == 1 .or. ierr /= DFM_NOERR) then  ! Either force findcells, or if cells have not been found in file.
     if ( ierr.eq.DFM_NOERR ) call mess(LEVEL_WARN, 'Domain numbers read from file, but overwriting cell numbering by enforcing findcells.', my_rank)

     call findcells(0)                               ! shortest walks in network (0 means: look for all shapes, tris, quads, pentas, hexas)
     call find1dcells()
 endif

 if ( jaidomain.eq.1 .and. .not. allocated(idomain)) then
    call mess(LEVEL_ERROR, 'Domain numbers could not be read. Either the PartitionFile is missing in the MDU file, or the network file misses domain numbers, in subdomain number', my_rank)
 end if

 if ( jaiglobal_s.eq.1 .and. .not. allocated(iglobal_s)) then
    call mess(LEVEL_INFO, 'Global cell numbers could not be read. Subdomain number:', my_rank)
 end if

 if ( jampi.eq.1 ) then
    call reduce_int_min(jaiglobal_s)
 end if

 !if (len_trim(md_dryptsfile) > 0) then
 !   call strsplit(md_dryptsfile,1,fnames,1)
 !   do ifil=1,size(fnames)
 !      call delete_drypoints_from_netgeom(fnames(ifil),0)
 !   enddo
 !   deallocate(fnames)
 !end if
 call delete_dry_points_and_areas()

! also disabled isolated cells due to cutcells and store masks
  call cutcell_list(6,'dum',3, 1)

 ! if (makeorthocenters .gt. 0 .and. jglobe == 0) then
 if (makeorthocenters .gt. 0) then
    call make_orthocenters(0.5d-2,makeorthocenters)
 endif

 call thindams_on_netgeom()                          ! Convert thin dam-type cross sections to real thin dams in network kn.

 ! AvD: NOTE: We could also place this cosphiunetcheck *after* the nsmalllink
 !  check (see some blocks below). But then again based on flow links. Such
 !  that too small flow link lengths do *not* lead to large cosphiunet values. (TODO?)
 call cosphiunetcheck(1)                             ! Check for bad orthogonality on netlinks
 if (nlinkbadortho > 0) then
    call checknetwork()                              ! If badortho, check entire network for net link crossings.
    lnx = 0
    ndx = 0
    return
 end if


! move partition domain ghostcells back in array
! call partition_arrange_ghostcells(numpi,nump1d2di)

 NDX2D = NUMP                                        ! NR OF 2d CELLS=NUMP
 NDX   = NUMP1d2d                                    ! NR OF 1d and 2d CELLS, = ndxi
 LNX1D = NUML1D

                                                  ! so after this loop the only points with kc = 1 are 1D points
 call readyy ('geominit-FINDLINKS',0.1d0)


 ! Renumber (internal) flow nodes.
 ! Based on link data in lne (ln not yet available), which is almost
 ! correct, except for the links that will be eliminated if distance
 ! between circumcenters is very small.
 !if (jased > 0) jarenumber = 0
 if (jarenumber == 1 .and. nump > 00 .and. (.not. ti_waq > 0d0) ) then
     call renumberFlowNodes()
 end if

 do n = 1,nump
    do m = 1,netcell(n)%n
       k = netcell(n)%NOD(m)
       kc(k) = 2                                     ! all corners of cells are now 2, 1D nodes are still 1
    enddo
 enddo

 ! TODO add elemnode and flowelemnode here...

! note: findexternalboundarypoints reads ext-file for the first time, and not only counts open boundaries
 call findexternalboundarypoints()                   ! total nr of closed boundaries to be opened

 ndxi = NDX                                          ! total nr of 2D cellS (tris, quads, pentas and hexas) plus 1D cells
 ndx  = ndxi + numbnp                                ! add open boundaries

! increase netcell admin. to include boundary nodes (safety)
 call add_boundarynetcells()

 if ( allocated(kcs) )  then
    deallocate ( nd, bl, bai, kcs, bai_mor, ba_mor)  ! and allocate geometry related node arrays
 endif
 allocate ( nd(ndx), bl(ndx), bai(ndx), bai_mor(ndx), ba_mor(ndx), kcs(ndx) , stat = ierr )
 call aerr('nd(ndx), bl(ndx), bai(ndx), bai_mor(ndx), ba_mor(ndx), kcs(ndx)', ierr, 8*ndx ) ; kcs = 1
 bl = dmiss
 ba_mor = 0d0

 ! for 1D only
 if (network%loaded .and. ndxi-ndx2d > 0) then
    call realloc(groundLevel, ndxi-ndx2d, keepExisting = .false., fill = dmiss, stat = ierr)
    call aerr('groundLevel(ndxi-ndx2d)', ierr, ndxi-ndx2d)

    call realloc(groundStorage, ndxi-ndx2d, keepExisting = .false., fill = 0, stat = ierr)
    call aerr('groundStorage(ndxi-ndx2d)', ierr, ndxi-ndx2d)

    call realloc(volMaxUnderground, ndxi-ndx2d, keepExisting = .false., fill = dmiss, stat = ierr)
    call aerr('volMaxUnderground(ndxi-ndx2d)', ierr, ndxi-ndx2d)
 end if
 
 if ( allocated (kfs) ) deallocate(kfs)
 allocate(kfs(ndx))   ;  kfs   = 0

 ! Reallocate circumcenters with extra space for 1D nodes, but keep existing 2D data.
 call realloc(xz , ndx)
 call realloc(yz , ndx)
 call realloc(xzw, ndx)
 call realloc(yzw, ndx)
 call realloc(ba , ndx); ba = 0d0

 do k = 1,ndx
    nd(k)%lnx = 0
 enddo

 M = max(ndx2d/100, 1)
 sarea = 0d0
 !jacenterinside = 1
 do n = 1,ndx2d                                      ! get cell center coordinates 2D

    kcs(n) = 2
    if (mod(n,M) == 0) then
       af = 0.2d0 + 0.6d0*dble(n)/dble(ndx2d)
       call readyy('geominit-cell areas ba',af)
    endif

    ! Cell circumcenters for ndx2d were already determined in findcells.

    call getcellsurface(n, ba(n), xzw(n), yzw(n) )
    sarea = sarea + ba(n)
    call allocateandset2Dnodexyarrays( n )           ! only for plotting...
 enddo
 ! jacenterinside = 0

 fwind  = (5d6 / max(sarea,1d4) )**0.05d0            ! Only for jatem == 3, excess model.

 DO L = 1, NUML1D                                    ! get cell center coordinates 1D
    IF ( KN(3,L) == 1 .or. KN(3,L) >= 3 .and. KN(3,L) <= 7) THEN
       K1n = KN(1,L)   ; K2n = KN(2,L)
       nc1 = lne(1,L)  ; nc2 = lne(2,L)
       N1  = IABS(NC1) ; N2  = IABS(NC2)
       if ( n1.eq.0 ) then
           call dumpnetlink('flownode 1 not found for netlink = ', L)
       end if
       if ( n2.eq.0 ) then
           call dumpnetlink('flownode 2 not found for netlink = ', L)
       end if


       if (nc1 < 0 ) then
          k1 = netcell(n1)%nod(1)
         ! TODO: duplicated codes: xz, yz, xzw, yzw are already computed in subroutine find1Dcells.
          xz(N1) = xk(k1) ; yz(N1) = yk(k1); BL(N1) = ZK(K1); xzw(n1) = xz(n1) ; yzw(n1) = yz(n1)
          if ( .not.allocated(nd(n1)%nod) ) then
             allocate ( nd(n1)%nod(1), stat=ierr )      ! Store original net node with this flow node
             call aerr('nd(n1)%nod(1)', ierr, 1)
          else
             if ( nd(n1)%nod(1).ne.k1 ) then
                call mess(LEVEL_ERROR, '1D numbering error')
             end if
          end if
          nd(n1)%nod(1) = k1
       endif

       if (nc2 <0 ) then
          k2 = netcell(n2)%nod(1)
          xz(n2) = xk(k2) ; yz(n2) = yk(k2); BL(N2) = ZK(K2) ; xzw(n2) = xz(n2) ; yzw(n2) = yz(n2)
          if ( .not.allocated(nd(n2)%nod) ) then
             allocate ( nd(n2)%nod(1), stat=ierr )
             call aerr('nd(n2)%nod(1)', ierr, 1)
          else
             if ( nd(n2)%nod(1).ne.k2 ) then
                call mess(LEVEL_ERROR, '1D numbering error')
             end if
          end if
          nd(n2)%nod(1) = k2
       endif
    endif
 enddo

 lnxi  = 0
 lnx1D = 0
 nlinktoosmall = 0

 do L  = 1,numl                                      ! count nr of edges that connect cells, ie. have nd1 and nd2
    n1 = iabs(lne(1,L)) ; n2 = iabs(lne(2,L))
    if (n1 .ne. 0 .and. n2 .ne. 0 .and. KN(3,L) /= 0) then    ! so that you know the nr of lins to be allocated

       isbadlink = .false.
       ! Check on too short flow links. Only for 2D. 1D is always considered 'good'.
       if (KN(3,L) == 2) then
          dxlim  = 0.9d0*removesmalllinkstrsh*0.5d0*(sqrt(ba(n1)) + sqrt(ba(n2)))
          dxlink = dbdistance(xz(n1), yz(n1), xz(n2), yz(n2), jsferic, jasfer3D, dmiss)
          if (dxlink < dxlim) then
            isbadlink = .true.
          end if
       end if

       if (.not. isbadlink) then
          lnxi = lnxi + 1                                              ! prevents connection between overlying identical elements
          IF ( KN(3,L) == 1 .or. KN(3,L) >= 3 .and. KN(3,L) <= 7) THEN ! Also recount 1D flow links (in case some are
             lnx1D = lnx1D+1                                           ! thrown away by this distance check)
          end if
       else
          nlinktoosmall = nlinktoosmall + 1
          if (nlinkbadortho+nlinktoosmall > size(linkbadqual)) then
            call realloc(linkbadqual, ceiling(1.2*nlinkbadortho+nlinktoosmall))
          end if
          linkbadqual(nlinkbadortho+nlinktoosmall) = L
          lne(1,L) = 0 ; lne(2,L) = 0 ; LNN(L) = 0
       endif
    else
       continue
    endif
 enddo
 if (nlinktoosmall > 0) then

!    copy bad link coordinates to dots
     numdots = 0
     do k=1,nlinkbadortho+nlinktoosmall
        L = linkbadqual(k)
        k1 = kn(1,L)
        k2 = kn(2,L)
        call half(xk(k1),yk(k1),xk(k2),yk(k2),xref,yref, jsferic, jasfer3D)
        call adddot(xref,yref)
     end do

     write (txt,'(i5)') nlinktoosmall
     if ( jagui.ne.1 ) then
        call qnerror(txt//' small flow links discarded. Run ''merge circumcenters'' to remove small flow links or increase threshold', ' ', ' ')
     else
        call qnerror(txt//' small flow links discarded. Run ''remove small flowlinks'' to remove small flow links or increase threshold', ' ', ' ')
     end if
     NDRAW(2)=5 !< Automatically set 'Display > Network + crossing/quality checks'
 end if
 if (lnxi == 0 .and. numbnp.eq.0 ) return


 lnx = lnxi + numbnp                                 ! add open boundary points

 call readyy ('geominit-NODELINKS         ',0.5d0)

 if (allocated (ln) ) deallocate(ln,lncn,bob,bob0, dx,dxi,wu,wui,kcu,csu,snu,acl,iadv,teta,wu_mor,wu1D2D,hh1D2D)
 if (allocated(ibot)) deallocate(ibot)
 allocate (  ln   (2,lnx) , stat=ierr  )
 call aerr( 'ln   (2,lnx)', ierr, 2*lnx)
 allocate (  lncn (2,lnx) , stat=ierr  )
 call aerr( 'lncn (2,lnx)', ierr, 2*lnx)
 allocate (  bob  (2,lnx) , stat=ierr  )
 call aerr( 'bob  (2,lnx)', ierr, 2*lnx)
 allocate (  bob0  (2,lnx) , stat=ierr  )
 call aerr( 'bob0  (2,lnx)', ierr, 2*lnx)
 allocate (  dx   (  lnx) , stat=ierr )
 call aerr( 'dx   (  lnx)', ierr, lnx )
 allocate (  dxi  (  lnx) , stat=ierr )
 call aerr( 'dxi  (  lnx)', ierr, lnx )
 allocate (  wu   (  lnx) , stat=ierr )
 call aerr( 'wu   (  lnx)', ierr, lnx )
 allocate (  wu_mor (  lnx) , stat=ierr )
 call aerr( 'wu_mor (  lnx)', ierr, lnx )
 allocate (  wui  (  lnx) , stat=ierr )
 call aerr( 'wui  (  lnx)', ierr, lnx )
 allocate (  wu1D2D(lnx1D) , stat=ierr )
 call aerr( 'wu1D2D(lnx1D)', ierr, lnx1D )
 allocate (  hh1D2D(lnx1D) , stat=ierr )
 call aerr( 'hh1D2D(lnx1D)', ierr, lnx1D )
 allocate (  kcu  (  lnx) , stat=ierr ); kcu = 0
 call aerr( 'kcu  (  lnx)', ierr, lnx )
 allocate (  csu  (  lnx) , stat=ierr )
 call aerr( 'csu  (  lnx)', ierr, lnx )
 allocate (  snu  (  lnx) , stat=ierr )
 call aerr( 'snu  (  lnx)', ierr, lnx )
 allocate (  acl  (  lnx) , stat=ierr )
 call aerr( 'acl  (  lnx)', ierr, lnx )
 allocate (  acn  (2,lnx) , stat=ierr ) ! will be deallocated after cornerweights
 call aerr( 'acn  (2,lnx)', ierr, lnx )
 allocate (  iadv   (lnx) , stat= ierr); iadv = 0
 call aerr( 'iadv   (lnx)', ierr, lnx )
 allocate (  teta   (lnx) , stat= ierr); teta = 0
 call aerr( 'teta   (lnx)', ierr, lnx )
 allocate (  ibot   (lnx) , stat= ierr); ibot = 0
 call aerr( 'ibot   (lnx)', ierr, lnx )

 if (allocated(xu) ) deallocate(xu,yu,blu)
 allocate ( xu(lnx), yu(lnx) , blu(lnx) ,  stat = ierr)
 call aerr('xu(lnx), yu(lnx) , blu(lnx)',  ierr, 3*lnx) ; blu = dmiss


 if (allocated (ln2lne) ) deallocate ( ln2lne, lne2ln )
 nex = max(lnx,numl)
 allocate (  ln2lne (nex) , stat=ierr ) ! local array
 call aerr( 'ln2lne (nex)', ierr, nex ); ln2lne = 0
 allocate (  lne2ln (nex) , stat=ierr ) ! local array
 call aerr( 'lne2ln (nex)', ierr, nex ); lne2ln = 0

 call readyy ('geominit',0.86d0)
 Lf = 0

 do L = 1,numl                                        ! again count nr of edges and fill in links
    n1  = lne(1,L) ; n2  = lne(2,L)
    n1a = iabs(n1) ; n2a = iabs(n2)
!    if (n1 .ne. 0 .and. n2 .ne. 0) then              ! L=net, Lf=flow
    if (n1 .ne. 0 .and. n2 .ne. 0 .and. KN(3,L) /= 0) then          ! L=net, Lf=flow
       Lf         = Lf + 1
       ln(1,LF)   = n1a
       ln(2,LF)   = n2a
       ln2lne(LF) = L
       lne2ln(L)  = LF
       if (kn(3,L) == 1 .or. kn(3,L) == 6) then                      ! 1D link
          kcu(Lf) = 1
       else if (kn(3,L) == 4) then
          k1  = kn(1,L) ; k2 = kn(2,L)
          jaend = 0
          if (nmk(k1) == 1 .or. nmk(k2) == 1) then
              jaend = 1
          endif
          if (jaend == 1 .and. n1a > ndx2d .and. n2a <= ndx2d .or. &
              jaend == 1 .and. n2a > ndx2d .and. n1a <= ndx2d ) then
             kcu(Lf) = 4                                   ! 1D2D longitudinal link
             nc2 = n2a
             if (n1a <= ndx2d) then
                nc2 = n1a
             endif
             call WHICH2DNETLINKWASCROSSED(nc2,k1,k2,LL )  ! TEMP STORE CROSSED 2d NETLINK IN LC
             if (lnn(LL) == 2) then
                call dumpnetlink('netlink kn3==4 not on border of 2D net ', LL)
             endif
             ln2lne(LF) = LL                               ! refer back to crossed 2D netlink instead of to 1D netlink
          else                                             ! 1D link
             kcu(Lf) = 1
          endif
       else if (kn(3,L) == 3 .or. kn(3,L) == 7) then
          if (n1a > ndx2d .and. n2a <= ndx2d .or. &
             n2a > ndx2d .and. n1a <= ndx2d ) then
             kcu(Lf) = kn(3,L)                                ! 1D2D internal link
             if (n1a <= ndx2d) then
                kcs(n1a) = 21
             endif
             if (n2a <= ndx2d) then
                kcs(n2a) = 21
             endif
             if (kcs(n2a)*kcs(n1a) .ne. 21) then
                 write (msgbuf, '(a,i0,a)') '(netlink L=', L, ')'
                 call qnerror('1d2d link kn3 = 3 or 5 or 7 not connected between kcs=21 and kcs=1 ',trim(msgbuf),' ')
             endif
          else
             write (msgbuf, '(a,i0,a)') '(netlink L=', L, ')'
             call qnerror('1d2d link kn3 = 3 or 7 not connected between 1D node and 2D cell ',trim(msgbuf),' ')
          endif
       else if (kn(3,L) == 5) then
          if (n1a > ndx2d .and. n2a <= ndx2d .or. &
              n2a > ndx2d .and. n1a <= ndx2d .or. &
              n2a <= ndx2d .and. n1a <= ndx2d) then
             kcu(Lf) = kn(3,L)                                ! 1D2D internal link, now also between 2 2D pts
             if (n1a <= ndx2d) then
                kcs(n1a) = 21
             endif
             if (n2a <= ndx2d) then
                kcs(n2a) = 21
             endif
          else
             write (msgbuf, '(a,i0,a)') '(netlink L=', L, ')'
             call qnerror('1d2d link kn3 = 5 not connected to 2D cell ',trim(msgbuf),' ')
          endif
       else if (kn(3,L) == 2) then                         ! 2D link
          kcu(Lf) = 2
       endif
    else if (n1  == 0) then                          ! if negative, refer back to attached node
       lne2ln(L)  = -n2
    else if (n2  == 0) then
       lne2ln(L)  = -n1
    endif
 enddo

 call addexternalboundarypoints()                    ! add links due to open boundaries

 numswap = 0
 do L  = 1,lnx                                       ! for all 2d links, check positivity

    k1 = ln(1,L)               ! o---4---o  1,2: flow nodes, 3,4: net nodes
    k2 = ln(2,L)               ! | 1 | 2 |  L: 1--2  Ln=ln2lne(L): 3--4
    k3 = kn(1,ln2lne(L))       ! o---3---o  lncn(:,L) = 3--4, or 4--3 if
    k4 = kn(2,ln2lne(L))       !            ||3--4 X 1--2|| < 0,
                               ! i.e., flux is 'to the right' through net link 3--4.

    ja1D  = 0
    if (kcu(L) == 1 .or. kcu(L) == -1 .or. kcu(L) == 4) then
       ja1D = 1
    endif

    if (ja1D == 1) then
       call half(xz(k1),yz(k1),xz(k2),yz(k2),xu(L),yu(L), jsferic, jasfer3D)
    else
       call half(xk(k3),yk(k3),xk(k4),yk(k4),xu(L),yu(L), jsferic, jasfer3D)
    endif

    if (abs(kcu(L)) == 2) then
       call normalin(xz(k1), yz(k1), xz(k2), yz(k2), rnl, rtl, xu(L), yu(L),jsferic, jasfer3D, dxymis)  ! in pos L direction
       call normalin(xk(k3), yk(k3), xk(k4), yk(k4), rn , rt,  xu(L), yu(L),jsferic, jasfer3D, dxymis)  ! edge

       if (rnl*rt - rtl*rn < 0) then                    ! checking/ensuring positive local axis orientation
          kh = k4
          k4 = k3
          k3 = kh
          numswap = numswap + 1
       endif                                            ! indeed, now this may occur

       lncn(1,L) = k3                                   ! used in eddy visc terms
       lncn(2,L) = k4
    else if ( kcu(L) == 1 ) then                        ! keep natural reference
       lncn(1,L) = k3
       lncn(2,L) = k4
    else if ( kcu(L) == -1 ) then                       ! refer twice to last netnode
       if      (nmk(k3) == 1) then
          lncn(1,L) = k3
          lncn(2,L) = k3
       else if (nmk(k4) == 1) then
          lncn(1,L) = k4
          lncn(2,L) = k4
       endif

    else if ( kcu(L) == 3 .or. kcu(L) == 4 .or. kcu(L) == 5 .or. kcu(L) == 7 ) then       ! 1D2D, inherit 2D keep natural reference

       lncn(1,L) = k3
       lncn(2,L) = k4

    endif
 enddo

 call readyy ('geominit',0.88d0)

 do L = 1,lnx                                        ! for all links, count nr of links attached to a node
    k1 = ln(1,L)
    nd(k1)%lnx = nd(k1)%lnx + 1
    k2 = ln(2,L)
    nd(k2)%lnx = nd(k2)%lnx + 1
 enddo

 call readyy ('geominit',0.90d0)

 do k = 1,ndx                                        ! for all nodes, allocate linknrs
! GD: memory leak
!    if(allocated(nd(k)%ln)) deallocate(nd(k)%ln)

    allocate ( nd(k)%ln ( nd(k)%lnx ) ,stat=ierr)
    call aerr('nd(k)%ln ( nd(k)%lnx',ierr, nd(k)%lnx )
    nd(k)%ln  = 0                                    ! set to zero for recount
    nd(k)%lnx = 0
 enddo

 do L = 1,lnx                                        ! for all links, recount nr of links attached to a node
    k1 = ln(1,L)
    nd(k1)%lnx = nd(k1)%lnx + 1
    nd(k1)%ln(nd(k1)%lnx) = - L                      ! outflowing, negative indexnr
    k2 = ln(2,L)
    nd(k2)%lnx = nd(k2)%lnx + 1
    nd(k2)%ln(nd(k2)%lnx) =   L                      ! inflowing, positive indexnr
 enddo

! sort flowlinks
  call sort_flowlinks_ccw()

! start of second phase
9002 continue

 call readyy ('geominit-METRICS               ',0.92d0)

 if ( allocated(cn) ) deallocate(cn,ucnx,ucny,ban) ! vort

 allocate (  cn (numk) , stat = ierr)                ! some cell corner related stuff
 call aerr(' cn (numk)', ierr, numk)
 allocate ( ucnx(numk) , stat = ierr)
 call aerr('ucnx(numk)', ierr, numk)
 allocate ( ucny(numk) , stat = ierr)
 call aerr('ucny(numk)', ierr, numk)
 allocate ( ban (numk) , stat=ierr  )                ! for keeps, netnode area
 call aerr('ban (numk)', ierr, numk )

 cn  (1:numk)%lnx = 0
 cn  (1:numk)%nwx = 0
 ucnx(1:numk) = 0
 ucny(1:numk) = 0
 ban (1:numk) = 0

 do L = 1,lnx                                        ! for all links, set dx and coordinates
    k1    = ln(1,L)
    k2    = ln(2,L)
    k3    = lncn(1,L)
    k4    = lncn(2,L)

    ja1D  = 0
    if (kcu(L) == 1 .or. kcu(L) == -1 .or. kcu(L) == 4) then
       ja1D = 1
    endif

    if (ja1D == 1) then
       call half(xz(k1),yz(k1),xz(k2),yz(k2),xu(L),yu(L), jsferic, jasfer3D)
    else
       call half(xk(k3),yk(k3),xk(k4),yk(k4),xu(L),yu(L), jsferic, jasfer3D)
    endif

    dx(L) = dbdistance ( xz(k1), yz(k1), xz(k2), yz(k2), jsferic, jasfer3D, dmiss)  ! set link length
    ! Optionally, override dx(L) with netlink length as read from file (typically 1D with user-defined branch lengths).
    if (allocated(dxe) .and. ja1D == 1) then
       LL = ln2lne(L)
       if (dxe(LL) /= dmiss) then
          dx(L) = dxe(LL) ! NOTE: also see izbndpos correction after this loop
       end if
    end if

    if (kcu(L) == 4) then                                  ! 1D2D lateral link, normal to 2D netlink
       call normalout(xk(k3), yk(k3), xk(k4), yk(k4), xn, yn, jsferic, jasfer3D, dmiss, dxymis)
       call normalin (xz(k1), yz(k1), xz(k2), yz(k2), xt, yt, xu(L), yu(L),jsferic, jasfer3D, dxymis)
       if ( xn*xt + yn*yt < 0d0) then
          lncn(1,L) = k4
          lncn(2,L) = k3
       endif
       dx(L) = dx(L) * abs( xn*xt + yn*yt )
    else if (kcu(L) == 3 .or. kcu(L) == 5 .or. kcu(L) == 7) then            ! 1D2D internal link, some averaged 2D length
       k = 0
       if (kcs(k1) == 21) k = k1
       if (kcs(k2) == 21) k = k2
       if (k == 0) then
          write (msgbuf, '(a,i0,a)') '(netlink L=', ln2lne(L), ')'
          call qnerror('1d2d link kcu=3 or 5 not connected to kcs=21 ',trim(msgbuf),' ')
       else
          dx(L) = max(dx(L), 0.5d0*sqrt(ba(k)) )
       endif
    endif

!   for partition_init: compute temporary csu, snu (will be overwritten in phase 2), based on xzw, yzw (instead of xz, yz)
    if (kcu(L) .ne. 4) then
       call normalin (xzw(k1), yzw(k1), xzw(k2), yzw(k2), rn, rt,xu(L),yu(L),jsferic, jasfer3D, dxymis)  ! = normalin (k1,k2)
    else
       call normalout(xk(k3), yk(k3), xk(k4), yk(k4), rn, rt, jsferic, jasfer3D, dmiss, dxymis)  ! 1D2D
    endif

    csu(L) = rn ; snu(L) = rt
 enddo

 if (allocated(dxe) .and. izbndpos /= 0) then
    ! Optionally fix dx for waterlevel type boundaries affected by izbndpos
    do k = 1, nbndz
       L  = kez(k)
       Lf = lne2ln(L)
       if (dxe(L) /= dmiss .and. L <= numl1d) then ! 1D Boundary
          if (izbndpos == 0) then                      ! full grid cell outward
             dx(Lf) = dxe(L)
          else if (izbndpos == 1) then                 ! half a grid cell outward
             dx(Lf) = .5d0*dxe(L)
          else ! izbndpos==2                           ! on specified boundary polyline
             continue ! nowhere supported yet
          end if
       end if
    end do
 end if

 ! end of first phase
 if ( iphase.eq.1 ) then
    return
 end if

 call setbedlevelfromextfile()                     ! set bl bathymetry if specified through file, so ibedlevtype must be 1

 ! Default parameters for 1D2D links
 do L = 1,lnx1D
    if (kcu(L) == 5) then
       wu1D2D(L) = wu1Duni5
       hh1D2D(L) = hh1Duni5
    else if (kcu(L) == 7) then
       wu1D2D(L) = wu1Duni7
       hh1D2D(L) = hh1Duni7
    else
       wu1D2D(L) = wu1Duni
       hh1D2D(L) = hh1Duni
    endif
 end do

 ! Custom parameters for 1D2D links
 if (len_trim(md_1d2dlinkfile) > 0) then
    call load1D2DLinkFile(md_1d2dlinkfile)
 end if
    
 IF (ALLOCATED (prof1D) ) deallocate( prof1D)
 allocate  ( prof1D(3,lnx1D) , stat= ierr)
 call aerr ('prof1D(3,lnx1D)', ierr, 2*lnx1D)
 do L = 1,lnx1D
    prof1D(1,L) = wu1D2D(L)           !  prof1d(1,*) > 0 : width   or prof1d(1,*) < 0 : ka ref
    prof1D(2,L) = hh1D2D(L)           !  prof1d(2,*) > 0 : height  or prof1d(2,*) < 0 : kb ref
    if (kcu(L) == 5) then             !  restricting dimensions of streetinlet
       prof1D(3,L) = iproftypuni5      !  prof1d(3,*) > 0 : ityp    or prof1d(3,*) < 0 : alfa tussen a en b .
    else if (kcu(L) == 7) then        !  restricting dimensions of roofgutterpipe
       prof1D(3,L) = iproftypuni7      !  prof1d(3,*) > 0 : ityp    or prof1d(3,*) < 0 : alfa tussen a en b .
    else
       prof1D(3,L) = iproftypuni       !  prof1d(3,*) > 0 : ityp    or prof1d(3,*) < 0 : alfa tussen a en b .
    endif
 enddo

 IF (ALLOCATED (Lbnd1D) ) deallocate( Lbnd1D)
 allocate  ( Lbnd1D(lnxi+1:lnx) , stat= ierr) ;  Lbnd1D = 0
 call aerr ('Lbnd1D(lnxi+1:lnx)', ierr, lnx-lnxi+1)

 IF (ALLOCATED (grounlay) ) deallocate( grounLay)
 allocate  ( grounLay(lnx1D) , stat= ierr) ; grounLay = dmiss
 call aerr ('grounLay(lnx1D)', ierr, Lnx1D)

 teta = abs(teta0)                   ! set spatially constant teta. Override only in setdt for ivariableteta = 2
 if (teta0 == 1d0) then
    ivariableteta = 0                ! fully implicit
    teta = 1d0
 else if (teta0 <  0  ) then
    ivariableteta = 2                ! variable teta
 else
    ivariableteta = 1                ! constant teta
    teta = teta0
 endif
 call setprofs1D()                                        ! get prof1D by reading and interpolating profiles

 do L = 1,lnx                                             ! for all links, set link width
    k1    = ln(1,L)
    k2    = ln(2,L)
    k3    = lncn(1,L)
    k4    = lncn(2,L)

    if (kcu(L) == 1 .or. kcu(L) == -1 .or. kcu(L) == 3 .or. kcu(L) == 4 .or. kcu(L) == 5 .or. kcu(L) == 7) then
       LL = L
       if ( kcu(L) == -1) then                            ! 1D boundary link, find attached regular link
          if (iabs(nd(k2)%ln(1)) == L) then
             LBND1D(L) = iabs ( nd(k2)%ln(2) )
          endif
          if (iabs(nd(k2)%ln(2)) == L) then
             LBND1D(L) = iabs ( nd(k2)%ln(1) )            ! and store in LBND1D
          endif
          LL = LBND1D(L)                                  ! LL refers to prof1D
       endif
       if (kcu(L) == 4) then                              ! 1D2D lateral link inherits 2D
          wu(L)  = dbdistance ( xk(k3), yk(k3), xk(k4), yk(k4), jsferic, jasfer3D, dmiss)  ! set 2D link width
       else if (kcu(L) == 3) then                         ! 1D2D internal link 3  flows over side of attached 1D channel
          call getdxofconnectedkcu1(L,wu(L))              !  dbdistance ( xk(k3), yk(k3), xk(k4), yk(k4) )  ! set 2D link width
       else
          IF ( prof1D(1,LL) > 0) THEN
             wu(L) = prof1d(1,LL)                         ! todo, wu1DUNI from max width of profile interpolations
          ELSE
             KA    = -PROF1D(1,LL); KB = -PROF1D(2,LL); ALFA  = PROF1D(3,LL)
             WU(L) = (1D0-ALFA)*PROFILES1D(KA)%WIDTH + ALFA*PROFILES1D(KB)%WIDTH
          ENDIF
       endif
       hdx = 0.5d0*dx(L)
       if (kcu(L) .ne. 3) then
          if (k1 > ndx2d) ba(k1) = ba(k1) + hdx*wu(L)     ! todo, on 1d2d nodes, choose appropriate wu1DUNI = min ( wu1DUNI, intersected 2D face)
          if (k2 > ndx2d) ba(k2) = ba(k2) + hdx*wu(L)
       endif
    else
       wu(L)  = dbdistance ( xk(k3), yk(k3), xk(k4), yk(k4), jsferic, jasfer3D, dmiss)  ! set 2D link width
    endif
 enddo

 do L = lnxi+1,Lnx
    k1 = ln(1,L) ; k2 = ln(2,L)
    ba(k1) = ba(k2)                                        ! set bnd ba to that of inside point
 enddo


 k    = 0                                                  ! count MAX nr of 1D endpoints, dir zijn dead ends
 do L = 1,lnx
    if ( kcu(L) == 1) then
       k1 = ln(1,L) ; k2 = ln(2,L)
       if (nd(k1)%lnx == 1) then
           k = k + 1
       endif
       if (nd(k2)%lnx == 1) then
           k = k + 1
       endif
    endif
 enddo
 mx1Dend = k

 if (allocated(n1Dend) ) deallocate (n1Dend)
 allocate ( n1Dend(mx1Dend) , stat = ierr  ) ; n1Dend = 0
 call aerr('n1Dend(mx1Dend)', ierr, mx1Dend)

 k = 0
 do L = 1,lnx
    if ( kcu(L) == 1) then
       k1 = ln(1,L) ; k2 = ln(2,L)
       if (nd(k1)%lnx == 1) then
           k = k + 1
           n1Dend(k) = k1
       endif
       if (nd(k2)%lnx == 1) then
           k = k + 1
           n1Dend(k) = k2
       endif
    endif
 enddo
 mx1Dend = k

 do k  = 1, mx1Dend
    k1     = n1Dend(k)
    ba(k1) = 2D0*ba(k1)
 enddo

 ! fraction of dist(nd1->edge) to link lenght dx
 call readyy ('geominit',0.94d0)

 acl =0.5d0 ; acn = 0.5d0                               ! for pipes
 do L = 1,lnx                                           ! for all links,
    k1     = ln(1,L)
    k2     = ln(2,L)
    k3     = lncn(1,L)
    k4     = lncn(2,L)

    if (iabs(kcu(L)) == 2 .or. iabs(kcu(L)) == 4) then  ! override for 2D

    !   x34   = 0.5d0*( xk(k3) + xk(k4) )
    !   y34   = 0.5d0*( yk(k3) + yk(k4) )
    !   dxn1e = dbdistance(xz(k1),yz(k1),x34,y34)        !
    !   dxn2e = dbdistance(xz(k2),yz(k2),x34,y34)        !

       CALL DLINEDIS2(xz(k1), yz(k1), xk(k3), yk(k3), xk(k4), yk(k4), JA, dxn1e, XN, YN, RL)
       CALL DLINEDIS2(xz(k2), yz(k2), xk(k3), yk(k3), xk(k4), yk(k4), JA, dxn2e, XN, YN, RL)

       if ( abs(dxn1e+dxn2e).lt.1d-15 ) then
          dxn1e = 5d-16
          dxn2e = 5d-16
       end if

       acl(L) = dxn1e / (dxn1e + dxn2e)                 ! weight factor of nd1

!       ! SPvdP: the following may cause problems for periodic sperical coordinates
!       x12   = 0.5d0*( xz(k1) + xz(k2) )
!       y12   = 0.5d0*( yz(k1) + yz(k2) )
       call half(xz(k1),yz(k1),xz(k2),yz(k2),x12,y12, jsferic, jasfer3D)
       dxn1e = dbdistance(xk(k3),yk(k3),x12,y12,jsferic, jasfer3D, dmiss)        !
       dxn2e = dbdistance(xk(k4),yk(k4),x12,y12,jsferic, jasfer3D, dmiss)        !

       acn(1,L) = dxn1e / (dxn1e + dxn2e)               ! weight factor of nd1
       acn(2,L) = dxn2e / (dxn1e + dxn2e)               ! weight factor of nd2, sum = 1d0 !
    endif

    if (kcu(L) .ne. 4 .and. (iNormalMethod.eq.0 .or. L.le.Lnx1D) ) then
       call normalin (xz(k1), yz(k1), xz(k2), yz(k2), rn, rt, xu(L), yu(L),jsferic, jasfer3D, dxymis)  ! = normalin (k1,k2)
    else
       call normalout(xk(k3), yk(k3), xk(k4), yk(k4), rn, rt, jsferic, jasfer3D, dmiss, dxymis)  ! 1D2D
    endif

    csu(L) = rn ; snu(L) = rt                        !
 enddo

 do L = 1,lnx
     ! the max func after setting dx1 fraction
    dxi(L) = 1d0/dx(L)                               ! dxi to minimise nr. of divisions
    if (wu(L) > 0) then
       wui(L) = 1d0/wu(L)
    else
       write (msgbuf, '(a,i0,a)') 'flow_geominit(): wu(', L, ') = 0'
       call qnerror (trim(msgbuf),' ',' ')
    endif
 enddo

 do n = 1,ndx
    bai(n) = 1d0/ba(n)                               ! inbitially, ba based on 'max wet envelopes', take bai used in linktocentreweights
 enddo

 ! call message ('cutcell call 4',' ',' ')
 if (allocated (kfs)) deallocate(kfs)
 fnam =  '*.cut'
 n12 = 4
 allocate (kfs(ndx)) ; kfs = 0
 call cutcell_list(n12,'*.cut',5, 2) ! trim(fnam))        ! CUT CELLS, N12 = 4, flag cells to be cut in kfs, prior to setlinktocenter/CORNERweights calls below

 call setcentertolinkorientations()

 ! call setlinktocenterweights()

 call setcornertolinkorientations()

 call setlinktocornerweights()

 do n = ndx2D+1, ndxi
    call allocateandset1Dnodexyarrays(n)             ! na  csu en snu
 enddo


 call readyy ('geominit',0.98d0)


 call iadvecini()                                    ! set desired advection for non (-1) links

 avortho = 0d0
 do L  = lnx1D+1,lnx                                        ! for all links, check link orthogonality
    if (abs(kcu(L)) == 1) cycle
    k1 = ln(1,L)
    k2 = ln(2,L)
    k3 = lncn(1,L)
    k4 = lncn(2,L)
    call normalin(xz(k1), yz(k1), xz(k2), yz(k2), rnl, rtl, xu(L), yu(L),jsferic, jasfer3D, dxymis)  ! in pos LL direction
    call normalin(xk(k3), yk(k3), xk(k4), yk(k4), rn , rt,  xu(L), yu(L),jsferic, jasfer3D, dxymis)  ! = normalin (k1,k2)
    ortho   = rnl*rn + rtl*rt
    avortho = avortho + ortho
 enddo
 avortho = avortho / lnx


 n12 = 5 ; fnam =  '*.cut'
 ! call message ('cutcell call 5',' ',' ')

 if (allocated(numlimdt) ) deallocate(numlimdt)
 allocate ( numlimdt(ndx) , stat = ierr) ; numlimdt = 0
 call aerr('numlimdt(ndx)', ierr , ndx )
 if (numlimdt_baorg > 0) then         ! if prev_numlimdt(k) > numlimdt_baorg then ba(k) = baorg(k) in cutcell
    call reanumlimdt()
 endif
 call cutcell_list(n12,'*.cut',5, 3 ) ! trim(fnam))       ! CUT CELLS, N12 = 5, WU AND BA ADAPTATION
 numlimdt = 0
! deallocate(kfs) ; allocate(kfs(ndx)) ! SPvdP: removed, since (1) uninitialized and (2) kfs needed in "setlinktocenterweights" later

 call readyy ('geominit',-1d0)

 if (isimplefixedweirs == 0) call fixedweirs_on_flowgeom()                        ! Impose fixed weirs paths on all crossed flow links.

 jaupdbndbl = 1
 if (network%loaded ) then
    jaupdbobbl1d = 1
 else
    jaupdbobbl1d = 0
 endif

 call set_1d_indices_in_network()
 
 if (network%loaded .and. ndxi-ndx2d > 0 .and. (jamapTimeWetOnGround > 0 .or. jamapFreeboard > 0 .or. jamapDepthOnGround > 0 .or. jamapVolOnGround > 0)) then
    call set_ground_level_for_1d_nodes(network) ! set ground level for 1d nodes
 end if

 call setbobs()
 call setbobsonroofs()

 if (jawindpartialdry == 1) then
    if (ibedlevtyp .ne. 3) then
        jawindpartialdry = 0
    endif
 endif


 !-------------------------------------------------- CLOSED WALL (STRESS) RELATED -----------------------------------------------

                                                     ! add some closed boundary administration for stress terms

 nw = 0
 do L = lnx1D+1,numl                                 ! first count nr of closed walls
    if (lne2ln(L) < 0) then
       nw = nw + 1
    endif
 enddo

 if ( allocated (walls) ) deallocate(walls)
 allocate ( walls(17,nw) , stat = ierr  ) ; walls = 0
 call aerr('walls(17,nw)', ierr, nw*17     )


 nw   = 0                                           ! number of closed walls
 do L = lnx1D+1, numl
    if (lne2ln(L) < 0 ) then
       nw = nw + 1
       k1 = abs(lne2ln(L))
       k3 = kn(1,L)
       k4 = kn(2,L)

       walls(1,nw) = k1                             ! waterlevel point on the inside
       walls(2,nw) = k3                             ! first wall corner
       walls(3,nw) = k4                             ! second wall corner

       call duitpl(xzw(k1), yzw(k1), xk(k3), yk(k3), xzw(k1), yzw(k1), xk(k4), yk(k4), sig, jsferic)
       call dlinedis(xzw(k1), yzw(k1), xk(k3), yk(k3), xk(k4), yk(k4),JA,DIS,XN,YN, jsferic, jasfer3D, dmiss)
!
!       dxx = getdx( xk(k3), yk(k3), xk(k4), yk(k4) )  ! xk(k4) - xk(k3)
!       dyy = getdy( xk(k3), yk(k3), xk(k4), yk(k4) )  ! yk(k4) - yk(k3)
!       rrr = sqrt(dxx*dxx + dyy*dyy)
!       cs  = 0 ; sn = 0
!       if (rrr .ne. 0) then
!          cs = sig*dxx/rrr
!          sn = sig*dyy/rrr
!       endif

       rrr = dbdistance(xk(k3),yk(k3),xk(k4),yk(k4),jsferic, jasfer3D, dmiss)
       call half(xk(k3),yk(k3),xk(4),yk(k4),xh,yh,  jsferic, jasfer3D)
       call normalin(xk(k3),yk(k3),xk(k4),yk(k4),cs,sn,xh,yh,jsferic, jasfer3D, dxymis)

       if (wall_z0 > 0) then
          sf = vonkar/log(c9of1 + dis/wall_z0)
                                                     ! us  = utangential, un = unormal
                                                     ! us  = ucx*cs + ucy*sn, ustar = sf*us
          walls(6,nw)  = sf                          ! sux = -cs*ustar
       endif

       walls(7,nw)  = cs                             ! suy = -sn*ustar    ( )
       walls(8,nw)  = sn                             ! sinus              ( )
       walls(9,nw)  = rrr                            ! length of the wall (m)

       L1 = 0 ; L2= 0
       do LL  = 1,nd(k1)%lnx
          LLL = nd(k1)%ln(LL) ; LLA = iabs(LLL)
          if (lncn(1,LLA) ==  k3 .or. lncn(2,LLA) == k3) then
             L1 = LLA
             walls(4,nw)  = L1                       ! link 1 to which this wall contributes
             if (LLL < 0) then                       ! outflowing link: use alfa1
                walls(10,nw) = acl(L1)
             else
                walls(10,nw) = (1d0-acl(L1))
             endif
          endif
          if (lncn(1,LLA) ==  k4 .or. lncn(2,LLA) == k4) then
             L2 = LLA
             walls(5,nw)  = L2                       ! link 2 to which this wall contributes
             if (LLL < 0) then
                walls(11,nw) = acl(L2)
             else
                walls(11,nw) = (1d0-acl(L2))
             endif
          endif
       enddo

       walls(12,nw) = 0.5d0*dis                   ! half of distance circumcentre to the wall (m)
       walls(13,nw) = bl(k1)                      ! cell bottom level (m)
       walls(14,nw) = abs(zk(k4)-zk(k3))          ! bottom level difference (m)
       walls(15,nw) = walls(14,nw) / walls(9,nw)  ! bottom level inclination()
       walls(17,nw) = walls(12,nw) * walls(9,nw)  ! ba part of wall
    endif
 enddo
 mxwalls   = nw

 call setwallorientations()
 call setlinktocenterweights()

!-------------------------------------------------- CELL CORNER RELATED -----------------------------------------------

 do L  = lnx1D+1,lnx                                 ! for all links,
    k3 = lncn(1,L)
    k4 = lncn(2,L)
    cn(k3)%lnx = cn(k3)%lnx + 1                      ! count nr of links attached to a cell corner
    cn(k4)%lnx = cn(k4)%lnx + 1
 enddo

 do k = 1,numk
    m = cn(k)%lnx
    if (m > 0) then
! GD: memory leak
!       if(allocated(cn(k)%ln)) deallocate(cn(k)%ln)
       allocate ( cn(k)%ln (m) , stat = ierr )       ! allocate nr of links attached to a cell corner
       call aerr('cn(k)%ln (m)', ierr, m )
       cn(k)%lnx = 0
    endif
 enddo

 do L  = lnx1D+1,lnx                                 ! for all links,
    k3 = lncn(1,L)
    k4 = lncn(2,L)

    cn(k3)%lnx   = cn(k3)%lnx + 1
    m            = cn(k3)%lnx
    cn(k3)%ln(m) = L                                 ! set attached linknrs

    cn(k4)%lnx   = cn(k4)%lnx + 1
    m            = cn(k4)%lnx
    cn(k4)%ln(m) = -L                                ! set attached linknrs
 enddo

 do nw  = 1,mxwalls                                  ! for all closed walls
    k3 = walls(2,nw)                                 ! first wall corner
    k4 = walls(3,nw)                                 ! first wall corner
    cn(k3)%nwx = cn(k3)%nwx + 1                      ! count nr of walls attached to a cell corner
    cn(k4)%nwx = cn(k4)%nwx + 1
 enddo

 do k = 1,numk
    m = cn(k)%nwx
    if (m > 0) then
       allocate ( cn(k)%nw (m) , stat = ierr )       ! allocate nr of links attached to a cell corner
       call aerr('cn(k)%nw (m)', ierr, m )
       cn(k)%nwx = 0
    endif
 enddo

 do nw  = 1,mxwalls                                  ! for all closed walls
    k3 = walls(2,nw)                                 ! first wall corner
    k4 = walls(3,nw)                                 ! first wall corner

    cn(k3)%nwx = cn(k3)%nwx + 1                      ! count nr of walls attached to a cell corner
    m          = cn(k3)%nwx
    cn(k3)%nw(m) = nw                                ! set attached wallnrs

    cn(k4)%nwx = cn(k4)%nwx + 1                      ! count nr of walls attached to a cell corner
    m          = cn(k4)%nwx
    cn(k4)%nw(m) = -nw                               ! set attached wallnrs
 enddo

 nwalcnw = 0
 do icn = 1,nrcnw                                    ! attach closed walls to closed corners
    k   = kcnw(icn)
    if (cn(k)%nwx == 0) then
        m = icn
    else
       if (cn(k)%nwx > 0) then
           nwalcnw(1,icn) = cn(k)%nw(1)
       endif
       if (cn(k)%nwx > 1) then
           nwalcnw(2,icn) = cn(k)%nw(2)
       endif
    endif
 enddo

 do icn = 1,nrcnw
    sf = 0d0 ; n = 0
    if (abs(nwalcnw(1,icn)) > 0) then
        sf = walls(6, abs(nwalcnw(1,icn) ) )      ; n = n + 1
    endif
    if (abs(nwalcnw(2,icn)) > 0) then
        sf = walls(6, abs(nwalcnw(2,icn) ) ) + sf ; n = n + 1
    endif
    if ( sf > 0d0 ) then
       sfcnw(icn) = sf / dble(n)  ! averaged
    endif
 enddo

 dx  = max(dx,dxmin)
 dxi = 1d0/dx

 if (allocated(jaduiktmp) ) then
    do L = 1,Lnx1D
       if (jaduiktmp(L) .ne. 1) then
          dx(L) = max(dx(L), dxmin1D)
       endif
    enddo
    deallocate(jaduiktmp)
 else
    do L = 1,Lnx1D
       dx(L) = max(dx(L), dxmin1D)
    enddo
 endif

 do L = Lnx1D+1,Lnx
    dx(L) = max(dx(L), dxmin2D)
 enddo

 if (Lnx1D < -1 ) then
    kc = 0 ! allocate(inodes(Ndxi-ndx2D)) ; inodes = 0
    call find_flowcells_kdtree(treeglob,Ndxi-ndx2D,xz(ndx2D+1),yz(ndx2D+1),kc,0,INDTP_2D,ierr)
    do k1 = ndx2D+1, ndxi
       k2 = kc(k1-ndx2D)
       if ( k2 > 0 ) then
          if (ba(k1) < ba(k2) ) then
            !  ba(k2) = ba(k2) - ba(k1)
          else
              continue
          endif
       endif
    enddo
 endif

 do n = 1, ndxi                                      ! after all metrics, maximise ba and dx for better conditioning
    if (n > ndx2D) then                              ! reset ba on strictly 1D nodes, to bamin1D or to specified manhole area's (todo)
       ba(n) = max(ba(n), bamin1D)                   ! 2D handled in cutcelwu
    endif
 enddo
 do L = lnxi+1,Lnx
    ba(ln(1,L)) = ba(ln(2,L))                        ! set bnd ba to that of inside point
 enddo

 if (allocated (banf) ) then
     deallocate(banf,nban)
 endif

 if (nump > 0) then

   mxban = 0
   do k = 1, ndx2D ! nump
      mxban = mxban + netcell(k)%n
   enddo
   allocate ( banf(mxban)    , stat=ierr  )                 ! for keeps, netnode/flownode subarea
   call aerr('banf(mxban)'   , ierr, mxban ) ; banf = 0d0
   allocate ( nban(4,mxban)  , stat=ierr  )                 ! for keeps, banf admin
   call aerr('nban(4,mxban)' , ierr, mxban ) ; nban = 0

   allocate ( rr(mxban), nr(mxban)  , stat=ierr  )          ! for temp
   call aerr('rr(mxban), nr(mxban)' , ierr, mxban )
   allocate ( banh (mxban)    , stat=ierr  )
   call aerr('banh (mxban)'   , ierr, mxban ) ; banh  = 0d0
   allocate ( nbanh(4,mxban)  , stat=ierr  )
   call aerr('nbanh(4,mxban)' , ierr, mxban ) ; nbanh = 0


   ka = 0                                              ! set netnode/flownode subarea array ban
   do k = 1, ndx2D ! nump

      nn     = netcell(k)%n
      do kk2 = 1,nn                                    ! walk in netcells
         ka  = ka + 1                                  ! subarea nr

         kk1 = kk2 - 1 ; if (kk1 < 1   ) kk1 = nn
         kk3 = kk2 + 1 ; if (kk3 > nn  ) kk3 = 1

         K1  = netcell(k)%nod(kk1)                     ! k1 , k2, k3 subsequent netcell nrs
         K2  = netcell(k)%nod(kk2)
         K3  = netcell(k)%nod(kk3)

         xx(1) = xz(k)                    ;  yy(1) = yz(k)
!         xx(2) = 0.5d0*( xk(k1)+xk(k2) )  ;  yy(2) = 0.5d0*( yk(k1)+yk(k2) )
         call half(xk(k1),yk(k1),xk(k2),yk(k2),xx(2),yy(2), jsferic, jasfer3D)
         xx(3) = xk(k2)                   ;  yy(3) = yk(k2)
!         xx(4) = 0.5d0*( xk(k2)+xk(k3) )  ;  yy(4) = 0.5d0*( yk(k2)+yk(k3) )
         call half(xk(k2),yk(k2),xk(k3),yk(k3),xx(4),yy(4), jsferic, jasfer3D)

         call dAREAN( XX, YY, 4, banh(ka) , DLENGTH, DLENMX )
         nbanh(1,ka) = k2                               ! netnode nr
         nbanh(2,ka) = k                                ! flownode nr
         rr(ka)      = k2

         do kk3 = 1, nd(k)%lnx
            L   = iabs(nd(k)%ln(kk3))
            La  = iabs(L)
            if (lncn(1,La) == k2 .or. lncn(2,La) == k2) then
                if (nbanh(3,ka) == 0) then
                    nbanh(3,ka) = La
                else if (nbanh(4,ka) == 0) then
                    nbanh(4,ka) = La
                endif
             endif
         enddo

     enddo
   enddo

   CALL INDEXX(mxban,rr,nr)
   do k = 1, mxban
      ka = nr(k)
      nban(1,k) = nbanh(1,ka)
      nban(2,k) = nbanh(2,ka)
      nban(3,k) = nbanh(3,ka)
      nban(4,k) = nbanh(4,ka)
      banf  (k) = banh   (ka)
   enddo

   ban  = 0d0
   do k = 1, mxban               ! netnode area
      n =  nban(1,k)
      ban(n) = ban(n) + banf(k)
   enddo

   deallocate(banh,nbanh,rr,nr)


 endif

 if (jaconveyance2D >= 1 ) then   ! set link based bed skewness array aifu

    ! bed skewness is not intended for bedlevel type < 3
    if ( ibedlevtyp.lt.3 ) then
       call qnerror('bed-level type and conveyance type do not match', ' ', ' ')
    else

       if (allocated (aifu) ) deallocate(aifu, bz)
       allocate ( aifu(lnx), bz(ndx) )

       call setaifu()

    end if   ! if ( ibedlevtyp.lt.3 )

 endif


!JRE
 if ( jawave.eq.4 ) then
    call xbeach_makethetagrid()
    call makethindamadmin()
    ! now that ntheta is determined:
    itheta_view = max(ntheta/2, 1)
 end if

 !call makeba()
 !sf = ba(4) / ba(1588)
 !write(*,*) sf

 !sf = ba(96) / ba(1674)
 !write(*,*) sf

 blmin = minval(bl)

 if (dxwuimin2D > 0d0) then
    do L = lnx1D+1, lnxi
       if ( dx(L)  < dxwuimin2D*wu(L) ) then
            dxorgL = dx(L)
            dx(L)  = dxwuimin2D*wu(L)
            dxi(L) = 1d0/dx(L)
            write(Msgbuf,'(A,4F15.6)') 'Circumcentre distance dx(L)  < dxwuimin2D*wu(L) : xu, yu, old dx, new dx: ', xu(L), yu(L), dxorgL, dx(L) ; call msg_flush()
       endif
    enddo
 endif

 end subroutine flow_geominit


 subroutine dumpnetlink(tex,L)
 use m_netw
 use m_flowgeom
 use m_flow
 use unstruc_messages
 implicit none
 integer :: L,k1,k2
 character *(*) tex
 character(len = 14) tex2

 write(tex2,'(i14.0)') L
 k1 = kn(1,L) ; k2 = kn(2,L)
 call mess(LEVEL_INFO, trim(tex), trim(tex2), ' ')
 call mess(LEVEL_INFO, ' 2  2 ', ' ' , ' ')
 call mess(LEVEL_INFO, xk(k1), yk(k1))
 call mess(LEVEL_INFO, xk(k2), yk(k2))
 end subroutine dumpnetlink

 subroutine makeba()  ! recompute ba
 use m_flow
 use m_flowgeom
 use m_netw
 implicit none
 integer          :: k,L,m,n,k1,k2
 double precision :: dxw, aa1

 ba = 0d0   ! ; acl = 0.5d0
 Do L = 1,lnx
    k1 = ln(1,L) ; k2 = ln(2,L)
    dxw    = 0.5d0*dx(L)*wu(L)
    ba(k1) = ba(k1) + dxw*acl(L)
    ba(k2) = ba(k2) + dxw*(1d0-acl(L))
 enddo

 do n   = 1, mxwalls
    k1  = walls(1,n)
    aa1 = walls(17,n)
    ba(k1) = ba(k1) + aa1
 enddo

 do L = Lnxi, Lnx
    k1 = ln(1,L) ; k2 = ln(2,L)
    ba(k1) = ba(k2)
 enddo

 end subroutine makeba


 subroutine setaifu()  ! set bed skewness array for roughness
 use m_flow
 use m_flowgeom
 use m_netw
 use m_missing
 implicit none
 integer          :: k,L,m,n,k1,k2
 double precision :: zu, ai, bi, zkk
 aifu = 1d0
 bz   = 0d0
 do m = 1, mxban                                  ! bz based on netnodes area
    k = nban(1,m)
    n = nban(2,m)
    if (zk(k) .ne. dmiss) then
       zkk = zk(k)
    else
       zkk = zkuni + xk(k)*bedslope
    endif
    bz(n) = bz(n) + banf(m)*zkk
 enddo
 bz = bz/ba

 do L  = 1, Lnx                             ! next, link bed slope  bi in link, ai cross link
    k1 = Ln(1,L)  ; k2 = Ln(2,L)
    ai = (bob(2,L) - bob(1,L))*wui(L)
    if (L <= lnx1D) then
       bi      = 0d0
    else if (L > Lnxi) then
        zu = 0.5d0*(bob(1,L) + bob(2,L))
        bi = (bz(k2) - zu)*dxi(L)/max(eps4, 1d0-acL(L))
    else
        bi = (bz(k2) - bz(k1))*dxi(L)
    endif
    if (jaconveyance2D == 1) then
       aifu(L) = 1d0 + bi*bi
    else
       aifu(L) = 1d0 + ai*ai + bi*bi
    endif
    aifu(L) = sqrt(aifu(L))
 enddo

 end subroutine setaifu

 subroutine getdxofconnectedkcu1(Lf,wuL)    ! width of connection link has lenght of connected 1D links
 use m_flowgeom
 use m_flow
 use m_netw
 implicit none
 integer          :: Lf, L, LL, k, kk, n, k1, k2, n1, n2
 double precision :: wu1, wu2, wuL
 wu1 = 0d0 ; n = 0

 !if (kcs(ln(1,L) ) == 21)  k = ln(2,L)
 !if (kcs(ln(2,L) ) == 21)  k = ln(1,L)
 !do kk = 1,nd(k)%lnx
 !   if (kcu(L) == 1) then
 !      n   = n + 1
 !      LL  = iabs( nd(k)%ln(kk) )
 !      wu1 = wu1 + dx(L)
 !   endif
 ! enddo

 L  = ln2lne(Lf)
 k1 = kn(1,L)
 k2 = kn(2,L)
 if (nmk(k1) == 1) k = k2
 if (nmk(k2) == 1) k = k1
 do kk = 1, nmk(k)
    LL = iabs(nod(k)%lin(kk))
    if (kn(3,LL) == 1 .or. kn(3,LL) == 6) then    ! on second thought, only true 1D links should influence lateral inflow width ! .or. kn(3,LL) == 4) then
        n   = n + 1
        wu1 = wu1 + dx(lne2ln(LL))
    endif
 enddo

 if (n > 0) then
    wu1 = wu1 / n
 endif

 n1 = ln(1,Lf) ; n2 = ln(2,Lf)
 if (kcs(n1) == 21) then
    wu2 = sqrt(ba(n1))
 else if (kcs(n2) == 21) then
    wu2 = sqrt(ba(n2))
 endif

 wuL = min (wu1, wu2)     ! both 1D sides flood at the same moment, no division by 2
 end subroutine getdxofconnectedkcu1

 subroutine sortnetlinks()
 use m_netw
 use sorting_algorithms, only: indexxi
 implicit none
 integer, allocatable :: n1(:), in(:), ni(:)
 integer              :: L1, k, kk, L

 if (numL == 0) return

 allocate ( n1(numL), in(numL), ni(numL) )

 L1   = numl1D+1
 do L = L1, numL
    n1(L) = lne(1,L)
 enddo

 call indexxi(numL-L1+1, n1(L1:), IN(L1:) )

 do L = 1,numl1D
    in(L) = L
 enddo

 do L = L1, numL
   in(L) = in(L) + numL1D
 enddo

 do L = 1,numL
    ni(in(L)) = L
 enddo

 do L = L1, numL
    n1(L)    = lne(1,L)
 enddo
 do L = L1, numL
    lne(1,L) = n1(in(L))
 enddo

 do L = L1, numL
    n1(L)   = lne(2,L)
 enddo
 do L = L1, numL
    lne(2,L) = n1(in(L))
 enddo

  do L = L1, numL
    n1(L)    = kn(1,L)
 enddo
 do L = L1, numL
    kn(1,L) = n1(in(L))
 enddo

 do L = L1, numL
    n1(L)   = kn(2,L)
 enddo
 do L = L1, numL
    kn(2,L) = n1(in(L))
 enddo

 do L = L1, numL
    n1(L)   = kn(3,L)
 enddo
 do L = L1, numL
    kn(3,L) = n1(in(L))
 enddo

 do L = L1, numL
    n1(L)  = lnn(L)
 enddo
 do L = L1, numL
    lnn(L) = n1(in(L))
 enddo

 do k = 1,numk
    do kk = 1,nmk(k)
       NOD(K)%LIN(kk) = ni(NOD(K)%LIN(kk))
    enddo
 enddo

 do k = 1,nump
    do kk = 1,netcell(k)%n
       netcell(K)%LIN(kk) = ni(netcell(K)%LIN(kk))
    enddo
 enddo

 deallocate(n1, in, ni)

 end  subroutine sortnetlinks

 subroutine which2Dnetlinkwascrossed(NC1,K1,K2,L) ! find the crossed 2D link
 use m_flowgeom
 use m_netw
 use geometry_module, only: cross
 use m_missing, only: dmiss
 use m_sferic, only: jsferic

 implicit none
 integer          :: NC1,K1,K2,LL
 integer          :: nn,kk,kku,jacros,k3,k4,L
 double precision :: SL,SM,XCR,YCR,CRP

 LL = 0
 nn = NETCELL(nc1)%N

 do kk  = 1,nn
    L   = NETCELL(Nc1)%lin(kk)
    K3  = kn(1,L)
    K4  = kn(2,L)

    call CROSS(xk(k1), yk(k1), xk(k2), yk(k2), xk(k3), yk(k3),  xk(k4), yk(k4), JACROS,SL,SM,XCR,YCR,CRP, jsferic, dmiss)
    if (jacros == 1) then
       LL = L
       return
    endif
 enddo

 end subroutine which2Dnetlinkwascrossed ! TEMP STORE CROSSED 2d LINK IN LC

 Subroutine shift1Dnetnodestoduikers()
 use m_netw
 use m_flowgeom
 use m_flow
 use m_missing
 use m_polygon
 use unstruc_files
 use geometry_module, only: dbdistance
 use m_sferic, only: jsferic, jasfer3D
 use gridoperations

  implicit none
 integer          :: minp, Ls, n, k1, k2, kL, kR, LnL
 double precision :: x1,y1,z1,x2,y2,z2,xc,yc,XLS,YLS,dum,dis12,dis11, disL, disd, dis22,dis21,alf,zx, xL,yL,xR,yR, half, xkc, ykc
 character(len=maxlength) :: pipefilein, pipefileout
 if (numL == 0) return

 pipefilein  = defaultFilename('pipe')  ! is dit duikers.pliz ?
 pipefileout = defaultFilename('pipe2') ! duikers2.pliz ?

 call oldfil(minp, pipefilein)
 call reapol(minp,0)
 kn3typ = 1

 do n  = 1,npl-1

    x1 = xpl(n)   ; y1 = ypl(n)   ; z1 = zpl(n)
    x2 = xpl(n+1) ; y2 = ypl(n+1) ; z2 = zpl(n+1)
    if (x1 .ne. dmiss .and. x2 .ne. dmiss) then
       xc = 0.5d0*(x1+x2)
       yc = 0.5d0*(y1+y2)
       zx = max(z1,z2)
       CALL CLOSETO1Dnetlink(Xc,Yc,LS,XLS,YLS,dum)
       if (Ls > 0) then
          k1 = kn(1,LS) ; k2 = kn(2,LS)
          dis11 = dbdistance(x1,y1,xk(k1), yk(k1), jsferic, jasfer3D, dmiss)
          dis12 = dbdistance(x2,y2,xk(k1), yk(k1), jsferic, jasfer3D, dmiss)
          dis21 = dbdistance(x1,y1,xk(k2), yk(k2), jsferic, jasfer3D, dmiss)
          dis22 = dbdistance(x2,y2,xk(k2), yk(k2), jsferic, jasfer3D, dmiss)
          disL  = dbdistance(xk(k1),yk(k1),xk(k2), yk(k2), jsferic, jasfer3D, dmiss)
          disd  = dbdistance(x1,y1,x2,y2,jsferic, jasfer3D, dmiss)
          alf   = min(1d0, disd/disL) ; half = 0.5d0*alf
          if (nmk(k1) > 0 .and. nmk(k2) > 0) then       ! both fixed, shift to centre
             ! call splitlink(x1, y1, L_, 0.9d0, 1, ierror)
             xkc = 0.5d0*( xk(k2)+xk(k1) )
             ykc = 0.5d0*( yk(k2)+yk(k1) )
             xL  = xkc - half*(xk(k2)-xk(k1))
             yL  = ykc - half*(yk(k2)-yk(k1))
             xR  = xkc + half*(xk(k2)-xk(k1))
             yR  = ykc + half*(yk(k2)-yk(k1))
             kn(1,Ls) = 0 ; kn(2,Ls) = 0; kn(3,Ls) = 0
             call setnewpoint(xL, YL, zx, kL)
             call connectdbn(k1,kL,LnL)
             call setnewpoint(xR, YR, zx, kR)
             call connectdbn(kL,kR,LnL)
             call connectdbn(kR,k2,LnL)
             k1 = kL ; k2 = kR
          else if (nmk(k1) > 2) then  ! keep k1
             if (nmk(k2) == 2) then   ! shift to k1
                  xk(k2) = xk(k1) + alf*(xk(k2)-xk(k1))
                  yk(k2) = yk(k1) + alf*(yk(k2)-yk(k1))
             endif
          else  if (nmk(k2) > 2) then ! keep k2
             if (nmk(k1) == 2) then   ! shift to k2
                  xk(k1) = xk(k2) + alf*(xk(k1)-xk(k2))
                  yk(k1) = yk(k2) + alf*(yk(k1)-yk(k2))
             endif
          else
             if (dis11 < dis12) then
                xk(k1) = x1 ; yk(k1) = y1
             else
                xk(k1) = x2 ; yk(k1) = y2
             endif
             if (dis21 < dis22) then
                xk(k2) = x1 ; yk(k2) = y1
             else
                xk(k2) = x2 ; yk(k2) = y2
             endif
          endif
          zk(k1)   = dmiss  ; zk(k2)   = dmiss
          xpl(n)   = xk(k1) ; ypl(n)   = yk(k1)
          xpl(n+1) = xk(k2) ; ypl(n+1) = yk(k2)
       endif
    endif
 enddo

 call newfil(minp, pipefileout)
 call wripol(minp)

 return
 end subroutine shift1Dnetnodestoduikers

 subroutine duikerstoprofs()
 use m_netw
 use m_flowgeom
 use m_flow
 use m_missing
 use m_polygon
 use unstruc_model
 use m_sferic
 use geometry_module, only: dbdistance
 implicit none

 integer          :: minp, Ls, Lf, n, k1, k2
 double precision :: x1,y1,z1,x2,y2,z2,xc,yc,XLS,YLS,dum,w1,w2,h1,h2
 logical          :: jawel

 inquire(file=trim(md_pipefile) , exist=jawel)
 if (.not. jawel) return

 call oldfil(minp, md_pipefile)
 call reapol(minp,0)
 allocate(jaduiktmp(1:Lnx1D)) ; jaduiktmp = 0

 do n  = 1,npl-1

    x1 = xpl(n)   ; y1 = ypl(n)   ; z1 = zpl(n)   ; w1 = dzL(n)   ; h1 = dzR(n)
    x2 = xpl(n+1) ; y2 = ypl(n+1) ; z2 = zpl(n+1) ; w2 = dzL(n+1) ; h2 = dzR(n+1)
    if (x1 == DMISS .or. x2 == DMISS) cycle
    if (w1 <= 0d0 .or. w2 <= 0d0) then
       call qnerror(' pipes: width <= 0d0, fourth column', 'in', md_pipefile)
       call qnerror(' pipes: width <= 0d0, fourth column', 'in', md_pipefile)
    endif

    if (x1 .ne. dmiss .and. x2 .ne. dmiss) then
        xc = 0.5d0*(x1+x2)
        yc = 0.5d0*(y1+y2)
        CALL CLOSETO1Dnetlink(Xc,Yc,LS,XLS,YLS,dum)
        if (Ls > 0) then
            Lf = lne2ln(Ls)
            if (kcu(Lf) == 1 .or. kcu(Lf) == 5) then
               k1 = ln(1,Lf) ; k2 = ln(2,Lf)
               IF ( dbdistance(X1,Y1,Xzw(K1),Yzw(K1), jsferic, jasfer3D, dmiss) < dbdistance(X1,Y1,Xzw(K2),Yzw(K2), jsferic, jasfer3D, dmiss) ) THEN
                  bob(1,Lf)  = z1 ; bl(k1) = min(z1, bl(k1) )
                  bob(2,Lf)  = z2 ; bl(k2) = min(z2, bl(k2) )
                else
                  bob(1,Lf)  = z2 ; bl(k1) = min(z2, bl(k1) )
                  bob(2,Lf)  = z1 ; bl(k2) = min(z1, bl(k2) )
               endif
               prof1D(1,Lf)  = w1 ; wu(Lf) = w1
               prof1D(2,Lf)  = h1
               prof1D(3,Lf)  =  2                                      ! for now, simple rectan
               jaduiktmp(Lf) =  1
            endif
         endif
     endif

 enddo
 end subroutine duikerstoprofs


 subroutine setprofs1D()

 use m_flowgeom
 use m_flow
 use UNSTRUC_MODEL
 use m_netw
 use m_profiles
 use m_missing
 use unstruc_messages
 use m_partitioninfo
 use sorting_algorithms, only: indexx
 use geometry_module, only: dbdistance
 use m_sferic, only: jsferic, jasfer3D
 use m_samples

 IMPLICIT NONE
 integer                       :: ierr, MINP, LS, L, K, LF, IBR, LL,LA,K1,K2,KA,KB,NRL,NSK, KK, ja, ium
 DOUBLE PRECISION              :: XL, ZL, ALFA
 logical                       :: jawel
 character (len=256)           :: fnam
 INTEGER, allocatable          :: LSAM(:)              ! sample K IS ON NET LINK LSAM
 INTEGER, allocatable          :: NSbr (:)             ! nr of profiles on branch

 INTEGER                       :: NSBRMX               ! MX NR OF PROFILES ON BRANCH
 INTEGER, allocatable          :: IDX(:)               ! INDEX ARR, SIZE = NSBRMX
 INTEGER, allocatable          :: KLH(:), KLHH(:)      ! INDEX  ARR, + SORTED BY IDX
 double precision, allocatable :: XLH(:), XLHH(:)      ! LENGTH ARR, + SORTED BY IDX
 double precision, allocatable :: ZLH(:), ZLHH(:)      ! VALUE  ARR, + SORTED BY IDX
 integer                       :: nyz

 type tKBSAM                                           !< TEMP
     integer, allocatable      :: KS (:)               !< successive SAMPLE nrs ON BRANCH
 end type tKBSAM
 TYPE (TKBSAM),    dimension(:), ALLOCATABLE :: KBSAM  ! ARRAY OF SAMPLES PER BRANCH


 double precision, dimension(:), allocatable :: XLLin
 double precision, dimension(:), allocatable :: XLsam          ! link and sample line distances

 double precision, dimension(:), allocatable :: distsam  ! distance from sample to link
 integer,          dimension(:), allocatable :: iconnsam ! globally connected branch number associated with sample

 double precision, dimension(:), allocatable :: zkk, wkk ! help interpolate zk in profiles if dmiss

 double precision                            :: XLS, YLS, XLB, DXB, dum, ZA, ZB, wa, wb, zul, wul
 double precision                            :: wn(100), zn(100)
 integer                                     :: np(100) , nn, n1, kn3now

 if ( jampi.ne.1 ) then
    if (lnx1D == 0) return
 end if

 fnam =  trim(md_proflocfile)
 inquire(file=trim(fnam) , exist=jawel)

 if (jawel) then

    call oldfil(minp, fnam )

    call readprofilesloc(minp)           ! read profloc

    call readprofilesdef(ja)             ! read profdef

    if (ja == 0) then
       call qnerror( ' Profs not ok. ', ' ',' ')
       return
    endif

    if (nproflocs > 0) then

       CALL SETBRANCH_LC(ium)

       if ( jampi.eq.1 ) then
         call global_netbranch_numbering()
       end if

       if ( allocated(xllin) ) then
           deallocate(xllin)
       endif
       ierr = 0
       allocate ( XLLIN(numL) , stat = ierr)
       call aerr('XLLIN(numL)', ierr, numL )

       allocate ( XLSAM(Nproflocs)   , stat = ierr)
       call aerr('XLSAM(Nproflocs)  ', ierr, Nproflocs  )

       allocate ( LSAM(Nproflocs)    , stat = ierr)
       call aerr('LSAM(Nproflocs)   ', ierr, Nproflocs  )

       if ( jampi.eq.1 ) then
         allocate(distsam(Nproflocs), stat=ierr)
         call aerr('distsam(Nproflocs)', ierr, Nproflocs)

         allocate(iconnsam(Nproflocs), stat=ierr)
         call aerr('iconnsam(Nproflocs)', ierr, Nproflocs)
       end if

       if ( Lnx1D.gt.0 ) then
          do ibr = 1,mxnetbr                                    ! SET UP BRANCH DISTANCE COORDINATE
             if ( jampi.eq.0 ) then
                XLB = 0d0
             else
                XLB = netbr(ibr)%doff
             end if
             do LL = 1, netbr(ibr)%NX
                L  = netbr(ibr)%ln(LL); LA = iabs(L)
                if (L > 0) then
                   k1 = kn(1,La); k2 = kn(2,LA)
                else
                   k2 = kn(1,La); k1 = kn(2,LA)
                endif
                dxB = dbdistance( xk(k1), yk(k1), xk(k2), yk(k2), jsferic, jasfer3D, dmiss)
                XLB = XLB + dxB
                XLLIN(LA) = xLB
             enddo
          enddo

          DO K = 1,nproflocs                                    ! SET UP BRANCH DISTANCE COORDINATE OF SAMPLE POINTS
             if ( jampi.eq.0 ) then
                CALL CLOSETO1Dnetlink(Xpr(K),Ypr(K),LS,XLS,YLS,dum)
             else
                CALL CLOSETO1Dnetlink(Xpr(K),Ypr(K),LS,XLS,YLS,distsam(k))
                ibr = LC(LS)
                iconnsam(k) = netbr(ibr)%iconn
             end if
             NRL = NRLB(LS)
             K1  = K1BR(NRL)
             IF (K1 == KN(1,LS) )THEN                           ! K1 = FIRST IN BRANCH, K2 = SECOND
                 K2 =  KN(2,LS)
             ELSE
                 K2 = K1
                 K1 = KN(2,LS)
             ENDIF

             XLSAM(K) = XLLIN(LS) - DBDISTANCE(XLS,YLS,XK(K2),YK(K2), jsferic, jasfer3D, dmiss)

             LSAM(K) = LS

             !DO L = 1,NUML
             !   IF (LC(L) == LC(LS)) THEN
             !      LF = LNE2LN(L)
             !      PROF1D(1,LF) = ZS(K)
             !   ENDIF
             !ENDDO

          ENDDO

       else
          xlsam = 0d0
          distsam = 1d99
          iconnsam = 0
       end if

! parallel: reduce XLSAM and the connected branch numbers
       if ( jampi.eq.1 ) then
          call reduce_xlsam(Nproflocs, xlsam, distsam, iconnsam)
!       else
!          write(6,*) (xlsam(k), k=1,Nproflocs)
       end if

       if ( Lnx1D.gt.0 ) then
          do ibr = 1,mxnetbr                                    ! SET UP BRANCH AGAIN, NOW WITH LINK POSITIONS
             if ( jampi.eq.0 ) then
                XLB = 0d0
             else
                XLB = netbr(ibr)%doff
             end if
             do LL = 1, netbr(ibr)%NX
                L  = netbr(ibr)%ln(LL); LA = iabs(L)
                if (L > 0) then
                   k1 = kn(1,La); k2 = kn(2,LA)
                else
                   k2 = kn(1,La); k1 = kn(2,LA)
                endif
                dxB = dbdistance( xk(k1), yk(k1), xk(k2), yk(k2), jsferic, jasfer3D, dmiss)
                XLB = XLB + dxB
                XLLIN(LA) = xLB - 0.5D0*DXB
             enddo
          enddo

          ALLOCATE ( NSBR (MXNETBR) , STAT=IERR) ;  NSBR = 0
          CALL AERR('NSBR (MXNETBR)', IERR, MXNETBR)
          ALLOCATE ( KBSAM(MXNETBR) , STAT=IERR)
          CALL AERR('KBSAM(MXNETBR)', IERR, MXNETBR)

          DO K   = 1,Nproflocs                                    ! COUNT NR OF SAMPLES PER BRANCH
             L   = LSAM(K)
             IBR = LC(L)
             if ( jampi.eq.0 ) then
                NSBR(IBR) = NSBR(IBR) + 1
             else
   !            parallel: add profile to all branches that are in the corresponding connected branch
                do ibr=1,mxnetbr
                   if ( iconnsam(k).eq.netbr(ibr)%iconn ) then
                      NSBR(IBR) = NSBR(IBR) + 1
                   end if
                end do
             end if
          ENDDO

          DO IBR = 1,MXNETBR                                      ! ALLOC BRANCH SAMPLES BACKREF.
             IF (NSBR(IBR)  > 0) THEN
                ALLOCATE(KBSAM(IBR)%KS(NSBR(IBR) ) )
             ENDIF
          ENDDO

          NSBR   = 0; NSBRMX = 0
          DO K   = 1,Nproflocs                                    ! REFER BACK TO SAMPLES ON BRANCH
             L   = LSAM(K)
             IBR = LC(L)
             if ( jampi.eq.0 ) then
                NSBR(IBR) = NSBR(IBR) + 1
                KBSAM(IBR)%KS(NSBR(IBR)) = K
                NSBRMX = MAX( NSBRMX,NSBR(IBR) )
             else
                do ibr=1,mxnetbr
                   if ( iconnsam(k).eq.netbr(ibr)%iconn ) then
                      NSBR(IBR) = NSBR(IBR) + 1
                      KBSAM(IBR)%KS(NSBR(IBR)) = K
                      NSBRMX = MAX( NSBRMX,NSBR(IBR) )
                   end if
                end do
             end if
          enddo

          ALLOCATE ( KLH (NSBRMX), XLH (NSBRMX), ZLH (NSBRMX), IDX(NSBRMX) )
          ALLOCATE ( KLHH(NSBRMX), XLHH(NSBRMX), ZLHH(NSBRMX)              )

          DO IBR = 1,MXNETBR                                      ! ORDER SAMPLES ON BRANCH AND INTERP LINKS INTO IT

             IF (NSBR(IBR) > 0) THEN                              ! ER ZITTEN PROFIELEN OP
                DO KK = 1,NSBR(IBR)
                   K  = KBSAM(IBR)%KS(KK)
                   XLH(KK)  = XLSAM(K)
                   !ZLH(KK)  = Zpr(K)
                   KLH(KK)  = K
                ENDDO
                CALL INDEXX(NSBR(IBR),XLH,IDX)
                DO KK = 1,NSBR(IBR)                               ! NU GESORTEERD NAAR AFSTAND
                   XLHH(KK) = XLH(IDX(KK))
                   !ZLHH(KK) = ZLH(IDX(KK))
                   KLHH(KK) = KLH(IDX(KK))
                ENDDO

                K1 = 0; K2 = 1
                DO LL = 1, netbr(ibr)%NX
                   ! NOTE: vulnerability: netbr(:)%ln(:) contains NETlinks (see SETBRANCH_LC()), but it is used below as FLOWlinks
                   !       Not a problem as long as *no* netlinks are discarded during geominit. (Then: numl1d == lnx1d.)
                   LA = IABS( NETBR(IBR)%LN(LL) )
                   XL = XLLIN(LA)
                   DO WHILE (XL > XLHH(K2) .AND. K2 < NSBR(IBR) )
                      K2 = K2 + 1; K1 = K1 + 1
                   ENDDO

                   IF ( XL > XLHH(K2) ) THEN
                      K1 = K2
                   ENDIF

                   IF (K1 == 0) THEN                             ! IN FIRST SEGMENT, VALUE IS THAT OF K1
                      ALFA = 0D0
                   ELSE IF (K1 == NSBR(IBR) ) THEN               ! IN LAST  SEGMENT, VALUE IS THAT OF K2
                      ALFA = 1D0
                   ELSE                                          ! IN BETWEEN, REGULAR INTERPOLATION
                      ALFA = ( XL - XLHH(K1) ) / ( XLHH(K2) - XLHH(K1) )
                   ENDIF
                   IF (K1 == 0) THEN
                       KA = KLHH(K2)
                   ELSE
                       KA = KLHH(K1)
                   ENDIF
                   IF (K1 == NSBR(IBR)) THEN
                       KB = KLHH(K1)
                   ELSE
                       KB = KLHH(K2)
                   ENDIF
                   KA = NPR(KA) ; KB = NPR(KB)
                   IF (profiles1D(ka)%ityp <= 3 .and. profiles1D(ka)%ityp  == profiles1D(kb)%ityp ) THEN   ! identical simple profs are interpolated immediately
                       PROF1D(1,LA) = (1D0-alfa)*profiles1D(ka)%width  + alfa*profiles1D(kb)%width
                       PROF1D(2,LA) = (1D0-alfa)*profiles1D(ka)%height + alfa*profiles1D(kb)%height
                       PROF1D(3,LA) = PROFILES1D(KA)%ITYP
                   ELSE                                                                                    ! POINTEREN VOOR YZPROF OR MIXED PROFILE TYPES
                       PROF1D(1,LA) = -KA
                       PROF1D(2,LA) = -KB
                       PROF1D(3,LA) = ALFA
                   ENDIF

                   !call mess('profile interpolation ready',nproflocs)                                     ! EN NU IS DE INTERPOLATIE KLAAR

                ENDDO

             ENDIF

          ENDDO

          DEALLOCATE ( IBN  , LIB  , K1BR , NRLB)
          DEALLOCATE ( KLH  , XLH  , ZLH  , IDX )
          DEALLOCATE ( KLHH , XLHH , ZLHH       )

          IF (jainterpolatezk1D > 0) THEN

              allocate ( zkk(numk), wkk(numk))
              do kn3now = 6,1,-5
                 wkk = 0d0 ; zkk = 0d0
                 do L = 1, lnx1D
                    if (abs(kcu(L)) == 1 .and. kn(3,ln2lne(L)) == kn3now ) then   ! regular 1D links
                        KA = PROF1D(1,L)
                        KB = PROF1D(2,L)
                        IF (KA < 0 .AND. KB < 0 ) THEN        ! for which profile pointering exists
                            ALFA    = PROF1D(3,L)
                            ZA      = profiles1D(-KA)%ZMIN
                            ZB      = profiles1D(-KB)%ZMIN
                            WA      = profiles1D(-KA)%width
                            WB      = profiles1D(-KB)%width
                            zuL     = (1d0-ALFA)*ZA + ALFA*ZB  ! z on these links
                            wuL     = 1d0 ! (1d0-ALFA)*WA + ALFA*WB  ! z on these links
                            LL      = abs( ln2lne(L) )
                            k       = kn(1,LL)
                            zkk(k)  = zkk(k) + zul*wuL
                            wkk(k)  = wkk(k) + wuL
                            k       = kn(2,LL)
                            zkk(k)  = zkk(k) + zul*wuL
                            wkk(k)  = wkk(k) + wuL
                        ENDIF
                    endif
                 enddo
                 do k = 1, numk
                    if (zk(k) == dmiss .or. zk(k) == zkuni) then
                       if (wkk(k) .ne. 0) then
                          zk(k) = zkk(k) / wkk(k)
                       endif
                    endif
                 enddo
              enddo
              deallocate (zkk, wkk)
          ENDIF

       endif   ! if ( Lnx1D.gt.0 ) then
    endif   ! if (nproflocs > 0) then

!   parallel: reduce nonlin
    if (jampi.eq.1) then
       call reduce_key(nonlin)
    end if

    call restoresam()
    deallocate(XLLIN, XLSAM)
    if ( Lnx1D.gt.0 ) then
       if ( allocated(NSBR)  ) deallocate(NSBR)
       if ( allocated(KBSAM) ) deallocate(KBSAM)
    end if
    deallocate(xpr, ypr, zpr, npr)

    if ( jampi.eq.1 ) then
       if ( allocated(distsam)  ) deallocate(distsam)
       if ( allocated(iconnsam) ) deallocate(iconnsam)
    end if

 endif

 !call duikerstoprofs()

 end subroutine setprofs1D

 subroutine readprofilesloc(minp)
 use m_profiles
 implicit none
 integer :: minp
 character rec*256
 integer :: ierr, n

 minproflocnr = 99999999 ; maxproflocnr = 0

 n = 0
 10 read(minp,'(a)',end=999) rec
 if (rec(1:1) == '*') goto 10
 n = n + 1
 goto 10

 999 rewind(minp)
 allocate (xpr(n), ypr(n), zpr(n), npr(n), stat=ierr)

 n = 0
 20 read(minp,'(a)',end=888) rec
 if (rec(1:1) == '*') goto 20
 n = n + 1
 read(rec,*) xpr(n), ypr(n), npr(n)

 goto 20

 888 call doclose(minp)
 nproflocs = n

 end subroutine readprofilesloc


subroutine readprofilesdef(ja)    ! in afwachting van een module die profieldefinities leest
 USE UNSTRUC_MODEL
 use m_flowgeom
 use m_profiles
 use m_physcoef, only: ifrctypuni, frcuni1D
 use m_missing
 use messagehandling
 use m_alloc
 implicit none
 integer          :: ja

 integer              :: minp, n, nr, ierr, k, L, Lp,lnumuniq, nyz, npfx, myzprofs, mxprof
 logical              :: jawel
 character (len=256)  :: rec
 integer, allocatable :: npr2(:)
 double precision     :: yp, zp, base, talud, width, height, zmin

 integer, parameter   :: mx = 2000
 double precision     :: yyh(mx), zzh(mx)

 myzprofs = 0

 rec = trim (md_profdeffile)
 inquire(file = rec , exist=jawel)

 ja = 0
 if (jawel) then

     call oldfil(minp, md_profdeffile )

     mxprof    = nproflocs

     if (allocated (profiles1D) ) deallocate (profiles1D)
     allocate ( profiles1D(mxprof) , stat=ierr)
     call aerr('profiles1D(mxprof)', ierr, 40*nprofdefs)

     allocate ( npr2(mxprof) ) ; npr2 = 0


     profiles1D(1:mxprof)%ityp   = 0
     profiles1D(1:mxprof)%width  = 0
     profiles1D(1:mxprof)%height = 3d3
     profiles1D(1:mxprof)%zmin   = -999


20   read(minp, '(A)', end = 888)  rec
     Lp = index(rec,'PROFNR=')

     if (Lp > 0) then

       read(rec(Lp+7:),*)  nr                        ! profile NR

       n = 0
       do k = 1, nproflocs
          if (npr(k) == nr) then
             if (n == 0) then
                 n = k
             endif
             npr2(k) = n
             npr(k)  = 0
          endif
       enddo

       if (n > 0) then

        L = index(rec,'TYPE=')                       ! profile type
        if (L > 0) then
           read(rec(L+5:),*)  profiles1D(n)%ityp
        endif

        L = index(rec,'WIDTH=')                      ! profile width
        if (L > 0) then
           read(rec(L+6:),*) width
           if (width < 1d-3) then
              call qnerror('profile width too small', rec, ' ')
           endif
           profiles1D(n)%width = width
        endif

        L = index(rec,'HEIGHT=')                     ! profile height
        if (L > 0) then
           read(rec(L+7:),*) height
           if (height < 1d-3) then
              call qnerror('profile height too small', rec, ' ')
           endif
           profiles1D(n)%height = height
        endif

        L = index(rec,'ZMIN=')                      ! profile level
        if (L > 0) then
           read(rec(L+7:),*) zmin
           profiles1D(n)%zmin = zmin
        endif

        L = index(rec,'BASE=')                       ! trapezoid base
        base = 0d0
        if (L > 0) then
           read(rec(L+5:),*) base
        endif

        L = index(rec,'TALUD=')                       ! trapezoid base
        talud = 0d0
        if (L > 0) then
           read(rec(L+6:),*) talud
        endif

        L = index(rec,'FRCTP=')                      ! friction type
        if (L > 0) then
           read(rec(L+6:),*)  profiles1D(n)%frctp
        else
           profiles1D(n)%frctp = -999
        endif

        L = index(rec,'FRCCF=')                      ! friction coefficient, only if type specified
        if (L > 0 .and. profiles1D(n)%frctp .ne. -999) then
           read(rec(L+6:),*)  profiles1D(n)%frccf
        else
           profiles1D(n)%frccf = dmiss
        endif

        if ( profiles1D(n)%ityp == 200 .or. profiles1D(n)%ityp == 201) then  ! todo read true y,z or xyz profile

            if (myzprofs == 0 .and. len( trim(md_profdefxyzfile) ) > 1) then
               call oldfil(myzprofs, md_profdefxyzfile )
            endif

            if (myzprofs == 0) then
               call qnerror('xyzprofile (TYPE= 200 or 201) is referenced, but profdefxyzfile not specified in mdu',' ',' ')
            endif

            nyz = 0
            call readyzprofnr(myzprofs, nr, nyz, yyh, zzh, mx, width, height, zmin)

            if (nyz == 0) then
               call qnerror(' xyzprofile not found ',' ',' ')
            else
               allocate ( profiles1D(n)%y(nyz ), stat = ierr ) ; profiles1D(n)%y = 0d0
               allocate ( profiles1D(n)%z(nyz ), stat = ierr ) ; profiles1D(n)%z = 0d0
               do k  = 1,nyz
                  profiles1D(n)%y(k) = yyh(k)
                  profiles1D(n)%z(k) = zzh(k)
               enddo
               profiles1D(n)%width   = width
               profiles1D(n)%height  = height
               profiles1D(n)%zmin    = zmin
               profiles1D(n)%ityp    = profiles1D(n)%ityp - 100 ! internally only distinguish 100 and 101
            endif
        endif

        if ( profiles1D(n)%ityp == 4 .or. profiles1D(n)%ityp == 5) then  ! V-shape comes as a yz type
            nyz = 3
            allocate ( profiles1D(n)%y(nyz ), stat = ierr )
            allocate ( profiles1D(n)%z(nyz ), stat = ierr )
            do k  = 1,nyz
               profiles1D(n)%y(k) = profiles1D(n)%width * ( dble(k-1)/dble(nyz-1) - 0.5d0 )
               profiles1D(n)%z(k) = profiles1D(n)%height
            enddo
            profiles1D(n)%z(2) = 0d0
            profiles1D(n)%ityp = profiles1D(n)%ityp + 96
        endif

        if ( profiles1D(n)%ityp == 6 .or. profiles1D(n)%ityp == 7) then  ! Trapezoid comes as a yz type
            if (base == 0d0 .and. talud .ne. 0.d0) then
               base = max(0d0, profiles1D(n)%width - 2d0*profiles1D(n)%height*talud)
            endif

            nyz = 4
            allocate ( profiles1D(n)%y(nyz ), stat = ierr )
            allocate ( profiles1D(n)%z(nyz ), stat = ierr )
            profiles1D(n)%y(1) =  -profiles1D(n)%width / 2d0
            profiles1D(n)%y(2) =   profiles1D(n)%y(1) + (profiles1D(n)%width-base) / 2d0
            profiles1D(n)%y(3) =   profiles1D(n)%y(2) + base
            profiles1D(n)%y(4) =   profiles1D(n)%width / 2d0


            profiles1D(n)%z(1) = profiles1D(n)%height
            profiles1D(n)%z(2) = 0d0
            profiles1D(n)%z(3) = 0d0
            profiles1D(n)%z(4) = profiles1D(n)%height
            profiles1D(n)%ityp = profiles1D(n)%ityp + 94
        endif

     endif
     endif

     goto 20


     888 call doclose(minp)
     ja = 1
     do k = 1,nproflocs
        if (npr2(k) == 0) then
            ja = 0
            call mess(LEVEL_info, 'Profloc nr. not found in profdef : ' , npr(k)  )
            npr2(k) = 0
        endif
     enddo
     if (ja == 0) then
         call mess(LEVEL_error, 'Errors in 1D profile references' )
     endif

     npr = npr2
     deallocate (npr2)
     ja  = 1
     if (myzprofs > 0) then
        call doclose(myzprofs)
     endif

 endif

 end subroutine readprofilesdef

 !> Reads xyz profiles (and stores them as yz profiles).
 !! When the model is in spherical coordinates, the x,y pairs (lon,lat) are translated
 !! into metric distances.
 subroutine readyzprofnr(myzprofs, iprofnr, nyz, yy, zz, mx, width, height, zmin)
 use unstruc_messages
 use m_profiles, only : tolzprof , ntolsave
 use geometry_module, only: dbdistance
 use m_sferic, only: jsferic, jasfer3D
 use m_missing
 implicit none
 integer              :: myzprofs, iprofnr, nyz, mx
 double precision     :: yy(mx), zz(mx), width, height, zmin, yh(9999), zh(9999)

 integer              :: L, nr, n, ikp(9999), n0, n1, n2, nn
 character (len=256)  :: rec, tex
 double precision     :: xx0, yy0, zz0, xx1, yy1, zz1, zmax, a, b, dif, zn1, y01, y02, dy

 nyz = 0

 ! rewind (myzprofs)
10 read   (myzprofs,'(a)',end= 999) rec
 if (index(rec,'PROFNR') > 0) then
    L = index(rec, '=') + 1
    read(rec(L:) , *) nr
    if (nr == iprofnr) then
       read(myzprofs,'(a)',end=999) rec
       read(rec,*, err = 888) nyz

       read(myzprofs,'(a)',end=999) rec
       read(rec,*, err = 777) xx0, yy0, zz0
       yy(1) = 0d0
       zz(1) = zz0
       zmin  = zz0

       nn = 1
       do n = 2, nyz
          read(myzprofs,'(a)',end=999) rec
          read(rec,*, err = 777) xx1, yy1, zz1

 !         read(myzprofs,*,err=777) xx1, yy1, zz1
          dy = dbdistance(xx0, yy0, xx1, yy1, jsferic, jasfer3D, dmiss)
          !dy = sqrt( (xx1-xx0)**2 + (yy1-yy0)**2)
          if (dy > 0d0) then
             nn = nn+1
             yy(nn) = yy(nn-1) + dy
             zz(nn) = zz1
             xx0   = xx1
             yy0   = yy1
          else
             write(msgbuf, '(a,i0,a,i0,a)') ' While reading PROFNR=', nr, ': point #', n, ' discarded, because it is the same as previous point.'
             call warn_flush()
          end if

          zmin  = min(zmin, zz1)
       enddo
       nyz = nn ! Some points may have been discarded
       zmax = -9d9
       do n = 1, nyz
          zz(n) = zz(n) - zmin
          zmax  = max(zmax, zz(n))
       enddo
       height = zmax
       width  = yy(nn)

       if (nyz > 2) then ! throw away points that can be represented by linear interpolation
          ikp(1)   = 1
          ikp(nyz) = 1
          do n1  = 2, nyz-1
             n0  = n1-1 ; n2 = n1+1
             if ( (zz(n1)-zz(n0))*(zz(n2)-zz(n1)) < 0) then ! do not touch local maxima or minima
                ikp(n1) = 1
             else 
                y02 = yy(n2) - yy(n0)
                y01 = yy(n1) - yy(n0)
                b   = y01/y02 ; a = 1d0 - b
                zn1 = a*zz(n0) + b*zz(n2)  
                dif = abs(zz(n1) - zn1)
                if (dif > tolzprof) then
                   ikp(n1) = 1
                else
                   ikp(n1) = 0
                endif
             endif
          enddo
          n = 0
          do n1 = 1, nyz
             if (ikp(n1) == 1) then
                 n = n + 1
                 yy(n) = yy(n1)
                 zz(n) = zz(n1)
             endif
          enddo
          ntolsave = ntolsave + nyz - n
          nyz = n
       endif

       return
    endif
 endif
 goto 10

999 write(tex, '(i10)') iprofnr
    call readerror('could not find profnr iprofnr = ', tex, myzprofs) ; return

888 call readerror('reading two integers nrows, nkols, but getting ', rec, myzprofs) ; return

777 call readerror('reading x,y,z , but getting ', rec, myzprofs) ; return

 end subroutine readyzprofnr

 subroutine triarea3D(xx,yy,zz,triarea)                      ! input: two vectors starting from zero
 implicit none
 double precision :: xx(2), yy(2), zz(2), triarea
 double precision :: d(3)
 d(1) =      yy(1)*zz(2) - yy(2)*zz(1)
 d(2) =-1d0*(xx(1)*zz(2) - xx(2)*zz(1))
 d(3) =      xx(1)*yy(2) - xx(2)*yy(1)

 triarea = 0.5d0*sqrt( d(1)*d(1) + d(2)*d(2) + d(3)*d(3) )

 end subroutine triarea3D

 !> Initializes all administration encessary for writing output to his-files.
 !! That is: snap observation stations to flow cells, cross sections to flow links.
 !! And bookkeeping for time series output on structures.
 subroutine flow_obsinit()
 use m_observations, only: init_valobs
 use m_structures
 implicit none
    call crosssections_on_flowgeom()

    call obs_on_flowgeom(0)

!   for the following, it is assumed that the moving obsrevation stations have been initialized (in flow_initexternalforcings)
    call init_valobs()   ! (re)initialize work array and set pointers for observation stations

    call updateValuesOnObervationStations() ! and fill first value

    call init_structure_hisvalues()

 end subroutine flow_obsinit

 double precision function cosphiu(L)                ! get link cos

 use m_flowgeom
 use m_netw
 use geometry_module, only: normalin
 use m_missing, only : dxymis
 use m_sferic, only: jsferic, jasfer3D

 implicit none

 integer :: L                                        ! for link L,

 ! locals
 integer          :: k1, k2, k3, k4
 double precision :: rn, rt, rnl, rtl
 k1 = ln(1,L)
 k2 = ln(2,L)
 k3 = lncn(1,L)
 k4 = lncn(2,L)
 call normalin(xz(k1), yz(k1), xz(k2), yz(k2), rnl, rtl, xu(L), yu(L),jsferic, jasfer3D, dxymis)  ! in pos LL direction
 call normalin(xk(k3), yk(k3), xk(k4), yk(k4), rn , rt,  xu(L), yu(L),jsferic, jasfer3D, dxymis)  ! = normalin (k1,k2)
 cosphiu = rnl*rn + rtl*rt

 end function cosphiu

 double precision function cosphiunet(L)                ! get link cos on net link

 use m_flowgeom
 use m_netw
 use geometry_module, only: dcosphi
 use m_sferic, only: jsferic, jasfer3D
 use m_missing, only : dxymis

 implicit none


 integer :: L                                        ! for net link L,

 ! locals
 integer          :: k1, k2, k3, k4
 double precision :: rn, rt, rnl, rtl

 ! Check: no findcells done yet. Report 'all bad'.
 if (nump <= 0) then
    cosphiunet = 1
    return
 end if

 ! Check: 1D or closed boundary link: report 'good'.
 if (lnn(L) < 2) then
    cosphiunet = 0
    return
 elseif (lne(1,L) <= 0 .or. lne(2,L) <= 0) then
    cosphiunet = 0
    return
 elseif (kn(1,L) <= 0 .or. kn(2,L) <= 0) then
    cosphiunet = 0
    return
 end if

 k1 = lne(1,L)
 k2 = lne(2,L)
 k3 = kn(1,L)
 k4 = kn(2,L)
 cosphiunet = dcosphi(xz(k1), yz(k1), xz(k2), yz(k2), xk(k3), yk(k3), xk(k4), yk(k4), jsferic, jasfer3D, dxymis)

 end function cosphiunet

 subroutine ispointinsidecells( xz, yz, nn )         ! check if certain point is inside other cells

 use m_netw
 use geometry_module, only: pinpok
 use m_missing, only: jins, dmiss

 implicit none
 double precision :: xz, yz, x(10), y(10)
 integer          :: nn

 ! locals
 integer          :: m,n,k

 do n = 1,nump
    do m = 1,netcell(n)%n
       k = netcell(n)%NOD(m)
       x(m) = xk(k)
       y(m) = yk(k)
    enddo
    call pinpok(xz,yz,netcell(n)%n,x,y,nn, jins, dmiss)
    if (nn .ne. 0) then
       nn = n ; return
    endif
 enddo

 end subroutine ispointinsidecells

 subroutine allocateandset2Dnodexyarrays(n)
 use m_netw
 use m_flowgeom
 use m_sferic

 implicit none
 integer          :: n, IERR
 ! locals
 integer          :: m,k,nn
 double precision :: xmn, xmx

 nn = netcell(n)%n

! GD: memory leak
 if(allocated(nd(n)%x)) deallocate(nd(n)%x)
 if(allocated(nd(n)%y)) deallocate(nd(n)%y)
 if(allocated(nd(n)%nod)) deallocate(nd(n)%nod)

 allocate ( nd(n)%x(nn), nd(n)%y(nn), nd(n)%nod(nn), stat=ierr )
 call aerr('nd(n)%x(nn), nd(n)%y(nn), nd(n)%nod(nn)', ierr, nn*3)
 do m  = 1,nn
    k  = netcell(n)%NOD(m)
    nd(n)%x(m) = xk(k)
    nd(n)%y(m) = yk(k)
    nd(n)%nod(m) = k;
 enddo

 if (jsferic == 1) then ! jglobe
    xmn   = minval( nd(n)%x )
    xmx   = maxval( nd(n)%x )
    if (xmx - xmn > 180d0) then
       do m  = 1,nn
          k  = netcell(n)%NOD(m)
          if ( xmx - nd(n)%x(m) > 180d0) then
             nd(n)%x(m) = nd(n)%x(m) + 360d0
          endif
       enddo
    endif
 endif

 end subroutine allocateandset2Dnodexyarrays

 subroutine allocateandset1Dnodexyarrays( n )          ! only for plotting ....
 use m_netw
 use m_flowgeom
 use m_sferic
 use m_missing
 use geometry_module, only: getdx, getdy
 use gridoperations
 implicit none

 integer          :: n, LL

 ! locals
 integer          :: m,k,nn, no, L, La, n1, n2, ierr, JACROS
 double precision :: x1, y1, x2, y2, hwu, cs, sn
 double precision :: x1a, y1a, x2a, y2a, x1b, y1b, x2b, y2b
 double precision :: SL,SM,XCR,YCR,CRP
 integer :: K1, K2
 double precision :: dxt, dyt, phi
 integer, allocatable :: linnrs(:)
 double precision, allocatable :: arglins(:), arglin(:)
 double precision, allocatable :: xx(:), yy(:)
 integer :: num
 integer :: jausedualnetcell

 jausedualnetcell = 0

 m = 3*nd(n)%lnx+1
 if (nd(n)%lnx == 1) m = m+1

 allocate ( nd(n)%x(m), nd(n)%y(m) , stat=ierr )
 call aerr('nd(n)%x(m), nd(n)%y(m)', ierr, m*2 )


 ! Sort nd%ln in counterclockwise order
allocate(linnrs(nd(n)%lnx), arglins(nd(n)%lnx), arglin(nd(n)%lnx))
do L=1,nd(n)%lnx
    K1 = LN(1,abs(nd(n)%ln(L))); K2 = LN(2,abs(nd(n)%ln(L)))
    if (K2 == n) then
        K2 = K1
        K1 = n
    end if
    dxt = getdx(xz(k1), yz(k1), xz(k2), yz(k2), jsferic)
    dyt = getdy(xz(k1), yz(k1), xz(k2), yz(k2), jsferic)
    if (abs(dxt) < 1d-14 .and. abs(dyt) < 1d-14) then
        if (dyt < 0) then
            phi = -pi/2
        else
            phi = pi/2
        end if
    else
        phi = atan2(dyt, dxt)
    end if
    arglin(L) = phi
end do

linnrs = 0
! Do a basic insertion sort (#links is small)
do L=1,nd(n)%lnx
    do LL=1,L-1
        if (arglin(L) < arglins(LL)) then
            exit
        end if
    end do
    arglins(LL+1:L) = arglins(LL:L-1)
    arglins(LL)     = arglin(L)
    linnrs (LL+1:L) = linnrs(LL:L-1)
    linnrs (LL)     = nd(n)%ln(L)
end do
! links are locally sorted in linnrs

 m  = 0
 x1 = xz(n)
 y1 = yz(n)

! For each link, save its 'bottom' side (wrt counterclockwise view) and its tip (i.e., 3 points)
! The intersection between this bottom side and the 'top' side of previous link
! is computed. This yields a good contour line in nd%x/y.

! Use last link to prepare connection for 1st link in following loop:
 La = abs(linnrs(nd(n)%lnx))
 cs = csu(La) ; sn = snu(La)
 hwu = 0.5d0*wu(La)
 if (jsferic == 1) then
    hwu = rd2dg*hwu/ra
 endif
 no = ln(2,La)
 if (no == n) then
     no = ln(1,La)
     cs = -cs ! Flip link means: negate normal components
     sn = -sn
 end if
 x1b = x1 - sn * hwu
 y1b = y1 + cs * hwu
 x2b = 0.5*(x1+xz(no)) - sn * hwu
 y2b = 0.5*(y1+yz(no)) + cs * hwu

 do LL = 1,nd(n)%lnx
    L  = linnrs(LL)

    La = iabs(L)

    if (kcu(La) /= 1 .and. kcu(La) /= 4) then
       cycle ! Only use real 1D links in the flow node contour, no 1d2d links
    end if

    n1 = ln(1,La) ; n2 = ln(2,La)
    cs = csu(La) ; sn = snu(La)
    hwu = 0.5d0*wu(La)
    if (jsferic == 1) then
       hwu = rd2dg*hwu/ra
    endif
    no = n2                     ! N on Other side = no
    if (no == n) then
        no = n1
        cs = -cs
        sn = -sn
    end if
    x2 = 0.5*(x1+xz(no))
    y2 = 0.5*(y1+yz(no))


    x1a = x1 + sn*hwu
    y1a = y1 - cs*hwu
    x2a = x2 + sn*hwu
    y2a = y2 - cs*hwu

    SL = dmiss; SM = dmiss
    call dCROSS(x1b, y1b, x2b,y2b, x1a, y1a, x2a, y2a,JACROS,SL,SM,XCR,YCR,CRP)
    !if (SL /= dmiss .and. SM /= dmiss) then
    IF (JACROS == 1) THEN
        x1a = xcr
        y1a = ycr
    ! else: parallel, use original x1a, y1a
    end if

    m  = m + 1
    nd(n)%x(m) = x1a
    nd(n)%y(m) = y1a

    m  = m + 1
    nd(n)%x(m) = x2a
    nd(n)%y(m) = y2a

    x1b = x1 - sn*hwu
    y1b = y1 + cs*hwu
    x2b = x2 - sn*hwu
    y2b = y2 + cs*hwu

    m  = m + 1
    nd(n)%x(m) = x2b
    nd(n)%y(m) = y2b

 enddo
 ! Only a single link, add fourth (extra) point.
 if (nd(n)%lnx == 1) then
    m  = m + 1
    nd(n)%x(m) = x1b
    nd(n)%y(m) = y1b
 end if

 ! For pfiller, close contour
 m  = m + 1
 nd(n)%x(m) = nd(n)%x(1)
 nd(n)%y(m) = nd(n)%y(1)
 call realloc(nd(n)%x, m, keepExisting = .true.)
 call realloc(nd(n)%y, m, keepExisting = .true.)
 deallocate(linnrs, arglins, arglin)

 if ( jausedualnetcell.eq.1 ) then
    k = nd(n)%nod(1)
    m = 10*nmk(k)
    call realloc(xx,m, keepExisting=.false.)
    call realloc(yy,m, keepExisting=.false.)

    call make_dual_cell(k, m, 1d0, xx, yy, num, Wu1Duni)

    call realloc(nd(n)%x, num+1, keepExisting = .true.)
    call realloc(nd(n)%y, num+1, keepExisting = .true.)

    nd(n)%x = (/ xx(1:num), xx(1) /)
    nd(n)%y = (/ yy(1:num), yy(1) /)
 end if

 !------------------------------------------------------

 end subroutine allocateandset1Dnodexyarrays

 subroutine getAVCOR( n, xz, yz, zz )                  ! average coordinate values
 use m_netw
 implicit none

 double precision :: xz, yz, zz                      !
 integer          :: m, n, nn, k

 xz = 0d0 ; yz = 0d0 ; zz = 0d0
 nn = netcell(n)%n                                      ! zwaartepunt
 do m  = 1,nn
    k  = netcell(n)%NOD(m)
    xz = xz + xk(k)
    yz = yz + yk(k)
    zz = zz + zk(k)
 enddo
 xz = xz / nn
 yz = yz / nn
 zz = zz / nn
 end subroutine getAVCOR


 !> Prepares a mirror cell as candidate for an open boundary cell, and a probe point 'uitsteker' for use in selectelset().
 !! This is done by determining a representative half cell size:
 !! dis = MAX(.5*sqrt(cell area), distance from circumcenter to edge)
 !! The mirrored circumcenter is obtained by projecting cell circumcenter onto edge, and from there extend by dis (i.e., half approximate cell 'width').
 !! The probe point is also obtained by projecting cell circumcenter onto edge, and from there extend by rrtol*dis (i.e., rrtol*apprimate cell 'width')
 subroutine mirrorcell( n, x3_, y3, x4_, y4, xci, yci, xcb, ycb, xmir, ymir, xx, yy )   !
 use m_netw                ! bounday segment   !intern circumcentre, boundary circumcentre, mirrorpoint, cell corners
 use m_flowgeom
 use m_sferic
 use m_missing, only: dmiss, dxymis
 use geometry_module, only: normaloutchk, duitpl, dprodout, half, spher2locvec, xpav, dlinedis

 implicit none
 integer,          intent(in)  :: n !< cell number (in 1:nump)
 double precision, intent(in)  :: x3_, y3, x4_, y4 !< net node coordinates of a boundary edge of this cell
 double precision, intent(out) :: xci, yci !< cell circumcenter coordinates for this cell (i.e., xz(n), yz(n))
 double precision, intent(out) :: xcb, ycb !< cell circumcenter coordinates for the 'mirror' cell
 double precision, intent(out) :: xmir, ymir !< 'Uitsteker' probe point, used for testing for open boundary in selectelset
 double precision, intent(out) :: xx(4), yy(4) !< Coordinates for mirrored cell contour (counter clockwise), contains x3,y3 and also x4,y4.

 double precision :: rtol
 double precision :: dis, dis2, diszw, edge, zci, rdot, rx, ry, xd, yd
 double precision :: x3, x4
 double precision, external :: dprodin
 integer :: ja, jadismxbnd = 0

 double precision, dimension(1) :: rxloc, ryloc
 double precision               :: xref, yref
 double precision               :: x5, y5, x6, y6
 double precision               :: dout


 ! call getcellWEIGHTEDcenter( n, xci, yci, zci )
 ! edge = dbdistance(x3,y3,x4,y4)
 ! dis  = ar/edge


!fix for spherical, periodic coordinates: get external boundary points close to internal in (lon,lat)
 x3 = x3_
 x4 = x4_
 if ( jsferic.eq.1 ) then
 !   x3 = x3 + floor( (180d0+xz(n)-x3)/360d0 ) * 360d0
 !   x4 = x4 + floor( (180d0+xz(n)-x4)/360d0 ) * 360d0

     x3 = x3 + nint( (xz(n)-x3)/360d0 ) * 360d0
     x4 = x4 + nint( (xz(n)-x4)/360d0 ) * 360d0
 end if

 CALL DLINEDIS(Xzw(n),Yzw(n),X3,Y3,X4,Y4,JA,DIS,Xd,Yd, jsferic, jasfer3D, dmiss)  ! dis is half cell size in boundary normal dir
 if (jadismxbnd == 1) dis = max(dis,0.5d0*sqrt(ba(n)))
 ! dis = max(dis,0.5d0*sqrt(ba(n)))

! (rx,ry) outward normal in reference frame of half(x3,y3,x4,y4)
 call normaloutchk(x3, y3, x4, y4, xzw(n), yzw(n), rx, ry, ja, jsferic, jasfer3D, dmiss, dxymis)

 xci  = xz(n)
 yci  = yz(n)

 if ( jsferic.eq.1 .and. jasfer3D.eq.1 ) then
    CALL DLINEDIS(Xci,Yci,X3,Y3,X4,Y4,JA,DIS2,Xd,Yd, jsferic, jasfer3D, dmiss)  ! dis is half cell size in boundary normal dir

!   compute reference point coordinates
    call half(x3,y3,x4,y4,xref,yref, jsferic, jasfer3D)

!   get outward normal in frame reference point
    call spher2locvec(xd,yd,1,(/xref/),(/yref/),(/rx/),(/ry/),rxloc,ryloc,jsferic, jasfer3D, dmiss)

!   xcb = xd + dis*rx
    call xpav(xd,yd,dis,rxloc(1),ryloc(1),xcb,ycb, jsferic, jasfer3D)
!   xmir = xd + 2*rrtol*dis*rx
    call xpav(xd,yd,2d0*rrtol*dis,rxloc(1),ryloc(1),xmir,ymir, jsferic, jasfer3D)

!   x5 = x3 + dis*rx
    call spher2locvec(x3,y3,1,(/xref/),(/yref/),(/rx/),(/ry/),rxloc,ryloc,jsferic, jasfer3D, dmiss)
    call xpav(x3,y3,dis,rxloc(1),ryloc(1),x5,y5, jsferic, jasfer3D)

!   x6 = x4 + dis*rx
    call spher2locvec(x4,y4,1,(/xref/),(/yref/),(/rx/),(/ry/),rxloc,ryloc,jsferic, jasfer3D, dmiss)
    call xpav(x4,y4,dis,rxloc(1),ryloc(1),x6,y6, jsferic, jasfer3D)

!   dout = rx*(y4-y3) - ry*(x4-x3)
    dout = dprodout(xd,yd,xcb,ycb,x3,y3,x4,y4, jsferic, jasfer3D)/dis
 else

    ! Convert back to sferic, if necessary
    if (jsferic == 1) then
       dis = dis*rd2dg/ra
    endif

    CALL DLINEDIS(Xci,Yci,X3,Y3,X4,Y4,JA,DIS2,Xd,Yd, jsferic, jasfer3D, dmiss)  ! dis is half cell size in boundary normal dir

    xcb  = xd + rx*dis
    ycb  = yd + ry*dis
    xmir = xd + rx*2d0*rrtol*dis
    ymir = yd + ry*2d0*rrtol*dis

    x5 = x3 + dis*rx
    y5 = y3 + dis*ry

    x6 = x4 + dis*rx
    y6 = y4 + dis*ry

    dout = rx*(y4-y3) - ry*(x4-x3)
 end if


 !call movabs(xci, yci)
 !call lnabs(xmir, ymir)
 !call toemaar()


! store ordered contour of cell
 if (dout > 0d0) then
    xx(1) = x3          ; yy(1) = y3
    xx(2) = x5          ; yy(2) = y5
    xx(3) = x6          ; yy(3) = y6
    xx(4) = x4          ; yy(4) = y4
 else
    xx(4) = x3          ; yy(4) = y3
    xx(3) = x5          ; yy(3) = y5
    xx(2) = x6          ; yy(2) = y6
    xx(1) = x4          ; yy(1) = y4
 end if
 end subroutine mirrorcell


 !> compute the length of a netlink
 double precision function linksize(L)
 use m_netw
 use geometry_module, only: dbdistance
 use m_missing, only: dmiss
 use m_sferic, only: jsferic, jasfer3D

 implicit none
 integer :: L, k1, k2

 k1 = kn(1,L) ;  k2 = kn(2,L)
 linksize = dbdistance ( xk(k1), yk(k1), xk(k1), yk(k2), jsferic, jasfer3D, dmiss)
 end function linksize

 !> initialize sferical coordinate frame
 subroutine inisferic()
 use m_sferic
 use m_physcoef
 implicit none
 double precision :: sidereal, st2
 pi       = acos(-1d0)
 twopi    = 2d0*pi
 dg2rd    = pi/180d0
 rd2dg    = 180d0/pi
 sidereal = 23d0*3600d0 + 56d0*60d0 + 4.1d0
 omega    = twopi/sidereal
 fcorio   = 2d0*omega*sin(anglat*dg2rd)
 dy2dg    = rd2dg/ra
 end subroutine inisferic

 subroutine flow_allocflow()                             ! initialise flow model time independent parameters
 use m_netw, only : kn
 use m_flowgeom
 use m_flow
 use m_flowtimes
 ! use m_flowexternalforcings
 use m_missing
 use unstruc_model
 use m_netw, only : netcell, numk, numl
 use m_alloc
 use m_waves
 use m_flowexternalforcings, only: nbndw
 use m_sediment
 use m_ship
 use m_sferic
 use m_partitioninfo
 use m_transport, only : NUMCONST
 use m_integralstats
 use unstruc_channel_flow

 implicit none
 integer :: ierr, n, k, mxn, j, kj, kk, LL, L, k1, k2, k3, k4, n1, n2, n3, n4, nL, kb1, kb2, numkmin, numkmax, kbc1, kbc2
 integer :: nlayb, nrlay, nlayb1, nrlay1, nlayb2, nrlay2, Lb, Lt, mx, ltn, mpol, Lt1, Lt2, Lt3, Ld1, Ld2, Ld3, Ldn
 integer :: laybed, laytop, nrlayL, Lf, kuni, kb

 double precision :: zmn, zmx, dzm, zw, zkk  ! for 3D
 double precision :: xL, xR, dLR, alf, xfixed, xsigma, gf, d1, di, w1, w2, w3, zbt, zbb, dzb, gfi, gfk, sumcof
 logical          :: jawel

 integer          :: ierror

 if (ndx == 0) return

! if ( jampi.eq.1 ) then
!!   synchronise bed level
!    call update_ghosts(ITYPE_SALL, 1, Ndx, bl, ierror)
! end if


 call ilowercase(md_netfile)  ! INTERACTOR!

! node related
 if (allocated(s0) ) then
    deallocate(s0,s1,a0,a1,hs,s00,cfs)
 endif

 allocate ( s0  (ndx) , s1 ( ndx) , stat = ierr)
 call aerr('s0  (ndx) , s1  (ndx)', ierr, 2*ndx) ; s0   = 0 ; s1   = 0
 allocate ( a0  (ndx) , a1  (ndx) , stat = ierr)
 call aerr('a0  (ndx) , a1  (ndx)', ierr, 2*ndx) ; a0   = 0 ; a1   = 0
 allocate ( hs  (ndx) , s00 (ndx) , stat = ierr)
 call aerr('hs  (ndx) , s00 (ndx)', ierr, 2*ndx) ; hs   = 0 ; s00  = 0
 allocate ( cfs (ndx) , stat = ierr)
 call aerr('cfs (ndx)', ierr,   ndx) ; cfs = 0

 if (allocated (kbot) ) then
    deallocate( kbot,ktop,ktop0,kmxn,Lbot,Ltop,kmxL )
 endif
 allocate ( kbot (ndx) , stat= ierr )
 call aerr('kbot (ndx)', ierr,  ndx )
 allocate ( ktop (ndx) , stat= ierr )
 call aerr('ktop (ndx)', ierr,  ndx )
 allocate ( ktop0(ndx) , stat= ierr )
 call aerr('ktop0(ndx)', ierr,  ndx )
 allocate ( kmxn (ndx) , stat= ierr )
 call aerr('kmxn (ndx)', ierr,  ndx )
 allocate ( Lbot (Lnx) , stat= ierr )
 call aerr('Lbot (Lnx)', ierr,  Lnx )
 allocate ( Ltop (Lnx) , stat= ierr )
 call aerr('Ltop (Lnx)', ierr,  Lnx )
 allocate ( kmxL (Lnx) , stat= ierr )
 call aerr('kmxL (Lnx)', ierr,  Lnx )

 if (allocated (ustb) ) deallocate(ustb, ustw)
 allocate ( ustb  (lnx) , stat= ierr )
 call aerr('ustb  (lnx)', ierr,  lnx ) ; ustb  = 0
 allocate ( ustw  (lnx) , stat= ierr )
 call aerr('ustw  (lnx)', ierr,  lnx ) ; ustw  = 0

 if (allocated (laydefnr) ) deallocate(laydefnr, laytyp, laymx)
 allocate ( laydefnr(ndx)      , stat= ierr      )
 call aerr('laydefnr(ndx)'     , ierr,  ndx      )
 allocate ( laytyp(mxlaydefs)  , stat= ierr      )
 call aerr('laytyp(mxlaydefs)' , ierr, mxlaydefs )
 allocate ( laymx(mxlaydefs)   , stat= ierr      )
 call aerr('laymx(mxlaydefs)'  , ierr, mxlaydefs )

 do k=1,Ndx
    kbot(k) = k
    ktop(k) = k
    kmxn(k) = 1
 end do
 do L=1,Lnx
    Lbot(L) = L
    Ltop(L) = L
    kmxL(L) = 1
 end do

 if (kmx > 0) then

    numkmin = int(1d8) ; numkmax = -numkmin
    do Lf = Lnx1D+1, Lnx                ! we only need netnode nrs in 2D, todo: trim to numkmin
       L  = ln2lne(Lf)
       if (kn(3,L) == 2) then
          numkmin = min(numkmin, kn(1,L), kn(2,L) )
          numkmax = max(numkmax, kn(1,L), kn(2,L) )
       endif
    enddo

    numkmax = numk
    if (allocated ( kbotc) ) then
        deallocate( kbotc, kmxc )
    endif
    allocate ( kbotc(numkmax)  , stat= ierr)       ! may also be numkmin -> numkmax
    call aerr('kbotc(numkmax)' , ierr, numkmax)
    allocate ( kmxc (numkmax)  , stat= ierr)
    call aerr('kmxc (numkmax)' , ierr, numkmax)

    kbot  = 1 ; ktop = 1 ; kmxn = 1
    Lbot  = 1 ; Ltop = 1 ; kmxL = 1
    kbotc = 1 ; kmxc = 1

    mxlays = kmx ; numvertdis = 3 ! mxlayz = 6
    mxlaydefs = numvertdis ;  mx = 0;
    laydefnr  = 1

    if (layertype == 3) then
       inquire (file = md_vertplizfile, exist = jawel)
       if (jawel) then
          call oldfil(mpol, md_vertplizfile )
       else
          call qnerror( 'vertical_layering.pliz not found, switch back to sigma', ' ', ' ')
          layertype = 1
       endif
    endif

    if (layertype == 1 .or. layertype == 4  ) then                                     ! all sigma
        mxlaydefs = 1
        laytyp(1) = 1
        laymx(1)  = kmx
        if (layertype == 4 ) then
           if (allocated  (dkx)) deallocate  (dkx, sdkx)
           allocate ( sdkx(ndx), dkx(ndx) )
        endif
    else if (layertype == 2) then                                ! all z
        mxlaydefs = 1
        laytyp(1) = 2

        if( zlaybot == dmiss ) then
           zmn = bl(1)
           do n = 2,ndx
              zmn = min(bl(n),zmn)
           enddo
        else
           zmn = zlaybot
        endif

        if ( jampi.eq.1 ) then
           call reduce_double_min(zmn)
        end if

        if( iStrchType >= 0 ) then
           if (zlaytop == dmiss) then
              zmx  = sini
           else
              zmx  = zlaytop
           endif
        else
           if (Floorlevtoplay == dmiss) then
              zmx  = sini
           else
              if (jaorgFloorlevtoplaydef == 1) then
                 zmx  = Floorlevtoplay
              else
                 if (dztop == dmiss) then
                    zmx  = Floorlevtoplay
                 else
                    zmx  = Floorlevtoplay + dztop
           endif
        endif
        endif
        endif

        if (dztopuniabovez == dmiss) then
           zbt  = zmn
        else
           zbt  = max(zmn, dztopuniabovez)
        endif

        if (dztop == dmiss) then
           dzm  = (zmx - zbt) / mxlayz
        else
           dzm  = dztop ; mxlayz = (zmx - zbt) / dzm
        endif

        kuni = mxlayz  ; mx = kuni
        if (zbt > zmn) then  ! count extra layers needed to fill out till bottom

           zbb = zbt  ; dzb = dzm
           do while (zbb > zmn .and. mx < kmxx-1)
              dzb = dzb*sigmagrowthfactor
              zbb = zbb - dzb
              mx  = mx  + 1
           enddo

        endif

        dzm  = max(dzm, 1d-2)
        ! toplayminthick = 0.01d0  ! 0.5d0*dzm
        mxlayz   = mx
        kmx      = mx  ! repair code
        laymx(1) = mx
    else if (layertype == 3) then                                ! combination in polygons
        call polygonlayering(mpol)
    endif
    do k = 1,mxlaydefs
       mx = max(mx, laymx(k) )
    enddo
    if (allocated (zslay) ) deallocate (zslay, dzslay)
    allocate ( zslay (0:mx, mxlaydefs) , stat = ierr )           ! nr of layer distributions
    allocate ( dzslay (0:mx, mxlaydefs) , stat = ierr ) ; dzslay = 0d0

    if( iStrchType == STRCH_USER ) then
       sumcof = abs( sum( laycof ) - 100d0 )
       if( sumcof > 1d-8 ) then
          call mess(LEVEL_ERROR, 'Error : The sum of sigma layer thicknesses must be equal to 100!')
       endif
    endif

    if( iStrchType == STRCH_USER ) then
       do j = 1,mxlaydefs
          mx = laymx(j)
          do k = 1,mx
             dzslay(k,j) = laycof(k) / 100d0
          enddo
       enddo

    elseif( iStrchType == STRCH_EXPONENT ) then
       gfi = 1d0 / laycof(2)
       gf  = laycof(3)
       do j = 1,mxlaydefs
          mx = laymx(j)
          k1 = laycof(1) * mx
          gfk = gfi**k1
          if( gfk == 1d0 ) then
             gfi = 1d0
             dzslay(1,j) = 1d0 / mx
          else
             dzslay(1,j) = ( 1d0 - gfi ) / ( 1d0 - gfk )* laycof(1)
          endif
          do k = 2,k1
             dzslay(k,j) = dzslay(k-1,j) * gfi
          enddo
          gfk = gf**(kmx-k1)
          if( k1 < kmx ) then
             if( gfk == 1d0 ) then
                gf = 1d0
                dzslay(k1+1,j) = 1d0 / mx
             else
                dzslay(k1+1,j) = ( 1d0 - gf ) / ( 1d0 - gfk ) * ( 1d0 - laycof(1) )
             endif
             do k = k1+2,mx
                dzslay(k,j) = dzslay(k-1,j) * gf
             enddo
          endif
       enddo
    else
       do j = 1,mxlaydefs
          mx = laymx(j)
          do k = 1,mx
             dzslay(k,j) = 1d0 / mx
          enddo
       enddo
    endif

    do j = 1,mxlaydefs
       mx = laymx(j)
       if (laytyp(j) == 1) then

           zslay(0,j) = 0d0
           do k = 1, mx
              zslay(k,j) = zslay(k-1,j) + dzslay(k,j)
           enddo

       else if (laytyp(j) == 2) then

           if ( allocated(zslay) ) deallocate(zslay)
           allocate ( zslay (0:mx, mxlaydefs) , stat = ierr )           ! nr of layer distributions

           if( iStrchType >= 0 ) then
              zslay(0,j) = zmn
              do k = 1,mx
                 zslay(k,j) = zslay(k-1,j) + dzslay(k,j) * (zmx-zmn)
              enddo
           else
              zslay(0,j) = zmn ; zslay(mx,j) = zmx
              do k = mx-1, mx - kuni , -1
                 zslay(k,j) = zslay(k+1,j) - dzm
              enddo

              dzb = dzm
              do k  = mx - kuni, 1, -1
                 dzb = dzb*sigmagrowthfactor
                 zslay(k,j) = zslay(k+1,j) - dzb
              enddo
           endif
       endif
    enddo


    kk  = Ndx
    do n   = 1,ndx


       kbot(n) = 0
       kk = kk + 1                                      ! spoke cell for everyone

       Ldn = laydefnr(n)
       if (Ldn >= 1) then
          if ( laytyp(Ldn) == 1 ) then
              mx  = laymx(Ldn)
              kmxn(n) = mx
          else if ( laytyp(Ldn) == 2 ) then
              call getzlayerindices(n,nlayb,nrlay)
              kmxn(n) = nrlay
              ! mx  = laymx(Ldn)
              ! do k = 1,mx
              !   if ( zslay(k,Ldn) > bl(n) ) then
               !       kmxn(n) = mx - k + 1
              !       exit
              !   endif
              ! enddo
          endif
       endif

    enddo

    kk  = Ndx
    do n   = 1,ndx                                 ! Count ndkx + set kbot array

       kbot(n) = 0
       kk = kk + 1

       Ldn = laydefnr(n)
       if (Ldn == 0) then
          k1 = indlaynod(1,n) ; k2 = indlaynod(2,n) ; k3 = indlaynod(3,n)
          w1 =  wflaynod(1,n) ; w2 =  wflaynod(2,n) ; w3 =  wflaynod(3,n)
          kmxn(n) = max(1, nint( w1*kmxn(k1) + w2*kmxn(k2) + w3*kmxn(k3) )  )

         ! kmxn(n) = max( kmxn(k1), kmxn(k2), kmxn(k3) )
       endif

       do k    = 1, kmxn(n)
          kk   = kk + 1
          if (k == 1) then
              kbot(n)   = kk
          endif
       enddo
    enddo
    ndkx = kk


    LL = Lnx                                           ! Stapelen vanaf grondlaag
    do L  = 1,lnx
       n1 = ln(1,L)   ; n2 = ln(2,L)
       kmxL(L) = min( kmxn(n1), kmxn(n2) ) ! 30-04       !  kmxL(L) = max ( kmxn(n1), kmxn(n2) )

       if (abs(kcu(L)) == 2) then
          n3 = lncn(1,L) ; n4 = lncn(2,L)
          kmxc(n3) = max( kmxc(n3), kmxL(L) )
          kmxc(n4) = max( kmxc(n4), kmxL(L) )
       endif

       do k  = 0, kmxL(L)
          LL = LL + 1
       enddo
    enddo
    Lnkx = LL

    call realloc(ln  ,   (/ 2, Lnkx  /) )
    call realloc(lncn,   (/ 2, Lnkx  /) )

    LL = Lnx                                           ! Stapelen vanaf grondlaag

    kk = numk                                          ! setup cornerpoint admin
    do n = numkmin, numkmax
       do k    = 0, kmxc(n)
          kk   = kk + 1
          if (k == 1) then
              kbotc(n) = kk
          endif
       enddo
    enddo
    call realloc(ucnx, kk )
    call realloc(ucny, kk )

    do L  = 1,lnx
       n1 = ln  (1,L) ; n2 = ln  (2,L)
       n3 = lncn(1,L) ; n4 = lncn(2,L)

       Lt1 = 0 ; Lt2 = 0
       if ( laydefnr(n1) > 0 .and. laydefnr(n2) > 0) then
          Lt1 = laytyp( laydefnr(n1) ) ; Lt2 = laytyp( laydefnr(n2) )
       endif

       if ( Lt1 == 2 .and. Lt2 == 2) then
          if (jaZlayeratubybob == 1) then
             call getzlayerindicesbobL(n1,nlayb1,nrlay1, 0.5d0*( bob(1,L) + bob(2,L) )  )
             call getzlayerindicesbobL(n2,nlayb2,nrlay2, 0.5d0*( bob(1,L) + bob(2,L) )  )
          else
             call getzlayerindices(n1,nlayb1,nrlay1)
             call getzlayerindices(n2,nlayb2,nrlay2)
          endif

          kb1 = max(0, nlayb2-nlayb1)
          kb2 = max(0, nlayb1-nlayb2)

          laybed = max( nlayb1,nlayb2 )
          laytop = min( nlayb1+nrlay1, nlayb2+nrlay2 ) ! should be identical for n1,n2,n3,n4
          nrlayL = laytop - laybed + 1

          kbc1   = kmxc(n3) - nrlayL
          kbc2   = kmxc(n4) - nrlayL

       else
          kb1  = 0 ; kb2  = 0     ! linking starts at kbot(n1) + kb1 on left and at kbot(n2) + kb2 on right
          kbc1 = 0 ; kbc2 = 0
       endif

       do k   = 0, kmxL(L)     ! 1 extra below bedlayer k = 1
          LL  = LL  + 1
          if (k == 1) then
              Lbot(L) = LL
          endif
          if (k > 0) then
             ln(1,LL)   = kbot (n1) + kb1
             ln(2,LL)   = kbot (n2) + kb2
             kb1 = kb1 + 1 ; kb1 = min(kb1, kmxn(n1))
             kb2 = kb2 + 1 ; kb2 = min(kb2, kmxn(n2))


             if (abs(kcu(L)) == 2) then
                lncn(1,LL) = kbotc(n3) + kbc1
                lncn(2,LL) = kbotc(n4) + kbc2
                kbc1 = kbc1 + 1 ; kbc1 = min(kbc1, kmxc(n3))
                kbc2 = kbc2 + 1 ; kbc2 = min(kbc2, kmxc(n4))
             endif

          endif
       enddo
    enddo

    call realloc(ln0  ,   (/ 2, Lnkx  /) )
    ln0 = ln

    do LL = 1,lnx ! only checking
       Lb = Lbot(LL)
       Lt = Lb + kmxL(LL) - 1
       n1 = ln(1,LL) ; n2 = ln(2,LL)
       do L = Lb, Lt
          k1 = ln(1,L) ; k2 = ln(2,L)
          if (k1 > kbot(n1) + kmxn(n1) - 1) then
             ln(1,L) = k1
          endif
          if (k2 > kbot(n2) + kmxn(n2) - 1) then
             ln(2,L) = k2
          endif
       enddo
    enddo

 else
    ndkx = ndx
    Lnkx = Lnx
 endif

 if (allocated (ucx) ) then ! basic flow arrays
    deallocate (ucx,ucy,uqcx,uqcy,ucxq,ucyq,qin,vih,dvxc,dvyc,squ,sqi,sq,sqa,vol0,vol1,vol1_f,volerror)
 endif
 allocate ( ucx (ndkx) , ucy (ndkx) , stat = ierr)
 call aerr('ucx (ndkx) , ucy (ndkx)', ierr, 2*ndkx) ; ucx  = 0 ; ucy  = 0
 allocate ( uqcx(ndkx) , uqcy(ndkx) , stat = ierr)
 call aerr('uqcx(ndkx) , uqcy(ndkx)', ierr, 2*ndkx) ; uqcx = 0 ; uqcy = 0
 allocate ( ucxq(ndkx) , ucyq(ndkx) , stat = ierr)
 call aerr('ucxq(ndkx) , ucyq(ndkx)', ierr, 2*ndkx) ; ucxq = 0 ; ucyq = 0
 if (jamapucmag == 1 .or. len_trim(md_foufile) > 0 .or. allocated(map_classes_ucmag)) then
    call realloc(ucmag, ndkx, keepExisting=.false.)
 end if
 allocate ( qin (ndkx) , vih (ndkx) , stat = ierr)
 call aerr('qin (ndkx) , vih (ndkx)', ierr, 2*ndkx) ; qin  = 0 ; vih  = 0
 allocate ( dvxc(ndkx) , dvyc(ndkx) , stat = ierr)
 call aerr('dvxc(ndkx) , dvyc(ndkx)', ierr, 2*ndkx) ; dvxc = 0 ; dvyc = 0
 allocate ( squ (ndkx) , stat=ierr )
 call aerr('squ (ndkx)', ierr, ndkx)                ; squ  = 0
 allocate ( sqi (ndkx) , stat=ierr )
 call aerr('sqi (ndkx)', ierr, ndkx)                ; sqi  = 0
 allocate ( sq  (ndkx) , stat=ierr )
 call aerr('sq  (ndkx)', ierr, ndx )                ; sq   = 0
 allocate ( sqa (ndkx) , stat=ierr )
 call aerr('sqa (ndkx)', ierr, ndx )                ; sq   = 0
 allocate ( vol0(ndkx) , stat = ierr)
 call aerr('vol0(ndkx)', ierr, ndkx)                ; vol0 = 0
 allocate ( vol1(ndkx) , stat = ierr)
 call aerr('vol1(ndkx)', ierr, ndkx)                ; vol1 = 0
 allocate ( vol1_f(ndkx) , stat = ierr)
 call aerr('vol1_f(ndkx)', ierr, ndkx)                ; vol1_f = 0
 allocate ( volerror(ndkx) , stat = ierr)
 call aerr('volerror(ndkx)', ierr,   ndx)           ; volerror = 0

 if ( allocated(dtcell) ) then
    deallocate(dtcell)
 endif
 allocate( dtcell(ndkx), stat = ierr)
 call aerr('dtcell(ndkx)', ierr, ndkx) ; dtcell = 0d0

 ! for 1D only
 if (network%loaded) then
    if (ndxi-ndx2d > 0) then
       call realloc(time_wetground, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
       call aerr('time_wetground(ndx)', ierr, ndx)
       
       call realloc(freeboard, ndx, keepExisting = .false., fill = dmiss, stat = ierr)
       call aerr('freeboard(ndx)', ierr, ndx)
       
       call realloc(hsOnGround, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
       call aerr('hsOnGround(ndx)', ierr, ndx)
       
       call realloc(volOnGround, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
       call aerr('volOnGround(ndx)', ierr, ndx)
       
       call realloc(qCur1d2d, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
       call aerr('qCur1d2d(ndx)', ierr, ndx)
       
       call realloc(vTot1d2d, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
       call aerr('vTot1d2d(ndx)', ierr, ndx)
       
       call realloc(qCurLat, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
       call aerr('qCurLat(ndx)', ierr, ndx)
       
       call realloc(vTotLat, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
       call aerr('vTotLat(ndx)', ierr, ndx)
    end if
    if (lnx1d > 0) then
       call realloc(s1Gradient, lnx, keepExisting = .false., fill = dmiss, stat = ierr)
       call aerr('s1Gradient', ierr, lnx)
    end if
end if
 
 if (kmx > 0 .and. (ja_timestep_auto == 3 .or. ja_timestep_auto == 4) ) then
    if (allocated (squ2D)) deallocate (squ2d)
    allocate ( squ2D(ndkx) , stat=ierr )
    call aerr('squ2D(ndkx)', ierr, ndkx)            ; squ2D = 0
 endif

if (ja_timestep_auto == 1 .and. ja_timestep_nostruct > 0) then
   if (allocated (squcor)) deallocate (squcor)
   allocate ( squcor(ndx) , stat=ierr )
   call aerr('squcor(ndx)', ierr, ndx)            ; squcor = 0
endif

if (icorio == 7 .or. icorio == 8 .or. icorio == 27 .or. icorio == 28) then  
   if ( allocated(hus) ) deallocate(hus) 
   allocate ( hus(ndkx) , stat=ierr )
   call aerr('hus(ndkx)', ierr, ndkx) ; hus = 0
endif
 if (kmx > 0) then
   if (allocated (ucz) ) deallocate(ucz)
   allocate ( ucz (ndkx) , stat = ierr)
   call aerr('ucz (ndkx)', ierr, ndkx) ; ucz  = 0
endif

 if (allocated(rho) ) deallocate(rho)
 allocate ( rho (ndkx) , stat= ierr )
 call aerr('rho (ndkx)', ierr, ndkx ) ; rho  = rhomean

 if (jasal > 0 .or. jatem > 0 .or. jased> 0 .or. stm_included ) then
    if (abs(jabaroctimeint) >= 2) then
       if (jacreep == 1 .or. abs(jabaroctimeint) >= 3) then
          if (allocated(dpbdx0) ) deallocate(dpbdx0)
          allocate ( dpbdx0 (lnkx) , stat= ierr )
          call aerr('dpbdx0 (lnkx)', ierr, lnkx ) ; dpbdx0 = 0d0
       endif

       if (jacreep .ne. 1 .and. abs(jabaroctimeint) .ne. 3) then
          if (allocated(rho0) ) deallocate(rho0)
          allocate ( rho0 (ndkx) , stat= ierr )
          call aerr('rho0 (ndkx)', ierr, ndkx ) ; rho0  = rhomean
       endif

    endif
 endif

 if (kmx > 0) then
    if (allocated(zws) ) deallocate (zws,zws0,ww1,qw)
    allocate ( ww1 (ndkx) , stat=ierr  )
    call aerr('ww1 (ndkx)', ierr, ndkx ) ; ww1  = 0
    allocate ( qw  (ndkx) , stat=ierr  )
    call aerr('qw  (ndkx)', ierr, ndkx ) ; qw   = 0

    allocate ( zws (ndkx) , stat= ierr )
    call aerr('zws (ndkx)', ierr, ndkx ) ; zws  = 0
    allocate ( zws0(ndkx) , stat= ierr )
    call aerr('zws0(ndkx)', ierr, ndkx ) ; zws0 = 0

    do n1 = 1,ndx
       Ldn = laydefnr(n1)
       Ltn = laytyp(Ldn)
       kb  = kbot(n1)
       zws(kb-1) = bl(n1) - zwsbtol
       if (Ltn == 2 .and. keepzlayeringatbed == 1) then
          call getzlayerindices(n1,nlayb1,nrlay1)
          zws(kb-1) = zslay(nlayb1-1,Ldn)
       endif
    enddo

 endif

 kmxd = max(1,kmx)


 if( allocated(workx) ) then
     deallocate( workx, worky, work0, work1 )
 endif
 allocate ( workx (ndkx) , stat = ierr)
 call aerr('workx (ndkx)', ierr, ndkx) ; workx  = 0
 allocate ( worky (ndkx) , stat = ierr)
 call aerr('worky (ndkx)', ierr, ndkx) ; worky  = 0
 allocate ( work0 (0:max(kmx,1),max(ndx,lnx)) , stat = ierr)
 call aerr('work0 (0:max(kmx,1),max(ndx,lnx))', ierr, max(kmx+1,1)*max(ndx,lnx)) ; work0  = 0
 allocate ( work1 (max(kmx,1),max(ndx,lnx)) , stat = ierr)
 call aerr('work1 (max(kmx,1),max(ndx,lnx))', ierr, max(kmx,1)*max(ndx,lnx)) ; work1  = 0


!    Secondary Flow
 if (jasecflow > 0) then
    allocate ( spirint( ndx ) , stat = ierr )
    call aerr('spirint( ndx )', ierr, ndx  ) ; spirint = 0
    allocate ( czusf  ( lnx ) , stat = ierr )
    call aerr('czusf  ( lnx )', ierr, lnx  ) ; czusf   = 0
    allocate ( czssf  ( ndx ) , stat = ierr )
    call aerr('czssf  ( ndx )', ierr, ndx  ) ; czssf   = 0
    if (kmx == 0) then
       if (allocated (spircrv) ) then
          deallocate ( spircrv, spirint, spirsrc, spirfx, spirfy, spirucm, ht_xx, ht_xy )
       endif
       allocate ( spircrv( ndx ) , stat = ierr )
       call aerr('spircrv( ndx )', ierr, ndx  ) ; spircrv = 0
       allocate ( spirsrc( ndx ) , stat = ierr )
       call aerr('spirsrc( ndx )', ierr, ndx  ) ; spirsrc = 0
       allocate ( spirfx ( ndx ) , stat = ierr )
       call aerr('spirfx ( ndx )', ierr, ndx  ) ; spirfx  = 0
       allocate ( spirfy ( ndx ) , stat = ierr )
       call aerr('spirfy ( ndx )', ierr, ndx  ) ; spirfy  = 0
       allocate ( spirucm( ndx ) , stat = ierr )
       call aerr('spirucm( ndx )', ierr, ndx   ) ; spirucm = 0
       allocate ( ht_xx  ( ndx ) , stat = ierr )
       call aerr('ht_xx  ( ndx )', ierr, ndx   ) ; ht_xx   = 0
       allocate ( ht_xy  ( ndx ) , stat = ierr )
       call aerr('ht_xy  ( ndx )', ierr, ndx   ) ; ht_xy   = 0
    else
       if (allocated (spiratx) ) then
          deallocate ( spiratx, spiraty )
       endif
       allocate ( spiratx( ndx ) , stat = ierr )
       call aerr('spiratx( ndx )', ierr, ndx   ) ; spiratx = 0
       allocate ( spiraty( ndx ) , stat = ierr )
       call aerr('spiraty( ndx )', ierr, ndx   ) ; spiraty = 0
    endif
 endif

 if (jabarrieradvection == 3) then
    if (allocated (struclink) ) then
       deallocate ( struclink )
    endif
    allocate ( struclink( lnx ) , stat = ierr )
    call aerr('struclink( lnx )', ierr, lnx   ) ; struclink = 0
 endif

 if (limtypmom == 6) then
    if (allocated (ducxdx) ) deallocate (ducxdx,ducxdy)
    allocate  ( ducxdx (ndkx) , stat = ierr)
    call aerr ('ducxdx (ndkx)', ierr, ndkx) ; ducxdx  = 0d0
    allocate  ( ducxdy (ndkx) , stat = ierr)
    call aerr ('ducxdy (ndkx)', ierr, ndkx) ; ducxdy  = 0d0

    if (allocated (ducydx) ) deallocate (ducydx,ducydy)
    allocate  ( ducydx (ndkx) , stat = ierr)
    call aerr ('ducydx (ndkx)', ierr, ndkx) ; ducydx  = 0d0
    allocate  ( ducydy (ndkx) , stat = ierr)
    call aerr ('ducydy (ndkx)', ierr, ndkx) ; ducydy  = 0d0
 endif

 if (limtypsa == 6) then
    if (allocated (dsadx) ) deallocate (dsadx,dsady)
    allocate  ( dsadx (ndkx) , stat = ierr)
    call aerr ('dsadx (ndkx)', ierr, ndkx) ; dsadx  = 0
    allocate  ( dsady (ndkx) , stat = ierr)
    call aerr ('dsady (ndkx)', ierr, ndkx) ; dsady  = 0
 endif

! if (allocated (dudx) ) then
!    deallocate (dudx,dudy,dvdx,dvdy,rsi,uc3rsi,rsiexact)
!    deallocate (dsdx,dsdy)
! endif
!    Secondary Flow
! if (kmx < 2) then
!     allocate ( dudx (ndkx) , stat = ierr)
!     call aerr('dudx (ndkx)', ierr, ndkx) ; dudx  = 0
!     allocate ( dsdx (ndkx) , stat = ierr)
!     call aerr('dsdx (ndkx)', ierr, ndkx) ; dsdx  = 0
!     allocate ( dsdy (ndkx) , stat = ierr)
!     call aerr('dsdy (ndkx)', ierr, ndkx) ; dsdx  = 0
!     allocate ( dudy (ndkx) , stat = ierr)
!     call aerr('dudy (ndkx)', ierr, ndkx) ; dudy  = 0
!     allocate ( dvdx (ndkx) , stat = ierr)
!     call aerr('dvdx (ndkx)', ierr, ndkx) ; dudx  = 0
!     allocate ( dvdy (ndkx) , stat = ierr)
!     call aerr('dvdy (ndkx)', ierr, ndkx) ; dudy  = 0
!     allocate ( rsi (ndkx) , stat = ierr)
!     call aerr('rsi (ndkx)', ierr, ndkx) ; rsi  = 0
!     allocate ( rsiexact (ndkx) , stat = ierr)
!     call aerr('rsiexact (ndkx)', ierr, ndkx) ; rsiexact  = 0
!     allocate ( uc3rsi (ndkx) , stat = ierr)
!     call aerr('uc3rsi (ndkx)', ierr, ndkx) ; uc3rsi  = 0
! endif

 ! Anti-creep
 if ( jacreep == 1 .and. ( jasal > 0 .or. jatem > 0 .or. jased> 0 .and. jased < 4) ) then
    if( allocated( dsalL ) ) then
       deallocate( dsalL, dtemL )
    endif
    if( kmx >= 2 ) then
        allocate ( dsalL(lnkx) , stat = ierr )
        call aerr('dsalL(lnkx)', ierr, lnkx  ) ; dsalL  = 0
        allocate ( dtemL(lnkx) , stat = ierr )
        call aerr('dtemL(lnkx)', ierr, lnkx  ) ; dtemL  = 0
    endif
 endif


 if (jsferic == 1) then
    if (allocated (tidep) ) deallocate(tidep)
    if ( allocated(tidef) ) deallocate(tidef)
    if ( allocated(s1init) ) deallocate(s1init)
    if ( jaselfal.gt.0 ) then
!      also store SAL potential
       allocate ( tidep (2,ndx) , stat = ierr)
       call aerr('tidep (2,ndx)', ierr, 2*ndx) ; tidep = 0
    else
       allocate ( tidep (1,ndx) , stat = ierr)
       call aerr('tidep (1,ndx)', ierr,   ndx) ; tidep = 0
    end if

    if ( jatidep.eq.1 .or. jaselfal.gt.0 ) then
       allocate(tidef(Lnx), stat=ierr)
       call aerr('tidef(Lnx)', ierr, Lnx)
       tidef = 0d0
    end if

    if ( jaselfal.gt.0 .and. jaSELFALcorrectWLwithIni.eq.1 ) then
       allocate(s1init(Ndx), stat=ierr)
       call aerr('s1init(Ndx)', ierr, Ndx)
       s1init = 0d0
    end if
 endif


 if (kmx > 0) then  ! 7 turbulence arrays (0:kmx)
    if (allocated(turkin0) ) then
        deallocate (turkin0, turkin1, tureps0, tureps1, vicwwu, vicwws)
    endif

    allocate ( turkin0  (Lnkx) , stat= ierr )
    call aerr('turkin0  (Lnkx)', ierr, Lnkx ) ; turkin0   = epstke
    allocate ( turkin1  (Lnkx) , stat= ierr )
    call aerr('turkin1  (Lnkx)', ierr, Lnkx ) ; turkin1   = epstke
    allocate ( tureps0  (Lnkx) , stat= ierr )
    call aerr('tureps0  (Lnkx)', ierr, Lnkx ) ; tureps0   = epseps
    allocate ( tureps1  (Lnkx) , stat= ierr )
    call aerr('tureps1  (Lnkx)', ierr, Lnkx ) ; tureps1   = epseps
    allocate ( vicwwu   (Lnkx) , stat= ierr )
    call aerr('vicwwu   (Lnkx)', ierr, Lnkx ) ; vicwwu    = 0d0
    allocate ( vicwws   (ndkx) , stat= ierr )
    call aerr('vicwws   (ndkx)', ierr, ndkx ) ; vicwws    = 0d0

    if (allocated (turkinepsws) ) then
       deallocate (turkinepsws)
    endif
    allocate ( turkinepsws (2,ndkx) , stat= ierr )
    call aerr('turkinepsws (2,ndkx)', ierr, ndkx ) ; turkinepsws  = 0

    if (allocated (sqcu) ) then
        deallocate(sqcu, tqcu, eqcu)
    endif
    allocate ( sqcu(Ndkx) , stat= ierr )
    call aerr('sqcu(Ndkx)', ierr, ndkx ) ; sqcu = 0
    allocate ( tqcu(Ndkx) , stat= ierr )
    call aerr('tqcu(Ndkx)', ierr, ndkx ) ; tqcu = 0
    allocate ( eqcu(Ndkx) , stat= ierr )
    call aerr('eqcu(Ndkx)', ierr, ndkx ) ; eqcu = 0
 endif

 if (allocated (rhou) ) deallocate(rhou)
 call realloc( z0ucur,lnx  , stat=ierr, keepExisting = .false., fill = 1d-10)
 call aerr   ('z0ucur(lnx)', ierr, lnx)
 call realloc( z0urou,lnx  , stat=ierr, keepExisting = .false., fill = 1d-10)
 call aerr   ('z0urou(lnx)', ierr, lnx)

 ! link related
 if (allocated(cfuhi))    deallocate(cfuhi)
 if (allocated(frcu))     deallocate(frcu)
 if (allocated(ifrcutp))  deallocate(ifrcutp)
 if (allocated(wdsu))     deallocate(wdsu)
 if (allocated(wdsu_x))   deallocate(wdsu_x)
 if (allocated(wdsu_y))   deallocate(wdsu_y)
 if (allocated(u0))       deallocate(u0)
 if (allocated(u1))       deallocate(u1)
 if (allocated(q1))       deallocate(q1)
 if (allocated(qa))       deallocate(qa)
 if (allocated(v))        deallocate(v)
 if (allocated(ucxu))     deallocate(ucxu)
 if (allocated(ucyu))     deallocate(ucyu)
 if (allocated(hu))       deallocate(hu)
 if (allocated(huvli))    deallocate(huvli)
 if (allocated(au))       deallocate(au)
 if (allocated(viu))      deallocate(viu)
 if (allocated(vicLu))    deallocate(vicLu)
 if (allocated(suu))      deallocate(suu)
 if (allocated(advi))     deallocate(advi)
 if (allocated(adve))     deallocate(adve)
 if (allocated(plotlin))  deallocate(plotlin)
 if (allocated(frcu_bkp)) deallocate(frcu_bkp)
 if (allocated(frcu_mor)) deallocate(frcu_mor)

 allocate ( cfuhi(lnx)   , stat=ierr)            ! hk: hier stond + 1, heb ik weggehaald
 call aerr('cfuhi(lnx)'  , ierr, lnx)   ; cfuhi   = 0
 allocate ( frcu (lnx)   , stat = ierr)
 call aerr('frcu (lnx)'  , ierr,   lnx) ; frcu    = dmiss
 if (jacali == 1) then
     allocate ( frcu_bkp (lnx)   , stat = ierr)
     call aerr('frcu_bkp (lnx)'  , ierr,   lnx) ; frcu_bkp    = dmiss
 endif
 allocate ( frcu_mor (lnx)   , stat = ierr)
 call aerr('frcu_mor (lnx)'  , ierr,   lnx) ; frcu_mor    = dmiss
 allocate ( ifrcutp(lnx) , stat = ierr)
 call aerr('ifrcutp(lnx)', ierr,   lnx) ; ifrcutp = abs(ifrctypuni)
 allocate ( wdsu  (lnx)  , stat=ierr  )
 call aerr('wdsu  (lnx)' , ierr, lnx  ) ; wdsu     = 0
 if (jamapwindstress > 0) then
    allocate ( wdsu_x(lnx)  , stat=ierr  )
    call aerr('wdsu_x(lnx)' , ierr, lnx  ) ; wdsu_x  = 0
    allocate ( wdsu_y(lnx)  , stat=ierr  )
    call aerr('wdsu_y(lnx)' , ierr, lnx  ) ; wdsu_y  = 0
 endif
 allocate ( u0   (lnkx)  , stat = ierr)
 call aerr('u0   (lnkx)' , ierr , lnkx )  ; u0    = 0
 allocate ( u1   (lnkx)  , stat = ierr)
 call aerr('u1   (lnkx)' , ierr , lnkx )  ; u1    = 0
 allocate ( q1   (lnkx)  , stat = ierr)
 call aerr('q1   (lnkx)' , ierr , lnkx )  ; q1    = 0
 allocate ( qa   (lnkx)  , stat = ierr)
 call aerr('qa   (lnkx)' , ierr , lnkx )  ; qa    = 0
 allocate ( v    (lnkx)  , stat = ierr)
 call aerr('v    (lnkx)' , ierr , lnkx )  ; v     = 0  ; v(1:lnx) = 100d0
 allocate ( ucxu (lnkx)  , stat = ierr)
 call aerr('ucxu (lnkx)' , ierr , lnkx )  ; ucxu  = 0
 allocate ( ucyu (lnkx)  , stat = ierr)
 call aerr('ucyu (lnkx)' , ierr , lnkx )  ; ucxu  = 0
 allocate ( hu   (lnkx)  , stat = ierr)
 call aerr('hu   (lnkx)' , ierr , lnkx )  ; hu    = 0
 allocate ( huvli(lnkx)  , stat =ierr )
 call aerr('huvli(lnkx)' , ierr, lnkx  )  ; huvli = 0
 allocate ( au   (lnkx)  , stat = ierr)
 call aerr('au   (lnkx)' , ierr , lnkx ) ; au    = 0
 allocate ( viu  (lnkx)  , stat =ierr )
 call aerr('viu  (lnkx)' , ierr, lnkx  ) ; viu   = 0
 allocate ( vicLu(lnkx)  , stat =ierr )
 call aerr('vicLu(lnkx)' , ierr, lnkx  ) ; vicLu   = 0
 allocate ( suu  (lnkx)  , stat = ierr)
 call aerr('suu  (lnkx)' , ierr , lnkx ) ; suu   = 0
 allocate ( advi (lnkx)  , stat = ierr)
 call aerr('advi (lnkx)' , ierr , lnkx ) ; advi  = 0
 allocate ( adve (lnkx)  , stat = ierr)
 call aerr('adve (lnkx)' , ierr , lnkx ) ; adve  = 0
 allocate ( plotlin(max(lnkx,ndkx)) , stat = ierr)
 call aerr('plotlin(max(lnkx,ndkx))', ierr , lnkx ) ; plotlin = 0

 if (jafrculin > 0) then
     if (allocated (frculin) ) deallocate (frculin)
     allocate ( frculin (lnx)    , stat = ierr)
     call aerr('frculin (lnx)'   , ierr,   ndx) ; frculin = dmiss
 endif

 ! TODO alloceer u_to_main alleen bij md1d netwerk
 if (network%loaded .or. stm_included) then
    if ( allocated(u_to_umain) ) deallocate(u_to_umain)
    allocate ( u_to_umain   (lnkx) , stat = ierr)
    call aerr('u_to_umain   (lnkx)', ierr , lnkx ) ; u_to_umain    = 1d0

    if ( allocated(q1_main) ) deallocate(q1_main)
    allocate ( q1_main   (lnkx) , stat = ierr)
    call aerr('q1_main   (lnkx)', ierr , lnkx ) ; q1_main    = 0
 endif

 if (jacali.eq.1) then
    if (allocated (cfclval) ) deallocate(cfclval)
    allocate ( cfclval(numl)    , stat=ierr)
    call aerr('cfclval(numl)'   , ierr, numl)   ; cfclval = 0
 end if

 if (jatrt.eq.1) then
    if (allocated (cftrt) ) deallocate(cftrt)
    allocate ( cftrt(numl,3)    , stat=ierr)
    call aerr('cftrt(numl,3)'   , ierr, numl)   ; cftrt   = 0
 end if

 if (jamapchezy > 0) then
    if (allocated (czs) ) deallocate(czs)
    allocate ( czs(ndx)    , stat=ierr)
    call aerr('czs(ndx)'   , ierr, ndx)   ; czs   = 0
 endif

 if (jarhoxu > 0 .or. jased > 0) then
    if (allocated (rhou) ) deallocate(rhou)
    allocate ( rhou (lnkx) , stat = ierr)
    call aerr('rhou (lnkx)', ierr , lnkx ) ; rhou = rhomean
 endif

 ! m_integralstats
 if (is_numndvals > 0) then
    call realloc(is_maxvalsnd, (/ is_numndvals, ndx /), keepExisting = .false., fill = 0d0)
    call realloc(is_sumvalsnd, (/ is_numndvals, ndx /), keepExisting = .false., fill = 0d0)
    call realloc(is_valnamesnd, is_numndvals, keepExisting = .false., fill = '')
 end if

 ! solving related
 if (allocated(fu) ) then
    deallocate(fu, ru, bb, dd)
 endif

 allocate ( bb   (ndx ) , stat = ierr)
 call aerr('bb   (ndx )', ierr,   ndx) ; bb    = 0
 allocate ( dd   (ndx ) , stat = ierr)
 call aerr('dd   (ndx )', ierr,   ndx) ; dd    = 0
 allocate ( fu   (lnkx) , stat = ierr)
 call aerr('fu   (lnkx)', ierr,   ndx) ; fu    = 0
 allocate ( ru   (lnkx) , stat = ierr)
 call aerr('ru   (lnkx)', ierr,   ndx) ; ru    = 0

 if (jasal > 0 .or. kmx > 0) then
    if (allocated (sa1) ) deallocate (sa1)
    allocate ( sa1 (ndkx) , stat = ierr)
    call aerr('sa1 (ndkx)', ierr, ndkx) ; sa1  = salini

    if (allocated (sam0) ) deallocate (sam0, sam1, same)
    allocate (sam0(ndkx), sam1(ndkx), same(ndkx) )  ; sam0 = 0 ; sam1 = 0 ; same = 0

    if (jasteric > 0) then
       if (allocated (steric) ) deallocate (steric)
       allocate ( steric(2,ndkx) , stat = ierr)
       call aerr('steric(2,ndkx)', ierr, 2*ndkx)
       do n=1,ndkx
          steric(1,n) = backgroundsalinity
          steric(2,n) = backgroundwatertemperature
       enddo
    endif

    if ( jatransportmodule == 0) then
       if ( allocated (supq) )  deallocate (supq, qsho)
       allocate ( supq(ndkx), qsho(lnkx)  , stat = ierr)
       call aerr('supq(ndkx), qsho(lnkx) ', ierr, ndkx)

       if (allocated (salsrc) ) deallocate (salsrc)
       allocate ( salsrc(ndkx) , stat = ierr)
       call aerr('salsrc(ndkx)', ierr, ndkx) ; salsrc = 0d0
    endif

 endif

 if (jatem > 0) then
    if ( allocated (tem1) ) deallocate (tem1)
    allocate ( tem1(ndkx)  , stat = ierr)
    call aerr('tem1(ndkx) ', ierr, 2*ndkx) ; tem1 = temini
    if ( allocated (heatsrc) )  deallocate (heatsrc, heatsrc0)
    allocate ( heatsrc(ndkx), heatsrc0(ndkx) , stat = ierr) ; heatsrc = 0d0 ; heatsrc0 = 0d0
    call aerr('heatsrc(ndkx), heatsrc0(ndkx)', ierr, ndkx)

    if (jatransportmodule == 0) then
        if ( allocated (tupq) )  deallocate (tupq,  qtho)
        allocate ( tupq(ndkx), qtho(lnkx)  , stat = ierr)
        call aerr('tupq(ndkx), qtho(lnkx))', ierr, ndkx)
    endif

    if (jatem > 1) then ! also heat modelling involved
       if ( allocated (tair) )  deallocate (tair, rhum, clou)
       allocate ( tair(ndx), rhum(ndx), clou(ndx) , stat = ierr)
       call aerr('tair(ndx), rhum(ndx), clou(ndx)', ierr, 3*ndx)
       tair = backgroundairtemperature
       rhum = backgroundhumidity
       clou = backgroundcloudiness
       if ( allocated (qrad) )  deallocate (qrad)
       allocate ( qrad(ndx) , stat = ierr)
       call aerr('qrad(ndx)', ierr, ndx)
       qrad = 0d0
       if (Soiltempthick > 0) then
          if ( allocated (tbed) )  deallocate (tbed)
          allocate ( tbed(ndx) , stat = ierr)
          call aerr('tbed(ndx)', ierr, ndx)
          tbed = temini
       endif

    endif

    if ((jamapheatflux > 0 .or. jahisheatflux > 0) .and. jatem > 1) then
       if (allocated (Qtotmap) ) deallocate (Qtotmap)
       allocate ( Qtotmap(ndx)   , stat = ierr) ; Qtotmap = 0d0
       call aerr('Qtotmap(ndx)'  , ierr , ndx )
    endif

    if (jatem == 5) then ! save cd coeff if heat modelling also involved
       if (allocated (cdwcof) ) deallocate(cdwcof)
       allocate ( cdwcof(lnx) , stat = ierr)
       call aerr('cdwcof(lnx)', ierr ,  lnx) ; cdwcof = 0d0

       if (jaroro > 1) then ! save rhoair for windstress
          if (allocated (roair) ) deallocate(roair)
          allocate ( roair(ndx) , stat = ierr)
          call aerr('roair(ndx)', ierr ,  ndx) ; roair = rhoair
       endif

       if (jamapheatflux > 0 .or. jahisheatflux > 0) then ! his or map output
          if (allocated(qsunmap)) deallocate (Qsunmap, Qevamap, Qconmap, Qlongmap, Qfrevamap, Qfrconmap)
          allocate ( Qsunmap(ndx)   , stat = ierr) ; Qsunmap = 0d0
          call aerr('Qsunmap(ndx)'  , ierr , ndx )
          allocate ( Qevamap(ndx)   , stat = ierr) ; Qevamap = 0d0
          call aerr('Qevamap(ndx)'  , ierr , ndx )
          allocate ( Qconmap(ndx)   , stat = ierr) ; Qconmap = 0d0
          call aerr('Qconmap(ndx)'  , ierr , ndx )
          allocate ( Qlongmap(ndx)  , stat = ierr) ; Qlongmap = 0d0
          call aerr('Qlongmap(ndx)' , ierr , ndx )
          allocate ( Qfrevamap(ndx) , stat = ierr) ; Qfrevamap = 0d0
          call aerr('Qfrevamap(ndx)', ierr , ndx )
          allocate ( Qfrconmap(ndx) , stat = ierr) ; Qfrconmap = 0d0
          call aerr('Qfrconmap(ndx)', ierr , ndx )
       endif
    endif
 endif

 if (jased > 0 .and. jased < 4) then
    if ( allocated (sed) )  deallocate (sed, grainlay)
    allocate ( sed (mxgr,ndkx)  ,  stat = ierr)
    call aerr('sed (mxgr,ndkx)' ,  ierr, ndkx*mxgr)

    if ( allocated(sdupq) )  deallocate (sdupq)
    allocate ( sdupq(mxgr,ndkx) , stat = ierr) ; sdupq = 0d0
    call aerr('sdupq(mxgr,ndkx)', ierr, ndkx*mxgr)

    if (jaceneqtr == 1) then                  ! cell centre equilibrium transport concentration
       mxn = ndx
       if (allocated(blinc)) deallocate(blinc)
       allocate  ( blinc(ndx) , stat=ierr)
       call aerr ('blinc(ndx)', ierr , ndx) ; blinc = 0d0
    else                                      ! cell corner equilibrium transport concentration
       mxn  = numk
       if (allocated(sedi)) deallocate(sedi)
       allocate ( sedi(mxgr,ndx)  , stat = ierr)
       call aerr('sedi(mxgr,ndx)' , ierr, ndx*mxgr) ; sedi = 0d0
    endif
    allocate ( grainlay(mxgr,mxn) , stat=ierr)
    call aerr('grainlay(mxgr,mxn)', ierr, mxgr*mxn); grainlay = 0d0

    if (kmx > 0 .and. jased > 0 .and. jased < 4) then
       if (allocated (ustbc) ) deallocate (ustbc)
       allocate  ( ustbc(mxn) , stat=ierr)
       call aerr ('ustbc(mxn)', ierr , mxn) ; ustbc = 0d0
    endif


    !if ( allocated (tauu) )   deallocate (taucx,taucy,tauu)
    !allocate ( taucx(ndx) , stat=ierr)
    !call aerr('taucx(ndx)', ierr, ndx); taucx = 0d0
    !allocate ( taucy(ndx) , stat=ierr)
    !call aerr('taucy(ndx)', ierr, ndx); taucy = 0d0
    !allocate ( tauu (lnx) , stat=ierr)
    !call aerr('tauu (lnx)', ierr, ndx); tauu  = 0d0

 endif

 if (idensform > 0 .and. jaRichardsononoutput > 0) then
     if (allocated (rich) ) deallocate(rich)
     allocate  ( rich(lnkx) , stat=ierr)
     call aerr ('rich(lnkx)', ierr , ndkx) ; rich = 0d0
 else
     jaRichardsononoutput = 0
 endif

 if (ti_waq > 0) then
    call realloc(q1waq, lnkx, keepExisting = .false., fill = 0d0, stat = ierr)
    if (kmx > 0) then
       call realloc(qwwaq, ndkx, keepExisting = .false., fill = 0d0, stat = ierr)
    end if
 end if

 if ( itstep.eq.4 ) then   ! explicit time-step
    if ( allocated(sqwave) ) deallocate(sqwave)
    allocate ( sqwave (ndx) , stat=ierr )
    call aerr('sqwave (ndx)', ierr, ndx)                ; sqwave  = 0
 end if

 if (infiltrationmodel > 0) then
    call realloc(infilt, ndx, keepExisting = .false., fill = 0d0, stat = ierr)

    if (infiltrationmodel >= 2) then
       call realloc(infiltcap, ndx, keepExisting = .false., fill = infiltcapuni, stat=ierr )
    endif
 end if

 if (jagrw > 0) then
    if (allocated (sgrw0) ) deallocate (sgrw0, sgrw1, pgrw, bgrw)
    allocate  ( sgrw0(ndx) , stat=ierr)
    call aerr ('sgrw0(ndx)', ierr , ndx) ; sgrw0 = 0d0
    allocate  ( sgrw1(ndx) , stat=ierr)
    call aerr ('sgrw1(ndx)', ierr , ndx) ; sgrw1 = 0d0
    allocate  ( pgrw (ndx) , stat=ierr)
    call aerr ('pgrw (ndx)', ierr , ndx) ; pgrw  = 0d0
    allocate  ( bgrw (ndx) , stat=ierr)
    call aerr ('bgrw (ndx)', ierr , ndx)
    if (h_aquiferuni > 0d0 ) then
       bgrw  = bl - h_aquiferuni
    else
       bgrw = bgrwuni
    endif

 endif

 if (jarain > 0) then
    call realloc(rain, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
 end if

 if (jaevap > 0) then
    call realloc(evap, ndx, keepExisting = .false., fill = 0d0, stat = ierr)
 end if

 if (jawind > 0) then
    call realloc(wx, lnx, keepExisting = .false., fill = 0d0, stat = ierr)
    call realloc(wy, lnx, keepExisting = .false., fill = 0d0, stat = ierr)
    call realloc(kcw, lnx, keepExisting = .false., fill = 1, stat = ierr)
 end if

 if (jaQinext > 0) then
    call realloc(qinext, ndkx, keepExisting = .false., fill = 0d0, stat = ierr)
    call aerr('qinext(ndkx)', ierr, ndkx)
    call realloc(qinextreal, ndkx, keepExisting = .false., fill = 0d0, stat = ierr)
    call aerr('qinextreal(ndkx)', ierr, ndkx)
    call realloc(vincum, ndkx, keepExisting = .false., fill = 0d0, stat = ierr)
    call aerr('vincum(ndkx)', ierr, ndkx)
 end if

 if (nshiptxy > 0) then
    if (allocated( zsp0) ) deallocate(zsp0 )
    allocate     ( zsp0(numk) , stat = ierr )
    call aerr    ('zsp0(numk)', ierr, numk   ) ; zsp0 = 0d0

    if (allocated( zspc) ) deallocate(zspc)
    allocate     ( zspc(numk) , stat = ierr )
    call aerr    ('zspc(numk)', ierr, numk  )  ; zspc = 0d0

    if (allocated( zspc0) ) deallocate(zspc0)
    allocate     ( zspc0(numk) , stat = ierr ) ; zspc0 = 0d0
    call aerr    ('zspc0(numk)', ierr, numk  )

    if (allocated(v0ship) ) deallocate(v0ship, v1ship, qinship)
    allocate  ( v0ship(ndx), v1ship(ndx), qinship(ndx) , stat = ierr )  ; v0ship = 0d0; v1ship = 0d0; qinship = 0d0
    call aerr ('v0ship(ndx), v1ship(ndx), qinship(ndx)', ierr, ndx   )

    call realloc(shL, 2, keepExisting    = .false., fill = 0d0, stat = ierr)
    call aerr('shL(2)', ierr, 2)
    call realloc(shB, 2, keepExisting    = .false., fill = 0d0, stat = ierr)
    call aerr('shB(2)', ierr, 2)
    call realloc(shd, 2, keepExisting    = .false., fill = 0d0, stat = ierr)
    call aerr('shd(2)', ierr, 2)
    call realloc(stuw, 2, keepExisting   = .false., fill = 0d0, stat = ierr)
    call aerr('stuw(2)', ierr, 2)
    call realloc(fstuw, 2, keepExisting  = .false., fill = 0d0, stat = ierr)
    call aerr('fstuw(2)', ierr, 2)
    call realloc(stuwmx, 2, keepExisting = .false., fill = 0d0, stat = ierr)
    call aerr('stuwmx(2)', ierr, 2)
    call realloc(roer, 2, keepExisting   = .false., fill = 0d0, stat = ierr)
    call aerr('roer(2)', ierr, 2)
    call realloc(froer, 2, keepExisting  = .false., fill = 0d0, stat = ierr)
    call aerr('froer(2)', ierr, 2)
    call realloc(roermx, 2, keepExisting = .false., fill = 0d0, stat = ierr)
    call aerr('roermx(2)', ierr, 2)
 endif

 if ( janudge.eq.1 ) then
    call realloc(nudge_tem, Ndkx, fill=DMISS)
    call realloc(nudge_sal, Ndkx, fill=DMISS)
    call realloc(zcs, Ndkx)
    call realloc(nudge_time, Ndx, fill=DMISS)
    call realloc(nudge_rate, Ndx, fill=DMISS)
 end if

 end subroutine flow_allocflow

 subroutine setkbotktop(jazws0)                                        ! initialise vertical coordinates
 use m_netw
 use m_flowgeom
 use m_flow
 use m_flowtimes
 use m_transport, only: NUMCONST, Constituents, ISALT, ITEMP, ISED1, ISEDN, ITRA1, itraN, itrac2const

 implicit none

 integer          :: jazws0

 integer          :: k2, kb, k, n, kk, nL, nR, nlayb, nlayt, nrlay, ktx, kL, ndz, i
 integer          :: ktmn, ktmx, kt0, kt1, kt2, kt3, LL, L, Lb, Lt, n1,n2, kb1,kb2,ki,kt, kkk, kwaq, Ltn, Ldn
 double precision :: zkk, h0, zks, zkz, sigm, hdz, toplaymint, volkt, savolkt, tevolkt, dtopsi
 double precision :: w1, w2, w3, h1, h2, h3, dz1, dz2, dz3, zw1, zw2, zw3, bL1, bL2, bL3, ht1, ht2, ht3
 integer          :: k1, k3, kb3, Lt1, Lt2, Lt3, Ld1, Ld2, Ld3, kk1, kk2, kk3, numtopsig2

 integer          :: numbd, numtp, j
 double precision :: drhok, dzk, a, aa, h00, zsl, aaa, sig, dsig, dsig0

 if (kmx == 0) return

 zws0  = zws
 ktop0 = ktop
 vol1  = 0d0

 nL    = 1
 nR    = 2

 if (Layertype == 1) then ! sigma only

    do n  = 1,ndx

       kb = kbot(n)

       if (jased>0)  zws(kb-1) = bl(n)
       h0        = s1(n) - zws(kb-1) ! bl(n)
       do k = 1, kmxn(n)
          kk       = kb + k - 1
          zws(kk)  = zws(kb-1) + h0*zslay(k,1)
          vol1(kk) = ba(n)*(zws(kk) - zws(kk-1))    ! just for now here
          vol1(n)  = vol1(n) + vol1(kk)
       enddo
       ktop(n) = kb - 1 + kmxn(n)

    enddo
    return                                ! sigma only: quick exit

 else if (Layertype == 2) then            ! z only

    ! toplayminthick = 0.5d0*( zslay(1,1) - zslay(0,1) )

    ! toplayminthick = 0d0

    numtopsig2 = numtopsig / 2

    do n  = 1,ndx

       kb  = kbot(n)

       ktx = kb + kmxn(n) - 1
       call getzlayerindices(n,nlayb,nrlay)

       do k   = kb, ktx
          kk  = k - kb + nlayb
          zkk = zslay(kk,1)
          if (zkk < s1(n) - toplayminthick .and. k < ktx ) then
              zws(k)  = zkk
          else
              zws(k)  = s1(n)
              ktop(n) = k
              if (ktx > k) then
                 zws (k+1:ktx) = zws(k)
              endif
              exit
          endif
       enddo

       if (numtopsig > 0) then
          kt1    = max(kb-1, ktx - numtopsig )
          if ( ktop(n) > kt1 + 1) then
             h0     = s1(n) - zws(kt1)
             dtopsi = 1d0/dble(ktx - kt1)
             do k   = kt1 + 1, ktx
                kk  = k - kt1
                zws(k) = zws(kt1) + h0*dble(kk)*dtopsi
             enddo

             ktop(n) = ktx

          endif
       endif

       if (keepzlayeringatbed == 2) then
           if (ktop(n) > kb) then
               zws(kb) = 0.5d0*( zws(kb+1) + zws(kb-1) )
           endif
       endif

    enddo

 else if (Layertype == 4) then            ! density controlled sigma

    dkx  = 0.5d0
    do n = 1,ndx
       drhok = 0.01d0
       kb = kbot(n) ;  kt = kb - 1 + kmxn(n) ; ktop(n) = kt
       do k = kb+1,kt
          if ( abs(rho(k) - rho(k-1)) > drhok ) then
              drhok  = abs( rho(k) - rho(k-1) )
              dkx(n) = dble(k - kb) / dble(kt - kb + 1)
              dkx(n) = min( 0.8d0, dkx(n) )
              dkx(n) = max( 0.2d0, dkx(n) )
          endif
       enddo
    enddo

    do j = 1, 10
       sdkx = 0d0
       do L = 1,Lnx
          k1 = ln(1,L) ; k2 = ln(2,L)
          sdkx(k1) = sdkx(k1) + dkx(k2)
          sdkx(k2) = sdkx(k2) + dkx(k1)
       enddo

       a = 0.25d0
       do n = 1,ndx
          dkx(n) = a*dkx(n) + (1d0-a)*sdkx(n) / dble(nd(n)%lnx)
       enddo
    enddo

    numbd = 0.5d0*kmx ; numtp = kmx - numbd ; aaa = 1.05d0  ; aa = min(1d0, exp(-dts/Tsigma) )

    dkx = 0.5d0

    do n  = 1,ndx

       call getkbotktop(n,kb,kt)

       h0 = s1(n) - zws(kb-1) ; h00 = max(epshu, zws0(kt) - zws0(kb-1) ) ; sig = 0d0
       dsig0 = 0.1d0/dble(numtp)

       do k = 1, kmxn(n)

          if (k == 1) then
             dsig = dkx(n)*(1d0-aaa) / (1d0-aaa**numbd)
             dsig = dsig*aaa**(numbd-1)
          else if ( k <= numbd ) then
             dsig = dsig / aaa
          else if (k == numbd + 1) then
             dsig = (1d0-sig)*(1d0-aaa) / (1d0-aaa**numtp)
          else
             dsig = dsig*aaa
          endif

          !if (k == 1) then
          !   dsig = dkx(n) / numbd
          !else if ( k <= numbd ) then
          !
          !else if (k == numbd + 1) then
          !   aaa  = ( (1d0-dkx(n))**(1d0/dble(numbd)) - dsig0 ) / dsig0
          !   dsig = dsig0
          !else
          !   dsig = dsig*(1d0 + a)
          !endif

          sig = sig + dsig

          kk  = kb + k - 1
          if ( k == kmxn(n) ) then
             zws(kk) = s1(n)
          else
          if (jazws0 == 1) then
             zsl   = zslay(k,1)
          else
                zsl   = (1d0-aa)*sig + aa*(zws0(kk) - zws0(kb-1) ) / h00
          endif
          zws(kk)  = zws(kb-1) + h0*zsl
          endif

          vol1(kk) = ba(n)*(zws(kk) - zws(kk-1))    ! just for now here
          vol1(n)  = vol1(n) + vol1(kk)
       enddo

    enddo
    return                                ! sigma only: quick exit

 else if (Layertype == 3) then             ! mix : first do sigma and z

    do n   = 1,ndx

       kb  = kbot(n)

       Ldn = laydefnr(n)
       if (Ldn > 0) then

          if (Laytyp(Ldn) == 1) then       ! sigma
             h0   = s1(n) - zws(kb-1)
             do k = 1, kmxn(n) - 1
                zws(kb + k - 1) = zws(kb-1) + h0*zslay(k,Ldn)
             enddo
             ktop(n) = kb + kmxn(n) - 1
             zws(ktop(n)) = s1(n)
          else if (Laytyp(Ldn) == 2) then  ! z

             ktx = kb + kmxn(n) - 1
             call getzlayerindices(n,nlayb,nrlay)
             ! toplayminthick = 0.5d0*( zslay(2,1) - zslay(1,1) )
             do k   = kb, ktx
                kk  = k - kb + nlayb
                zkk = zslay(kk,Ldn)
                if (zkk < s1(n) - toplayminthick .and. k < ktx ) then
                    zws(k)  = zkk
                else
                    zws(k)  = s1(n)
                    ktop(n) = k
                    if (ktx > k) then
                       zws (k+1:ktx) = zws(k)
                    endif
                    exit
                endif
             enddo

          endif

        endif

    enddo

 endif

 do n  = 1,ndx


    kb   = kbot(n)
    ktx  = kb - 1 + kmxn(n)

    if (laydefnr(n) == 0) then    ! overlap zone
       w1  =  wflaynod(1,n) ; w2  =  wflaynod(2,n) ; w3  =  wflaynod(3,n)
       k1  = indlaynod(1,n) ; k2  = indlaynod(2,n) ; k3  = indlaynod(3,n)
       kb1 = kbot(k1)       ; kb2 = kbot(k2)       ; kb3 = kbot(k3)
       bL1 = zws(kb1-1)     ; bL2 = zws(kb2-1)     ; bL3 = zws(kb3-1)
       h1  = s1(k1)-bL1     ; h2  = s1(k2)-bL2     ; h3  = s1(k3)-bL3     ; h0 = s1(n)-zws(kb-1)
       kt1 = ktop(k1)       ; kt2 = ktop(k2)       ; kt3 = ktop(k3)
       ht1 = zws(kt1)-zws(kt1-1)
       ht2 = zws(kt2)-zws(kt2-1)
       ht3 = zws(kt3)-zws(kt3-1)
       !Ld1 = laydefnr(k1)   ; Ld2 = laydefnr(k2)   ; Ld3 = laydefnr(k3)
       !dz1 = 0d0            ; dz2 = 0d0            ; dz3 = 0d0
       !if (laytyp(Ld1) == 2) dz1 = 0.5d0*zslay(2,Ld1) - zslay(1,Ld1)
       !if (laytyp(Ld2) == 2) dz2 = 0.5d0*zslay(2,Ld2) - zslay(1,Ld2)
       !if (laytyp(Ld3) == 2) dz3 = 0.5d0*zslay(2,Ld3) - zslay(1,Ld3)
       !toplaymint = w1*dz1 + w2*dz2 + w3*dz3

       toplaymint  = 0.1d0 ! 0.5d0*min(ht1,ht2,ht3)

       do k = 1, kmxn(n)
          kk  = kb + k - 1

          kk1 = kb1 + k - 1
          if ( kk1 > kt1 ) then
             ! zw1 =  2d0*zws(kt1) - zws(kt1-1)
             ! zw1 = zw1 + 0.5d0*(ht2 + ht3)
             zw1 = zw1 + min (zw2,zw3)
          else
             zw1 =  ( zws(kk1)-bL1 ) / h1
          endif

          kk2 = kb2 + k - 1
          if ( kk2 > kt2 ) then
             ! zw2 =  2d0*zws(kt2) - zws(kt2-1)
             ! zw2 = zw2 + 0.5d0*(ht1 + ht3)
             zw2 = zw2 + min(zw1,zw3)
          else
             zw2 =  ( zws(kk2)-bL2 ) / h2
          endif

          kk3 = kb3 + k - 1
          if ( kk3 > kt3 ) then
             ! zw3 = 2d0*zws(kt3) - zws(kt3-1)
             ! zw3 = zw3 + 0.5d0*(ht1 + ht2)
             zw3 = zw3 + min(zw1,zw2)
          else
             zw3 =  ( zws(kk3)-bL3 ) / h3
          endif

          zkk = zws(kb-1) + (w1*zw1 + w2*zw2 + w3*zw3) * h0

          !sigm = dble(k) / dble( kmxn(n) )
          !zkk  = bl(n) + h0*sigm
          if (zkk < s1(n) - toplaymint .and. k < kmxn(n) ) then
              zws(kk)  = zkk
          else
              zws(kk) = s1(n)
              ktop(n) = kk
              if (ktx > kk) then
                 zws (kk+1:ktx) = zws(kk)
              endif
              exit
          endif
       enddo
    endif

    kt  = ktop(n)
    kkk = kt - kb + 1  ! nr of layers
    if (kkk >= 2 .and. sigmagrowthfactor > 0) then ! bedlayers equal thickness
       ! zws(kb) = 0.5d0*(zws(kb+1) + zws(kb-1))
    endif
    if (kkk >= 3) then
       ! zws(kt-1) = 0.5d0*(zws(kt) + zws(kt-2))   ! toplayers equal thickness
    endif

    do kk  = kb,kt ! x
       vol1(kk) = ba(n)*(zws(kk) - zws(kk-1))    ! just for now here
       vol1(n)  = vol1(n) + vol1(kk)
    enddo

    kt0 = ktop0(n)
    if (kt0 > kt) then
        volkt   = vol0(kt)

        if (jasal > 0) savolkt = volkt*sa1(kt)
        if (jatem > 0) tevolkt = volkt*constituents(itemp, kt)

        do kkk  = kt0 , kt+1, -1                 ! old volumes above present ktop are lumped in ktop
           volkt     = volkt + vol0(kkk)
           vol0(kt)  = volkt
           if (jasal > 0) savolkt   = savolkt  + vol0(kkk)*sa1(kkk)
           if (jatem > 0) tevolkt   = tevolkt  + vol0(kkk)*constituents(itemp, kkk)
           if (ti_waq > 0) then
              do kwaq = kkk, kt + 1, -1
                 qwwaq(kwaq-1) = qwwaq(kwaq-1) - vol0(kkk)
              enddo
           endif
           vol0(kkk) = 0d0
        enddo
        if (volkt > 0) then
           if (jasal > 0) then
              sa1(kt) = savolkt/volkt
              if (ktx > kt) then
                 sa1(kt+1:ktx) = sa1(kt)
              endif
           endif
           if (jatem > 0) then
              constituents(itemp, kt) = tevolkt/volkt
              if (ktx > kt) then
                 constituents(itemp, kt+1:ktx) = constituents(itemp, kt)
              endif
           endif
        endif
    endif

 enddo

 if (jazws0 == 1) then   ! at initialise, store zws in zws0
     zws0 = zws
 endif

 if (layertype > 1) then ! ln does not change in sigma only

    do LL = 1,Lnx
       n1  = ln(1,LL) ; n2  = ln(2,LL)
       kt1 = ktop(n1) ; kt2 = ktop(n2)
       call getLbotLtop(LL,Lb,Lt)
       do L  = Lb, Lt
          ln(1,L) = min(ln0(1,L), kt1)
          ln(2,L) = min(ln0(2,L), kt2)
       enddo
    enddo

 endif


 end subroutine setkbotktop


 subroutine setveg()
 use m_flow
 use m_flowgeom
 use m_sferic
 use m_flowtimes
 implicit none

 double precision :: h1,h0, stemcos, stemsin, stemh, PL, Pv, Pm, Pmi, Bp,dp
 double precision :: rhodif, buoym, bendm, Fbe, Fbu, Ti, Tdti, phi, phit, C, Rm, ep, qsa, qds, ds2
 integer          :: kk, k, num, idum = 1, i, L, k1, k2

 if (kmx == 0 .and. growthunidicouv > 0.0) then

     !stemheight = 0.55d0
     !diaveg     = 0.05d0
     if (.not. allocated(supq) ) allocate( supq(ndx) )
     supq  = 0d0
     do L  = 1,lnxi
        k1 = ln(1,L) ; k2 = ln(2,L)
        qds = growthunidicouv*dxi(L)*wu(L)
        ds2 = rnveg(k2) - rnveg(k1)
        qsa = qds*ds2
        supq(k2) =  supq(k2) - qsa
        supq(k1) =  supq(k1) + qsa
     enddo
     do k  = 1, ndxi
        rnveg(k) = max(0d0, rnveg(k) + dts*supq(k)*bai(k))
     enddo
     return
 endif

 num = 1
 if (rhoveg > 0d0) then
    num    = 10
    rhodif = rhomean - rhoveg
 endif

 do kk = 1,ndxi

    if ( diaveg(kk) > 0d0) then

       phi     = phiv(kk)  ! 0d0                                                                ! 1/s   stemphi
       phit    = phivt(kk) ! 0d0                                                                ! 1/s2  stemomega
       Pl      = stemheight(kk)                                                                 ! m       plantlength
       Pl      = min(hs(kk), Pl)

       do i = 1, num

       stemcos = cos(phi) ; stemsin  = sin(phi)

       if (rhoveg > 0d0) then

          Pv      = Pl*diaveg(kk)*diaveg(kk)*0.25d0*pi                                          ! m3      plantvolume
          Pm      = rhoveg*Pv                                                                   ! kg      plantmass
          Pmi     = (1d0/6d0)*Pm*Pl*Pl                                                          ! kg.m2   plant inertia moment
          Tdti    = 2d0*Pmi/dts                                                                 ! kg.m2/s

          Bendm = 0d0
          do k  = kbot(kk), ktop(kk)
             Fbe   = -0.5d0*rhomean*Cdveg*diaveg(k)*(zws(k)-zws(k-1))*ucx(k)*sqrt( ucx(k)*ucx(k) + ucy(k)*ucy(k) )  ! kg.m/s2
             Bendm = Bendm + Fbe*0.5d0*(zws(k)+zws(k-1))*stemcos                                ! kg.m2/s2
          enddo

          Fbu      = ag*rhodif*diaveg(kk)*diaveg(kk)*0.25d0*pi*Pl                               ! kg.m/s2
          Buoym    = Fbu*0.5d0*Pl*stemsin                                                       ! kg.m2/s2

          Bp       = 0.5d0*rhomean*Cdveg*diaveg(kk)*( (0.5*Pl)**4 )
          Bp       = Bp*max(0.1d0, phivt(kk))                                                   ! kg.m2/s

          phit     = ( phit*Tdti + (Bendm - Buoym) ) / ( Tdti + Bp )
          ep       = 0.1
          if (phit >  ep) then
             phit  =  ep
          else if (phit < -ep) then
             phit  = -ep
          endif
          phivt(kk) = phit
          phi       = (phi/dts + phit) / (1d0/dts + cbveg/Tdti)
          phi       = max(-1.5d0, min(phi, 1.5d0) )
          phiv(kk)  = phi

          stemcos   = cos(phi)

       endif
       stemh = Pl*stemcos

       if (kmx > 0) then
          do k  = kbot(kk), ktop(kk)
             h1 = zws(k)   - zws(kbot(kk) -1)
             h0 = zws(k-1) - zws(kbot(kk) -1)
             if ( h1 < stemh ) then
                 diaveg(k) = diaveg(kk)
                 rnveg (k) = rnveg (kk)
             else if (h0 < stemh .and. h1 > stemh ) then
                 diaveg(k) = diaveg(kk)
                 rnveg (k) = rnveg (kk)*( stemh - h0 ) / ( h1 - h0 )
             else
                 diaveg(k) = 0d0
                 rnveg (k) = 0d0
             endif
          enddo
       endif

       enddo

    endif

 enddo

 end subroutine setveg

 double precision FUNCTION ran0(idum)
 INTEGER idum,IA,IM,IQ,IR,MASK
 double precision :: AM
 PARAMETER (IA=16807,IM=2147483647,AM=1./IM,IQ=127773,IR=2836,MASK=123459876)
 INTEGER k
 idum=ieor(idum,MASK)
 k=idum/IQ
 idum=IA*(idum-k*IQ)-IR*k
 if (idum.lt.0) idum=idum+IM
 ran0=AM*idum
 idum=ieor(idum,MASK)
 return
 END

 subroutine setzminmax()
    use m_netw
    use m_flowgeom
    use m_flow
    use m_flowparameters
    use m_sediment, only: stm_included 
    implicit none

    integer          :: i, k, ki, kb, kt, itrac, isf

    if ( kmx>0 ) then   ! 2D, set dummy values
       do i  = 1, nbnds
          ki = kbnds(2,i)
          call getkbotktop(ki,kb,kt)
             zminmaxs(i) = zws(kb-1)
             zminmaxs(i+nbnds) = zws(kt)
       end do
       do i  = 1, nbndTM
          ki = kbndTM(2,i)
          call getkbotktop(ki,kb,kt)
             zminmaxTM(i) = zws(kb-1)
             zminmaxTM(i+nbndTM) = zws(kt)
       end do
       do i  = 1, nbnduxy
          ki = kbnduxy(2,i)
          call getkbotktop(ki,kb,kt)
             zminmaxuxy(i) = zws(kb-1)
             zminmaxuxy(i+nbnduxy) = zws(kt)
       end do
       do i  = 1, nbndu
          ki = kbndu(2,i)
          call getkbotktop(ki,kb,kt)
             zminmaxu(i) = zws(kb-1)
             zminmaxu(i+nbndu) = zws(kt)
       end do
       do itrac=1,numtracers
          do i=1,nbndtr(itrac)
             ki = bndtr(itrac)%k(2,i)
             call getkbotktop(ki,kb,kt)
                bndtr(itrac)%zminmax(i) = zws(kb-1)
                bndtr(itrac)%zminmax(i+nbndtr(itrac)) = zws(kt)
          end do
       end do
       do i  = 1, nbndsd
          ki = kbndsd(2,i)
          call getkbotktop(ki,kb,kt)
             zminmaxsd(i) = zws(kb-1)
             zminmaxsd(i+nbndsd) = zws(kt)
       end do
       
       if (jased==4 .and. stm_included) then
          do isf=1,numfracs
             do i=1,nbndsf(isf)
                ki = bndsf(isf)%k(2,i)
                call getkbotktop(ki,kb,kt)
                bndsf(isf)%zminmax(i) = zws(kb-1)
                bndsf(isf)%zminmax(i+nbndsf(isf)) = zws(kt)
             end do
          end do
       end if
    endif
 end subroutine setzminmax

 subroutine setsigmabnds()
    use m_netw
    use m_flowgeom
    use m_flow
    use m_sediment, only: stm_included
    implicit none

    integer          :: i, k, ki, kb, kt, itrac, isf


 !   if (layertype == 2) return

    if ( kmx.eq.0 ) then   ! 2D, set dummy values
       if ( allocated(sigmabnds)  ) sigmabnds  = 0d0
       if ( allocated(sigmabndTM) ) sigmabndTM = 0d0
!       if ( allocated(sigmabndtr) ) sigmabndtr = 0d0
       if ( allocated(sigmabndu) ) sigmabndu = 0d0
    else                   ! 3D
       do i  = 1, nbnds
          ki = kbnds(2,i)
          call getkbotktop(ki,kb,kt)
             do k = kb, kt
             sigmabnds(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / max(epshs, (zws(kt)-zws(kb-1)) )
             end do
!            SPvdP: fill remainder
             do k=kt+1,kb+kmx-1
                sigmabnds(kmx*(i-1)+k-kb+1) = 1d0
             end do

          ! if ( zws(kt)-zws(kb-1) .gt. epshs ) then
          !   do k = kb, kt
          !      sigmabnds(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / (zws(kt)-zws(kb-1))
          !   end do
          !else  ! fix for dry points
          !   do k = kb, kt
          !     sigmabnds(kmx*(i-1)+k-kb+1) = dble(k-kb)/dble(kt-kb)  ! hk: this goes wrong if kt==kb
          !   end do
          !end if

       end do

       do i  = 1, nbndTM
          ki = kbndTM(2,i)
          call getkbotktop(ki,kb,kt)
             do k = kb, kt
             sigmabndTM(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / max(epshs, (zws(kt)-zws(kb-1)) )
             end do
!            SPvdP: fill remainder
             do k=kt+1,kb+kmx-1
                sigmabndTM(kmx*(i-1)+k-kb+1) = 1d0
             end do

          ! if ( zws(kt)-zws(kb-1) .gt. epshs ) then
          !   do k = kb, kt
          !      sigmabndTM(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / (zws(kt)-zws(kb-1))
          !   end do
          ! else  ! fix for dry points
          !   do k = kb, kt
          !     sigmabndTM(kmx*(i-1)+k-kb+1) = dble(k-kb)/dble(kt-kb)
          !   end do
          ! end if
       end do

       do i  = 1, nbndu
          ki = kbndu(2,i)
          call getkbotktop(ki,kb,kt)
          do k = kb, kt
          sigmabndu(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / max(epshs, (zws(kt)-zws(kb-1)) )
          end do
          do k=kt+1,kb+kmx-1
             sigmabndu(kmx*(i-1)+k-kb+1) = 1d0
          end do
       end do

       do i  = 1, nbnduxy
          ki = kbnduxy(2,i)
          call getkbotktop(ki,kb,kt)
             do k = kb, kt
             sigmabnduxy(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / max(epshs, (zws(kt)-zws(kb-1)) )
             end do
!            SPvdP: fill remainder
             do k=kt+1,kb+kmx-1
                sigmabnduxy(kmx*(i-1)+k-kb+1) = 1d0
             end do

          ! if ( zws(kt)-zws(kb-1) .gt. epshs ) then
          !   do k = kb, kt
          !      sigmabnduxy(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / (zws(kt)-zws(kb-1))
          !   end do
          ! else  ! fix for dry points
          !   do k = kb, kt
          !     sigmabnduxy(kmx*(i-1)+k-kb+1) = dble(k-kb)/dble(kt-kb)
          !   end do
          ! end if
       end do

       do itrac=1,numtracers
          do i=1,nbndtr(itrac)
             ki = bndtr(itrac)%k(2,i)
             call getkbotktop(ki,kb,kt)
             do k=kb,kt
                bndtr(itrac)%sigma(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / max(epshs, (zws(kt)-zws(kb-1)) )
             end do
!            SPvdP: fill remainder
             do k=kt+1,kb+kmx-1
                bndtr(itrac)%sigma(kmx*(i-1)+k-kb+1) = 1d0
             end do
          end do
       end do 

       do i  = 1, nbndsd
          ki = kbndsd(2,i)
          call getkbotktop(ki,kb,kt)
             do k = kb, kt
                sigmabndsd(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / max(epshs, (zws(kt)-zws(kb-1)) )
             end do
             do k=kt+1,kb+kmx-1
                sigmabndsd(kmx*(i-1)+k-kb+1) = 1d0
             end do
       end do

       if ( stm_included ) then
          ! sediment boundaries
          do isf=1,numfracs
             do i=1,nbndsf(isf)
                ki = bndsf(isf)%k(2,i)
                call getkbotktop(ki,kb,kt)
                do k=kb,kt
                   bndsf(isf)%sigma(kmx*(i-1)+k-kb+1) = (0.5d0*(zws(k-1)+zws(k))-zws(kb-1)) / max(epshs, (zws(kt)-zws(kb-1)) )
                end do
                !            SPvdP: fill remainder
                do k=kt+1,kb+kmx-1
                   bndsf(isf)%sigma(kmx*(i-1)+k-kb+1) = 1d0
                end do
             end do
          end do
       end if
    end if

 end subroutine setsigmabnds


 subroutine setzcs()
    use m_flow
    use m_flowgeom
    implicit none

    integer :: kk, k, kb, kt

    do kk=1,Ndx
       call getkbotktop(kk,kb,kt)
       do k=kb,kt
          zcs(k) = 0.5d0*(zws(k)+zws(k-1))
       end do
    end do

    return
 end subroutine setzcs


 subroutine polygonlayering(mpol)
 use m_flow
 use m_flowgeom
 use m_polygon
 use m_samples
 use m_missing
 use m_ec_triangle
 use m_sferic, only: jsferic, jasfer3D
 use m_ec_basic_interpolation, only: TRIINTfast
 use geometry_module

 implicit none
 integer                       :: mpol
 integer                       :: k, j, jstart, jend, ierr, jdla, ipoint , jakdtree, ndim , n, in, nspl, n1
 integer,          allocatable :: indxn (:,:) , nds(:), inp(:), ndn(:)
 double precision, allocatable :: wfn (:,:), zz(:)

 call reapol(mpol,0)

 call increasesam(npl+ndx)

 if ( allocated (indlaynod) ) deallocate (indlaynod, wflaynod)
 allocate ( indlaynod(3,ndxi)     , stat= ierr   ) ; indlaynod = 0
 call aerr('indlaynod(3,ndxi)'    , ierr,  ndxi  )
 allocate (  wflaynod(3,ndxi)     , stat= ierr   ) ; wflaynod  = 0d0
 call aerr(' wflaynod(3,ndxi)'    , ierr,  ndxi  )

 allocate ( ndn(ndxi+npl)         , stat= ierr       )
 call aerr('ndn(ndxi+npl)'        , ierr,  ndxi+npl  ) ; ndn       = 0

 allocate ( zz(ndxi)              , stat= ierr   )
 call aerr('zz(ndxi)'             , ierr,  ndxi  ) ; zz        = dmiss

 mxlaydefs = 0  ; ipoint = 1 ! first count and allocate
 jstart = 0 ; jend = 0 ; k = 0
 do while (ipoint <= npl)    ! nr of layers in first polygonpoint, layertype in second point
    call get_startend(npl-ipoint+1, xpl(ipoint:npl), ypl(ipoint:npl), jstart, jend, dmiss)
    jstart = ipoint+jstart-1
    jend   = ipoint+jend-1
    ipoint = jend + 1
    mxlaydefs = mxlaydefs + 1
 enddo
 deallocate (laymx, laytyp)
 allocate  ( laymx(mxlaydefs), laytyp(mxlaydefs) , stat = ierr )
 call aerr ('laymx(mxlaydefs), laytyp(mxlaydefs)', ierr, mxlaydefs )

 mxlaydefs = 0  ; ipoint = 1 ! then fill
 jstart = 0 ; jend = 0 ; k = 0

 do while (ipoint <= npl)    ! nr of layers in first polygonpoint, layertype in second point

    call get_startend(npl-ipoint+1, xpl(ipoint:npl), ypl(ipoint:npl), jstart, jend, dmiss)
    jstart = ipoint+jstart-1
    jend   = ipoint+jend-1
    ipoint = jend + 1

    mxlaydefs = mxlaydefs + 1

    if (zpl(jstart) > kmx) then
        call error('increase kmx to allow for nr of layers specified in vertical_layering.pliz', ' ', ' ')
    endif

    laymx (mxlaydefs) = zpl(jstart)       ! first point  = nr of layers
    laytyp(mxlaydefs) = zpl(jstart + 1)   ! second point = type
    zpl(jstart:jend)  = mxlaydefs         ! now only point to laydef nr

    do j = jstart, jend                   ! add to sample set
       k = k + 1
       xs(k) = xpl(j)
       ys(k) = ypl(j)
       zs(k) = mxlaydefs
    enddo

 enddo
 nspl = k

 laydefnr =  0
 in       = -1
 do n = 1,ndx                            ! add flownodes in polygon/laydef nr in to samples
    call inwhichpolygon( xz(n), yz(n), in)
    if (in > 0) then
       k = k + 1
       xs(k) = xz(n) ; ys(k) = yz(n) ; zs(k) = in; laydefnr(n) = in; ndn(k) = n
    endif
 enddo
 ns = k

 jdla = 1; jakdtree = 1; ndim = 1

 jagetwf = 1
 allocate ( indxx(3,ndxi), wfxx(3,ndxi) ) ! if module variable jagetw == 1, make weightfactor_index arrays

 call TRIINTfast(XS,YS,ZS,NS,NDIM,Xz,Yz,Zz,ndxi,JDLA,jakdtree, jsferic, 0, jins, dmiss, jasfer3D, &
                 Xpl,Ypl,ZPL,transformcoef)   !

 allocate (nds(nspl))
 do j = 1, nspl
    call CLOSEdefinedflownode(Xs(j),Ys(j),N1)
    if (n1 == 0) then
       nds(j) = 0
    else
       nds(j) = n1
    endif
 enddo

 do n = 1,ndx                            ! refer back to flownode instead of polygonpoint
    if (laydefnr(n) == 0) then
       do k = 1,3
          if (indxx(k,n) <= nspl) then
             indlaynod(k,n) = nds( indxx(k,n) )
             wflaynod (k,n) = wfxx(k,n)
          else
             indlaynod(k,n) = ndn( indxx(k,n) )
             wflaynod (k,n) = wfxx(k,n)
          endif
       enddo
    endif
 enddo

 ns = 0; npl = 0
 deallocate (indxx, wfxx, zz, nds, ndn, iistart, iiend )

 end subroutine polygonlayering

 subroutine getkbotktop(n,kb,kt)
 use m_flow
 use m_flowgeom
 implicit none
 integer :: n,kb,kt
 if (kmx == 0) then
    kb = n       ; kt = n
 else
    kb = kbot(n) ; kt = ktop(n)
 endif
 end subroutine getkbotktop

 subroutine getkbotktopmax(n,kb,kt,ktx)
! Variation on getkbotktop. Always returns the maximum possible layer range instead of the actual range.
 use m_flow
 use m_flowgeom
 implicit none
 integer :: n,kb,kt,ktx
 if (kmx == 0) then
    kb = n       ; kt = n       ; ktx = n
 else
    kb = kbot(n) ; kt = ktop(n) ; ktx = kb +  kmxn(n) - 1
 endif
 end subroutine getkbotktopmax


 subroutine getLbotLtop(LL,Lb,Lt)
 use m_flow
 use m_flowgeom
 implicit none
 integer :: LL,Lb,Lt
 if (kmx == 0) then
    Lb = LL
    if (hu(LL) > 0) then
        Lt = LL
    else
        Lt = 0
    endif
 else
    Lb = Lbot(LL) ; Lt = Ltop(LL)
 endif
 end subroutine getLbotLtop

 subroutine getLbotLtopmax(LL,Lb,Ltx)
! Variation on getLbotLtop. Always returns the maximum possible layer range in stead of the actual range.
 use m_flow
 use m_flowgeom
 implicit none
 integer :: LL,Lb,Ltx
 if (kmx == 0) then
    Lb = LL
    if (hu(LL) > 0) then
        Ltx = LL
    else
        Ltx = 0
    endif
 else
    Lb = Lbot(LL) ; Ltx = Lbot(LL) + kmxL(LL) - 1
 endif
 end subroutine getLbotLtopmax


 !> Gets the local layer numbers for a given grid cell.
 subroutine getzlayerindices(n,nlayb,nrlay)
 use m_flowgeom
 use m_flow
 use m_missing
 implicit none

 integer, intent(in   ) :: n     !< Flow node/grid cell number
 integer, intent(  out) :: nlayb !< Layer number for the bottom layer (in 1:kmx)
 integer, intent(  out) :: nrlay !< Nr. of active layers for this flow node.

 integer          :: j,j1,j3,k, Ltn, mx ! layerdistribution indexes


 Ltn = laydefnr(n)
 mx  = laymx(Ltn)
 nlayb = mx ; nrlay = 1 ! default
! if (nlaybn(n) == 0) then
    do k = 1,mx
       if ( zslay(k,Ltn) > bl(n) ) then
           nlayb = k
           nrlay = mx - k + 1
           exit
       endif
    enddo
!    nlayb = nlaybn(n)
!    nrlay = nrlayn(n)

! else
!    nlayb = nlaybn(n)
!    nrlay = nrlayn(n)
! endif

 end subroutine getzlayerindices

 !> Gets the local layer numbers for a given grid cell.
 !! Note: works both for sigma and z, but for sigma, the return values are trivial: nlayb==1, nrlay==kmx.
 subroutine getlayerindices(n,nlayb,nrlay)
 use m_flowgeom
 use m_flow
 use m_missing
 implicit none

 integer, intent(in   ) :: n     !< Flow node/grid cell number
 integer, intent(  out) :: nlayb !< Layer number for the bottom layer (in 1:kmx)
 integer, intent(  out) :: nrlay !< Nr. of active layers for this flow node.

 integer          :: Ltn


 Ltn = laydefnr(n)
 if (laytyp(Ltn) == 1) then ! sigma
    nlayb = 1          ! Bottom layers always the first
    nrlay = laymx(Ltn) ! Sigma: always all layers
 else                       ! z-layers
    call getzlayerindices(n, nlayb, nrlay)
 end if

 end subroutine getlayerindices

 !> Gets the local layer numbers for a given flow link.
 !! Always uses the maximum possible layer range instead of the actual range.
 !! Note: works both for sigma and z, but for sigma, the return values are trivial: nlaybL==1, nrlayLx==kmx.
 subroutine getlayerindicesLmax(L, nlaybL, nrlayLx)
 use m_flow
 implicit none

 integer, intent(in)  :: L       !< Flow link (L \in [1,lnx] )
 integer, intent(out) :: nlaybL  !< Layer number for the bottom layer (in 1:kmxL(L))
 integer, intent(out) :: nrlayLx !< Max nr. of active layers for this flow link.

 nrlayLx = kmxL(L)
 nlaybL = kmx - nrlayLx + 1

 end subroutine getlayerindicesLmax

 subroutine getzlayerindicesbobL(n,nlayb,nrlay,bobL)
 use m_flowgeom
 use m_flow
 use m_missing
 implicit none

 integer          :: n,nlayb, nrlay
 integer          :: j,j1,j3,k, Ltn, mx ! layerdistribution indexes
 double precision :: bobL

 Ltn = laydefnr(n)
 mx  = laymx(Ltn)
 nlayb = mx ; nrlay = 1 ! default
 do k = 1,mx
    if ( zslay(k,Ltn) > bobL ) then
        nlayb = k
        nrlay = mx - k + 1
        exit
    endif
 enddo

 end subroutine getzlayerindicesbobL


 subroutine reabar2pli(mthd, mout)   ! convert barrier v file to model independent, barv content =  m,n,sill depth
 use m_grid
 implicit none
 integer :: mthd, mout
 double precision      :: xce, yce,dep
 character (len = 132) :: rec
 character (len = 1 )  :: uv
 integer               :: m,n,m2,n2, mn, mx, nn, nx, i

 10 read(mthd,'(a)', end = 999) rec

 read(rec,*) m,n,dep

 write(mout,'(a)') 'Line'
 write(mout,'(a)') ' 2 2'

 if ( index(rec,'u') > 0 .or. index(rec,'U') > 0 ) then

     write(mout,*) xc(m,n-1), yc(m,n-1) ,-dep
     write(mout,*) xc(m,n)  , yc(m,n)   ,-dep

 else

     write(mout,*) xc(m-1,n), yc(m-1,n) ,-dep
     write(mout,*) xc(m,n)  , yc(m,n)   ,-dep

 endif

 goto 10

 999 call doclose (mthd)
     call doclose (mout)

 end subroutine reabar2pli

 subroutine readry2pli(mthd, mout)   ! convert barrier v file to model independent, barv content =  m,n,sill depth
 use m_grid
 implicit none
 integer :: mthd, mout
 double precision      :: xce, yce, z=9999d0
 character (len = 132) :: rec
 character (len = 1 )  :: uv
 integer               :: m,n,m2,n2, mn, mx, nn, nx, i

 10 read(mthd,'(a)', end = 999) rec

 read(rec,*) m,n

 write(mout,'(a)') 'Line'
 write(mout,'(a)') ' 5 3'

 write(mout,*) xc(m  ,n-1), yc(m  ,n-1), z
 write(mout,*) xc(m  ,n  ), yc(m  ,n  ), z
 write(mout,*) xc(m-1,n  ), yc(m-1,n  ), z
 write(mout,*) xc(m-1,n-1), yc(m-1,n-1), z
 write(mout,*) xc(m  ,n-1), yc(m  ,n-1), z


 goto 10

 999 call doclose (mthd)
     call doclose (mout)

 end subroutine readry2pli


 subroutine reathd2pli(mthd, mout)   ! convert d3d obs file to model independent
 use m_grid
 implicit none
 integer :: mthd, mout
 double precision      :: xce, yce
 character (len = 132) :: rec
 character (len = 1 )  :: uv
 integer               :: m,n,m2,n2, mn, mx, nn, nx, i

 10 read(mthd,'(a)', end = 999) rec

 read(rec,*) m,n,m2,n2,uv

 write(mout,'(a)') 'Line'
 write(mout,'(a)') ' 2 2'

 if ( index(rec,'u') > 0 .or. index(rec,'U') > 0 ) then

     nn = min(n,n2) ; nx = max(n,n2)
     write(mout,*) xc(m,nn-1)  , yc(m,nn-1)
     do i = nn, nx
        write(mout,*) xc(m,i), yc(m,i)
     enddo

 else

     mn = min(m,m2) ; mx = max(m,m2)
     write(mout,*) xc(mn-1,n)  , yc(mn-1,n)
     do i = mn, mx
        write(mout,*) xc(i,n), yc(i,n)
     enddo

 endif

 goto 10

 999 call doclose (mthd)
     call doclose (mout)

 end subroutine reathd2pli



 subroutine reaobs2stat(mobs, mout)   ! convert d3d obs file to model independent
 use m_grid
 implicit none
 integer :: mobs, mout
 double precision      :: xce, yce
 character (len = 132) :: rec
 character (len = 20 ) :: name
 integer               :: m,n

 10 read(mobs,'(a)', end = 999) rec

 read(rec( 1:),'(a)') name
 read(rec(21:),*    ) m,n

 xce      = 0.25d0*( xc(m-1,n) + xc(m-1,n-1) + xc(m,n) + xc(m,n-1) )
 yce      = 0.25d0*( yc(m-1,n) + yc(m-1,n-1) + yc(m,n) + yc(m,n-1) )

 write(mout,*) xce, yce, name

 goto 10

 999 call doclose (mobs)
     call doclose (mout)

 end subroutine reaobs2stat

 subroutine reabnd2pol(mbnd,mbca)     ! convert d3d boundaryes stuf to model independent
 use m_grid
 use m_polygon
 USE M_MISSING
 implicit none

 character            :: rec*132 , fnam*20
 integer, allocatable :: ma(:), na(:), mb(:), nb(:)
 integer              :: mmx=1000, k=0, mbnd, mbca
 character (len = 132):: a(100), b(100)
 integer :: i, j
 integer :: kx, nra, kd, ku, kk, nr
 double precision :: x1, x2, x3, x4


 allocate ( ma(mmx), na(mmx), mb(mmx), nb(mmx) )

 if ( allocated(ijyes) ) deallocate (ijyes)
 allocate ( ijyes(mc+1, nc+1) ) ; ijyes = 0

 DO I = 2,MC  ! set up flow oriented ijyes array, sorry for the inconvenience
    DO J = 2,NC
       X1 = Xc(I-1,J-1)
       X2 = Xc(I  ,J-1)
       X3 = Xc(I  ,J  )
       X4 = Xc(I-1,J  )
       IF (X1 .NE. XYMIS .AND. X2 .NE. XYMIS .AND.   &
           X3 .NE. XYMIS .AND. X4 .NE. XYMIS ) IJYES(I,J) = 1
    enddo
 enddo


 10  read(mbnd, '(a)', end = 666) rec
 k = k + 1
 read(rec(25:) ,* ) ma(k), na(k), mb(k), nb(k)
 goto 10

 666 continue

 kx = k; nra = 0
 do k = 1,kx
    kd = max(1,k-1) ; ku = min(kx, k+1)

    if (mbca > 0) then
       kk = 9
       call readset(kk+1,mbca, a) ! ; call readset(kk,mbca, b)
    endif

    fnam = 'kham_0001.cmp'

    ! if (k==1 .or. ma(k).ne.mb(kd) .and. na(k).ne.nb(kd) ) then
       call bndpoint2pol( ma(k), na(k) )
       if (mbca > 0) then
          nr = nr + 1 ; call writeset(kk,fnam,nr,a)
       endif
    ! endif

    ! call bndpoint2pol( mb(k), nb(k) )
    ! if (mbca > 0) then
    !    nr = nr + 1 ; call writeset(kk,fnam,nr,b)
    ! endif

    ! if ( k.ne.kx .and. mb(k).ne.ma(ku) .and. nb(k).ne.na(ku) ) then
    !    npl = npl + 1 ; xpl(npl) = dmiss; ypl(npl) = dmiss ; nr = 0
    ! endif

 enddo

 deallocate (ma, na, mb, nb, ijyes)

 if (mbnd .ne. 0) call doclose(mbnd)
 if (mbca .ne. 0) call doclose(mbca)

 return
 end subroutine reabnd2pol

 !> Writes a set of template component files (_xxxx.cmp) associated with the current polyline.
 !! Should only be called directly after savepol has been called.
 !! If the current polyline was then saved to polname.pli, then
 !! polname_0001.cmp up to polname_xxxn.cmp will be saved (with n the nr 'npl' of polyline points).
 subroutine wricmps(fnam)
 use m_polygon
 use m_missing
 implicit none

 character (len=*), intent(in) :: fnam !< Filename from .pli file (should have been saved just before)
 integer           :: mou2, L, n, jacmps = 0
 logical           :: jawel
 character (len=len(fnam)) :: fnamc
 character(len=256) :: qid
 L = index( fnam, '.pli' )
 fnamc = fnam

 if (L > 0) then

    L = L-1
    if (jacmps == 1) then

       write(fnamc(l+1:l+1) , '(a)'   )  '_'
       write(fnamc(l+2:l+5) , '(i4.4)') n
       inquire (file = fnamc(1:L+5)//'.cmp', exist = jawel)
       if (.not. jawel) then
          call newfil (mou2, fnamc(1:L+5)//'.cmp')
          write(mou2,'(a)') '* COLUMNN=3'
          write(mou2,'(a)') '* COLUMN1=Period (min) or Astronomical Componentname'
          write(mou2,'(a)') '* COLUMN2=Amplitude (ISO)'
          write(mou2,'(a)') '* COLUMN3=Phase (deg)'
          write(mou2,'(a)') '0.0  1.0  0.0 '
          call doclose(mou2)
       endif

    else if (index(fnam,'crit') == 0) then

       do n = 1, 1 ! min(2,npl)
          write(fnamc(l+1:l+1) , '(a)'   )  '_'
          write(fnamc(l+2:l+5) , '(i4.4)') n
          inquire (file = fnamc(1:L+5)//'.tim', exist = jawel)
          if (.not. jawel) then
             call newfil (mou2, fnamc(1:L+5)//'.tim')
             write(mou2,'(a)') '0.0         0.0 '
             write(mou2,'(a)') '60.0        1.0 '
             write(mou2,'(a)') '65.0        0.0 '
             write(mou2,'(a)') '99999999.0  0.0 '
             call doclose(mou2)
          endif
          if (xpl(n) == dmiss) exit ! only for 1st polygon
       enddo

    endif

    inquire (file = fnamc(1:L)//'.ext', exist = jawel)
    if (.not. jawel) then
       if (index(fnam,'lev') > 0) then
          qid = 'QUANTITY=waterlevelbnd'
       else if (index(fnam,'dis') > 0) then
          qid = 'QUANTITY=dischargebnd'
       else if (index(fnam,'crit') > 0) then
          qid = 'QUANTITY=criticaloutflowbnd'
       else if (index(fnam,'out') > 0) then
          qid = 'QUANTITY=outflowbnd'
       else
          qid = ' '
       endif
       if (qid(1:1) .ne. ' ') then
          call newfil (mou2, fnamc(1:L)//'.ext')
          write(mou2,'(a)')  qid
          write(mou2,'(a)') 'FILENAME='//trim(fnam)
          write(mou2,'(a)') 'FILETYPE=9'
          write(mou2,'(a)') 'METHOD=3'
          write(mou2,'(a)') 'OPERAND=O'
          write(mou2,'(a)') ' '
       endif
    endif

 endif

 if ( index( fnam, '.pol') > 0 ) then

    L = index( fnam, '.pol' )
    L = L-1
    inquire (file = fnamc(1:L)//'.ext', exist = jawel)
    if (.not. jawel) then
       if (index(fnam,'fric') > 0) then
          qid = 'QUANTITY=frictioncoefficient'
       else if (index(fnam,'visc') > 0) then
          qid = 'QUANTITY=horizontaleddyviscositycoefficient'
       else if (index(fnam,'inilev') > 0) then
          qid = 'QUANTITY=initialwaterlevel'
       else
          qid = ' '
       endif
       if (qid(1:1) .ne. ' ') then
          call newfil (mou2, fnamc(1:L)//'.ext')
          write(mou2,'(a)') trim(qid)
          write(mou2,'(a)') 'FILENAME='//trim(fnam)
          write(mou2,'(a)') 'FILETYPE=10'
          write(mou2,'(a)') 'METHOD=4'
          write(mou2,'(a)') 'OPERAND=O'
          write(mou2,'(a)') 'VALUE=specify here'
          write(mou2,'(a)') ' '
       endif
    endif

 endif

 end subroutine wricmps


 subroutine csmfinebnds2unstruc()
 implicit none
 double precision x,y,amp,phas, x0, y0, d
 character fnam*132, cmp*8, rec*132
 integer :: mou2, k, kkk, L, minp, mout

 mou2 = 0

 do k = 1,3
    kkk = 0
    if (k == 1) fnam = 'zuid'
    if (k == 2) fnam = 'west'
    if (k == 3) fnam = 'noord'

    L  = len_trim(fnam)

    call oldfil (minp, fnam(1:L)//'rand_new10')
    call newfil (mout, fnam(1:L)//'.pli')
    write(mout,'(a)') 'bl01'
    if (k == 1) write(mout,'(a)') ' 23  2 '
    if (k == 2) write(mout,'(a)') ' 85  2 '
    if (k == 3) write(mout,'(a)') ' 99  2 '


8      continue
       read(minp,'(a)',end = 999) rec
       read (rec,*) cmp,y,x,d,d,amp,phas
       if (cmp == 'Q1') then
          if (mou2>0) call doclose(mou2)
          write(mout, *) x, y
          kkk = kkk + 1
          write(fnam(l+1:l+1) , '(a)'   )  '_'
          write(fnam(l+2:l+5) , '(i4.4)') kkk
          call newfil (mou2, fnam(1:L+5)//'.cmp')
          write(mou2,'(a)') '* COLUMNN=3'
          write(mou2,'(a)') '* COLUMN1=Period (min) or Astronomical Componentname'
          write(mou2,'(a)') '* COLUMN2=Amplitude (m)'
          write(mou2,'(a)') '* COLUMN3=Phase (deg)'
        endif

       if (cmp == 'PHI1')    cmp = 'FI1'
       if (cmp == 'LAMBDA2') cmp = 'LABDA2'
       if (cmp == 'RHO1')    cmp = 'RO1'

       write(mou2,'(a,2f14.6)') cmp, 0.01d0*amp, phas
       goto 8



999 call doclose(minp)
    call doclose(mout)
    call doclose(mou2); mou2 = 0
 enddo
 end subroutine csmfinebnds2unstruc

 subroutine readset(kk,mbca, a)
 implicit none
 integer :: kk
 character (len = 132) :: a(100)
 character (len = 132) :: rec
 integer :: k, mbca

 do k = 1,kk
    read(mbca,'(a)') a(k)
 enddo
 end subroutine readset

 subroutine writeset(kk,fnam,nr,a)
 implicit none
 integer :: kk, nr
 character (len = 132) :: a(100)
 character (len = 132) :: rec
 character*(*) fnam
 integer :: l, mout, k

 L = index(fnam,'_')
 write(fnam(L+1:L+4), '(i4.4)' ) nr

 call newfil(mout, fnam)
 write(mout,'(a)') '*'//a(1)
 do k = 2,kk
    ! call correctiefile(a(k))
    write(mout,'(a)') a(k)
 enddo
 call doclose(mout)
 end subroutine writeset

 subroutine correctiefile(a)
 implicit none
 character*(*) a
 double precision :: am, ph
 character*8   cmp

 read (a,'(a)') cmp
 read (a(8:),*) am, ph

 if ( index(cmp,'O1')        .ne. 0 ) then
     am = am*1.100d0  ; ph = ph -  10d0
 else if ( index(cmp,'K1')   .ne. 0 ) then
     am = am*1.050d0  ; ph = ph -   5d0
 else if ( index(cmp,'P1')   .ne. 0 ) then
     am = am*1.050d0  ; ph = ph -   0d0
 else if ( index(cmp,'N2')   .ne. 0 ) then
     am = am*1.000d0  ; ph = ph -   5d0
 else if ( index(cmp,'M2')   .ne. 0 ) then
     am = am*1.150d0  ; ph = ph -   5d0
 else if ( index(cmp,'S2')   .ne. 0 ) then
     am = am*1.100d0  ; ph = ph -   0d0
 else if ( index(cmp,'L2')   .ne. 0 ) then
     am = am*1.000d0  ; ph = ph -  20d0
 else if ( index(cmp,'K2')   .ne. 0 ) then
     am = am*1.100d0  ; ph = ph - 0d0
 endif

 a =  ' '
 write(a,*) cmp, am, ph

 end subroutine correctiefile


 subroutine bndpoint2pol(m,n)
 use m_polygon
 use m_grid
 implicit none
 integer :: m, n
 double precision :: xce, yce, xbb, ybb
 integer :: mu,nu,md,nd

 if (ijyes(m,n) == 0) then

    mu = m + 1 ; nu = n + 1 ; md = m - 1 ; nd = n - 1

    if (m <= mc .and. n > 1 .and. n < nc+1) then
       if (ijyes(mu,n)==1) then     ! linkerrand
          npl      = npl + 1
          xce      = 0.25d0*( xc(mu,n) + xc(mu,nd) + xc(m,n) + xc(m,nd) )
          xbb      = 0.50d0*( xc(m,n)  + xc(m,nd ) )
          xpl(npl) = 1.1d0*xbb - 0.1d0*xce
          yce      = 0.25d0*( yc(mu,n) + yc(mu,nd) + yc(m,n) + yc(m,nd) )
          ybb      = 0.50d0*( yc(m,n)  + yc(m,nd ) )
          ypl(npl) = 1.1d0*ybb - 0.1d0*yce
       endif
    endif

    if (n <= nc .and. m > 1 .and. m < mc+1) then
       if (ijyes(m,nu)==1) then     ! onderrand
          npl      = npl + 1
          xce      = 0.25d0*( xc(m,nu) + xc(md,nu ) + xc(m,n) + xc(md,n) )
          xbb      = 0.50d0*( xc(m,n)  + xc(md,n) )
          xpl(npl) = 1.1d0*xbb - 0.1d0*xce
          yce      = 0.25d0*( yc(m,nu) + yc(md,nu ) + yc(m,n) + yc(md,n) )
          ybb      = 0.50d0*( yc(m,n)  + yc(md,n) )
          ypl(npl) = 1.1d0*ybb - 0.1d0*yce
       endif
    endif

    if (m >= 2 .and. n > 1 .and. n < nc+1  ) then
       if (ijyes(md,n)==1) then    ! rechterrand
          npl      = npl + 1
          xce      = 0.25d0*( xc(md-1,nd) + xc(md-1,n) + xc(m-1,nd) + xc(m-1,n) )
          xbb      = 0.50d0*( xc(m-1,n)   + xc(m-1,nd) )
          xpl(npl) = 1.1d0*xbb - 0.1d0*xce
          yce      = 0.25d0*( yc(md-1,nd) + yc(md-1,n) + yc(m-1,nd) + yc(m-1,n) )
          ybb      = 0.50d0*( yc(m-1,n)   + yc(m-1,nd) )
          ypl(npl) = 1.1d0*ybb - 0.1d0*yce
       endif
    endif

    if (n >= 2 .and. m > 1 .and. m < mc+1  ) then
       if (ijyes(m,nd)==1) then    ! bovenrand
          npl      = npl + 1
          xce      = 0.25d0*( xc(md,nd-1) + xc(md,n-1) + xc(m,nd-1) + xc(m,n-1) )
          xbb      = 0.50d0*( xc(m,n-1)   + xc(md,n-1) )
          xpl(npl) = 1.1d0*xbb - 0.1d0*xce
          yce      = 0.25d0*( yc(md,nd-1) + yc(md,n-1) + yc(m,nd-1) + yc(m,n-1) )
          ybb      = 0.50d0*( yc(m,n-1)   + yc(md,n-1) )
          ypl(npl) = 1.1d0*ybb - 0.1d0*yce
       endif
    endif

 endif

 end subroutine bndpoint2pol


 !> read from rfg grid file
      SUBROUTINE ECRREA(X,MMAX,NMAX,MC,NC,MRGF,HALF)
      use m_missing
      implicit none
      character dummy*10, REC*132
!     LEES RGF
      integer,          intent(in) :: MMAX, NMAX   !< array sizes
      integer,          intent(in) :: mc, nc       !< grid size
      integer,          intent(in) :: mrgf         !< grid-file unit number
      double precision, intent(in) :: half         !< progress bar length, 0:half, 0.5:full
      double precision             :: X(MMAX,NMAX)
      double precision             :: af
      integer                      :: i,j

      DO J=1,NC
         IF (HALF > -1D0) THEN
            AF = HALF + 0.5d0*dble(J)/dble(NC)
            CALL READYY('Reading Grid File',AF)
         ENDIF
         READ(MRGF,*,err=777,end=999) dummy,dummy, (X(I,J),I=1,MC)
      ENDDO

      RETURN

  777 BACKSPACE (MRGF)
      BACKSPACE (MRGF)
      DO J=1,NC
         IF (HALF > -1D0) THEN
            AF = HALF + 0.5d0*dble(J)/dble(NC)
            CALL READYY('Reading Grid File',AF)
         ENDIF
         READ(MRGF,'(10X5F12.0)',err=888,END=999) (X(I,J),I=1,MC)
      ENDDO


      ! where (x == 0d0) x = dxymis

      RETURN

  888 BACKSPACE (MRGF)
      READ(MRGF,'(A)') REC
      CALL QNREADERROR('Reading Grid Coordinates but Getting',REC,MRGF)
      RETURN

  999 BACKSPACE (MRGF)
      READ(MRGF,'(A)') REC
      CALL QNEOFERROR(MRGF)
      RETURN
      END SUBROUTINE ECRREA

      SUBROUTINE REAMDD(   MMDD,   RD1,MC,NC,JA)
      implicit none

      integer :: mmdd, mc, nc, ja
      DOUBLE PRECISION :: RD1(MC,NC)
      integer :: m, n
      double precision :: af

      CHARACTER REC*132
      CALL READYY('Reading md-Dept File',0d0)
    5 CONTINUE
      READ(MMDD,'(A)',END = 999) REC
      IF (REC(1:1) .EQ. '*') GOTO 5
      BACKSPACE(MMDD)


      DO 10 N = 1, NC
         AF = dble(N) / dble(NC)
         CALL READYY('Reading md-Dept File',AF)
         READ(MMDD,*,END = 999,ERR = 888) (RD1(M,N),M = 1,MC)
   10 CONTINUE
      CALL READYY('Reading md-Dept File',-1d0)
      CALL DOCLOSE (MMDD)
      JA = 1
      RETURN

  999 CONTINUE
      CALL QNEOFERROR(MMDD)
      CALL READYY('Reading md-Dept File',-1d0)
      CALL DOCLOSE (MMDD)
      JA = 0
      RETURN

  888 CALL QNREADERROR('Reading, DD Depth File With Wrong Dimensions', ' ', MMDD)
      CALL READYY('Reading md-Dept File',-1d0)
      CALL DOCLOSE (MMDD)
      JA = 0
      END SUBROUTINE REAMDD


      SUBROUTINE REABOT(   MMDD,   JA)
      USE M_GRID
      implicit none

      integer :: mmdd, ja, m1, n1, m2, n2, L1, L2, L3, L4, L5
      integer :: m, n
      double precision :: af

      CHARACTER REC*132
      CALL READYY('Reading SIMONA *.bottom File',0d0)

    5 CONTINUE

      READ(MMDD,'(A)',END = 777) REC
      IF (REC(1:3) .ne. 'BOX') THEN
          GOTO 5
      ELSE
          L1 =  INDEX(REC, '=(')
          READ  (REC(L1+2:), *)   M1

          L2 =  L1 + INDEX(REC(L1:), ',')
          L3 =       INDEX(REC(:), ';') -1

          READ  (REC(L2:L3), *)        N1


          L3 =  INDEX(REC, ';' )
          READ  (REC(L3+1:), *)    M2

          L4 =  L3 + INDEX(REC(L3:), ',')
          L5 =       INDEX(REC,     ')') - 1

          READ  (REC(L4:L5), *)    N2



      ENDIF

      DO 10 M = M1,M2
         AF = dble(M) / dble(MC)
         CALL READYY('Reading SIMONA *.bottom File',AF)

         READ(MMDD,'(A)',END = 777) REC
         BACKSPACE(MMDD)


         READ(MMDD,*,END = 999,ERR = 888) (ZC(M,N),N = N1, N2)
   10 CONTINUE
      GOTO 5


  777 CALL READYY('Reading SIMONA *.bottom File',-1d0)
      CALL DOCLOSE (MMDD)
      JA = 1
      RETURN

  999 CONTINUE
      CALL QNEOFERROR(MMDD)
      CALL READYY('Reading SIMONA *.bottom File',-1d0)
      CALL DOCLOSE (MMDD)
      JA = 0
      RETURN

  888 CALL QNREADERROR('Reading ERROR SIMONA bottom File With Wrong Dimensions', ' ', MMDD)
      CALL READYY('Reading *.bottom File',-1d0)
      CALL DOCLOSE (MMDD)
      JA = 0
      END SUBROUTINE REABOT


      SUBROUTINE REAweir(   MMDD, JA)
      use m_missing
      use m_fixedweirs
      USE M_GRID
      implicit none


      integer :: mmdd, ja, m1, n1, m2, n2, L1, L2, L3, L4, L5
      integer :: m, n, MOUT
      double precision :: af, hu, hv, Du1, Du2, Dv1, Dv2

      CHARACTER REC*132

      JA = 0

      CALL NEWFIL(MOUT, 'WEIRS.POL')

    5 CONTINUE

      READ(MMDD,'(A)',END = 777) REC

      IF ( index(rec,'#') ==0) THEN

          READ (REC(2:), *, ERR=999)   M, N, HU, Du1, Du2, HV, Dv1, Dv2

          IF (HU > 0) THEN
             WRITE(MOUT,*) XC(M,N  ) , YC(M,N  ), HU, DU1, DU2
             WRITE(MOUT,*) XC(M,N-1) , YC(M,N-1), HU, DU1, DU2
             WRITE(MOUT,*) DMISS, DMISS, DMISS
          ENDIF

          IF (HV > 0) THEN
             WRITE(MOUT,*) XC(M  ,N) , YC(M  ,N), HV, DV1, DV2
             WRITE(MOUT,*) XC(M-1,N) , YC(M-1,N), HV, DV1, DV2
             WRITE(MOUT,*) DMISS, DMISS, DMISS
          ENDIF

      ENDIF

      GOTO 5


  777 CALL DOCLOSE (MMDD)
      CALL DOCLOSE (MOUT)
      JA = 1
      RETURN

  999 CONTINUE
      CALL QNEOFERROR(MMDD)
      CALL READYY('Reading SIMONA *.bottom File',-1d0)
      CALL DOCLOSE (MMDD)
      JA = 0
      RETURN

  888 CALL QNREADERROR('Reading ERROR SIMONA WEIR File', REC, MMDD)
      CALL DOCLOSE (MMDD)
      JA = 0
      END SUBROUTINE REAWEIR

      SUBROUTINE REAcrs(   MMDD, JA)
      USE M_GRID
      use m_missing

      implicit none


      integer :: mmdd, ja, m1, n1, m2, n2, MH, NH , NR2

      integer :: m, n, MOUT
      double precision :: af, hu, hv, d

      CHARACTER REC*132

      JA  = 0
      NR2 = 2

      CALL NEWFIL(MOUT, 'sections_crs.pli')

    5 CONTINUE

      READ(MMDD,'(A)',END = 777) REC

      IF ( index(rec,'#') ==0) THEN

          READ (REC(21:), *, ERR=999)   M1, N1, M2, N2

          IF (M1 > M2) THEN
             MH = M2; M2 = M1; M1 = MH
          ENDIF
          IF (N1 > N2) THEN
             NH = N2; N2 = N1; N1 = NH
          ENDIF

     !     WRITE(MOUT,'(A  )') REC(1:20)
          IF (M1 == M2) THEN
             WRITE(MOUT,'(A  )') REC(1:20)
             WRITE(MOUT, '(2I8)') N2-N1+2, NR2
             DO N = N1-1,N2
                WRITE (MOUT,*) XC(M1,N), YC(M1,N)
             ENDDO
          ENDIF

          IF (N1 == N2) THEN
             if (m1 == m2) then
                WRITE(MOUT,'(A  )') REC(1:20)//'b'
             else
                WRITE(MOUT,'(A  )') REC(1:20)
             endif
             WRITE(MOUT, '(2I8)') M2-M1+2, NR2
             DO M = M1-1,M2
                WRITE (MOUT,*) XC(M,N1), YC(M,N1)
             ENDDO
          ENDIF

      ENDIF

      GOTO 5


  777 CALL DOCLOSE (MMDD)
      CALL DOCLOSE (MOUT)
      JA = 1
      RETURN

  999 CONTINUE
      CALL QNEOFERROR(MMDD)
      CALL READYY('Reading SIMONA *.bottom File',-1d0)
      CALL DOCLOSE (MMDD)
      JA = 0
      RETURN

  888 CALL QNREADERROR('Reading ERROR SIMONA WEIR File', REC, MMDD)
      CALL DOCLOSE (MMDD)
      JA = 0
      END SUBROUTINE REAcrs







  SUBROUTINE SCHERM()
   use m_netw
   use m_flowgeom
   use m_grid
   use unstruc_messages
   implicit none
   integer :: i
   integer :: omp_numt

   integer :: maxlin
   PARAMETER (MAXLIN = 11)
   integer :: nlevel
   COMMON /HELPNOW/  WRDKEY,NLEVEL
   CHARACTER TEX(MAXLIN)*70,WRDKEY*40
   integer, external ::omp_get_num_threads
!

   TEX(1) = 'ACTUAL AND MAXIMUM DIMENSIONS OF DATA                           '
   TEX(2) = '****************************************************************'
   TEX(3) = 'DATA TYPE                            :       ACTUAL      MAXIMUM'
   TEX(4) = 'NUMBER OF NETNODES                   :                          '
   TEX(5) = 'NUMBER OF NETLINKS                   :                          '
   TEX(6) = 'MAXIMUM NUMBER OF LINKS PER NODE     :                          '
   TEX(7) = 'land boundary                        :                          '
   TEX(8) = 'POLYGON                              :                          '
   TEX(9) = 'NUMBER OF FLOW CELLS                 :                          '
   TEX(10)= 'NUMBER OF FLOW LINKS                 :                          '
   TEX(11)= 'Grid m,n dimensions                  :                          '


!
   WRITE(TEX(4)(44:51),'(I8)')  NUMK
   WRITE(TEX(5)(44:51),'(I8)')  NUML
!  WRITE(TEX(6)(44:51),'(I8)')
   WRITE(TEX(7)(44:51),'(I8)')  MXLAN
   WRITE(TEX(8)(44:51),'(I8)')  NPL
   WRITE(TEX(9) (44:51),'(I8)')  NDX
   WRITE(TEX(10)(44:51),'(I8)')  LNX
   WRITE(TEX(11)(44:51),'(I8)')  mc

   WRITE(TEX(4)(57:64),'(I8)')  KMAX
   WRITE(TEX(5)(57:64),'(I8)')  LMAX
   WRITE(TEX(6)(57:64),'(I8)')  KNX
   WRITE(TEX(7)(57:64),'(I8)')  MAXLAN
   WRITE(TEX(8)(57:64),'(I8)')  MAXPOL
   WRITE(TEX(9) (57:64),'(I8)')  NDX
   WRITE(TEX(10)(57:64),'(I8)')  LNX
   WRITE(TEX(11)(57:64),'(I8)')  nc


!
   WRITE(msgbuf,'(A)'); call msg_flush()

   DO I = 1,MAXLIN
      WRITE(msgbuf,'(A)') TEX(I); call msg_flush()
   ENDDO


   omp_numt = 0
#ifdef _OPENMP
   WRITE(msgbuf,'(A,i8)') 'number of threads: ', omp_get_num_threads()  ; call msg_flush()
#else
   WRITE(msgbuf,'(A,i8)') 'number of threads: OMP disabled'  ; call msg_flush()
#endif


   WRDKEY = 'ACTUAL AND MAXIMUM DIMENSIONS OF DATA'
   NLEVEL = 2
   CALL HISTOR()

   RETURN
   END SUBROUTINE SCHERM
!

 Subroutine plusabs_flow(numchoice)
 use m_flow
 use m_flowgeom
 implicit none

 integer :: numchoice, k, kk, kb, kt

 ! locals
 integer :: key

 if (ndx == 0 .or. lnx == 0) then
    call qnerror('First reinitialise flow model, current dimensions are 0',' ',' ')
    return
 endif

 if (numchoice == 1) then
    call plusabsd(xz,yz,yz,ndx,key,s1); s1=max(s1,bl)
 else if (numchoice == 2) then
    if (.not. allocated (sa1) ) then
       CALL qnerror('first reinitialise with jasal=1',' ',' ')
       return
    endif
    call plusabsd(xz,yz,yz,ndx,key,sa1)
    if (kmx > 0) then
       do kk = 1,ndx
          call getkbotktop(kk,kb,kt)
          do k = kb,kt
             sa1(k) = sa1(kk)
          enddo
       enddo
    endif

    salmax = maxval(sa1)

 else if (numchoice == 3) then
    if (ibedlevtyp == 1) then
       call plusabsd(xz,yz,yz,ndx,key,bl)
    else if (ibedlevtyp == 2) then
       call plusabsd(xu,yu,yu,lnx,key,blu)
    else
       CALL qnerror('Specifying cell bottom levels bl (ibedlevtyp=1) or flow link bottom levels blu (ibedlevtyp=2)',' ',' ')
       CALL qnerror('Change parameter ibedlevtyp in Various, Change Geometry Parameters',' ',' ')
       return
    endif
    call setbobs()
    s1 = max(s1,bl)
 endif
 End subroutine plusabs_flow


Subroutine sethigherorderadvectionvelocities()
use m_flowgeom
use m_flow
use m_sferic
use m_flowtimes
use unstruc_messages

implicit none

integer                    :: L, LL, k1, k2, k, ku, kd, kku, ku2, is, ip, Lb, Lt, kkua, kkub
integer                    :: n12, ib
double precision           :: half, sl1, sl2, sl3, cf, ucxku, ucyku, ds1, ds2, ds, ql, qds, ds1x, ds1y, ds2x, ds2y
double precision, external :: dslim

double precision           :: ds1x_6, ds1y_6, ds_6
double precision           :: dsx, dsy

double precision, external :: nod2linx, nod2liny
double precision, external :: nodup2linx, nodup2liny


if (limtypmom < 1 ) return

if (kmx == 0) then

 !$OMP PARALLEL DO                                                             &
 !$OMP PRIVATE(L, LL, k1, k2, k, kd, is, half, ip, n12, ib, kku, ku, ku2)      &
 !$OMP PRIVATE(sl1, sl2, sl3, cf, ucxku, ucyku, ds1x, ds1y, ds2x, ds2y, ds, ql, qds, dsx, dsy )


do L  = 1,lnx                                                    ! upwind (supq) + limited high order (dsq)

  LL  = L
  if (qa(LL) .ne. 0d0) then

       k1  = ln(1,L) ; k2 = ln(2,L)

       if (qa(LL) > 0) then
                                                                       !   ->      ds1   ds2
          k = k1 ; kd = k2 ; is =  1 ; half = acl(LL)       ; ip = 0   !   ->   ku     k     kd
          n12 = 1
          ib  = 0
       else
                                                                       !   <-      ds2   ds1
          k = k2 ; kd = k1 ; is = -1 ; half = 1d0-acl(LL)   ; ip = 3   !   <-   kd     k     ku
          n12 = 2
          ib  = 2
       endif

       if (hs(ln(1,LL)) < Chkadvd .or. hs(ln(2,LL)) < Chkadvd) cycle

       if (limtypmom == 6) then

!         use klnup to check for disabled higher-order correction
          if ( klnup(1,LL).eq.0 ) cycle

          if (jasfer3D == 0) then
             ! ds1x =  -ducdx(k)*is
             ! ds1y =  -ducdy(k)*is
             ds1x = (ducxdx(k)*csu(LL) + ducxdy(k)*snu(LL)) * is * Dx(LL)
             ds1y = (ducydx(k)*csu(LL) + ducydy(k)*snu(LL)) * is * Dx(LL)
          else
             ds1x = (nod2linx(LL,n12,ducxdx(k),ducxdy(k))*csu(LL) + nod2liny(LL,n12,ducxdx(k),ducxdy(k))*snu(LL)) * is * Dx(LL)
             ds1y = (nod2linx(LL,n12,ducydx(k),ducydy(k))*csu(LL) + nod2liny(LL,n12,ducydx(k),ducydy(k))*snu(LL)) * is * Dx(LL)
          endif

       else

          kku  = klnup(1+ip,LL) ; if (kku == 0) cycle
          ku   = abs(kku)

          if (kku < 0) then

             if (jasfer3D == 0) then
                ucxku = ucx(ku)
                ucyku = ucy(ku)
             else
                ucxku = nodup2linx(LL,1+ib,ucx(ku),ucy(ku))
                ucyku = nodup2liny(LL,1+ib,ucx(ku),ucy(ku))
             endif
          else

             ku2   = iabs(klnup(2+ip,LL)) ; if ( ku2 == 0) cycle
             sl1   = slnup(1+ip,LL) ; sl2  = slnup(2+ip,LL)
             if (jasfer3D == 0) then
                ucxku = ucx(ku)*sl1 + ucx(ku2)*sl2
                ucyku = ucy(ku)*sl1 + ucy(ku2)*sl2
             else
                ucxku = nodup2linx(LL,1+ib,ucx(ku),ucy(ku))*sl1 + &
                        nodup2linx(LL,2+ib,ucx(ku2),ucy(ku2))*sl2
                ucyku = nodup2liny(LL,1+ib,ucx(ku),ucy(ku))*sl1 + &
                        nodup2liny(LL,2+ib,ucx(ku2),ucy(ku2))*sl2
             endif
          endif
          sl3  = slnup(3+ip,LL)
          if (jasfer3D == 0) then
             ds1x = (ucx(k)  - ucxku)*sl3
             ds1y = (ucy(k)  - ucyku)*sl3
          else
             ds1x = (nod2linx(LL,n12,ucx(k),ucy(k))  - ucxku)*sl3
             ds1y = (nod2liny(LL,n12,ucx(k),ucy(k))  - ucyku)*sl3
          endif
       endif

       cf   =  dts*abs(u1(L))*dxi(LL)  ! cflj(L)  !cfli(k ) ! cflj(L)
       cf  =  half*max( 0d0,1d0-cf )
       if (jasfer3D == 0) then
          ds2x =  ucx(kd) - ucx(k)
          ds2y =  ucy(kd) - ucy(k)
       else
          ds2x =  nod2linx(LL,3-n12,ucx(kd),ucy(kd)) - nod2linx(LL,n12,ucx(k),ucy(k))
          ds2y =  nod2liny(LL,3-n12,ucx(kd),ucy(kd)) - nod2liny(LL,n12,ucx(k),ucy(k))
       endif

!       if (abs(ds2x)  > eps10 .and. abs(ds1x) > eps10) then
!           ds = cf*dslim(ds1x, ds2x, limtypmom)  ! no cf, see belanger
!           if (abs(ds) > eps10) then
!               ucxu(L)    =  ucxu(L)  + ds
!           endif
!       endif
!
!       if (abs(ds2y)  > eps10 .and. abs(ds1y) > eps10) then
!           ds =  cf*dslim(ds1y, ds2y, limtypmom)  ! no cf, see belanger
!           if (abs(ds) > eps10) then
!               ucyu(L)    =  ucyu(L)  + ds
!           endif
!       endif

      call dslimvec(ds1x, ds1y, ds2x, ds2y, csu(L), snu(L), limtypmom, dsx, dsy)
      ucxu(L) = ucxu(L) + cf*dsx
      ucyu(L) = ucyu(L) + cf*dsy

   endif ! qa.ne.0

enddo  ! horizontal

 !$OMP END PARALLEL DO

else

do LL  = 1,lnx                                                    ! upwind (supq) + limited high order (dsq)

  if (qa(LL) .ne. 0d0) then

    call getLbotLtop(LL,Lb,Lt)

    do L = Lb,Lt

       k1  = ln(1,L) ; k2 = ln(2,L)

       if (qa(L) > 0) then
                                                                       !   ->      ds1   ds2
          k = k1 ; kd = k2 ; is =  1 ; half = acl(LL)       ; ip = 0   !   ->   ku     k     kd
          n12 = 1
          ib = 0

       else
                                                                       !   <-      ds2   ds1
          k = k2 ; kd = k1 ; is = -1 ; half = 1d0-acl(LL)   ; ip = 3   !   <-   kd     k     ku
          n12 = 2
          ib = 2

       endif

       if (hs(ln(1,LL)) < Chkadvd .or. hs(ln(2,LL)) < Chkadvd) cycle

       if (limtypmom == 6) then
!         ds1x =  -ducdx(k)*is
!         ds1y =  -ducdy(k)*is

!        use klnup to check for disabled higher-order correction
         if ( klnup(1,LL).eq.0 ) cycle

!         ds1x = (ducxdx(k)*csu(LL) + ducxdy(k)*snu(LL)) * is * Dx(LL)
!         ds1y = (ducydx(k)*csu(LL) + ducydy(k)*snu(LL)) * is * Dx(LL)

         ds1x = (nod2linx(LL,n12,ducxdx(k),ducxdy(k))*csu(LL) + nod2liny(LL,n12,ducxdx(k),ducxdy(k))*snu(LL)) * is * Dx(LL)
         ds1y = (nod2linx(LL,n12,ducydx(k),ducydy(k))*csu(LL) + nod2liny(LL,n12,ducydx(k),ducydy(k))*snu(LL)) * is * Dx(LL)

       else

       kku  = klnup(1+ip,LL) ; if (kku == 0) cycle ; kkua = abs(kku)
       ku   = kbot(kkua) + kmxn(kkua) - ( Lb + kmxL(LL) - L) ; if (ku < kbot(kkua) .or. ku > ktop(kkua) ) cycle

       if (kku < 0) then

          if (jasfer3D == 0) then
             ucxku = ucx(ku)
             ucyku = ucy(ku)
          else
             ucxku = nodup2linx(LL,1+ib,ucx(ku),ucy(ku))
             ucyku = nodup2liny(LL,1+ib,ucx(ku),ucy(ku))
          endif

       else

          kkub  = iabs( klnup(2+ip,LL) )
          ku2   = kbot(kkub) + kmxn(kkub) - ( Lb + kmxL(LL) - L) ; if (ku2 < kbot(kkub) .or. ku2 > ktop(kkub) ) cycle

          sl1   = slnup(1+ip,LL) ; sl2  = slnup(2+ip,LL)

          if (jasfer3D == 0) then
             ucxku = ucx(ku)*sl1 + ucx(ku2)*sl2
             ucyku = ucy(ku)*sl1 + ucy(ku2)*sl2
          else
             ucxku = nodup2linx(LL,1+ib,ucx(ku),ucy(ku))*sl1 + &
                     nodup2linx(LL,2+ib,ucx(ku2),ucy(ku2))*sl2
             ucyku = nodup2liny(LL,1+ib,ucx(ku),ucy(ku))*sl1 + &
                     nodup2liny(LL,2+ib,ucx(ku2),ucy(ku2))*sl2
          endif
       endif

         sl3 = slnup(3+ip,LL)
         if (jasfer3D == 0) then
            ds1x = (ucx(k)  - ucxku)*sl3
            ds1y = (ucy(k)  - ucyku)*sl3
         else
            ds1x = (nod2linx(LL,n12,ucx(k),ucy(k))  - ucxku)*sl3
            ds1y = (nod2liny(LL,n12,ucx(k),ucy(k))  - ucyku)*sl3
         endif
       endif

       cf  =  dts*abs(u1(L))*dxi(LL)  ! cflj(L)  !cfli(k ) ! cflj(L)
       cf  =  half*max( 0d0,1d0-cf )
       if (jasfer3D == 0) then
          ds2x =  ucx(kd) - ucx(k)
          ds2y =  ucy(kd) - ucy(k)
       else
          ds2x =  nod2linx(LL,3-n12,ucx(kd),ucy(kd)) - nod2linx(LL,n12,ucx(k),ucy(k))
          ds2y =  nod2liny(LL,3-n12,ucx(kd),ucy(kd)) - nod2liny(LL,n12,ucx(k),ucy(k))
       endif

       ! BEGIN DEBUG
       !
       !  ds1x_6 = (ducxdx(k)*csu(LL) + ducxdy(k)*snu(LL)) * is * Dx(LL)
       !  ds1y_6 = (ducydx(k)*csu(LL) + ducydy(k)*snu(LL)) * is * Dx(LL)
       ! END DEBUG

!       if (abs(ds2x)  > eps10 .and. abs(ds1x) > eps10) then
!           ds = cf*dslim(ds1x, ds2x, limtypmom)
!           ! BEGIN DEBUG
!           !   ds_6 = cf*dslim(ds1x_6, ds2x, 6)
!           ! END DEBUG
!           if (abs(ds) > eps10) then
!               ucxu(L)    =  ucxu(L)  + ds
!           endif
!       endif
!
!       if (abs(ds2y)  > eps10 .and. abs(ds1y) > eps10) then
!           ds =  cf*dslim(ds1y, ds2y, limtypmom)
!           ! BEGIN DEBUG
!           !   ds_6 = cf*dslim(ds1y_6, ds2y, 6)
!           !    if ( LL.eq.10262 ) then
!           !       continue
!           !    end if
!           ! END DEBUG
!           if (abs(ds) > eps10) then
!               ucyu(L)    =  ucyu(L)  + ds
!           endif
!       endif

      call dslimvec(ds1x, ds1y, ds2x, ds2y, csu(LL), snu(LL), limtypmom, dsx, dsy)
      ucxu(L) = ucxu(L) + cf*dsx
      ucyu(L) = ucyu(L) + cf*dsy
    enddo ! vertical

  endif

enddo  ! horizontal

endif ! kmx


End subroutine sethigherorderadvectionvelocities

Subroutine setequilibriumsedimentbnds(nbnd,n4,kbnd,kban,i01)
use m_flow
use m_flowgeom
use m_sediment
implicit none

integer           :: nbnd, kban(2,nbnd) , kbnd(n4,nbnd), i01, n4

integer           :: k, kb, ki, L, LL, Lb, Lt, j
double precision  :: hsk
double precision  :: seq  (mxgr)                !< sed equilibrium transport rate (kg/m/s) , dimension = mxgr
double precision  :: wse  (mxgr)                !< effective fall velocity (m/s)           , dimension = mxgr, ws*crefa=wse*seq



do k  = 1,nbnd                                  ! set equilibrium boundary conditions for open flow bnds, types z and u
   kb = kbnd(1,k)
   ki = kbnd(2,k)
   LL = kbnd(3,k)

   if (q1(LL) < 0) then
      bl(kb) = bl(ki)                            ! copy internal bottom level to outflow bnd level
      if (jaceneqtr == 1) then
         do j = 1,mxgr
            grainlay(j,kb) = grainlay(j,ki)
         enddo
      endif
   endif

   if (jaceneqtr == 1) then
      call getequilibriumtransportrates(ki, seq, wse, mxgr, hsk)                            ! get based on cellcentre
   else
      call getequilibriumtransportrates2(LL, kban(1,k), kban(2,k), seq, wse, mxgr, hsk, i01) ! get based on 2 netnodes
   endif
   call getLbotLtop(LL,Lb,Lt)
   do L  = Lb,Lt
      kb = ln(1,L) ; ki = ln(2,L)
      do j = 1,mxgr
         if (q1(L) > 0) then
            sed(j,kb) = seq(j)                      ! inflow ,  equilibrium boundary condition
         else
            sed(j,kb) = sed(j,ki)                   ! outflow
         endif
      enddo
   enddo
enddo

End Subroutine setequilibriumsedimentbnds

subroutine transport()                           ! transport for now, advect salinity and add
                                                  ! high order limited terms to uqcx, uqcy
 use m_flowgeom
 use m_flow
 use m_flowtimes
 use m_ship
 use m_sediment
 use m_netw, only : xk,yk,zk
 use m_flowtimes
 use m_physcoef, only : idensform, difmolsal
 use m_partitioninfo
 use m_timer
 use m_missing
 use unstruc_display, only: jaGUI
 use unstruc_messages
 use m_transport, only: NUMCONST, constituents, ISALT, ITEMP, ISED1, ISEDN, ITRA1, itraN, itrac2const

 implicit none

 integer :: L, k, ku, kd, k1, k2, kb, ierr, n, ntmx, it, jupwsal, jupq, itmax, jaimplorg, java

 integer :: L1, L2, Li, ip, is, maxit = 100, limtyp, kl1, kl2, kl2s, kku

 integer :: jalim2D, nx, k3, k4

 double precision               :: ds1, ds2, ds, sak, saku, teku, half, cf, tetaj2i, vv, tetav1, cadv, difsalw, diftemw, difsedw

 double precision               :: qst, qstu, qstd, qds, ql, qh, epssa, sasum, sasum0=0, diff, baroc, barocup, dif, dift, difs, ho

 double precision               :: ucxku, ucyku, s1ku, sl1, sl2, sl3, fi, qb, wsemx, dgrlay, dtvi, hsk, xx,yy,dmorfax, dv, aa

 double precision, allocatable, save  :: dsq(:), pp(:), pm(:), qp(:), qm(:), alf(:) ! todo kuzmin limiting jalim2D==1

 double precision, external     :: upwsalslope, upwsal, rminmod

 double precision, external     :: dslim, setrho, dlimitercentral

 integer                        :: j, kj, kdj, kuj, kl1j, kl2j, kbj, kij, ki, jastep, kk, kb1, kb2, n1, n2, kkua, kkub, ku2

 integer                        :: LL, Lb, Lt, kt, km, ivert, ja, m, LL1, LL2, jachange

 double precision               :: sedku(mxgr)           !< upper slope sed value                   , dimension = mxgr
 double precision               :: flx  (mxgr)           !< sed erosion flux (kg/s)                 , dimension = mxgr
 double precision               :: seq  (mxgr)           !< sed equilibrium transport rate (kg/m/s) , dimension = mxgr
 double precision               :: wse  (mxgr)           !< effective fall velocity (m/s)           , dimension = mxgr, ws*crefa=wse*seq


 double precision               :: cpuorg(3), cpunew(3), adv, adv1, hordif, qsk, qsa

 double precision               ::  a(kmxx), b(kmxx), c(kmxx), d(kmxx), e(kmxx)
 double precision               :: ta(kmxx),tb(kmxx),tc(kmxx),td(kmxx),te(kmxx)
 double precision               :: sa(kmxx),sb(kmxx),sc(kmxx),sd(kmxx),se(kmxx)


 double precision, allocatable  :: sa00(:), vold(:), cch(:), ccv(:), diagn(:) ! help arrays scalar transport

 double precision               :: dq(kmxx), samiobnd, samerr2, dsadn

 double precision               :: dfac1, dfac2, src, viL, diuspL, qdsL

 integer                        :: ierror, k3D, noadvection = 0

 double precision, allocatable  :: skmx(:)

 double precision               :: valtop

 if ( stm_included .and. jased.ne.0 .and. jatransportmodule.eq.0 ) then
    call mess(LEVEL_FATAL, 'unstruc::transport - Please use transport module when sediment model number == 4')
 end if

 if (jasal == 0) then
    ! limtypsa = 0
    maxitverticalforestersal = 0
 endif
 if (jatem == 0) then
    limtypTM = 0 ; maxitverticalforestertem = 0
 endif
 if (jased == 0) then
    limtypsed = 0
 endif
 if (iadvec == 0) then
    limtypmom = 0
 endif

 limtyp = max(Limtypsa, limtyptm, limtypsed)                   ! check if limiter need be applied

 if (jasal == 0 .and. jatem == 0 .and. jased == 0 .and. jatransportmodule == 0 ) return    ! no salinity, or sediment, no higher orders

 if (jasal > 0) then

     do k  = 1,nbnds                              ! set 1D or 3D sal boundary conditions
       LL = kbndS(3,k)
       call getLbotLtop(LL,Lb,Lt)
       kb = 0
       do L  = Lb,Lt
          kb = ln(1,L) ; ki = ln(2,L)
          if (q1(L) >= 0 .or. keepstbndonoutflow == 1) then
              kk      = kmxd*(k-1)+L-Lb+1
              sa1(kb) = zbnds(kk)                 ! inflow
              salmax  = max( salmax, sa1(kb) )
          else
              sa1(kb) = sa1(ki)                   ! outflow
          endif
          !if (jasteric > 0) then
          !   steric(1,kb) = zbnds(kk)
          !endif
       enddo

       if ( kb.gt.0 ) then
          valtop = sa1(kb)
          do L=Lt+1,Lb+kmxL(LL)-1
             kb      = ln(1,L)
             sa1(kb) = valtop
          end do
       end if
    enddo

    if ( jampi.eq.1 .and. jatransportmodule == 0) then
       if ( jatimer.eq.1 ) call starttimer(IMPIREDUCE)
       call reduce_double_max(salmax)
       if ( jatimer.eq.1 ) call stoptimer(IMPIREDUCE)
    end if

 endif

 if (jatem > 0) then
    do k  = 1,nbndtm                                  ! set 1D or 3D temp boundary conditions
       LL = kbndTM(3,k)
       call getLbotLtop(LL,Lb,Lt)
       kb = 0
       do L  = Lb,Lt
          kb = ln(1,L) ; ki = ln(2,L)
          if (q1(L) >= 0  .or. keepstbndonoutflow == 1) then
              kk        = kmxd*(k-1)+L-Lb+1
              constituents(itemp, kb)  = zbndTM(kk)                  ! inflow

!             BEGIN DEBUG
!              if ( zbndTM(kk).eq.DMISS ) then
!                 call mess(LEVEL_INFO, 'zbndTM=DMISS, (LL,kk)=', LL, kk)
!              end if
!             END DEBUG

          else
              constituents(itemp, kb)  = constituents(itemp, ki)     ! outflow
          endif

          !if (jasteric > 0) then
          !   steric(2,kb) = zbndTM(kk)
          !endif

       enddo

       if ( kb.gt.0 ) then
          valtop = constituents(itemp, kb)
          do L=Lt+1,Lb+kmxL(LL)-1
             kb                      = ln(1,L)
             constituents(itemp, kb) = valtop
          end do
       end if

    enddo
   ! tem1 = tem1 + 50d0 ! tkelvn
 endif

 if (jased > 0 .and. jased < 4) then

    if (nbndz > 0) then
       call setequilibriumsedimentbnds(nbndz,6,kbndz,kbanz,0)
    endif
    if (nbndu > 0) then
       call setequilibriumsedimentbnds(nbndu,6,kbndu,kbanu,1)
    endif

    do k  = 1,nbndsd                                 ! set prescribed sediment boundary conditions
       kb = kbndSd(1,k)
       ki = kbndSd(2,k)
       L  = kbndSd(3,k)
       do j = 1,mxgr
          if (q1(L) > 0) then
             sed(j,kb) = zbndsd(k)                   ! inflow ,  todo, check vectormax over grainsizes if boundaryprescribed, else
          endif
       enddo
    enddo

    if (dmorfac > 0 .and. time1 >= tstart_user + TMorfspinup) then
       jamorf = 1
    endif
    dvolbot = 0d0

 endif

! begin DEBUG
  if ( jatransportmodule.ne.0 ) then
     goto 1234
  endif
! end DEBUG

 if (limtypsa == 6) then

    dsadx = 0d0; dsady = 0d0
    do LL = 1,lnx
       Lb = Lbot(LL) ; Lt = Lb - 1 + kmxL(LL)
       do L  = Lb, Lt
          k1 = ln(1,L)
          k2 = ln(2,L)
          dsadn = dxi(LL)*( sa1(k2) - sa1(k1) )
          dsadx(k1) = dsadx(k1) + wcx1(LL)*dsadn
          dsady(k1) = dsady(k1) + wcy1(LL)*dsadn
          dsadx(k2) = dsadx(k2) + wcx2(LL)*dsadn
          dsady(k2) = dsady(k2) + wcy2(LL)*dsadn
       enddo
    enddo

 endif

 if (jasal > 0)  then
    supq   = 0d0 ; qsho = 0d0
 endif

 if (jatem > 0) then
    tupq   = 0d0 ; qtho = 0d0
  endif

 if (jased > 0) then
    sdupq  = 0d0
 endif

 jalim2D = 3                                                       ! 2D limiting
 if (jalim2D > 0) then
    if (.not. allocated(pp) ) then
       allocate ( pp(ndkx) , stat = ierr)
       call aerr('pp(ndkx)', ierr, lnkx+ndkx )
    endif
    if (jalim2D <= 2) then
        if (.not. allocated(pm) ) then
            allocate ( dsq(ndx), pm(ndx), qp(ndx), qm(ndx), alf(lnx)  , stat = ierr)
            call aerr('dsq(ndx), pm(ndx), qp(ndx), qm(ndx), alf(lnx)' , ierr, 6*ndx)
        endif
        dsq = 0d0
    endif
 endif

 do LL  = 1,lnx                                                    ! upwind (supq) + limited high order (dsq)


  if (q1(LL) .ne. 0d0) then

    call getLbotLtop(LL,Lb,Lt)
    do L = Lb,Lt

       k1  = ln(1,L) ; k2 = ln(2,L)

       if (q1(L) > 0) then
                                                                       !   ->      ds1   ds2
          k = k1 ; kd = k2 ; is =  1 ; half = acl(LL)       ; ip = 0   !   ->   ku     k     kd

       else
                                                                       !   <-      ds2   ds1
          k = k2 ; kd = k1 ; is = -1 ; half = 1d0-acl(LL)   ; ip = 3   !   <-   kd     k     ku

       endif

       ql  = is*q1(L)

       if (jasal > 0) then
           supq(kd) = supq(kd) + ql*sa1(k)
           supq(k ) = supq(k ) - ql*sa1(k)
       endif

       if (jatem > 0) then
           tupq(kd) = tupq(kd) + ql*constituents(itemp, k)
           tupq(k ) = tupq(k ) - ql*constituents(itemp, k)
       endif

       if (jased > 0) then
          do j = 1,mxgr ! grainsize loop
             sdupq(j,kd) = sdupq(j,kd) + ql*sed(j,k)
             sdupq(j,k ) = sdupq(j,k ) - ql*sed(j,k)
          enddo
       endif

       if (limtyp > 0 ) then  ! .and. L <= lnxi) then

          if (hs(ln(1,LL)) < Chkadvd .or. hs(ln(2,LL)) < Chkadvd) cycle

          kku  = klnup(1+ip,LL) ; if (kku == 0) cycle ; kkua = abs(kku)

          if (kmx > 0) then
             ku   = kbot(kkua) + kmxn(kkua) - ( Lb + kmxL(LL) - L) ; if (ku < kbot(kkua) .or. ku > ktop(kkua) ) cycle
          else
             ku   = abs(kku)
          endif

          if (kku < 0) then

             if (limtypsa > 0) then
                saku = sa1(ku)
             endif

             if (limtyptm > 0) then
                 teku = constituents(itemp, ku)
             endif

             if (limtypsed > 0) then
                do j = 1,mxgr ! grainsize loop
                   sedku(j) = sed(j,ku)
                enddo
             endif

          else

             kkub = iabs( klnup(2+ip,LL) )
             if (kmx > 0) then
                ku2  = kbot(kkub) + kmxn(kkub) - ( Lb + kmxL(LL) - L) ; if (ku2 < kbot(kkub) .or. ku2 > ktop(kkub) ) cycle
             else
                ku2  = kkub
             endif

             sl1  = slnup(1+ip,LL) ; sl2  = slnup(2+ip,LL)

             if (limtypsa > 0) then
                saku  = sa1(ku)*sl1 + sa1(ku2)*sl2
             endif

             if (limtyptm > 0) then
                 teku  = constituents(itemp,ku)*sl1 + constituents(itemp, ku2)*sl2
             endif

             if (limtypsed  > 0) then
                do j = 1,mxgr ! grainsize loop
                   sedku(j) = sed(j,ku)*sl1 + sed(j,ku2)*sl2
                enddo
             endif

          endif

          sl3 = slnup(3+ip,LL)
          cf  =  dts*abs(u1(L))*dxi(LL)  ! cflj(L)  !cfli(k ) ! cflj(L)
          cf  =  half*max( 0d0,1d0-cf )

          if (limtypsa > 0) then                ! set high order term for salinity
             ! if (min(sa1(kd), sa1(k), saku) > 1d-3 .and. max(sa1(kd), sa1(k), saku) < salmax -1d-3) then ! lower order near top
             if ( .true. ) then ! lower order near top

                ds2  =  sa1(kd) - sa1(k)        ! ds1 = voorlopende slope, ds2 = eigen slope
                ds1  = (sa1(k)  - saku )*sl3

                IF (LL == 28580) THEN
                   DS1 = 1D0*ds1
                ENDIF

                if (abs(ds2)  > eps10 .and. abs(ds1) > eps10) then
                   if (Limtypsa == 7) then
                       ds  =  0.5d0*ds2 ! central only for cursusdemo
                   else if (Limtypsa == 6) then
                       ds1 = is*(dsadx(k)*csu(LL) + dsady(k)*snu(LL))
                       ds  = cf*dlimitercentral(ds1, ds2, limtypsa)
                   else
                       ds  = cf*dslim(ds1, ds2, limtypsa)
                   endif
                   if (abs(ds) > eps10) then
                      qsho(L)  =   ds*ql
                   endif

                endif
                  ! plotlin(L) = qds
             endif
          endif

          if (limtyptm > 0) then                ! set high order term for temperature
              ds2  =  constituents(itemp, kd) - constituents(itemp, k)        ! ds1 = voorlopende slope, ds2 = eigen slope
              ds1  = (constituents(itemp, k)  - teku )*sl3
              if (abs(ds2)  > eps10 .and. abs(ds1) > eps10) then
                 ds  =  cf*dslim(ds1, ds2, limtypsa)
                 if (abs(ds) > eps10) then
                    qtho(L)  =  ds*ql
                 endif
              endif
          endif

          if (limtypsed > 0) then                           ! set high order term for sediment, transport limiter equal to that for salinity , = limtypsal
             do j = 1,mxgr  ! grainsize loop
                ds2           =  sed(j,kd) - sed(j,k)       ! ds1 = voorlopende slope, ds2 = eigen slope
                ds1           = (sed(j,k)  - sedku(j) )*sl3
                if (abs(ds2)  > eps10 .and. abs(ds1) > eps10) then
                   ds  =  cf*dslim(ds1, ds2, limtypsed)
                   if (abs(ds)    > eps10) then
                      qds         =  ds*ql
                      sdupq(j,kd) =  sdupq(j,kd) + qds
                      sdupq(j,k ) =  sdupq(j,k ) - qds
                   endif
                  ! plotlin(L) = qds
                endif
             enddo
          endif

       endif


     enddo ! vertical

   endif


 enddo  ! horizontal


 nrimptran  = 0
 if (jasal > 0 .and. nrimptran > 0) then

    if (.not. allocated(sa00) ) then
       allocate ( sa00(ndkx), cch(lnkx) )
    endif

    cfli = 0d0 ; cflj = 0d0 ; tetaj = 0d0

    do L = 1,lnx                                       ! set courant j for downwind i, add j's for i
       if (q1(L) .ne. 0d0) then
           k1 = ln(1,L) ; k2 = ln(2,L)
           if (     q1(L) > 0 .and. vol0(k2) > 0d0) then
               cflj(L)  =  dts*q1(L)/vol0(k2)
               cfli(k2) =  cfli(k2) + cflj(L)
           else if (q1(L) < 0 .and. vol0(k1) > 0d0) then
               cflj(L)  = -dts*q1(L)/vol0(k1)
               cfli(k1) =  cfli(k1) + cflj(L)
           endif
       endif
    enddo

    do k = 1,ndx
       if (cfli(k) > 1) nrimptran = nrimptran + 1
    enddo

    if (nrimptran > 0) then
       do L  = 1,lnx                                     ! set tetaj as tetai upwind cell
          tetaj(L) = 0d0
          if (q1(L) .ne. 0d0) then
             k1 = ln(1,L) ; k2 = ln(2,L)
             if (     q1(L) > 0) then
                tetaj(L) = max(0d0, 1d0 - 1d0/cfli(k1) )
             else if (q1(L) < 0) then
                tetaj(L) = max(0d0, 1d0 - 1d0/cfli(k2) )
             endif
          endif
        enddo
    endif

    sa00 = sa1 / max( 1d0, cfli )                                ! normalise with bbk

    do L = 1,lnx                                                 ! set up ccn, normalise with bbk
       k1 = ln(1,L) ; k2 = ln(2,L)
       if (     q1(L) > 0) then
          cch(L)  =  cflj(L)*tetaj(L) / max( 1d0, cfli(k2) )     ! L komt binnen voor k2
       else if (q1(L) < 0) then
          cch(L)  =  cflj(L)*tetaj(L) / max( 1d0, cfli(k1) )
       else
          cch(L) = 0d0
       endif
    enddo

    epssa = 1d9
    do it = 1,maxit

       sa0 = sa1
       sa1 = sa00

       do L = 1,lnx
          if ( cch(L) > 0 ) then
             k1 = ln(1,L) ; k2 = ln(2,L)
             if (     q1(L) > 0) then
                sa1(k2) = sa1(k2) + sa0(k1)*cch(L)
             else if (q1(L) < 0) then
                sa1(k1) = sa1(k1) + sa0(k2)*cch(L)
             endif
          endif
       enddo
       epssa = maxval(dabs(sa0-sa1))

       if (epssa < eps10) exit

    enddo

 endif

 if (limtypsa > 0 .and. jalim2D > 0)  then ! prepare for Kuzmin 2D limiting (comp and applied math 2008)

    if (jalim2D == 1) then
       pp = 0 ; pm = 0 ; qp = 0 ; qm = 0 ;alf  = 1d0
       do L = 1,lnx
          k1 = ln(1,L) ; k2 = ln(2,L)
          if (q1(L) > 0d0) then
             pp(k2) = pp(k2) + max( 0d0,  alf(L)* qsho(L) )           ! set   upwind pp, see 4.83
             pm(k2) = pm(k2) + min( 0d0,  alf(L)* qsho(L) )           !
             qp(k1) = qp(k1) + max( 0d0,   q1(L)*(sa1(k2)-sa1(k1)) )  ! set downwind qq
             qm(k1) = qm(k1) + min( 0d0,   q1(L)*(sa1(k2)-sa1(k1)) )  !
          else
             pp(k1) = pp(k1) + max( 0d0, -alf(L)* qsho(L) )           ! set   upwind pp
             pm(k1) = pm(k1) + min( 0d0, -alf(L)* qsho(L) )           !
             qp(k2) = qp(k2) + max( 0d0,  -q1(L)*(sa1(k1)-sa1(k2)) )  ! set downwind qq
             qm(k2) = qm(k2) + min( 0d0,  -q1(L)*(sa1(k1)-sa1(k2)) )  !
          endif
       enddo


       do L = 1,lnx
          k1 = ln(1,L) ; k2 = ln(2,L) ; aa = 1d0
          if (qsho(L) > 0d0) then
             if (pp(k1) .ne. 0d0 .and. qp(k1) .ne. 0d0) then
                aa = qp(k1) / pp(k1)
             endif
          else if (qsho(L) < 0d0 ) then
             if (pm(k2) .ne. 0d0 .and. qm(k2) .ne. 0d0) then
                aa = qm(k2) / pm(k2)
             endif
          endif
          if (aa > 0d0) then
              if ( aa < 1d0) then
                 alf(L) = aa
              endif
          else
              alf(L) = 1d0
          endif
       enddo

    else if (jalim2D == 2) then

       pp = supq ; pm = 0d0 ;  qp = -1d3 ; qm = 1d3

       do L = 1,lnx
          k1 = ln(1,L) ; k2 = ln(2,L)
          if (q1(L) > 0d0) then
             kd = k2 ; k = k1 ; is =  1d0
          else
             kd = k1 ; k = k2 ; is = -1d0
          endif
          pp(kd) = pp(kd) + qsho(L)
          pm(k ) = pm(k ) + qsho(L)

          qp(kd) = max(qp(kd),  sa1(k )) ! min and max of neighbours
          qm(kd) = min(qm(kd),  sa1(k ))
          qp(k ) = max(qp(k ),  sa1(kd))
          qm(k ) = min(qm(k ),  sa1(kd))

       enddo

       do L = 1,lnx
          k1 = ln(1,L) ; k2 = ln(2,L)
          if (q1(L) > 0d0) then ! limit outflow only: check the upwind cell
             k = k1
          else
             k = k2
          endif
          aa = 1d0


          if (pp(k) > 0) then

             if (pm(k) > 0) then
                 if (sa1(k) > qp(k) ) then  ! local max
                   aa = pp(k) / pm(k)
                 endif
             endif

          else if (pp(k) < 0) then

             if (pm(k) < 0) then
                 if ( sa1(k) < qm(k) ) then ! local min
                     aa = pp(k) / pm(k)
                 endif
             endif

          endif
          if (aa < 0d0) then
              aa = 0d0
          else if (aa > 1d0) then
              aa = 1d0
          endif
          alf(L) = aa
        enddo

    else if (jalim2D == 3) then ! testing to see if ho increases max - min, if so, switch off ho

       pp = supq

       do LL = 1,lnx
          if (q1(LL) .ne. 0) then
             call getLbotLtop(LL,Lb,Lt)
             do L = Lb, Lt
                k1 = ln(1,L) ; k2 = ln(2,L)
                if (q1(L) > 0) then
                   is =  1
                else
                   is = -1
                endif
                pp(k2) = pp(k2) + qsho(L)*is
                pp(k1) = pp(k1) - qsho(L)*is
             enddo
          endif
       enddo

       !$OMP PARALLEL DO                        &
       !$OMP PRIVATE(kk,k,kb,kt,aa,n,L)
       do kk = 1,ndx
          if (kfs(kk) == 0) cycle
          call getkbotktop(kk,kb,kt)
          do k = kb,kt
             if (vol1(k) > 0d0) then
                aa = sa1(k) + dts*pp(k)/vol1(k)
                if ( aa < 0d0 .or. aa > salmax ) then
                    do n = 1,nd(kk)%lnx
                       L = iabs( nd(kk)%ln(n) )
                       qsho(L) = 0d0
                    enddo
                endif
             endif
          enddo
       enddo
       !$OMP END PARALLEL DO

    endif

    do LL = 1,lnx
       if (q1(LL) .ne. 0d0) then
          call getLbotLtop(LL,Lb,Lt)
          do L = Lb, Lt
             k1 = ln(1,L) ; k2 = ln(2,L)
             if (q1(L) > 0) then
                is =  1
             else
                is = -1
             endif
             if (qsho(L) .ne. 0d0) then
                supq(k2) = supq(k2) + qsho(L)*is
                supq(k1) = supq(k1) - qsho(L)*is
             endif
             if (limtyptm > 0) then
                if (qtho(L) .ne. 0d0) then
                   tupq(k2) = tupq(k2) + qtho(L)*is
                   tupq(k1) = tupq(k1) - qtho(L)*is
                endif
             endif
             !if (limtypsd > 0) then
             !   if (qtho(L) .ne. 0d0) then
             !      sdupq(k2) = sdupq(k2) + qsdho(L)*is
             !      sdupq(k1) = sdupq(k1) - qsdho(L)*is
             !   endif
             !endif
          enddo
       endif
    enddo

   ! plotlin = alf

 endif

 if (jasal > 0 .or. jatem > 0) then

    if (dicouv >= 0d0 ) then  ! horizontal diffusion
       do LL = 1,lnx
          if (hu(LL) > 0d0) then
             !n1  = ln(1,LL) ; n2 = ln(2,LL)
             !dfac1 = 1d0/dble(nd(n1)%lnx)
             !dfac2 = 1d0/dble(nd(n2)%lnx)
!            safe for triangles, quads and pentagons, but not for hexahedrons:
             dfac1 = 0.2d0
             dfac2 = 0.2d0
             call getLbotLtop(LL,Lb,Lt)

             if (jadiusp == 1) then
                 diuspL = diusp(LL)
             else
                 diuspL = dicouv
             endif

             do L   = Lb,Lt
                k1  = ln(1,L) ; k2 = ln(2,L)
                viL = max(0d0, viu(L))
                qds = (sigsali*viL + diuspl)*dxi(LL)*au(L)
                qds = min( qds,  dfac1*( vol1(k1)/dts - sqi(k1) ) , dfac2*( vol1(k2)/dts - sqi(k2) ) ) ! zie Borsboom sobek note
                qds = max( 0d0, qds)
                if (jasal > 0) then
                   if (jacreep == 1) then
                      ds2 = dsalL(L)
                   else
                      ds2 = sa1(k2) - sa1(k1)
                   endif
                   qsa = qds*ds2
                   supq(k2) =  supq(k2) - qsa
                   supq(k1) =  supq(k1) + qsa
                endif
                if (jatem > 0) then
                   if (jacreep == 1) then
                       ds2 = dtemL(L)
                   else
                       ds2 = constituents(itemp, k2) - constituents(itemp, k1)
                   endif
                   qsa = qds*ds2
                   tupq(k2) =  tupq(k2) - qsa
                   tupq(k1) =  tupq(k1) + qsa
                endif
                if (jased > 0) then
                   do j = 1,mxgr
                      ds2 = sed(j,k2) - sed(j,k1)
                      qsa = qds*ds2
                      sdupq(j,k2) =  sdupq(j,k2) - qsa
                      sdupq(j,k1) =  sdupq(j,k1) + qsa
                   enddo
                endif

             enddo
          endif
       enddo
    endif

!   UPDATE SALT BY ADDING SALT FLUXES

    if (kmx == 0) then                                                        ! 2D


       !$OMP PARALLEL DO               &
       !$OMP PRIVATE(k,src,j)
       do k = 1,ndxi
          if ( vol1(k) > eps4 ) then
              if (jasal > 0) then
                  src = 0d0 ; if (numsrc > 0) src = salsrc(k)
                  sa1(k)  = sa1(k)   + dts*(supq(k) - sa1(k)*sq(k)  + src ) / vol1(k)
              endif
              if (jatem > 0) then
                 constituents(itemp,k)  = constituents(itemp, k)  + dts*(tupq(k) - constituents(itemp, k)*sq(k) + heatsrc(k) ) / vol1(k)
              endif
              if (jased > 0) then
                 do j = 1,mxgr
                    sed(j,k)  = sed(j,k)  + dts*(sdupq(j,k) - sed(j,k)*sq(k) ) / vol1(k)
                 enddo
              endif
           endif
       enddo
       !$OMP END PARALLEL DO

       if (jampi > 0) then

!         update sa1
          if (jasal > 0) then
             if ( jatimer.eq.1 ) call starttimer(IUPDSALL)
             call update_ghosts(ITYPE_Sall, 1, Ndx, sa1, ierror)
             if ( jatimer.eq.1 ) call stoptimer(IUPDSALL)
          endif
          if (jatem > 0) then
             if ( jatimer.eq.1 ) call starttimer(IUPDSALL)
             call update_ghosts(ITYPE_Sall, 1, Ndx, tem1, ierror)
             if ( jatimer.eq.1 ) call stoptimer(IUPDSALL)
          endif

       end if

    else                                                                      ! 3D

     tetav1 = 1d0-tetav

     !$xOMP PARALLEL DO                                                                                 &
     !$xOMP PRIVATE(kk,kb,kt,km,ku,kd,qst,qstd,qstu,ho,dif,a,b,c,d,e,java,n,adv,adv1,cf,ds1,ds2,m,ja,src)     &
     !$xOMP REDUCTION(+:sam1tot)

     do kk = 1,ndxi
        if (kfs(kk) == 0) cycle
        call getkbotktop(kk,kb,kt)
        !if ( kt < kb ) cycle
        !if ( vol1(kb) < eps10 ) cycle
        km = kt - kb + 1

        difsalw = 0d0 ; diftemw = 0d0 ; difsedw = 0d0
        if (dicoww >= 0d0 .and. hs(kk) > epshsdif) then
           if (jasal > 0) difsalw = dicoww + difmolsal
           if (jatem > 0) diftemw = dicoww + difmoltem
           if (jased > 0) difsedw = dicoww + 0d0 ! difmolsed
        endif

        if (javasal == 1 .or. javasal == 2 ) then                  ! vertical explicit
           do k = kb, kt - 1
              if (qw(k) > 0) then                                  ! ku = upwind
                 ku = k   ; kd = k+1 ; qst =  qw(k)                ! from k to k+1
              else
                 ku = k+1 ; kd = k   ; qst = -qw(k)                ! from k+1 to k
              endif

              qstd = qst*(sa1(ku) ) ! -sa1(kd))                         ! incoming - self
              qstu = qstd           ! 0d0
              if (javasal > 1) then
                 ho   = qst*(sa1(kd)-sa1(ku))*0.5d0
                 qstd = qstd + ho                                  ! ho
                 qstu = qstu + ho                                  ! ho
              endif
              if (difsalw > 0d0) then
                 dif  = (sigsali*vicwws(k) + difsalw)*(sa1(ku) - sa1(kd) )*ba(kk) / ( 0.5d0*(zws(k+1) - zws(k-1)) )
                 qstd = qstd + dif ; qstu = qstu + dif
              endif
              supq(kd) = supq(kd) + qstd
              supq(ku) = supq(ku) - qstu

           enddo

           do k = kb,kt
              if (vol1(k) > 0d0 ) then
                 src = 0d0 ; if (numsrc > 0) src = salsrc(k)
                 sa1(k)  = sa1(k)  + dts*(supq(k) - sa1(k)*sq(k) + src ) / vol1(k)
              endif
           enddo

        else if (javasal >= 3) then                                               ! vertical implicit

           java    = javasal
           if (java >= 5) then                          ! Forrester alternative: profile upwind if negative stratification
              java = 4
              if (hs(kk) < chkadvd) then
                 java = 3
              else
                 do k = kb+1, kt
                    if (sa1(k) > sa1(k-1) ) then
                       java = 3
                       exit
                    endif
                 enddo
              endif
           endif

           if (jasal > 0) then
               a(1:km) = 0d0 ; b(1:km) = 1d0 ; c(1:km) = 0d0
               src = 0d0 ; if (numsrc > 0) src = salsrc(kb)
               d(1)  = sa1(kb)  + dts*(supq(kb) - sa1(kb) *sq(kb) + src )  / vol1(kb)    ! put sa0 in d
           endif
           if (jatem > 0) then
               ta(1:km) = 0d0 ; tb(1:km) = 1d0 ; tc(1:km) = 0d0
               src   = heatsrc(kb)
               td(1) = constituents(itemp, kb) + dts*(tupq(kb) - constituents(itemp, kb)*sq(kb) + src ) / vol1(kb)     ! put sa0 in d
!              BEGIN DEBUG
!               td(1) = tem1(kb) + dts*src / vol1(kb)     ! put sa0 in d
!              END DEBUG
           endif
           if (jased > 0) then
               sa(1:km) = 0d0 ; sb(1:km) = 1d0 ; sc(1:km) = 0d0
               src   = 0d0 ! sedsrc(kk)
               do j = 1,mxgr ! grainsize loop
                  sd(1) = sed(j,kb) + dts*(sdupq(j,kb) - sed(j,kb)*sq(kb) + src ) / vol1(kb)   ! put sa0 in d
               enddo
           endif


           if (java == 3) then                          ! upwind implicit

              do k = kb, kt - 1
                 n = k - kb + 1
                 if (difsalw > 0d0) then
                    dif = dts*(sigsali*vicwws(k) + difsalw)*ba(kk) / ( 0.5d0*(zws(k+1) - zws(k-1)) )  ! m3
                 else
                    dif = 0d0
                 endif
                 if (diftemw > 0d0) then
                    dift = dts*(sigtemi*vicwws(k) + diftemw)*ba(kk) / ( 0.5d0*(zws(k+1) - zws(k-1)) )  ! m3
                 else
                    dift = 0d0
                 endif
                 if (difsedw > 0d0) then
                    difs = dts*(sigsedi*vicwws(k) + difsedw)*ba(kk) / ( 0.5d0*(zws(k+1) - zws(k-1)) )  ! m3
                 else
                    difs = 0d0
                 endif

                 if (qw(k) > 0) then
                     adv1  =  dts*qw(k) ; adv  = 0d0 ! m3
                 else if (qw(k) < 0) then
                     adv   = -dts*qw(k) ; adv1 = 0d0
                 else
                     adv = 0d0 ; adv1 = 0d0
                 endif

                 if (jasal > 0) then
                    b(n+1) = b(n+1) + ( dif  + adv *tetav) / vol1(k+1)
                    a(n+1) = a(n+1) - ( dif  + adv1*tetav) / vol1(k+1)
                    b(n  ) = b(n  ) + ( dif  + adv1*tetav) / vol1(k  )
                    c(n  ) = c(n  ) - ( dif  + adv *tetav) / vol1(k  )
                 endif

                 if (jatem > 0) then
                    tb(n+1) = tb(n+1) + ( dift  + adv *tetav) / vol1(k+1)
                    ta(n+1) = ta(n+1) - ( dift  + adv1*tetav) / vol1(k+1)

                    tb(n  ) = tb(n  ) + ( dift  + adv1*tetav) / vol1(k  )
                    tc(n  ) = tc(n  ) - ( dift  + adv *tetav) / vol1(k  )
                 endif

                 if (jased > 0) then
                    sb(n+1) = sb(n+1) + ( difs  + adv *tetav) / vol1(k+1)
                    sa(n+1) = sa(n+1) - ( difs  + adv1*tetav) / vol1(k+1)

                    sb(n  ) = sb(n  ) + ( difs  + adv1*tetav) / vol1(k  )
                    sc(n  ) = sc(n  ) - ( difs  + adv *tetav) / vol1(k  )
                 endif

                 if (jasal > 0) then
                    src = 0d0 ; if (numsrc > 0) src = salsrc(k+1)
                    d(n+1) = sa1(k+1) + dts*( supq(k+1) - sa1(k+1)*sq(k+1) + src) / vol1(k+1)              ! horizontal explicit, org allinout
                    if (tetav .ne. 1d0) then
                       d(n+1) = d(n+1) - tetav1*( sa1(k+1)*adv  - sa1(k)  *adv1 ) / vol1(k+1)
                       d(n  ) = d(n  ) - tetav1*( sa1(k  )*adv1 - sa1(k+1)*adv  ) / vol1(k  )
                    endif
                 endif

                 if (jatem > 0) then
                    src     = heatsrc(k+1)
                    td(n+1) = constituents(itemp, k+1) + dts*( tupq(k+1) - constituents(itemp, k+1)*sq(k+1) + src  )  / vol1(k+1)

                    if (tetav .ne. 1d0) then
                       td(n+1) = td(n+1) - tetav1*(  constituents(itemp,k+1)*adv  - constituents(itemp, k)  *adv1 ) / vol1(k+1)
                       td(n  ) = td(n  ) - tetav1*(  constituents(itemp,k  )*adv1 - constituents(itemp, k+1)*adv  ) / vol1(k  )
                    endif
                 endif

                 if (jased > 0) then
                    do j = 1,mxgr ! grainsize loop
                       src     = 0d0 ! sedsrc(k+1)
                       sd(n+1) = sed(j,k+1) + dts*( sdupq(j,k+1) - sed(j,k+1)*sq(k+1) + src  )  / vol1(k+1)

                       if (tetav .ne. 1d0) then
                          sd(n+1) = td(n+1) - tetav1*( sed(j,k+1)*adv  - sed(j,k)  *adv1 ) / vol1(k+1)
                          sd(n  ) = td(n  ) - tetav1*( sed(j,k  )*adv1 - sed(j,k+1)*adv  ) / vol1(k  )
                       endif
                    enddo
                 endif


               !                     b(k+1):+adv   / vol1(k+1)    a(k+1):-adv1 / vol1(k+1)
               !  d(n+1) = d(n+1) - sa0(k+1)*adv   / vol1(k+1) + sa0(k)  *adv1 / vol1(k+1)  ! allinout explicit:
               !  d(n  ) = d(n  ) - sa0(k  )*adv1  / vol1(k)   + sa0(k+1)*adv  / vol1(k  )
               !                     b(k  ):+adv1  / vol1(k)      c(k)  :-adv  / vol1(k  )


              enddo

           else if (java == 4) then                             ! central implicit

              do k = kb, kt - 1
                 n = k - kb + 1

                 if (difsalw > 0d0) then
                    dif  = dts*(sigsali*vicwws(k) + difsalw)*ba(kk) / ( 0.5d0*(zws(k+1) - zws(k-1)) )  ! m3
                 else
                    dif = 0d0
                 endif
                 if (diftemw > 0d0) then
                    dift = dts*(sigtemi*vicwws(k) + diftemw)*ba(kk) / ( 0.5d0*(zws(k+1) - zws(k-1)) )  ! m3
                 else
                    dift = 0d0
                 endif
                 if (difsedw > 0d0) then
                    difs = dts*(sigsedi*vicwws(k) + difsedw)*ba(kk) / ( 0.5d0*(zws(k+1) - zws(k-1)) )  ! m3
                 else
                    difs = 0d0
                 endif

                 adv     = 0.5d0*dts*qw(k)*tetav
!                BEGIN DEBUG
!                 adv     = 0d0
!                 dift    = 0d0
!                 dift = dts*(diftemw)*ba(kk) / ( 0.5d0*(zws(k+1) - zws(k-1)) )  ! m3
!                END DEBUG

                 if (jasal > 0) then
                    b(n+1)  = b(n+1)  + (dif - adv) / vol1(k+1)
                    a(n+1)  = a(n+1)  - (dif + adv) / vol1(k+1)

                    b(n  )  = b(n  )  + (dif + adv) / vol1(k)
                    c(n  )  = c(n  )  - (dif - adv) / vol1(k)
                 endif

                 if (jatem > 0) then
                    tb(n+1) = tb(n+1) + ( dift  - adv ) / vol1(k+1)
                    ta(n+1) = ta(n+1) - ( dift  + adv ) / vol1(k+1)

                    tb(n  ) = tb(n  ) + ( dift  + adv ) / vol1(k  )
                    tc(n  ) = tc(n  ) - ( dift  - adv ) / vol1(k  )
                 endif

                 if (jased > 0) then
                    sb(n+1) = sb(n+1) + ( difs  - adv ) / vol1(k+1)
                    sa(n+1) = sa(n+1) - ( difs  + adv ) / vol1(k+1)

                    sb(n  ) = sb(n  ) + ( difs  + adv ) / vol1(k  )
                    sc(n  ) = sc(n  ) - ( difs  - adv ) / vol1(k  )
                 endif

                 if (jasal > 0) then
                    src = 0d0 ; if (numsrc > 0) src = salsrc(k+1)
                    d(n+1)  = sa1(k+1) + dts*( supq(k+1) - sa1(k+1)*sq(k+1) + src ) / vol1(k+1)
                    if (tetav .ne. 1d0) then
                       adv    = 0.5d0*dts*qw(k)*tetav1*(sa1(k) + sa1(k+1))
                       d(n+1) = d(n+1) + adv/vol1(k+1)
                       d(n  ) = d(n  ) - adv/vol1(k)
                    endif
                 endif

                 if (jatem  > 0) then
                    src     = heatsrc(k+1)
                    td(n+1) = constituents(itemp,k+1) + dts*( tupq(k+1) - constituents(itemp, k+1)*sq(k+1) + src ) / vol1(k+1)
                    if (tetav .ne. 1d0) then
                       adv     = 0.5d0*dts*qw(k)*tetav1*( constituents(itemp, k) + constituents(itemp, k+1) )
                       td(n+1) = td(n+1) + adv/vol1(k+1)
                       td(n  ) = td(n  ) - adv/vol1(k)
                    endif
                 endif

                 if (jased  > 0) then
                    src     = 0d0 ! sedsrc(k+1)
                    sd(n+1) = sed(1,k+1) + dts*( supq(k+1) - sed(1,k+1)*sq(k+1) + src ) / vol1(k+1)
                    if (tetav .ne. 1d0) then
                       adv    = 0.5d0*dts*qw(k)*tetav1*(sed(1,k) + sed(1,k+1))
                       sd(n+1) = sd(n+1) + adv/vol1(k+1)
                       sd(n  ) = sd(n  ) - adv/vol1(k)
                    endif
                 endif


              enddo


           endif

           !do k    = kb, kt   check
           !   n    = k - kb + 1
           !   sa1(k) = d(n)
           !   if (n > 1) then
           !     sa1(k) = sa1(k) - a(n)*sa0(k-1)
           !   endif
           !   if (n < km) then
           !     sa1(k) = sa1(k) - c(n)*sa0(k+1)
           !   endif
           !
           !   sa1(k) = sa1(k) / ( b(n) -1 )
           !enddo


           if (jasal > 0) then
              call tridag(a,b,c,d,e,sa1(kb:kt),km)
           endif
           if (jatem > 0) then
              call tridag(ta,tb,tc,td,e,tem1(kb:kt),km)
              constituents(itemp, kb:kt) = tem1(kb:kt)
           endif
           if (jased > 0) then
              do j = 1,mxgr
                 call tridag(sa,sb,sc,sd,e,sed(j,kb:kt),km)
              enddo
           endif


        endif

        if (maxitverticalforestersal > 0) then

            call foresterpoint(sa1(kb:), vol1(kb:), a, d, km, kmxn(kk), maxitverticalforestersal, 1)

        endif

        if (maxitverticalforestertem > 0) then

            call foresterpoint2(constituents, numconst, ndkx, itemp, vol1(kb:), a, d, km, kmxn(kk), kb, maxitverticalforestertem, -1)

        endif

     end do
     !$xOMP END PARALLEL DO

       if ( jampi.eq.1 ) then
!         update sa1
          if ( jatimer.eq.1 ) call starttimer(IUPDSALL)
          if (jasal > 0) then
          call update_ghosts(ITYPE_Sall3D, 1, Ndkx, sa1, ierror)
          endif
          if (jatem > 0) then
             call update_ghosts(ITYPE_Sall3D, 1, Ndkx, tem1, ierror)
          endif
          if ( jatimer.eq.1 ) call stoptimer(IUPDSALL)
       end if
    endif ! 3D

! begin DEBUG
1234 continue
    if ( jatransportmodule.eq.1 ) then
       call apply_tracer_bc()
       call update_constituents(0) ! do all constituents
    end if
! end DEBUG

   if ( jasal.gt.0 ) then    !  compute salt error

      if (jatransportmodule == 0) sam0 = sam1
      sam0tot = sam1tot
      sam1tot = 0d0

     !$OMP PARALLEL DO                &
     !$OMP PRIVATE(kk,kb,kt,km,k)     &
     !$OMP REDUCTION(+:sam1tot)
     do kk = 1,ndxi
        call getkbotktop(kk,kb,kt)
        if ( kt < kb ) cycle
        if ( vol1(kb) < eps10 ) cycle
        km = kt - kb + 1

        do k = kb,kt
            sam1tot = sam1tot + sa1(k)*vol1(k)
            if (jatransportmodule == 0) then
               sam1(k) =        sa1(k)*vol1(k)            ! mass balance
               same(k) = sam1(k) - sam0(k) - dts*( supq(k) + salsrc(k) )    ! mass balance
            endif
        enddo
     enddo
     !$OMP END PARALLEL DO

       saminbnd = 0d0 ; samoutbnd = 0d0

      do LL = lnxi + 1, 0 !  lnx                                ! copy on outflow
          call getLbotLtop(LL,Lb,Lt)
          if (Lt < Lb) then
              cycle
          endif
          do L = Lb, Lt
             kb = ln(1,L) ; ki = ln(2,L)
             if (q1(L) > 0) then
                saminbnd  = saminbnd  + q1(L)*sa1(kb)*dts   ! mass in
             else
                samoutbnd = samoutbnd - ( q1(L)*sa1(ki)+qsho(L) ) *dts   ! mass out
             endif
          enddo
       enddo
      samerr = sam1tot - sam0tot !  - saminbnd + samoutbnd
   endif

  !$OMP PARALLEL DO             &
  !$OMP PRIVATE(kk,kb,kt,k)
   do kk = 1,ndx ! i
      call getkbotktop(kk,kb,kt)
      if ( kt < kb ) cycle
      do k = kb,kt
         rho(k)  = setrho(k)
      enddo
      do k = kt+1 , kb + kmxn(kk) - 1
         rho(k) = rho(kt)
      enddo
   enddo
   !$OMP END PARALLEL DO


   ! propagate rho

   if (jabaroctimeint == 5) then  ! rho advection
       dts  = 0.5d0*dts
       if (jarhoxu > 0) then
           rho0 = rho
       endif
       call update_constituents(1) ! do rho only
       dts = 2.0d0*dts
   endif

 endif

 if (jarhoxu > 0 .and. jacreep == 1) then
     do LL = 1,lnx
        do L = Lbot(LL), Ltop(LL)
           k1 = ln(1,L) ; k2 = ln(2,L)
           rhou(L) = 0.5d0*( rho(k1) + rho(k2) )
        enddo
     enddo
 endif

 if (jatem > 0d0) then
    ! tem1 = tem1 - 50d0 ! tkelvn
 endif

 if (jased > 0 .and. jased < 4) then

    dmorfax = max(1d0,dmorfac)

    if ( jaceneqtr == 1) then           ! original cell centre equilibriumtransport approach

       if (dmorfac > 0d0) then
          blinc = 0d0
       endif

       jastep = 1 ! 1 = first hor. transport, then limiting

       !$OMP PARALLEL DO    &
       !$OMP PRIVATE(k,flx,seq,wse,hsk,dtvi,wsemx,j,qb,kj,dgrlay,kb) &
       !$OMP REDUCTION(+:dvolbot)
       do k  = 1,ndxi
          kb = kbot(k)
          if (vol1(kb) > 0d0) then

             flx = 0d0
             if (kmx == 0) then
                call getequilibriumtransportrates(k, seq, wse, mxgr, hsk)                     ! get per flowcell and store in small array seq
             else
                wse    = ws
                seq(1) = 0d0
             endif

             dtvi  = dts/vol1(kb)
             wsemx = 0.45d0*vol1(kb) / ( ba(k)*dts )
             do j  = 1,mxgr

                if ( Wse(j) > wsemx) then
                     Wse(j) = wsemx
                endif
                qb = Wse(j)*ba(k)                                                             ! (m3/s)

                if (jastep == 0) then
                   flx(j)    = qb*( seq(j) - sed(j,kb) )                                      ! (m3/s).(kg/m3) = kg/s   , positive = erosion
                   sed(j,kb) = sed(j,kb) + dtvi*(sdupq(j,kb) + flx(j) )                       ! horizontal + vertical transport
                else
                   sed(j,kb) = sed(j,kb) + dtvi*(sdupq(j,kb)          )                       ! horizontal transport
                   flx(j)    = qb*( seq(j) - sed(j,kb) )                                      ! (m3/s).(kg/m3) = kg/s   , positive = erosion
                   sed(j,kb) = sed(j,kb) + dtvi*(            + flx(j) )                       ! vertical transport
                endif

                dgrlay      = - dts*dmorfax*flx(j) / (rhosed(j)*ba(k)*rhobulkrhosed)          ! (s)*( )* (kg/s) * (m3 / kg) / m2 = (m)

                if (jamorf   == 1) then
                    grainlay(j,k) = grainlay(j,k)  + dgrlay
                    blinc(k)      = blinc(k)       + dgrlay
                    dvolbot       = dvolbot        + dgrlay*ba(k)
                endif

             enddo

          else

             sed( :, k ) = 0d0

          endif
       enddo
       !$OMP END PARALLEL DO


    else


       if (jatransportmodule == 0) then
          !$OMP PARALLEL DO    &
          !$OMP PRIVATE(k,j,dtvi,kb)
          do k = 1,ndxi
             kb = kbot(k)
             if (vol1(kb) > 0d0) then                                            ! horizontal transport over flow nodes
                dtvi = dts/vol1(kb)
                do j = 1,mxgr
                   sed(j,kb) = sed(j,kb) + dtvi*(sdupq(j,kb) - sed(j,kb)*sq(kb) )    ! horizontal transport
                enddo
             else
                sed(:, kb) = 0d0
             endif
          enddo
          !$OMP END PARALLEL DO
       endif

       sedi = 0d0

       !$OMP PARALLEL DO    &
       !$OMP PRIVATE(kk,flx, seq, wse, hsk,n,k,dtvi,wsemx,j,qb,dgrlay,kb) &
       !$OMP REDUCTION(+:dvolbot)

       do kk = 1,mxban

          flx = 0d0

          call getequilibriumtransportrates(kk, seq, wse, mxgr, hsk)    ! get per netnode and store in small array seq

          n  = nban(1,kk)  ! net node
          k  = nban(2,kk)  ! flow node
          kb = kbot(k)

          if ( vol1(kb) > 0 .and. hsk > 0) then

             dtvi  = dts/vol1(kb)                                       ! (s/m3)
             wsemx = 0.45d0*vol1(kb) / ( ba(k)*dts )                    ! (m/s) was 0.45

             do j  = 1,mxgr
                if ( Wse(j) > wsemx) then
                     Wse(j) = wsemx
                endif
                qb = Wse(j) * banf(kk)                                  ! (m3/s)
                flx(j)      = qb*( seq(j) - sed(j,kb) )                 ! (m3/s).(kg/m3) = kg/s   , positive = erosion

                !  if (zk(n) > skmx(n) ) then                           ! no flux if net point above max surrouding waterlevels
                !     flx(j) = max( 0d0, flx(j) )
                !  endif

                sedi(j,k)   = sedi(j,k)  + dtvi*flx(j)                  ! vertical transport (s/m3)*(kg/s) = (kg/m3)

                dgrlay      = - dts*dmorfax*flx(j)  / (rhosed(j)*ban(n)*rhobulkrhosed)      ! (s)*( )* (kg/s) * (m3 / kg) * (1/m2) = m

                if (jamorf == 1) then
                    grainlay(j,n) = grainlay(j,n)    + dgrlay
                    zk(n)         = zk(n)            + dgrlay
                    dvolbot       = dvolbot + banf(kk)*dgrlay
                endif

             enddo

          endif


       enddo
       !$OMP END PARALLEL DO

       !$OMP PARALLEL DO    &
       !$OMP PRIVATE(k,j,kb)
       do k = 1,ndxi
          kb = kbot(k)
          do j  = 1,mxgr
             sed(j,kb) = max(0d0, sed(j,kb) + sedi(j,k) )
          enddo
       enddo
       !$OMP END PARALLEL DO

    endif ! jacenterfluxes

 endif    ! jased


 do LL = lnxi + 1, lnx                           ! copy on outflow
    call getLbotLtop(LL,Lb,Lt)
    if (Lt < Lb) then
        cycle
    endif
    do L = Lb, Lt
       if (q1(L) < 0) then
          kb = ln(1,L) ; ki = ln(2,L)
          if (jasal > 0 .and. keepstbndonoutflow == 0) then
              sa1(kb)  = sa1(ki)
          endif
          if (jatem > 0  .and. keepstbndonoutflow == 0) then
              constituents(itemp, kb) = constituents(itemp,ki)
          endif
          if (jased > 0) then
             do j = 1,mxgr
                sed(j,kb) = sed(j,ki)
             enddo
          endif
       endif
    enddo
 enddo

 if (kplotordepthaveraged == 2) then
    if (jasal > 0) then
       call getverticallyaveraged(sa1,ndkx)
    endif
 endif

end subroutine transport

subroutine getverticallyaveraged(sal,mx)
use m_flow
use m_flowgeom
Implicit none
double precision :: sal(mx)
integer          :: n, k, kb, kt, mx

do n = 1,ndx
   call getkbotktop(n,kb,kt)
   sal(n) = 0d0
   if (vol1(n) > 0) then
      do k = kb,kt
         sal(n) = sal(n) + sal(k)*vol1(k)
      enddo
      sal(n) = sal(n)/vol1(n)
   endif
enddo
end subroutine getverticallyaveraged

subroutine foresterpoint(temp, vol, a, d, km, kmxx, maxit, ip)
use m_flow, only  : eps6, eps10
implicit none

double precision :: temp(kmxx), vol(kmxx), a(km), d(km)
integer          :: km, kmxx, maxit, ip

double precision :: dif
integer          :: k, m, n, ja

a(1:km) = temp(1:km)

do m = 1, maxit

   d(1:km) = a(1:km)
   ja      = 0

   do k = 1, km - 1
      dif = d(k+1) - d(k)
      if (dif*ip > eps6 .or. d(k) < 0d0 .or. d(k+1) < 0d0 ) then
         if ( vol(k) > eps10 .and. vol(k+1) > eps10 ) then
             ja     = 1
             dif    = 0.1666666666667d0*dif*(vol(k+1) + vol(k))
             a(k)   = a(k)   + dif / vol(k)
             a(k+1) = a(k+1) - dif / vol(k+1)
         else
             dif = 0d0
         endif
      endif
   enddo

   if (ja == 0) then
       exit
   endif

enddo

temp(1:km) = a(1:km)

if (kmxx > km) then
   temp(km+1:kmxx) = temp(km)
endif

   end subroutine foresterpoint

subroutine foresterpoint2(constituents, numconst, ndkx, itemp, vol, a, d, km, kmxx, kb, maxit, ip)
use m_flow, only  : eps6, eps10
implicit none

double precision :: constituents(numconst, ndkx), vol(kmxx), a(km), d(km)
integer          :: numconst, ndkx, itemp, km, kmxx, kb, maxit, ip

double precision :: dif
integer          :: k, m, n, ja

do k = 1,km
   a(k) = constituents(itemp, kb+k-1)
enddo

do m = 1, maxit

   d(1:km) = a(1:km)
   ja      = 0

   do k = 1, km - 1
      dif = d(k+1) - d(k)
      if (dif*ip > eps6 .or. d(k) < 0d0 .or. d(k+1) < 0d0 ) then
         if ( vol(k) > eps10 .and. vol(k+1) > eps10 ) then
             ja     = 1
             dif    = 0.1666666666667d0*dif*(vol(k+1) + vol(k))
             a(k)   = a(k)   + dif / vol(k)
             a(k+1) = a(k+1) - dif / vol(k+1)
         else
             dif = 0d0
         endif
      endif
   enddo

   if (ja == 0) then
       exit
   endif

enddo

do k = 1,km
   constituents(itemp, kb+k-1) = a(k)
enddo
if (kmxx > km) then
   constituents(itemp, kb+km:kb+kmxx-1) = a(km)
endif

end subroutine foresterpoint2


subroutine addbaroclinicpressure()
use m_flowgeom
use m_flow
implicit none
integer                    :: L,LL,Lb,Lt,k1,k2
double precision, external :: hordiflimited
double precision           :: hordif,baroc,barocup


if (jabarocterm == 1) then

!$OMP PARALLEL DO       &
!$OMP PRIVATE(LL,Lb,Lt)

do LL = 1,lnxi
   if (hu(LL) == 0d0) cycle
   call getLbotLtop(LL,Lb,Lt)
   if (Lt < Lb) then
       cycle
   endif
   call addbaroc(LL,Lb,Lt)
enddo

!$OMP END PARALLEL DO

else

!$OMP PARALLEL DO       &
!$OMP PRIVATE(LL,Lb,Lt)

do LL = 1,lnxi
   if (hu(LL) == 0d0) cycle
   call getLbotLtop(LL,Lb,Lt)
   if (Lt < Lb) then
       cycle
   endif
   call addbaroc2(LL,Lb,Lt)
 enddo

!$OMP END PARALLEL DO

 endif

 end subroutine addbaroclinicpressure


 subroutine addbaroc2(LL,Lb,Lt)
 use m_flowgeom
 use m_flow

 implicit none
 integer              :: LL,Lb,Lt

 double precision     :: gradpu(kmxx), rhovol(kmxx), dz1(kmxx), dz2(kmxx)
 double precision     :: z1u,z1d,z2u,z2d,  p1u,p1d,p2u,p2d,  r1u,r1d,r2u,r2d,  dz3, d2
 double precision     :: barotr, barocl, alf1,alf2,alf3,gr1,gr2,gr3, zh, hdx, fzu1, fzd1, fzu2, fzd2, dzz, dxx, rvd, rv, vv, rvv, r
 integer              :: k1, k2, L

 ! rho = rhomean
 ! do L = Lb, Lt
 !    k1 = ln(1,L)
 !    rho(k1) = rhomean + 0.5d0*(zws(k1) + zws(k1-1))
 !    k2 = ln(2,L)
 !    rho(k2) = rhomean + 0.5d0*(zws(k2) + zws(k2-1))
 ! enddo

 if (kmx == 0) then
    k1 = ln(1,LL) ; k2 = ln(2,LL)
    barocl   = ag*( rho(k1) - rho(k2) )*hu(LL)*dxi(LL) / ( ( rho(k2) + rho(k1) ) )
    if (jarhoxu > 0) then
       rhou(LL) =  0.5d0*( rho(k2) + rho(k1) )
    endif
    adve(LL) = adve(LL) - barocL
    return
 endif

 if (zws(ln(1,Lt)) - zws(ln(1,Lb)-1) < epshs) return

 if (zws(ln(2,Lt)) - zws(ln(2,Lb)-1) < epshs) return

 do L = Lb, Lt
    k1 = ln(1,L)
    dz1(L-Lb+1) = max(1d-6, zws(k1) - zws(k1-1) )
 enddo

 do L = Lb, Lt
    k2 = ln(2,L)
    dz2(L-Lb+1) = max(1d-6, zws(k2) - zws(k2-1) )
 enddo

 k1   = ln(1,Lt)   ; k2  = ln(2,Lt)

 if (Lt > Lb) then
    d2   = (dz1(Lt-Lb+1) + dz1(Lt-Lb) )
    fzu1 = dz1(Lt-Lb+1) /  d2 ; fzd1 = 1d0 - fzu1

    d2   = (dz2(Lt-Lb+1) + dz2(Lt-Lb) )
    fzu2 = dz2(Lt-Lb+1) /  d2 ; fzd2 = 1d0 - fzu2

    if (jabaroctimeint == 2) then ! extrapolate rho at n+0.5
       r1d  = (2d0-fzu1)*(1.5d0*rho(k1) - 0.5d0*rho0(k1)) - fzd1*(1.5d0*rho(k1-1) - 0.5d0*rho0(k1-1)) - rhomean
       r2d  = (2d0-fzu2)*(1.5d0*rho(k2) - 0.5d0*rho0(k2)) - fzd2*(1.5d0*rho(k2-1) - 0.5d0*rho0(k2-1)) - rhomean
    else
       r1d  = (2d0-fzu1)*rho(k1) - fzd1*rho(k1-1) - rhomean
       r2d  = (2d0-fzu2)*rho(k2) - fzd2*rho(k2-1) - rhomean
    endif

    ! r1d = 1.5d0*rho(k1) - 0.5d0*rho(k1-1) - rhomean
    ! r2d = 1.5d0*rho(k2) - 0.5d0*rho(k2-1) - rhomean

 else
    if (jabaroctimeint == 2 ) then ! extrapolate rho at n+0.5
       r1d  = 1.5d0*rho(k1) - 0.5d0*rho0(k1) - rhomean
       r2d  = 1.5d0*rho(k2) - 0.5d0*rho0(k2) - rhomean
     else
       r1d  = rho(k1) - rhomean
       r2d  = rho(k2) - rhomean
     endif
 endif

 z1d = zws(k1)    ; z2d = zws(k2)
 p1d = 0d0        ; p2d = 0d0

 ! barotr = ag*(z2d - z1d) / dx(LL)
 ! r1d = abs(z1d) ; r2d = abs(z2d)  ! forced horizontal

 gradpu(1:Lt-Lb+1) = 0d0
 rhovol(1:Lt-Lb+1) = 0d0
 dxx               = dx(LL)
 hdx               = 0.5d0*dxx

 if (jabarocterm == 3) then
    gr3 = 0d0
    if (z1d > z2d) then              ! baroclinic contribution at free surface
       dz3  = z1d - z2d
       alf3 = r2d - r1d
       gr3  = p1d*dz3 + 0.5d0*r1d*dz3*dz3 + alf3*dz3*dz3/6d0
    else if (z1d < z2d) then
       dz3  = z2d - z1d
       alf3 = r1d - r2d
       gr3  = p2d*dz3 + 0.5d0*r2d*dz3*dz3 + alf3*dz3*dz3/6d0
       gr3  = -gr3
    endif
    gradpu(Lt-Lb+1) = gradpu(Lt-Lb+1) - gr3
 endif

 rvd  = 0d0
 do L = Lt, Lb, -1
    k1   = ln(1,L)   ; k2  = ln(2,L)            !
    z1u  = z1d       ; z2u = z2d
    r1u  = r1d       ; r2u = r2d
    p1u  = p1d       ; p2u = p2d

    z1d  = zws(k1-1) ; z2d = zws(k2-1)

    if (L > Lb) then
        fzu1 = dz1(L-Lb+1) / (dz1(L-Lb+1) + dz1(L-Lb) )   ; fzd1 = 1d0 - fzu1
        fzu2 = dz2(L-Lb+1) / (dz2(L-Lb+1) + dz2(L-Lb) )   ; fzd2 = 1d0 - fzu2
        if (jabaroctimeint == 2 ) then ! extrapolate rho at n+0.5
           r1d  = fzu1*(1.5d0*rho(k1)-0.5d0*rho0(k1)) + fzd1*(1.5d0*rho(k1-1)-0.5d0*rho0(k1-1)) - rhomean
           r2d  = fzu2*(1.5d0*rho(k2)-0.5d0*rho0(k2)) + fzd2*(1.5d0*rho(k2-1)-0.5d0*rho0(k2-1)) - rhomean
        else
           r1d  = fzu1*rho(k1) + fzd1*rho(k1-1) - rhomean
           r2d  = fzu2*rho(k2) + fzd2*rho(k2-1) - rhomean
        endif
    else
        if (Lt > Lb) then
           fzu1 = dz1(L-Lb+2) / (dz1(L-Lb+1) + dz1(L-Lb+2) ) ; fzd1 = 1d0 - fzu1
           fzu2 = dz2(L-Lb+2) / (dz2(L-Lb+1) + dz2(L-Lb+2) ) ; fzd2 = 1d0 - fzu2
           if (jabaroctimeint == 2 ) then ! extrapolate rho at n+0.5
              r1d  = (2d0-fzd1)*(1.5d0*rho(k1)-0.5d0*rho0(k1))  - fzu1*(1.5d0*rho(k1+1)-0.5d0*rho0(k1+1)) - rhomean
              r2d  = (2d0-fzd2)*(1.5d0*rho(k2)-0.5d0*rho0(k2))  - fzu2*(1.5d0*rho(k2+1)-0.5d0*rho0(k2+1)) - rhomean
           else
              r1d  = (2d0-fzd1)*rho(k1) - fzu1*rho(k1+1) - rhomean
              r2d  = (2d0-fzd2)*rho(k2) - fzu2*rho(k2+1) - rhomean
           endif
        else
           if (jabaroctimeint == 2 ) then ! extrapolate rho at n+0.5
              r1d  = 1.5d0*rho(k1) -0.5d0*rho0(k1) - rhomean
              r2d  = 1.5d0*rho(k2) -0.5d0*rho0(k2) - rhomean
           else
              r1d  = rho(k1) - rhomean
              r2d  = rho(k2) - rhomean
           endif
        endif
    endif

    if (dz1(L-Lb+1) + dz2(L-Lb+1) < 1d-10) then
       rhovol(L-Lb+1) = 1d-10 ; cycle
    else
       rhovol(L-Lb+1) = rhovol(L-Lb+1)    + dz1(L-Lb+1) *( rhomean+0.5d0*(r1u+r1d) )*hdx     ! left  interface Mass
       rhovol(L-Lb+1) = rhovol(L-Lb+1)    + dz2(L-Lb+1) *( rhomean+0.5d0*(r2u+r2d) )*hdx     ! right interface
       if (jarhoxu > 0) rhou(L) = rhovol(L-Lb+1) / ( (dz1(L-Lb+1)+dz2(L-Lb+1))*hdx )
    endif

    dzz  = dz1(L-Lb+1)
    alf1 = r1d - r1u
    p1d  = p1u + r1u*dzz + 0.5d0*alf1*dzz
    gr1  = p1u*dzz + 0.5d0*r1u*dzz*dzz + alf1*dzz*dzz/6d0             ! your left  wall

    dzz  = dz2(L-Lb+1)
    alf2 = r2d - r2u
    p2d  = p2u + r2u*dzz + 0.5d0*alf2*dzz                             ! alf2 ipv alf1
    gr2  = p2u*dzz + 0.5d0*r2u*dzz*dzz + alf2*dzz*dzz/6d0             ! your right wall

    if (jabarocterm == 3) then
       gr3 = 0d0 ; dz3 = 0d0
       if (z1d > z2d) then
          dz3  = z1d - z2d
          alf3 = r2d - r1d
          gr3  = p1d*dz3 + 0.5d0*r1d*dz3*dz3 + alf3*dz3*dz3/6d0          ! your own floor
       else if (z1d < z2d) then
          dz3  = z2d - z1d
          alf3 = r1d - r2d
          gr3  = p2d*dz3 + 0.5d0*r2d*dz3*dz3 + alf3*dz3*dz3/6d0          ! your own floor (kg*m2)
          gr3  = -gr3
       endif
    else
       vv  = 0.5d0*( dz1(L-Lb+1) + dz2(L-Lb+1) )                         ! integrate rho volume
       r   = 0.25d0*( r1u + r1d + r2u + r2d )
       rvv = r*vv
       rvd = rvd + rvv
       gr3 = rvd*(z1d - z2d)
    endif


       gradpu(L-Lb+1) = gradpu(L-Lb+1)   + gr1 - gr2 + gr3
    if (L > Lb ) then
       gradpu(L-Lb)   = gradpu(L-Lb)                 - gr3            ! ceiling of ff# downstairs neighbours
    endif

 enddo

 if (jabaroctimeint == 3) then                                           ! original AB implementation

    do L = Lb, Lt
       if (rhovol(L-Lb+1) > 0d0) then
           barocl    = ag*gradpu(L-Lb+1)/rhovol(L-Lb+1)                  !  
           adve(L)   = adve(L) - 1.5d0*barocl + 0.5d0*dpbdx0(L)
           dpbdx0(L) = barocL
        endif
    enddo

 else if (jabaroctimeint == 4) then                                      ! AB + better drying flooding

    do L = Lb, Lt
       if (rhovol(L-Lb+1) > 0d0) then
           barocl  = ag*gradpu(L-Lb+1)/rhovol(L-Lb+1)                    
           if (dpbdx0(L) .ne. 0d0) then                                  
               adve(L)   = adve(L) - 1.5d0*barocl + 0.5d0*dpbdx0(L)
           else 
               adve(L)   = adve(L) - barocl
           endif
           dpbdx0(L) = barocL
       endif
    enddo
    
    do L = Lt+1,Lb+kmxL(LL)-1 
       dpbdx0(L) = 0d0
    enddo

 else

    do L = Lb, Lt
        if (rhovol(L-Lb+1) > 0d0) then
           barocl  = ag*gradpu(L-Lb+1)/rhovol(L-Lb+1)                     !  Explicit 
           adve(L)   = adve(L) - barocl
       endif
    enddo

 endif

 end subroutine addbaroc2


subroutine addbaroc(LL,Lb,Lt)  ! this routine is wrong, here only for backward comp
 use m_flowgeom
 use m_flow

 implicit none
 integer              :: LL,Lb,Lt

 double precision     :: gradpu(kmxx), rhovol(kmxx), dz1(kmxx), dz2(kmxx)
 double precision     :: z1u,z1d,z2u,z2d,  p1u,p1d,p2u,p2d,  r1u,r1d,r2u,r2d,  dz3, d2
 double precision     :: barotr, barocl, alf1,alf2,alf3,gr1,gr2,gr3, zh, hdx, fzu1, fzd1, fzu2, fzd2, dzz, dxx
 integer              :: k1, k2, L

 ! rho = rhomean
 ! do L = Lb, Lt
 !    k1 = ln(1,L)
 !    rho(k1) = rhomean + 0.5d0*(zws(k1) + zws(k1-1))
 !    k2 = ln(2,L)
 !    rho(k2) = rhomean + 0.5d0*(zws(k2) + zws(k2-1))
 ! enddo

 if (kmx == 0) then
    k1 = ln(1,LL) ; k2 = ln(2,LL)
    barocl   = ag*( rho(k1) - rho(k2) )*hu(LL)*dxi(LL) / ( ( rho(k2) + rho(k1) ) )
    adve(LL) = adve(LL) - barocL
    return
 endif

 if (zws(ln(1,Lt)) - zws(ln(1,Lb)-1) < epshs) return

 if (zws(ln(2,Lt)) - zws(ln(2,Lb)-1) < epshs) return

 do L = Lb, Lt
    k1 = ln(1,L)
    dz1(L-Lb+1) = max(1d-6, zws(k1) - zws(k1-1) )
 enddo

 do L = Lb, Lt
    k2 = ln(2,L)
    dz2(L-Lb+1) = max(1d-6, zws(k2) - zws(k2-1) )
 enddo

 k1   = ln(1,Lt)   ; k2  = ln(2,Lt)

 if (Lt > Lb) then
    d2   = (dz1(Lt-Lb+1) + dz1(Lt-Lb) )
    fzu1 = dz1(Lt-Lb+1) /  d2 ; fzd1 = 1d0 - fzu1

    d2   = (dz2(Lt-Lb+1) + dz2(Lt-Lb) )
    fzu2 = dz2(Lt-Lb+1) /  d2 ; fzd2 = 1d0 - fzu2

    if (jabaroctimeint == 2) then ! extrapolate rho at n+0.5
       r1d  = (2d0-fzu1)*(1.5d0*rho(k1) - 0.5d0*rho0(k1)) - fzd1*(1.5d0*rho(k1-1) - 0.5d0*rho0(k1-1)) - rhomean
       r2d  = (2d0-fzu2)*(1.5d0*rho(k2) - 0.5d0*rho0(k2)) - fzd2*(1.5d0*rho(k2-1) - 0.5d0*rho0(k2-1)) - rhomean
    else
       r1d  = (2d0-fzu1)*rho(k1) - fzd1*rho(k1-1) - rhomean
       r2d  = (2d0-fzu2)*rho(k2) - fzd2*rho(k2-1) - rhomean
    endif

    ! r1d = 1.5d0*rho(k1) - 0.5d0*rho(k1-1) - rhomean
    ! r2d = 1.5d0*rho(k2) - 0.5d0*rho(k2-1) - rhomean

 else
    if (jabaroctimeint == 2 ) then ! extrapolate rho at n+0.5
       r1d  = 1.5d0*rho(k1) - 0.5d0*rho0(k1) - rhomean
       r2d  = 1.5d0*rho(k2) - 0.5d0*rho0(k2) - rhomean
     else
       r1d  = rho(k1) - rhomean
       r2d  = rho(k2) - rhomean
     endif
 endif

 z1d = zws(k1)    ; z2d = zws(k2)
 p1d = 0d0        ; p2d = 0d0

 ! barotr = ag*(z2d - z1d) / dx(LL)
 ! r1d = abs(z1d) ; r2d = abs(z2d)  ! forced horizontal

 gradpu(1:Lt-Lb+1) = 0d0
 rhovol(1:Lt-Lb+1) = 0d0
 dxx               = dx(LL)
 hdx               = 0.5d0*dxx

 do L = Lt, Lb, -1
    k1   = ln(1,L)   ; k2  = ln(2,L)            !
    z1u  = z1d       ; z2u = z2d
    r1u  = r1d       ; r2u = r2d
    p1u  = p1d       ; p2u = p2d

    z1d  = zws(k1-1) ; z2d = zws(k2-1)

    if (L > Lb) then
        fzu1 = dz1(L-Lb+1) / (dz1(L-Lb+1) + dz1(L-Lb) )   ; fzd1 = 1d0 - fzu1
        fzu2 = dz2(L-Lb+1) / (dz2(L-Lb+1) + dz2(L-Lb) )   ; fzd2 = 1d0 - fzu2
        if (jabaroctimeint == 2 ) then ! extrapolate rho at n+0.5
           r1d  = fzu1*(1.5d0*rho(k1)-0.5d0*rho0(k1)) + fzd1*(1.5d0*rho(k1-1)-0.5d0*rho0(k1-1)) - rhomean
           r2d  = fzu2*(1.5d0*rho(k2)-0.5d0*rho0(k2)) + fzd2*(1.5d0*rho(k2-1)-0.5d0*rho0(k2-1)) - rhomean
        else
           r1d  = fzu1*rho(k1) + fzd1*rho(k1-1) - rhomean
           r2d  = fzu2*rho(k2) + fzd2*rho(k2-1) - rhomean
        endif

    else
        if (Lt > Lb) then
           fzu1 = dz1(L-Lb+2) / (dz1(L-Lb+1) + dz1(L-Lb+2) ) ; fzd1 = 1d0 - fzu1
           fzu2 = dz2(L-Lb+2) / (dz2(L-Lb+1) + dz2(L-Lb+2) ) ; fzd2 = 1d0 - fzu2
           if (jabaroctimeint == 2 ) then ! extrapolate rho at n+0.5
              r1d  = (2d0-fzd1)*(1.5d0*rho(k1)-0.5d0*rho0(k1))  - fzu1*(1.5d0*rho(k1+1)-0.5d0*rho0(k1+1)) - rhomean
              r2d  = (2d0-fzd2)*(1.5d0*rho(k2)-0.5d0*rho0(k2))  - fzu2*(1.5d0*rho(k2+1)-0.5d0*rho0(k2+1)) - rhomean
           else
              r1d  = (2d0-fzd1)*rho(k1) - fzu1*rho(k1+1) - rhomean
              r2d  = (2d0-fzd2)*rho(k2) - fzu2*rho(k2+1) - rhomean
           endif
        else
           if (jabaroctimeint == 2 ) then ! extrapolate rho at n+0.5
              r1d  = 1.5d0*rho(k1) -0.5d0*rho0(k1) - rhomean
              r2d  = 1.5d0*rho(k2) -0.5d0*rho0(k2) - rhomean
           else
              r1d  = rho(k1) - rhomean
              r2d  = rho(k2) - rhomean
           endif
        endif
    endif

    if (dz1(L-Lb+1) + dz2(L-Lb+1) < 1d-10) then
       rhovol(L-Lb+1) = 1d-10 ; cycle
    else
       rhovol(L-Lb+1) = rhovol(L-Lb+1)    + dz1(L-Lb+1) *( rhomean+0.5d0*(r1u+r1d) )*hdx     ! left  interface Mass
       rhovol(L-Lb+1) = rhovol(L-Lb+1)    + dz2(L-Lb+1) *( rhomean+0.5d0*(r2u+r2d) )*hdx     ! right interface
       if (jarhoxu > 0) rhou(L) = rhovol(L-Lb+1) / ( (dz1(L-Lb+1)+dz2(L-Lb+1))*hdx )
    endif

    dzz  = dz1(L-Lb+1)
    alf1 = r1d - r1u
    p1d  = p1u + r1u*dzz + 0.50*alf1*dzz
    gr1  = p1u*dzz + 0.5d0*r1u*dzz*dzz + alf1*dzz*dzz/6d0          ! your left  wall

    dzz  = dz2(L-Lb+1)
    alf2 = r2d - r2u
    p2d  = p2u + r2u*dzz + 0.50*alf1*dzz  ! alf1=incorrect
    gr2  = p2u*dzz + 0.5d0*r2u*dzz*dzz + alf2*dzz*dzz/6d0          ! your right wall

    dz3  = z2d - z1d
    alf3 = r1d - r2d
    gr3  = p2d*dz3 + 0.5d0*r2d*dz3*dz3 + alf3*dz3*dz3/6d0          ! your own floor

       gradpu(L-Lb+1) = gradpu(L-Lb+1)   + gr1 - gr2 - gr3
    if (L > Lb ) then
       gradpu(L-Lb)   = gradpu(L-Lb)                 + gr3         ! ceiling of ff# downstairs neighbours
    endif

 enddo

 do L = Lt, Lb, -1
     if (rhovol(L-Lb+1) > 0d0) then
        barocl  = ag*gradpu(L-Lb+1)/rhovol(L-Lb+1)                 !  + barotr
        if (jabaroctimeint == 3) then                              ! Adams bashford
            adve(L)   = adve(L) - 1.5d0*barocl + 0.5d0*dpbdx0(L)
            dpbdx0(L) = barocL
        else
            adve(L)   = adve(L) - barocl
        endif
    endif
 enddo

end subroutine addbaroc

double precision function hordiflimited(LL,L,rho_,nx)  ! used to compute a strict horizontal gradient see vkester,stelling 1994
use m_flow
use m_flowgeom
implicit none

integer                       :: L,LL,nx
double precision, intent (in) :: rho_(nx)

integer          :: k1,k2,k2u,k1u,n1,n2,kb1,kb2,kt1,kt2
double precision :: alfu, rho1, rho2, drho1, drho2, drho3, drho4

k1  = ln(1,L)
k2  = ln(2,L)

k2u = k2
n2  = ln(2,LL) ; kb2 = kbot(n2); kt2 = ktop(n2)

if      (zws(k1) < zws(k2) .and. k2u > kb2) then

   do while ( zws(k2u-1) > zws(k1) .and. k2u > kb2)
      k2u = k2u - 1
   enddo

   alfu = zws(k1) - zws(k2u-1) / ( zws(k2u) - zws(k2u-1) )
   rho2 = alfu*rho_(k2u) + (1d0-alfu)*rho_(k2u-1)

else if (zws(k1) > zws(k2) .and. k2u < kt2  ) then

   do while ( zws(k2u) < zws(k1) .and. k2u < kt2)
      k2u = k2u + 1
   enddo

   alfu = zws(k1) - zws(k2u-1) / ( zws(k2u) - zws(k2u-1) )
   rho2 = alfu*rho_(k2u) + (1d0-alfu)*rho_(k2u-1)

else

   rho2 = rho(k2)

endif


k1u = k1
n1  = ln(1,LL) ; kb1 = kbot(n1); kt1 = ktop(n1)

if      (zws(k2) < zws(k1) .and. k1u > kb1) then

   do while ( zws(k1u-1) > zws(k2) .and. k1u > kb1)
      k1u = k1u - 1
   enddo

   alfu = zws(k2) - zws(k1u-1) / ( zws(k1u) - zws(k1u-1) )
   rho1 = alfu*rho_(k1u) + (1d0-alfu)*rho_(k1u-1)

else if (zws(k2) > zws(k1) .and. k1u < kt1  ) then

   do while ( zws(k1u) < zws(k2) .and. k1u < kt1)
      k1u = k1u + 1
   enddo

   alfu = zws(k2) - zws(k1u-1) / ( zws(k1u) - zws(k1u-1) )
   rho1 = alfu*rho_(k1u) + (1d0-alfu)*rho_(k1u-1)

else

   rho1 = rho_(k1)

endif

drho1 = rho2     - rho_(k1)
drho2 = rho_(k2) - rho1

if (limiterhordif == 1) then      ! minmod
   if (drho1*drho2 <=  0) then
      hordiflimited = 0d0
   else if ( abs(drho1) < abs(drho2) ) then
      hordiflimited = drho1
   else
      hordiflimited = drho2
   endif
elseif (limiterhordif == 2) then  ! monotonized central
   drho3 = rho_(k2) - rho_(k1)
   drho4 = 0.5d0*(drho1 + drho2)

   if (drho1*drho2 <=  0) then
      hordiflimited = 0d0
   else if ( abs(drho4) < abs(drho3) ) then
      hordiflimited = drho4
   else if ( min(abs(drho1),abs(drho2)) < abs(drho3) .and. abs(drho3) < max(abs(drho1),abs(drho2)) ) then
      hordiflimited = drho3
   else if (drho1 > 0d0) then
      hordiflimited =  min( abs(drho1),abs(drho2) )
   else
      hordiflimited = -min( abs(drho1),abs(drho2) )
   endif
endif

end function hordiflimited

subroutine inidensconstants()
use m_physcoef

implicit none
double precision :: temp

temp  = backgroundwatertemperature
cp0   = 5890.0d0 + 38.00d0*temp - 0.3750d0*temp*temp
clam  = 1779.5d0 + 11.25d0*temp - 0.0745d0*temp*temp
clam0 =    3.8d0 +  0.01d0*temp
end subroutine inidensconstants

double precision function rho_Eckart(sal, temp)
! use m_physcoef

implicit none
double precision :: sal, temp
double precision :: cp1, clam1, temp2, dum
double precision :: cp0, clam0, clam, alph0

temp2      = temp*temp
cp0        = 5890.0d0 + 38.00d0*temp - 0.3750d0*temp2
clam       = 1779.5d0 + 11.25d0*temp - 0.0745d0*temp2
clam0      =    3.8d0 +  0.01d0*temp
cp1        = cp0  + 3.0d0*saL
clam1      = clam - clam0*saL
rho_Eckart = 1000.0d0*cp1/(0.698d0*cp1+clam1)  ! alph0

! rho_Eckart = 1000.0d0* ( cp1/(alph0*cp1+clam1) - 1d0)

! rho_Eckart = abs( 0.5d0*(zws(k)+zws(k-1)) )

! rho_Eckart = 0.7d0*saL + 1000d0

end function rho_Eckart

double precision function rho_Unesco(sal, temp)
! use m_physcoef
implicit none
double precision :: saL, temp
double precision :: rhods, rhodt

call dens_unes(temp, sal, rho_Unesco, rhods, rhodt)

end function rho_Unesco

 subroutine dens_unes(temp, salt, rhouns, rhods, rhodt)
!----- GPL ---------------------------------------------------------------------
!
!  Copyright (C)  Stichting Deltares, 2011-2020.
!
!  This program is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation version 3.
!
!  This program is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!
!  contact: delft3d.support@deltares.nl
!  Stichting Deltares
!  P.O. Box 177
!  2600 MH Delft, The Netherlands
!
!  All indications and logos of, and references to, "Delft3D" and "Deltares"
!  are registered trademarks of Stichting Deltares, and remain the property of
!  Stichting Deltares. All rights reserved.
!
!-------------------------------------------------------------------------------
!  $Id: unstruc.F90 65931 2020-02-05 10:39:47Z kernkam $
!  $HeadURL: https://svn.oss.deltares.nl/repos/delft3d/tags/delft3d4/65936/src/engines_gpl/dflowfm/packages/dflowfm_kernel/src/unstruc.F90 $
!!--description-----------------------------------------------------------------
!
!    Function: Computes water density from temperature and
!              salinity using equation of state (rhowat).
!
! Method used: Equation of state following UNESCO, (UNESCO,
!              Algorithms for computation of fundamental
!              properties of seawater, UNESCO technical papers
!              in marine science, 1983)
!
!!--pseudo code and references--------------------------------------------------
! NONE
!!--declarations----------------------------------------------------------------
!
    implicit none
!
! Global variables
!
    double precision, intent(in)     :: salt, temp
    double precision, intent(out)    :: rhouns, rhods, rhodt
!
! Local variables
!
    double precision :: s, sq, rhwa, asal, bsal
    double precision, dimension(5) :: t
    double precision, dimension(0:5), parameter :: cf = &
      (/ 999.842594d0   ,&
         6.793952d-2  ,&
        -9.095290d-3  ,&
         1.001685d-4  ,&
        -1.120083d-6  ,&
         6.536332d-9  /)
    double precision, dimension(0:4), parameter :: ca = &
    (/   8.24493d-1 ,&
        -4.0899d-3  ,&
         7.6438d-5  ,&
        -8.2467d-7  ,&
         5.3875d-9  /)
    double precision, dimension(0:2), parameter :: cb = &
    (/  -5.72466d-3  ,&
         1.0227d-4   ,&
        -1.6546d-6   /)
    double precision,                 parameter :: csal = 4.8314d-4
!
!! executable statements -------------------------------------------------------
!
    t(1)   = temp
    t(2)   = temp*t(1)
    t(3)   = temp*t(2)
    t(4)   = temp*t(3)
    t(5)   = temp*t(4)
    !
    s      = salt
    sq     = sqrt(max(0d0,s))
    !
    rhwa   = cf(0) + cf(1)*t(1) + cf(2)*t(2) + cf(3)*t(3) + cf(4)*t(4) &
           &       + cf(5)*t(5)
    asal   = ca(0) + ca(1)*t(1) + ca(2)*t(2) + ca(3)*t(3) + ca(4)*t(4)
    bsal   = cb(0) + cb(1)*t(1) + cb(2)*t(2)
    !
    rhouns = rhwa + (asal+bsal*sq+csal*s) * s
    return
    !
    rhods  = asal + 1.5d0*bsal*sq + 2.0d0*csal*s
    !
    rhodt  = cf(1) +  2.0d0*cf(2)*t(1) + 3.0d0*cf(3)*t(2) &
           &       +  4.0d0*cf(4)*t(3) + 5.0d0*cf(5)*t(4) &
           &       + (ca(1) + 2.0d0*ca(2)*t(1) + 3.0d0*ca(3)*t(2) &
           &       +  4.0d0*ca(4)*t(3)) * s &
           &       + (cb(1) + 2.0d0*cb(2)*t(1)) * sq * s
end subroutine dens_unes


double precision function setrho(k)
use m_physcoef
use m_flow
use m_sediment
use sediment_basics_module, only: SEDTYP_NONCOHESIVE_TOTALLOAD
use m_transport, only: constituents, itemp, ISED1, ISEDN

implicit none
integer :: k, j, l, lsed
double precision, external :: densfm
double precision           :: rhom, sal, temp

if (jasal > 0) then
   saL = max(0d0, sa1(k))
else
   saL = backgroundsalinity
endif

if (jatem > 0) then
   temp  = max(0d0, constituents(itemp,k))
else
   temp = backgroundwatertemperature
endif

setrho = densfm(sal,temp)

if (jased > 0 .and. stm_included) then
   if (stmpar%morpar%densin) then     ! sediment effects
      l = ISED1
      do lsed = 1,stmpar%lsedtot
         if (stmpar%sedpar%sedtyp(lsed) /= SEDTYP_NONCOHESIVE_TOTALLOAD) then  ! suspended sand or mud
            setrho = setrho + constituents(l,k) - setrho*constituents(l,k)/stmpar%sedpar%rhosol(lsed)
            l = l+1
         end if
      end do
   end if
else if (jaseddenscoupling > 0) then ! jased < 4
   rhom = setrho
   do j = 1,mxgr
      setrho = setrho + sed(j,k)*(rhosed(j) - rhom)/rhosed(j)
   enddo
end if

setrho = min(setrho, 1250d0)           ! check overshoots at thin water layers
setrho = max(setrho,  990d0)           !

end function setrho

double precision function densfm(sal,temp)
use m_physcoef
use m_flow
double precision           :: sal, temp
double precision, external :: rho_Eckart, rho_Unesco

if (idensform == 0) then               ! Uniform density
    densfm = rhomean
    return
else if (abs(idensform) == 1) then     ! Carl Henry Eckart, 1958
    densfm = rho_Eckart(sal,temp)
else if (abs(idensform) == 2) then     ! Unesco
    densfm = rho_Unesco(sal,temp)
else if (abs(idensform) == 3) then     ! Baroclinic instability
    densfm = 1025d0 + 0.78d0*(sal - 33.73d0)
else if (abs(idensform) == 4) then     ! Test baroclni pressure term 'dicht.mdu'
    densfm = 2d0*rhomean
else if (abs(idensform) == 5) then     ! For Deltares flume experiment IJmuiden , Kees Kuipers saco code 1
    densfm = 999.904d0          + 4.8292d-2*temp - 7.2312d-3*temp**2 + &
             2.9963d-5*temp**3  + 7.6427d-1*sal  -                     &
             3.1490d-3*sal*temp + 3.1273d-5*sal*temp**2
endif
end function densfm


 subroutine getequilibriumtransportrates2(L, kb1, kb2, seq, wse, mx, hsk, jamin) ! get equilibrium transportrateconc seq based on bans associated with bndlink L
 use m_netw
 use m_flowgeom
 use m_sediment
 implicit none
 integer           :: L, kb1, kb2, mx, jamin                              ! Linknr, left and right ban nr, mxgr,
 double precision  :: seq(mx)  , seq2(mx)                                 ! seq(kg/m3)
 double precision  :: wse(mx)                                             ! effective fall velocity (m/s)
 double precision  :: hsk                                                 ! waterdepth, flowcell or ban
 integer           :: k1, k2, kk, n, j

 if (kb1 == 0) then        ! if bans unknown, first find them
    k1 = lncn(1,L) ; k2 = lncn(2,L)
    do kk = 1,mxban
       n = nban(1,kk)      ! net node
       if (kb1 == 0) then
          if (n == k1) then
             kb1 = kk
          endif
       endif
       if (kb2 == 0) then
          if (n == k2) then
             kb2 = kk
          endif
       endif
       if (kb1 .ne. 0 .and. kb2 .ne. 0) then
           exit
       endif
    enddo
 endif

 if (kb1 == 0) then
     kb1 = 0
 endif
 if (kb2 == 0) then
     kb2 = 0
 endif


 call getequilibriumtransportrates(kb1, seq , wse, mx, hsk)

 call getequilibriumtransportrates(kb2, seq2, wse, mx, hsk)

 if (jamin == 1) then
    do j = 1,mxgr
       seq(j) = min( seq(j), seq2(j) )
    enddo
 else
    do j = 1,mxgr
       seq(j) = max( seq(j), seq2(j) )
    enddo
 endif

 end subroutine getequilibriumtransportrates2

 subroutine getequilibriumtransportrates(kk, seq, wse, mx, hsk)       ! get them for flowcell kk or ban kk
 use m_flowgeom
 use m_flow
 use m_netw
 use m_sediment
 use m_waves, only: twav, uorb
 use geometry_module, only: dbdistance
 use m_missing, only: dmiss
 use m_sferic, only: jsferic, jasfer3D

 implicit none

 integer,          intent (in)  :: kk,mx                         ! flowcell kk or ban kk
 double precision, intent (out) :: seq(mx)                       ! seq(kg/m3)
 double precision, intent (out) :: wse(mx)                       ! effective fall velocity (m/s)
 double precision, intent (out) :: hsk                           ! waterdepth, flowcell or ban

 double precision :: cfsk, cz, taucur, flx
 double precision :: ucr, ueff, Twave, Uwave, Ucur, Ucrc, Ucrw, Pmob, beta, D50h, sbeq
 double precision :: aref, Tmob, crefa, sseq, ustar, ustar2, rouse,sqcf,dj1,dj2,z0k,dks,hdune=0
 double precision :: qsseq,garciaeinstein, effic, bav, caver, botsu, qsseqcheck, eincheck, eincheck2
 double precision :: qssevr84 ,vr84rel, deltaa, seqbed
 double precision :: blmax, hpr,dzz,wu2,wid,ar,hyr, zbu
 double precision :: erodable, sumlay, hseqb, aa , dmorfacL, dh, ustar2swart, ustw2, astar, fw, qeng, cf
 integer          :: j, kj, n, k, kg, nn, n1, L,  jabanhydrad = 0, kb

 integer :: ndraw
 COMMON /DRAWTHIS/ ndraw(50)

 if (stm_included) return

 seq   = 0d0 ; flx = 0d0

 if (jaceneqtr == 1) then
    k = kk
    if (ibedlevtyp == 1 .or. ibedlevtyp == 6) then ! tile type
        hsk  = s1(k) - bl(k)
    else                                           ! u-netwnodes / conv type
       hsk = 0d0 ; nn = 0
       do n  = 1, netcell(k)%n
          n1 = netcell(k)%nod(n)
          dh = max(0d0, s1(k)-zk(n1))
          if (dh > 0d0) then
             nn  = nn + 1
             hsk = hsk + dh
          endif
       enddo
       if (nn > 0) then
           hsk = hsk / nn
       endif
    endif
 else
    n = nban(1,kk)      ! net node
    k = nban(2,kk)      ! flow node
    hsk = 0d0
    if (jabanhydrad == 1) then ! Hydraulic radius for this ban
        wu2  = dbdistance( xz(k), yz(k), xk(n), yk(n), jsferic, jasfer3D, dmiss)
        L    = nban(3,kk)
        zbu  = 9d9
        if (L > 0) then
           zbu  = 0.5d0*( bob(1,L) + bob(2,L) )
        endif

        L    = nban(4,kk)
        if (L > 0) then
           zbu  = 0.5d0*( bob(1,L) + bob(2,L) ) + zbu
           zbu  = 0.5d0*zbu
        endif

        if (s1(k) > zbu) then
           hpr  = s1(k) - zbu
           dzz  = zk(n) - zbu
           call widarhyr(hpr,dzz,wu2,wid,ar,hyr)
           hsk  = hyr
        endif
    else
        hsk = s1(k) - zk(n) ! todo make netnode oriented waterlevel
    endif
 endif

 if (hsk < epshs) then                                             ! local waterdepth (m)
    return
 endif

 call getczz0(hsk, frcuni, ifrctypuni, cz, z0k)                     ! get roughness as specified in hydrodynamics
 sqcf = sag/cz                                                      ! sqrt(g)/C  ( )

 ! or whatever comes out of the roughness predictor, and van Rijn takes z0 = 3D90

 dks = 30d0*z0k                                                     ! nikuradse roughness (m)
 if (dks > 0.5d0*hsk) then  !0.2
    return
 endif

 hdune = 0d0                                                        ! half duneheight (m)
 wse   = ws

 if (jaceneqtr == 1) then
    ucur = sqrt(ucx(k)*ucx(k) + ucy(k)*ucy(k) )                     !                                                            ! current (transport) velocity (m/s)
 else
    ucur = sqrt(ucnx(n)*ucnx(n) + ucny(n)*ucny(n) )
 endif

 if (jased == 3) then                                               ! Engelund:
    cf     = sqcf*sqcf
    qeng   = 0.05d0*cf*sqcf*(ucur**5)/ (D50(1)*(rhodelta(1)*ag)**2 )              ! (m2/s)

    sseq   = qeng / ( max(ucur,1d-2)*hsk )                          ! ( ) dimensionless equilibrium 2D transport suspended sediment concentration
    sseq   = alfasus*sseq
    seq(1) = rhosed(1)*sseq                                         ! equilibrium transport concentration bed + suspended (kg/m3)
    wse(1) = wse(1)*crefcav
 else


 ueff        = ucur ; beta = 1d0 ; twave = 0d0                     !
 ustar2swart = sqcf*sqcf*Ueff*Ueff
 if (jawave > 0 .and. ueff > 0d0) then
    if (twav(k) > 1d-2) then
       twave = twav(k)
       uwave = uorb(k)                                             ! (m/s) for jased == 2, tauwav contains uorb

       beta  = ucur   / ( ucur + uwave )                           ! ( )

       Ueff  = Ucur   +    0.4d0*uwave                             ! (m/s) SvR 2007

       if (MxgrKrone > 0) then
          call Swart(Twave, uwave, z0wav, fw, ustw2)
          ustar2swart = ustar2swart + ustw2                        ! Swart
       endif

    endif
 endif
 ustar  = sqcf *Ueff

 if (kmx > 0) then
    ustar       = ustbc(k)
    ustar2swart = ustar*ustar
 endif

 ustar2 = ustar*ustar

 do j = 1,mxgr  ! loop over grainsizes

    if (j <= MxgrKrone) then                                        ! following Krone/Swart
       if (ustar2swart > Ustcre2(j)) then                           ! eroderen
           Tmob    = (ustar2swart - Ustcre2(j) ) / Ustcre2(j)       ! ( ) dimensionless mobility parameter
           flx     = erosionpar(j)*Tmob                             ! kg/(m2s)
       endif
       seq(j) = flx  / ws(j)                                        ! equilibrium sediment concentration

    else                                                            ! soulsby van rijn 2007 ASCE,

       !Ucr=Accr(j)*log(12.d0*hsk/dks)   ! 3d0*D90(j))              ! (2007a (12) )
       !Ucr=Accr(j)*log(hsk/(ee*z0k)) / vonkar

       Ucr=Accr(j)/sqcf

       if (Twave > 0) then
          Ucrw = Awcr(j)*Twave**Bwcr(j)                             !  = 0.24d0*(rhodelta*ag)**0.66d0*D50**0.33d0
          Ucr  = beta*Ucr + (1d0-beta)*Ucrw                         ! (m/s)
       endif

       if (isusandorbed >= 2) then
          Pmob =  (Ueff - Ucr) / sqsgd50(j)                         ! ( ) dimensionless mobility parameter
          sbeq = 0d0
          if (Pmob > 0 ) then

             Pmob   = Pmob**1.5d0                                   ! ( ) dimensionless mobility, old power was 2.4d0

             D50h   = ( D50(j)/ hsk )**1.2d0                        ! ( )

             sbeq   = 0.015d0*D50h*Pmob                             ! ( ) dimensionless equilibrium bedload concentration, formula 12 , so bed load transport =
                                                                    !  qb = u.h.sbeq.rhosed ( (m/s) . m . ( ). (kg/m3) ) = ( kg/(sm) ), old alfa was .005

             seq(j) = sbeq*rhosed(j)                                ! equilibrium concentration (kg/m3)

          endif
       endif
                                                                        ! reference height is max of (nikuradse and half dune height) (m)
       aref  = max(dks,hdune)                                           ! vRijns book page 7.65 (line 6)
       aref  = max(aref,0.01d0*hsk)                                     ! vRijns book page 7.64 (line 3)
       aref  = min(aref,0.25d0*hsk)                                     ! check, always < .25 waterdepth
                                                                        ! vrijns book pag 8.50 r 3 ????
       Tmob  = (Ueff*Ueff - Ucr*Ucr)/ (Ucr*Ucr)                         ! Mobility parameter T ( )
       if (Tmob > 0 .and. ustar > 0d0) then
          rouse = ws(j)/(vonkar*ustar)
          crefa = 0.015d0*(D50(j)/aref)*(Tmob**1.5d0)*Dstar03(j)        ! dimensionless reference concentration ( ), (book vRijn 1993, (7.3.31) )
          !crefa = min(crefa, 0.65d0)                                   ! max ref concentration ( )               or (book Garcia 2008, (2-226) )
          !crefa = min(crefa, 0.15d0)
          crefa = min(crefa, 0.05d0)                                    ! vRijns book ?

          if (kmx == 0) then
             call check_einstein_garcia2(aref,hsk,z0k,rouse, eincheck2)    ! numerical check einstein integrals, now used as vertical integrator anyway

             !qssevr84   = 0.012d0*Ueff*D50(j)*Pmob**2.4d0*Dstar(j)**-0.6d0       ! boek vanrijn (7.3.46), or 2007b


             qsseq = eincheck2*crefa*ustar/vonkar                          ! (conclusion : inaccuracy of einstein_garcia is about 10-20  )

             !qsseq = qssevr84

             sseq  = qsseq/ ( max(ucur,1d-2)*hsk )                         ! ( ) dimensionless equilibrium 2D transport suspended sediment concentration

             ! call checksuspended_transport()

             seq(j) = seq(j) + rhosed(j)*sseq                              ! equilibrium transport concentration bed + suspended (kg/m3)

             wse(j) = ws(j)*crefa/(sseq+sbeq)                              ! effective 2Dh fall velocity er (m/s)*( )

          else

             seq(j) = crefa

             wse(j) = ws(j)! *alfaT

          endif

       endif

    endif

 enddo

 endif  ! !jased 1, 2



 sumlay = 0d0                                                           ! check bed material

 if (jaceneqtr == 1) then
    kg = k
 else
    kg = n
 endif
 sumlay = 0d0                                                           ! check bed material
 do j = 1,mxgr
    sumlay = sumlay + grainlay(j,kg)
 enddo

 dmorfacL = max(1d0,dmorfac)
 if (sumlay == 0d0) then
    seq(1:mxgr) = 0d0
 else
    do j = 1,mxgr
       seq(j) = seq(j)*grainlay(j,kg)/sumlay                             ! normed with erodable fraction (kg/m3)
       seqbed = rhosed(j)*grainlay(j,kg)*rhobulkrhosed / (hsk*dmorfacL)  ! concentration if all bed material was suspended (kg/m3)

       if (grainlay(j,kg) < dks ) then                                   ! limiting below roughness thickness
          seqbed = seqbed*grainlay(j,kg)/dks
       endif

       if (seq(j) > seqbed) then
           seq(j) = seqbed
       endif

    enddo
 endif

 end subroutine getequilibriumtransportrates

 subroutine setgrainsizes() ! for all fractions:
 USE M_SEDIMENT
 use m_physcoef,       only : ag, rhomean, vonkar, backgroundwatertemperature
 use MessageHandling
 implicit none
 integer          :: m, j
 double precision :: Ucr, sster, c1, c2, wster, wschk, taucr, taucr1, thetcr, pclay=0d0, fcr=1d0

 double precision :: a = 2.414d-5, b = 247.8d0, c= 140d0, TempK, s

 TempK         = 273d0 + backgroundwatertemperature
 vismol        = A*10**( B / (TempK-C) ) / rhomean
 vismol        = 4.d0/(20.d0 + backgroundwatertemperature)*1d-5 ! Van rijn, 1993

 if (allocated (D90) ) then
     deallocate(D90, rhodelta, sqsgd50, dstar, dstar03, Accr, Awcr)
 endif
 if (mxgr == 0) return
 m = mxgr
 allocate (D90(m), rhodelta(m), sqsgd50(m), dstar(m), dstar03(m), Accr(m), Awcr(m))

 D90           = 2d0*D50
 rhodelta      = (rhosed-rhomean) / rhomean  ! rhodelta = (s-1), s=rhosed/rhomean
 sqsgd50       = sqrt( rhodelta*ag*D50)
 dstar         = D50*( rhodelta*ag/(vismol*vismol) )** (1d0/3d0)
 dstar03       = dstar**(-0.3d0)

 do j = 1,mxgr

    call fdster(dstar(j),taucr,thetcr,pclay,ag,d50(j),rhosed(j),rhomean,FCR) ! vanRijn Tr2004
    ACCR(J) = sqsgd50(j)*sqrt(thetcr)

    Awcr(j) = D50wa(j)*(rhodelta(j)*ag)**D50wb(j)*D50(j)**D50wc(j)

    Sster = D50(J)/(4*vismol)*sqsgd50(J)
    c1    = 1.06d0*tanh(0.064d0*Sster*exp(-7.5d0/Sster**2))
    c2    = 0.22d0*tanh(2.34d0*Sster**(-1.18d0)*exp(-0.0064d0*Sster**2))
    wster = c1+c2*Sster
    Ws(j) = wster*sqsgd50(j)                                         ! van Rijn
    Wschk = 16.17d0*D50(j)*D50(j)/(1.80d-5 + sqrt(12.12*D50(j)**3) ) ! Ferguson,Church 2006) Wikipedia sand fall velocity

    call mess(LEVEL_INFO,' Backgroundwatertemperature (degC) ', real(Backgroundwatertemperature)  )
    call mess(LEVEL_INFO,' Vismol                     (m2/s) ', real(Vismol)  )
    call mess(LEVEL_INFO,' Fraction diameter D50         (m) ', real(D50(j))    )
    call mess(LEVEL_INFO,' Fraction diameter Dstar       ( ) ', real(Dstar(j))  )
    call mess(LEVEL_INFO,' Settling velocity Ws vR     (m/s) ', real(Ws(j))     )
    call mess(LEVEL_INFO,' Settling velocity Ws F,C    (m/s) ', real(Wschk)     )
    call mess(LEVEL_INFO,' Setting time h=5(m)        (days) ', real(5d0/(ws(j)*24*3600) ) )
    call mess(LEVEL_INFO,' Rhosed                    (kg/m3) ', real(rhosed(j)) )

    Ucr = Accr(j)*log(4.d0*1d0/D90(j))
    call mess(LEVEL_INFO,' Ucrc h=1 (m)             (m/s) ', real(UCr)       )
    Ucr = Accr(j)*log(4.d0*5d0/D90(j))
    call mess(LEVEL_INFO,' Ucrc h=5 (m)             (m/s) ', real(UCr)       )
    Ucr = Accr(j)*log(4.d0*20d0/D90(j))
    call mess(LEVEL_INFO,' Ucrc h=20 (m)            (m/s) ', real(UCr)       )
 enddo

 end subroutine setgrainsizes

 subroutine fdster(dster,taucr,thetcr,pclay,g,d50,rhos,rhow,FCR)
 IMPLICIT NONE
 double precision :: dster,taucr,thetcr,pclay,g,d50,rhos,rhow,FCR
 double precision :: dsand, dsilt,cmaxs,fch1,cmax,fpack,fclay
 IF(DSTER.LE.1.)THETCR=.24  ! this line added by hk and svdp: critical shields parameter
 IF(DSTER.LE.4.)THETCR=0.115/(DSTER)**0.5
 IF(4. .LT.DSTER.AND.DSTER.LE.10.)THETCR=.14*DSTER**(-.64)
 IF(10..LT.DSTER.AND.DSTER.LE.20.)THETCR=.04*DSTER**(-.1 )
 IF(20..LT.DSTER.AND.DSTER.LE.150.)THETCR=.013*DSTER**(.29 )
 IF(DSTER.GT.150.)THETCR=.055
!Soulsby gives one single formula
!THETCR=(0.24/DSTER)+0.055*(1.0-exp(-0.02*DSTER))
 dsand=0.000062
 dsilt=0.000032
 cmaxs=0.65
 fch1=(dsand/d50)**1.5
 cmax=(d50/dsand)*cmaxs
!cmaxs=maximum bed concentration in case of sandy bottom (=0.65)
 if(cmax.lt.0.05)cmax=0.05
 if(cmax.gt.cmaxs)cmax=cmaxs
 fpack=cmax/cmaxs
 if(fch1.lt.1.)fch1=1.
 if(fpack.gt.1.)fpack=1.
 fclay=1.
 if(pclay.ge.0.)fclay=(1.+Pclay)**3.
!  if(pclay.ge.0..and.d50.ge.dsand)fclay=(1.+Pclay)**3.
 if(fclay.ge.2.)fclay=2.

 thetcr=FCR*fpack*fch1*fclay*THETCR

 TAUCR=(RHOS-RHOW)*G*D50*THETCR
 end



 subroutine checksuspended_transport()
 implicit none
 double precision :: cfsk, cz, taucur, hsk
 double precision :: ucr, ueff, Twav, Uwav, Ucur, Ucrc, Ucrw, Pmob, beta, D50h, sbeq, sster, wster, ws
 double precision :: aref, Tmob, crefa, sseq, ustar, rouse,sqcf,dj1,dj2,z0k,dks, hdune, qssevr84h
 double precision :: qsseq,garciaeinstein, effic, bav, caver, botsu, qsseqcheck, eincheck, eincheck2, qssevr84 ,vr84rel
 double precision :: blmin, blmax, D50, D90, dstar, ag, sag, vonkar, ee, rhomean, rhosed, sqsgd50, temp, vismol,c1,c2
 double precision :: Accr, D5085, Awcr, s095, rhodelta, wschk, ff, hf, df, qsseqrel, D50a, hska, g, deltaa

 integer          :: k, j, kj, n, i, kk, mout, nx = 4

 ag     = 9.81d0
 sag    = sqrt(ag)
 vonkar = 0.41d0
 ee     = exp(1d0)

 ucur   = 1d0                       ! depth avaraged flow velocity
 ueff   = ucur                      ! effective velocity, possibly plus wave contribution


 call newfil(mout, 'rvrcheck.xyz')
 write(mout,* ) ' Depth , D50   , Refcon   , Qsc Numerical, Qsc vR84_D50 ' ! QscNumerical/Refcon, Tau'

 hska  = 1.5d0
 ff    = 1.3d0
 hf    = 1d0 / ( hska*ff**(nx-1) )
 D50a  = 0.000062d0
 df    = 1d0 / ( D50a*ff**(nx-1) )
 do i = 1,nx
   !D50 = D50a*ff**(i-1)
    if (i == 1) D50 = 0.000062
    if (i == 2) D50 = 0.0002
    if (i == 3) D50 = 0.0006
    if (i == 4) D50 = 0.002
    do j = 1, nx
    ! hsk = hska*ff**(j-1)
      if (j == 1) hsk = 1d0
      if (j == 2) hsk = 5d0
      if (j == 3) hsk = 20d0
      if (j == 4) hsk = 40d0



 d90    = 2d0*d50                   ! grainsize
 dks    = 3d0*d90                   ! nikuradse
 z0k    = dks/30d0                  ! z0
 sqcf   = vonkar / log(hsk / (ee*z0k) )                                 ! sqrt(g)/C  ( )
 ustar  = sqcf*Ucur                                                     ! ustar
 hdune  = 0d0
 aref   = max(dks,hdune)                                                ! reference height is max of (nikuradse and half dune height) (m)

 rhosed    =  2650d0 ; rhomean = 1000d0
 rhodelta  = (rhosed-rhomean) / rhomean  ! rhodelta = (s-1), s=rhosed/rhomean
 sqsgd50   = sqrt( rhodelta*ag*D50)
 Temp      = 20d0
 vismol    = 4.d0/(20.d0+Temp)*1d-5 ! Van rijn, 1993
 Sster     = D50/(4*vismol)*sqsgd50
 c1        = 1.06d0*tanh(0.064d0*Sster*exp(-7.5d0/Sster**2))
 c2        = 0.22d0*tanh(2.34d0*Sster**(-1.18d0)*exp(-0.0064d0*Sster**2))
 wster     = c1+c2*Sster
 ws        = wster*sqsgd50

 dstar     = D50*( rhodelta/(vismol*vismol) )** (1d0/3d0)
 Wschk     = 16.17d0*D50*D50/(1.80d-5 + sqrt(12.12*D50*D50*D50) ) ! Ferguson,Church 2006) Wikipedia sand fall velocity


 if(D50<=0.0005d0) then                                           ! calculate treshold velocity Ucr, formula (12)
    Accr = 0.19d0*D50**0.1d0
 else ! if(D50<0.05d0) then                                       ! Dano see what happens with coarse material
    Accr = 8.50d0*D50**0.6d0
 endif
 Ucr   = Accr*log10(4.d0*hsk/D90)

 Pmob  = (Ueff - Ucr)/Ucr
 Tmob  = (Ueff*Ueff - Ucr*Ucr)/ (Ucr*Ucr)                         ! Mobility parameter T ( )

 if (Tmob > 0d0) then

    rouse  = ws/(vonkar*ustar)
    !deltaa = aref/hsk
    !call einstein_garcia(deltaa,rouse,dj1,dj2)                      ! einstein integrals following garcia 2008
    !garciaeinstein = dj1*log(hsk/z0k) + dj2                       ! garcia 2008(2-219) ( )
    !garciaeinstein = max(0d0,garciaeinstein)
    crefa = 0.015d0*(D50/aref)*(Tmob**1.5d0)/(Dstar**0.3d0)       ! dimensionless reference concentration ( ), (book vRijn 1993, (7.3.31) )
    if (crefa > 0.65d0) then
       crefa =  0.65d0                                            ! max ref concentration ( )               or (book Garcia 2008, (2-226) )
    endif
    !qsseq = (crefa*ustar*hsk/vonkar)*garciaeinstein               ! equilibrium suspended transport, ( ). (m/s) . (m) =  ( m2/s) )
    !sseq  = qsseq/ ( max(ucur,1d-2)*hsk )                         ! ( ) dimensionless equilibrium suspended sediment concentration

    call check_einstein_garcia(aref,hsk,z0k,rouse, eincheck)      ! numerical check einstein integrals slow, height is already in eincheck

    call check_einstein_garcia2(aref,hsk,z0k,rouse, eincheck2)    ! numerical check einstein integrals fast, height is already in eincheck


    qsseqcheck = (crefa*ustar/vonkar)*eincheck                    ! (conclusion : inaccuracy of einstein_garcia is about 10-20 % => improve if have time )

    qssevr84   = 0.012d0*Ucur*D50*Pmob**2.4d0*Dstar**(-0.6d0)       ! boek vanrijn (7.3.46), or 2007b

    write(mout,'(7F12.8)')   hsk, D50, crefa, qsseqcheck, qssevr84 !,  qsseqcheck/ crefa, rhomean*ustar**2


    !vr84rel    = qssevr84 / qsseqcheck

    !qsseqrel   = qsseq    / qsseqcheck

    !caver = crefa*dj1                                             ! just checking
    !if (caver > 0) then
    !   effic = qsseq / (caver*ucur*hsk)                              ! just checking
    !   bav   = crefa /  caver                                        ! just checking
    !   botsu = sbeq  /   sseq                                        ! just checking
    !endif

 endif



     enddo
 enddo


 call doclose(mout)

 end subroutine checksuspended_transport



subroutine tauwavefetch(tim)               ! fetchlength and fetchdepth based significant wave height and period
 use m_sediment                             ! based on Hurdle, Stive formulae
 use m_netw                                 ! tauwave based on Swart
 use m_flowgeom                             ! taus = taubmx = taucur + tauwave, as in Delwaq
 use m_flow
 use m_waves, only: fetch, nwf, fetdp, uorb, twav, hwav
 use m_flowtimes
 use m_partitioninfo
 use unstruc_display, only: jaGUI
 USE M_OBSERVATIONS
 use geometry_module, only: getdx, getdy, dbdistance, cross, normalout, normalin
 use m_missing, only: dmiss
 use m_sferic
 use m_plotdots

 implicit none

 double precision :: tim

 double precision :: U10, fetchL, fetchd, hsig, tsig, tlim, rl, rl0, sqrt2, rk, ust, xkk1, ykk1, xkk2, ykk2
 double precision :: dir, uwin, vwin, prin, cs, sn, fetc, fetd, xn, yn, sumw, www , dsk2
 double precision :: SL,SM,XCR,YCR,CRP, alfa1, alfa2, wdep,  xzk, yzk, dist, distmin, celsiz
 double precision :: sind, cosd, ustx1, ustx2, usty1, usty2
 integer          :: k, L, kk, kkk, k1, k2, kup, n, ndone, ierr, nup, nupf, jacros, nw1, nw2, nodenum, LL, knw = 5
 INTEGER          :: NDIR, NWND, NSTAT, MOUT, ndoneprevcycle, kkmin, ndoner, k12, ks, ke, ki, msam = 0, jaopen

 integer :: ndraw
 COMMON /DRAWTHIS/ ndraw(50)
 
 if ( .not. allocated (fetch) .or. size (fetch,2) .ne. ndx) then
      nwf = 13

      if (  allocated (fetch) )  deallocate (fetch)
      allocate ( fetch(nwf, ndx) , stat = ierr)
      call aerr('fetch(nwf, ndx)', ierr ,  ndx*nwf)
      if (  allocated (fetdp) )  deallocate (fetdp)
      allocate ( fetdp(nwf, ndx) , stat = ierr)
      call aerr('fetdp(nwf, ndx)', ierr ,  ndx*nwf)

      ndx2dr = 0
      if (jampi == 1) then
         allocate ( fett(2, ndx) , stat = ierr)
         call aerr('fett(2, ndx)', ierr ,  ndx*2)

         do k = 1,ndxi
            if (idomain(k) .ne. my_rank) cycle
            if (kcs(k) == 2) ndx2dr = ndx2dr + 1
         end do
         call reduce_int_sum(ndx2dr,ndoner)
         ndx2dr = ndoner
      else
         do k = 1,ndxi
             if (kcs(k) == 2) ndx2dr = ndx2dr + 1
         end do
      endif

 endif

 if (tim >= time_fetch) then

      ! call mpi_barrier(DFM_COMM_DFMWORLD,ierr)

      time_fetch = max(tim, time_fetch + tifetch )
      if (tifetch == 0d0) time_fetch = 1d30

      fetch = dmiss ; fetdp = dmiss
mainloop:do n  = 1, nwf
         if (jagui > 0) then
            call cls1()
            call setcol(221)
            ! numdots = 0
         endif
         dir   = twopi *real (n-1) / real(nwf-1)
         uwin  = cos(dir) ; vwin = sin(dir)
         ndone = 0

         do k = 1,ndxi
            if (kcs(k) .ne. 2) cycle
            kkmin = 0 ; distmin = 1d10; celsiz = 0d0
            if (jampi == 1) then
               if (idomain(k) .ne. my_rank) cycle
            endif
            do kk = 1,netcell(k)%n
               L  = netcell(k)%lin(kk)
               k1 = netcell(k)%nod(kk)
               if (kk == netcell(k)%n) then
                  k2 = netcell(k)%nod(1)
               else
                  k2 = netcell(k)%nod(kk+1)
               endif
               celsiz = max(celsiz, dbdistance(xk(k1), yk(k1), xk(k2), yk(k2), jsferic, jasfer3D, dmiss) )
            enddo
            if (jsferic == 1) celsiz=celsiz*rd2dg/ra

            jaopen = 0
            do kk = 1,nd(k)%lnx
               L  = iabs( nd(k)%ln(kk) )
               if (ln(1,L) > ndxi) then 
                  jaopen = 1 
               endif  
            enddo

            do kk = 1,netcell(k)%n
               L  = netcell(k)%lin(kk)
               k1 = netcell(k)%nod(kk)
               if (kk == netcell(k)%n) then
                  k2 = netcell(k)%nod(1)
               else
                  k2 = netcell(k)%nod(kk+1)
               endif

               wdep   = s1(k) - min(zk(k1),zk(k2))
               if (lnn(L) == 1 .or.  wdep < 0.5d0 .or. kn(3,L) == 0 .or. jaopen == 1) then    ! link shallow or closed => start fetch here
                  call normalout(xk(k1), yk(k1), xk(k2), yk(k2), xn, yn, jsferic, jasfer3D, dmiss, dxymis)
                  prin = uwin*xn + vwin*yn
                  if ( prin < 0d0 ) then                   ! if upwind
                     crp  = xn ; xn  = -yn ; yn = crp
                     crp  = 0d0
                     xkk1 = xk(k1) - 2*celsiz*xn
                     ykk1 = yk(k1) - 2*celsiz*yn
                     xkk2 = xk(k2) + 2*celsiz*xn
                     ykk2 = yk(k2) + 2*celsiz*yn
                     CALL CROSS(Xkk1,Ykk1,Xkk2,Ykk2,Xzw(k),Yzw(k),Xzw(k)-1d4*uwin,Yzw(k)-1d4*vwin, &
                                JACROS,SL,SM,XCR,YCR,CRP,jsferic, dmiss)
                     if (jacros == 1) then
                        dist = dbdistance(xz(k), yz(k), xcr, ycr, jsferic, jasfer3D, dmiss)
                        if (dist < distmin) then
                           distmin = dist ; kkmin = kk        ! closest crossed upwind edge
                        endif
                     endif
                  endif
               endif
            enddo
            if (kkmin > 0) then
                if (jaopen == 1) then  
                   fetch(n,k) = 1d5 
                else 
                   fetch(n,k) = min(distmin, celsiz)
                endif   
                fetdp(n,k) = max( s1(k) - bl(k), .1d0)
                if (jagui > 0) then
                   !CALL rCIRc(Xz(k),Yz(k) ) !, fetch(n,k))
                   !call adddot(Xz(k),Yz(k),1d0)
                endif
                ndone      = ndone + 1
            endif

         enddo

         if (jampi == 1) then
             call reducefett(n)
             call reduce_int_sum(ndone,ndoner)
             ndone = ndoner
         endif

         if (jagui > 0) call setcol(31)
         do while ( ndone < ndx2dr )

            ndoneprevcycle = ndone
            ndone          = 0

555         continue
            do k = 1,ndxi
               if (kcs(k) .ne. 2) cycle
               if (jampi == 1) then
                  if (idomain(k) .ne. my_rank) cycle
               endif

               if (fetch(n,k) .eq. dmiss) then
                  kup = 0 ; fetc = 0; fetd = 0; sumw = 0; nup = 0; nupf = 0
                  do kk = 1,nd(k)%lnx
                     L  = iabs( nd(k)%ln(kk) )
                     k2 = ln(1,L) ; if (k2 == k) k2 = ln(2,L)
                     if ( kcs(k2) == 2 ) then  ! internal
                        !prin = uwin*getdx(xz(k2),yz(k2),xz(k),yz(k), jsferic) + vwin*getdy( xz(k2),yz(k2),xz(k),yz(k), jsferic)
                        !dsk2 = dbdistance(xz(k2),yz(k2),xz(k),yz(k), jsferic, jasfer3D, dmiss)
                        !cs   = min(max(prin/dsk2,-1d0),1d0)                        

                        cs   = uwin*csu(L) + vwin*snu(L) 
                        if (L .ne. nd(k)%ln(kk) ) cs = -1d0*cs
                        dsk2 = dx(L) 
                        prin = dsk2*cs

                        if (cs > 0) then ! internal upwind points
                           nup = nup + 1
                           if (fetch(n,k2) .ne. dmiss) then ! do not look at open boundaries
                               nupf = nupf + 1
                               sn   = sqrt( 1d0 - cs*cs)
                               ! www  = (1d0-sn)/dsk2               ! first attempt
                               www  = (cs   + 0.05d0*sn)*wu(L)/dsk2 ! some diffusion
                               fetc = fetc  + www*(fetch(n,k2) + prin)
                               fetd = fetd  + www*(fetch(n,k2) + prin)*max(.1d0, 0.8d0*fetdp(n,k2) + 0.2d0*(s1(k)-bl(k)) )
                               sumw = sumw  + www
                           endif
                        endif
                     endif
                  enddo
                  if ( nup == nupf .and. sumw > 0d0) then
                     fetch(n,k) = fetc/sumw
                     fetdp(n,k) = fetd/ ( sumw*fetch(n,k) )
                     ndone      = ndone + 1
                     if (jagui > 0) then
                        !CALL rCIRc(Xz(k),Yz(k) )
                        !call adddot(Xz(k),Yz(k),2d0)
                         call KCIR(Xz(k),Yz(k),1d0)
                     end if
                  endif
               else
                  ndone = ndone + 1
               endif
            enddo ! k

            if (jampi == 1) then
               call reducefett(n)
               call reduce_int_sum(ndone,ndoner)
               ndone = ndoner
            endif

            if ( ndone.eq.ndoneprevcycle ) then
               call QNERROR('connectivity issue in fetch', ' ', ' ')
               exit mainloop
            end if

         enddo

    enddo mainloop

 endif

 sqrt2 = sqrt(2d0)

 do k = 1,ndx2d
    Hwav(k)   = 0d0
    Twav(k)   = 0d0
    Uorb(k)   = 0d0
    rlabda(k) = 0d0
    ustk(k)   = 0d0

    if ( hs(k) > 0.01d0 ) then
   
       call getfetch(k,U10,FetchL,FetchD)
       if (FetchL > 0) then  

          if (jawave == 1) then

             call hurdlestive (U10, fetchL, fetchD, Hsig, Tsig)

          else if (jawave == 2) then

             call ian_young_pt(U10, fetchL, fetchD, Hsig, Tsig)

          endif

          Hwav(k) = Hsig / sqrt2          ! Hwav === hrms
          Twav(k) = Tsig
          call tauwavehk(Hwav(k), Twav(k), hs(k), Uorb(k), rlabda(k), ustk(k))      ! basically now just a dispersion function with 2DH stokes drift
       endif
    endif

    if (NDRAW(28) == 35) then
       plotlin(k) = fetchL
    else if (NDRAW(28) == 36) then
       plotlin(k) = fetchD
    else if (NDRAW(28) == 37) then
       plotlin(k) = Hsig
    else if (NDRAW(28) == 38) then
       plotlin(k) = Tsig
    else if (NDRAW(28) == 39) then
       !  plotlin(k) = Taucur
    else if (NDRAW(28) == 40) then
       plotlin(k) = uorb(k)
    endif

 enddo

 ! need something for 2D ustokes
 do LL = 1, lnx
   if (hu(LL)>epswav) then
       k1 = ln(1,LL); k2 = ln(2,LL)
       dir   = atan2(wy(LL), wx(LL))
       sind  = sin(dir); cosd = cos(dir)
       ustx1 = ustk(k1)*cosd
       ustx2 = ustk(k2)*cosd
       usty1 = ustk(k1)*sind
       usty2 = ustk(k2)*sind
       ustokes(LL) =      acL(LL) *( csu(LL)*ustx1 + snu(LL)*usty1) + &
                     (1d0-acL(LL))*( csu(LL)*ustx2 + snu(LL)*usty2)
       vstokes(LL) =      acL(LL) *(-snu(LL)*ustx1 + csu(LL)*usty1) + &
                     (1d0-acL(LL))*(-snu(LL)*ustx2 + csu(LL)*usty2)
    else
       ustokes(LL) = 0d0
       vstokes(LL) = 0d0
    endif
 end do

end subroutine tauwavefetch

subroutine getfetch(k,U10,FetchL,FetchD) !and windspeed
use m_flow,  only:  Hs, Wx, Wy
use m_waves, only:  fetch, nwf, fetdp
use m_sferic
implicit none 

integer          :: k
double precision :: U10,FetchL,FetchD

integer          :: L,nw1,nw2
double precision :: alfa1, alfa2, dir


FetchL = 0d0 ; FetchD = 0d0

if (Hs(k) > 0d0) then  
   call getlink1(k,L) ! het is maar voor wind
   U10 = sqrt ( WX(L)*WX(L) + WY(L)*WY(L) )
   IF (U10 .LT. 1d0) return 

   DIR   = ATAN2(WY(L), WX(L))
   IF (DIR < 0D0) DIR = DIR + TWOPI

   dir = dir/twopi
   if (dir >= 1d0) dir = 0d0
   NW1 = DIR*(nwf-1) + 1
   NW2 = NW1 + 1
   
   if (fetch(nw1,k) > 0d0 .or. fetch(nw2,k) > 0d0 ) then
      alfa2  = (nwf-1)*( dir - dble(nw1-1) / dble(nwf-1) )
      alfa1  = 1d0 - alfa2
      fetchL = alfa1*fetch(nw1,k) + alfa2*fetch(nw2,k)
      fetchD = alfa1*fetdp(nw1,k) + alfa2*fetdp(nw2,k)
   endif
endif
end subroutine getfetch
       

subroutine reducefett(n)
use m_waves
use m_flowgeom
use m_partitioninfo
implicit none
integer :: n, k, ierror
do k = 1,ndx
   fett(1,k)  = fetch(n,k)
   fett(2,k)  = fetdp(n,k)
enddo
call update_ghosts(ITYPE_SaLL, 2, ndx, fett, ierror)
do k = 1,ndx
   fetch(n,k) = fett(1,k)
   fetdp(n,k) = fett(2,k)
enddo
end subroutine


subroutine getustwav(LL, z00, fw, ustw2, csw, snw, Dfu, Dfuc, deltau, costu) ! at u-point, get ustarwave and get ustokes
use m_flow
use m_flowgeom
use m_waves
use m_sferic
implicit none
integer,          intent(in)  :: LL
double precision, intent(in)  :: z00
double precision, intent(out) :: fw, ustw2, csw, snw
double precision, intent(out) :: Dfu                    ! wave dissipation due to bedfriction
double precision, intent(out) :: Dfuc                   ! Dfu/c
double precision, intent(out) :: deltau                 ! wave bed boundary layer thickness


double precision, external    :: sinhsafei
integer                       :: k1, k2 , Lb, Lt, L
double precision              :: Tsig, Hrms, asg, rk, shs, uorbu, astar, phiw, phi1, phi2, dks, aks, omeg, f1u, f2u, f3u, zu, costu, sintu
double precision              :: qsto, usto3Dav , usto2D, p1, p2, h, z, ustoktb, uusto, uwi

Lb   = Lbot(LL) ; Lt = Ltop(LL)
k1   = ln(1,LL) ; k2 = ln(2,LL)
Tsig = 0.5d0*( Twav(k1)   + Twav(k2) )
if (Tsig > 0.05d0) then
   omeg  = twopi/Tsig
else
   ustw2 = 0d0
   if (jawaveStokes > 0) then
       ustokes(Lb:Lt) = 0d0 ; vstokes(Lb:Lt) = 0d0
   endif
   return
endif
if (jawave <= 2) then
   uwi = sqrt(wx(LL)*wx(LL) + wy(LL)*wy(LL) )
   if (uwi > 0d0) then
      csw = wx(LL)/uwi
      snw = wy(LL)/uwi
   else
      csw = 1d0 ; snw = 0d0
   endif
else
   phi1   = Phiwav(k1) ; phi2  = Phiwav(k2)
   if ( phi2 - phi1 > 180d0 ) phi1 = phi1 + 360d0
   phiw   = 0.5d0*( Phi1 + Phi2 )
   csw    = cos(phiw*dg2rd)
   snw    = sin(phiw*dg2rd)
endif

call getwavenr(hu(LL), Tsig ,rk)
Hrms   = 0.5d0*( Hwav(k1)   + Hwav(k2) )
Hrms   = min(hrms,gammax*hu(LL))
asg    = 0.5d0*Hrms                              ! Wave amplitude = 0.5*Hrms
shs    = sinhsafei(rk*hu(LL))
if (shs > 0d0) then
   uorbu  = omeg*asg*shs                         ! Orbital velocity
   call  Swart(Tsig, uorbu, z00, fw, ustw2)
   ustw2  = ftauw*ustw2                          ! ustar wave squared times calibrationcoeff

   dks    = 30d0*z00                             ! should be 30 for consistency with getustb
   aks    = asg*shs/dks                          ! uorbu/(omega*ks), uorbu/omega = particle excursion length
   deltau = 0.09d0 * dks * aks**0.82d0           ! thickness of wave boundary layer also see: Sana, Tanaka 2007
   deltau = alfdeltau*max(deltau, ee*z00 )       ! alfaw = 20d0
   deltau = min(0.5d0*hu(LL), deltau)            !

   Dfu    = ustw2*uorbu/sqrt(pi)                 ! dissipation by waves (m3/s3)
   Dfu    = Dfu/deltau                           ! divided by deltau    (m2/s3)
   Dfuc   = Dfu*rk*Tsig/twopi                    ! Dfuc = dfu/c,        (m /s2) is contribution to adve
else
   ustw2  = 0d0
   Dfu    = 0d0
   Dfuc   = 0d0
   deltau = 0d0
endif

!Dfu   = ustw2*uorbu*rhomean/sqrt(pi)  ! in D3D it is multiplication with rhomean here icw with division by rhomean at setting RHS
!deltau(nm) = 0.09_fp * (ks/hu(nm)) * (a/ks)**0.82_fp
!deltau(nm) = alfaw*max(ee*z0ucur(nm)/hu(nm) , deltau(nm))
!deltau(nm) = min(0.5_fp, deltau(nm))*hu(nm)

costu  =  csw*csu(LL) + snw*snu(LL)            ! and compute stokes drift
sintu  = -csw*snu(LL) + snw*csu(LL)

if (jawaveStokes == 1) then
   uusto          =  0.5d0*omeg*asg*asg/hu(LL)
   ustokes(Lb:Lt) =  costu*uusto
   vstokes(Lb:Lt) =  sintu*uusto
else if (jawaveStokes >= 2) then
   f1u    = omeg*rk*asg**2
   h      = hu(LL)
   f3u    = (1d0 - exp(-2d0*rk*h ) )**2
   qsto   = 0d0
   do L   = Lb, Lt
      z   = 0.5d0*( hu(L) + hu(L-1) )         ! here, z is vertical coordinate upward, bed = 0,    (not z = 0 at average wl)
      p1  = max(-25d0,  2d0*rk*(z - h))
      p2  = max(-25d0, -4d0*rk*(z    ))       ! maximisation not necessary
      f2u = exp(p1) * ( 1d0 + exp(p2) )
      uusto      = f1u   * f2u / f3u
      ustokes(L) = costu * uusto
      vstokes(L) = sintu * uusto
      qsto       = qsto + ustokes(L)*(hu(L)-hu(L-1))
   enddo

   usto3Dav = qsto/hu(LL)
   usto2D   = costu*0.5d0*omeg*asg*asg/hu(LL)
   ustoktb  = f1u*(2d0*p1/ (1d0-p1)) **2

endif

end subroutine getustwav

subroutine gettau2(n,taucurc,czc,ustw2)
use m_flowgeom
use m_flow
use m_waves

 
implicit none
integer, intent(in)   :: n               !< Flow node number
double precision, intent(out) :: taucurc !< Bed shear stress from current or current plus wave 
double precision, intent(out) :: czc     !< Chezy at flow node (taucurrent)
double precision, intent(out) :: ustw2   !< Ustarwave Swart (if Jawaveswartdelwaq == 1)


!
!           Local variables
!
integer :: LL, nn                            !< Local link counters
double precision ::  cf, cfn, cz, frcn, ar,  wa, ust, ust2, fw    !< Local intermediate variables

taucurc = 0d0 ; ustw2 = 0d0
czc = 0d0
cfn = 0d0
wa  = 0d0
ust = 0d0

do nn = 1,nd(n)%lnx 
   LL = abs( nd(n)%ln(nn) )
   frcn = frcu(LL) 
   if (frcn > 0 .and. hu(LL) > 0) then 
      call getcz(hu(LL), frcn, ifrcutp(LL), cz,LL)
      cf  = ag/(cz*cz)
      ar  = au(LL)*dx(LL)
      wa  = wa + ar       ! area  weigthed
      cfn = cfn + cf*ar
      if (kmx > 0) then
         if (jawaveswartdelwaq <= 1) then 
            ust = ust + ustb(LL)*ar
         else
            ust = ust + taubxu(LL)*ar
         endif   
      endif
   endif 
enddo
if (wa > 0) then 
   cfn = cfn / wa 
   ust = ust / wa 
endif
if (cfn > 0) then 
   czc = sqrt(ag/cfn)
endif

ust2 = 0d0
if (kmx == 0) then
    ust2 = cfn*(ucx(n)*ucx(n) + ucy(n)*ucy(n))
else  
    ust2 = ust*ust
endif

if (jawaveswartdelwaq == 0) then 
   taucurc = rhomean*ust2
else if (jawaveSwartDelwaq == 1) then 
   if (twav(n) > 1d-2) then 
      call Swart(Twav(n), uorb(n), z0wav, fw, ustw2)
      ust2  = ust2 + ustw2                    ! Swart          
   endif
   taucurc = rhomean*ust2          
else if (jawaveSwartDelwaq == 2) then 
   taucurc = ust                              ! area averaged taubxu
endif

end subroutine gettau2

subroutine Swart(Tsig, uorbu, z00, fw, ustw2)
use m_flow,  only : rhomean

implicit none
double precision :: Tsig, uorbu, z00, fw, ustw2
double precision :: astar

if (uorbu == 0d0) then
   fw = 0d0 ; ustw2 = 0d0 ; return
endif

astar = Tsig*uorbu/z00
if (astar > 296.088d0)  then                       ! 30pipi
    fw = 0.00251d0*exp(14.1d0/(astar**0.19d0))     ! astar=Tuorb/z00
else
    fw = 0.3d0
endif
ustw2 = 0.5d0*fw*uorbu*uorbu

end subroutine Swart


 subroutine tauwavehk(Hrms, Tsig, Depth, Uorbi, rlabd, ust)
 use m_flow, only: plotlin, rhog, rhomean, jased
 use m_sferic
 use m_waves, only : gammax

 implicit none
 double precision           :: Hrms, Tsig, Depth, uorbi, Tauw, hrm, ust
 integer                    :: k, jatauw = 2
 double precision           :: hk, sh2hk,hksh2,rn,asg,ew,sxx,syy,sxy,syx,dtau,shs, h2k, cp, cg, omeg
 double precision           :: dsk2, rk, rkx, rky, astar, fw, cgcp, rk2cgcp,  cgcp5, arms, rlabd

 double precision, external :: tanhsafe, sinhsafe, sinhsafei
 integer :: ndraw
 COMMON /DRAWTHIS/ ndraw(50)

 call getwavenr(depth,tsig,rk)
 hrm    = min( Hrms,gammax*depth )
 arms   = 0.5d0*hrms
 omeg   = twopi/tsig
 shs    = sinhsafei(rk*depth)
 uorbi  = omeg*arms*shs                        !omeg*(0.5*hsig)
 ust    = 0.5d0*omeg*arms*arms/depth
 rlabd  = twopi/rk
 return

 if (ndraw(28) > 40) then
    omeg    = twopi/tsig                        ! omega
    cp      = omeg/rk                           ! fase velocity
    hk      = rk*depth                          ! kh
    sh2hk   = sinhsafei(2d0*hk)                 ! 1/sinh(2hk)
    hksh2   = hk*sh2hk                          ! kh/sinh(2kh)
    cgcp    = 0.5d0 + hksh2                     ! cg/cp
    cg      = cp*cgcp                           ! group velocity
    asg     = 0.5d0*hrms                        ! rms wave amplitude
    ew      = 0.5d0*rhog*asg*asg                ! wave energy
    !ustokes(z) =       rk*omeg*asg*asg*exp(2d0*rk*z)                         ! Vertical Stokes drift profile deep water
    !ustokes    =    0.5d0*omeg*asg*asg/depth                                 ! deep water vertical averaged
    !ustokes(z) = 0.5d0*rk*omeg*asg*asg*cosh(2d0*rk*(z+depth)/sinh2(rk*depth) ! Stokes drift profile  (5) Monismithetal2007.pdf

    Sxx     = ew*(0.5d0 + 2d0*hksh2)            ! radiation stress in wave dir
    Syy     = ew*hksh2                          ! radiation stress perpendicular to wave dir

    rk2cgcp = rk*rk*cgcp                        ! or, Wikipedia
    cgcp5   = cgcp - 0.5d0
    Sxx     = ew*( rkx*rkx/rk2cgcp + cgcp5 )
    Syy     = ew*( rky*rky/rk2cgcp + cgcp5 )
    Syx     = ew*( rkx*rky/rk2cgcp + 0d0   )
    Sxy     = Syx

    ! standard deviation or RMS of sine wave a*sin(om*t) : 0.5*sqrt(2)*a
    ! Hsig or HRMS is equal to 4 times RMS
    ! Hsig = 4*0.5*sqrt(2)*a = 2*sqrt(2)*a = 2.8*a

 endif

 end subroutine tauwavehk


 subroutine hurdlestive(U10,fetchL,fetchD,Hsig,Tsig)
 use m_physcoef
 IMPLICIT NONE
 double precision :: U10,fetchL,fetchD,Hsig,Tsig
 double precision :: rt, ua,fs,ds,aa1,aa2,aa3,aa4
 double precision, external :: tanhsafe

 rt   = 1.1d0                           ! temperature and density  dependent
 ua   = 0.71d0*(rt*U10)**1.23           ! reference wind speed
 fs   = ag * fetchl / ua**2             ! dimensieloze strijklengte
 ds   = ag * fetchd / ua**2             ! dimensieloze diepte

 aa1  = 0.60d0 *ds**0.750d0             ! formulae from : Coastal stabilisation, R. Silvester, J.R.C. Shu, 2.35 en 2.36
                                        ! taken from Hurdle, Stive 1989 , RESULTS SEEM VERY SIMILAR TO THOSE OF DELWAQ CODE ABOVE
 aa3  = 4.3d-5*fs/tanhsafe(aa1)**2
 hsig = 0.25d0*tanhsafe(aa1)*tanhsafe(aa3)**0.5000000d0
 hsig = hsig*ua*ua/ag

 aa2  = 0.76d0 *ds**0.375d0
 aa4  = 4.1d-5*fs/tanhsafe(aa2)**3
 tsig = 8.30d0*tanhsafe(aa2)*tanhsafe(aa4)**0.3333333d0
 tsig = tsig*ua/ag
 end subroutine hurdlestive

 SUBROUTINE ian_young_pt(U10,x,d,Hsig,Tsig)
  use m_physcoef
  IMPLICIT NONE
  double precision , INTENT(IN)  :: d,U10,x
  double precision , INTENT(OUT) :: Hsig, Tsig
  double precision               :: E,fp
  double precision               :: delta, XX, A1, B1, epsilon, nu, A2, B2, ta1, ta2
  double precision, external     :: tanhsafe
  XX=ag*x/U10**2             ! non-dim fetch
  delta=ag*d/U10**2          ! non-dim depth
                             ! calculate nondimensional energy
  B1=3.13e-3*XX**0.57
  A1=0.493*delta**0.75
  ta1=tanhsafe(A1)
  epsilon=3.64e-3*(tA1*tanhsafe(B1/ta1))**1.74
                             ! calculate nondimensional frequency
  B2=5.215e-4*XX**0.73
  A2=0.331*delta**1.01
  ta2=tanhsafe(A2)
  nu=0.133*(tA2*tanhsafe(B2/tA2))**(-0.37);
  E =U10**4*epsilon/ag**2    ! total energy from non-dim energy
  Hsig=4*SQRT(E)             ! significant wave height
  fp=nu*ag/U10               ! peak freq from non-dim freq, Hz
  Tsig=1d0/fp
 END SUBROUTINE ian_young_pt


 double precision function tanhsafe(a)
 implicit none
 double precision :: a
 if (a < 9d0) then
    tanhsafe = tanh(a)
 else
    tanhsafe = 1d0
 endif
 end function

 double precision function sinhsafe(a)
 implicit none
 double precision :: a
 if (a < 9d0) then
    sinhsafe = sinh(a)
 else
    sinhsafe = 0.5d0*exp(a)
 endif
 end function

 double precision function coshsafe(a)
 implicit none
 double precision :: a
 if (a < 9d0) then
    coshsafe = cosh(a)
 else
    coshsafe = 0.5d0*exp(a)
 endif
 end function

 double precision function sinhsafei(a) ! inverse
 implicit none
 double precision :: a
 if (a < 9d0) then
    sinhsafei = 1d0/sinh(a)
 else
    sinhsafei = 0d0
 endif
 end function

 double precision function coshsafei(a) !inverse
 implicit none
 double precision :: a
 if (a < 9d0) then
    coshsafei = 1d0/cosh(a)
 else
    coshsafei = 0d0
 endif
 end function


 subroutine getwavenr(h, T, k)
 use m_sferic
 use m_physcoef
 implicit none
 ! get wavenr from waterdepth and period, see d3d doc

 double precision, parameter    :: a1 = 5.060219360721177D-01, a2 = 2.663457535068147D-01,  &
                                   a3 = 1.108728659243231D-01, a4 = 4.197392043833136D-02,  &
                                   a5 = 8.670877524768146D-03, a6 = 4.890806291366061D-03,  &
                                   b1 = 1.727544632667079D-01, b2 = 1.191224998569728D-01,  &
                                   b3 = 4.165097693766726D-02, b4 = 8.674993032204639D-03

 double precision , intent(in)  :: h                    !  Waterheight
 double precision , intent(in)  :: t                    !  Period
 double precision , intent(out) :: k                    !  Approximation of wave lenght


 double precision               :: den                  ! Denominator
 double precision               :: kd                   ! Double value for K
 double precision               :: num                  ! Numerator
 double precision               :: ome2 , rk, fac, rlabda, rlab0, rn    ! Omega

 ome2 = ( (twopi/T)**2 )*h/ag
 num  = 1.0D0 + ome2*(a1 + ome2*(a2 + ome2*(a3 + ome2*(a4 + ome2*(a5 + ome2*a6)))))
 den  = 1.0D0 + ome2*(b1 + ome2*(b2 + ome2*(b3 + ome2*(b4 + ome2*a6))))
 k    = sqrt(ome2*num/den)/ h

 return

 call getwavenrqn(h,T,RK)
 fac    = k/rk                    ! check
 rlabda = twopi / k
 rlab0  = T*sqrt(9.81*h)
 rn     = rlabda/rlab0

 end subroutine getwavenr

SUBROUTINE getwavenrqn(DEPTH,Period, RK)
use m_sferic
implicit none
double precision :: PERIOD,DEPTH,RK
double precision :: OMEGAS, GR, RLAB0, DEP2PI,  RLAB1, rlab2, criter
OMEGAS = TWOPI / PERIOD
GR     = 9.81
RLAB0  = TWOPI*GR / OMEGAS**2
DEP2PI = TWOPI*DEPTH
RLAB1  = RLAB0*SQRT( TANH(DEP2PI / RLAB0) )

10 CONTINUE
   RLAB2  = RLAB0*TANH(DEP2PI/RLAB1)
   CRITER = (RLAB2 - RLAB1) / RLAB1
   IF (ABS(CRITER) .LT. 0.001) THEN
      RK = TWOPI/RLAB2
      RETURN
   ELSE
      RLAB1 = RLAB2
      GOTO 10
   ENDIF

end SUBROUTINE getwavenrqn

 subroutine setupwslopes()                           ! set upwind slope pointers and weightfactors
 ! TODO: 1D upwind slope pointers (gewoon de vorige)
 use m_flowgeom
 use m_flow, only  : plotlin
 use m_flowparameters, only: jaupwindsrc
 use m_sferic
 use m_alloc
 use geometry_module, only: getdx, getdy, dbdistance, spher2locvec
 use sorting_algorithms, only: indexx
 use m_missing, only: dmiss
 use m_flowexternalforcings

 implicit none


 integer           :: L, k12, k2
 double precision  :: dxn, dyn, rmin, xc, yc, dxu, dyu, r, rli
 integer           :: k,kk,LL,ku,kd,ja, ku2, nn, jacros
 integer           :: i, iup, ib, ng

 double precision  :: xzup, yzup, dxx, dyy, rfr, sum, slnupmax, dxk, dis, xn, yn, sl, sm, crp, xcr, ycr, dxl

 double precision, allocatable :: xzu(:), yzu(:)     ! temparrs for triangulations
 double precision, allocatable :: zz(:), zzu(:), wfn(:,:)
 integer         , allocatable :: indxn(:,:) , kcz(:), kcuu(:)
 integer                       :: jdla, ierr, n, NLNUPMAX
 double precision              :: rn (6)
 integer                       :: kun(6), nri(6)

 double precision, external    :: dprodin


 if (allocated (klnup) ) then
    deallocate (klnup, slnup)
 endif
 allocate (  klnup(6,lnx) , stat=ierr ); klnup = 0
 call aerr( 'klnup(6,lnx)', ierr, lnx )
 allocate (  slnup(6,lnx) , stat=ierr ); slnup = 0d0
 call aerr( 'slnup(6,lnx)', ierr, lnx )

 if ( allocated(csbup) ) then
    deallocate(csbup)
    deallocate(snbup)
 end if

 if ( jsferic.eq.1 .and. jasfer3D.eq.1 ) then
!   allocate orientation arrays
    allocate(  csbup(4,Lnx) , stat=ierr); csbup = 1d0
   call aerr( 'csbup(4,Lnx)', ierr, Lnx )
    allocate(  snbup(4,Lnx) , stat=ierr); snbup = 0d0
   call aerr( 'snbup(4,Lnx)', ierr, Lnx )
 end if

 do L = 1, lnx

    if (kcu(L) >= 3 .and. kcu(L) <= 7) then          ! switch off at 1D2D connections
       cycle
    endif


    dxn = -csu(L)  ; dyn = -snu(L)                   ! normal vector in upwind dir

    do k12  = 1,2

       rmin = 0
       k    = ln(k12,L)
       kd   = ln(2,L) ; if (k12 == 2) kd = ln(1,L)

! SPvdP: (xzup, yzup) not used here
!       xzup = 2d0*xz(k) - xz(kd)                     ! upwind position for which cell centre interpolated values
!       yzup = 2d0*yz(k) - yz(kd)                     ! need be found

       if (abs(kcu(L)) ==  1 ) then
          if ( nd(k)%lnx .ne. 2) then
             cycle
          endif
       endif

       if (k12 == 2) then
          dxn = -dxn; dyn = -dyn
       endif

       n = 0
       do kk = 1,nd(k)%lnx                           ! first try to find 1 point that is sufficiently close to link line
          LL = iabs(nd(k)%ln(kk))                    ! use this 1 point if it is less than e.g. 0.1dx away from xzup
          if (LL .gt. lnx1D .and. LL .ne. L) then                        !
             ku = ln(1,LL)
             if (ku == k) ku = ln(2,LL)

!             dxx  = getdx( xz(k), yz(k), xz(ku), yz(ku) )
!             dyy  = getdy( xz(k), yz(k), xz(ku), yz(ku) )
!
!             dxu = dxx*dxi(LL)
!             dyu = dyy*dxi(LL)
!             r   = dxu*dxn + dyu*dyn

             r = dprodin(xz(kd),yz(kd),xz(k),yz(k),xz(k),yz(k),xz(ku),yz(ku))
             r = r*(dxi(L)**2)

             if (r > 0) then                         ! points upwind
                n      = n + 1
                call dlinedis2(xz(ku), yz(ku), xz(k), yz(k), xz(kd), yz(kd), ja, dis, xn, yn, sl)
                rn(n)  = dis
                kun(n) = ku
             endif
          endif
       enddo

       if (n > 0) then
          nri(1) = 1
          if (n > 1) call indexx(n,rn,nri)           ! sorted in closeness to linkline

          nn  = 1
          ku  = kun(nri(nn))
          rfr =  rn(nri(nn)) * dxi(L)
!         if (n == 1 .or. rfr < 0.1d0) then          ! if only 1 link attached or upwind point sufficiently close
          if (            rfr < 0.1d0) then          ! if only 1 link attached or upwind point sufficiently close

             klnup(1+3*(k12-1),L) = -ku              ! flag for single value weighting
!             dxx  = getdx( xz(k), yz(k), xz(ku), yz(ku) )
!             dyy  = getdy( xz(k), yz(k), xz(ku), yz(ku) )
!             dxk  = sqrt(dxx*dxx + dyy*dyy)

             dxk = dbdistance(xz(k),yz(k),xz(ku),yz(ku), jsferic, jasfer3D, dmiss)

             dxl  = dx(L)
             slnup(3+3*(k12-1),L) = dxl/dxk          ! slope weigths in 3 or 6

             if (L > lnx1D) then                           ! switch of when intersecting fixed weir flagged by iadv type 6 or 8
                do kk = 1,nd(k)%lnx                        !
                   LL = iabs(nd(k)%ln(kk))                 ! see testcase transport harbour
                   k2 = ln(1,LL) + ln(2,LL) - k
                   if (k2 == ku) then
                       if (iadv(LL) == 6 .or. iadv(LL) == 8) then
                           klnup(1+3*(k12-1),L) = 0
                       endif
                   endif
                enddo
             endif


             cycle
          endif

          jacros = 0
          if (n >= 2) then
             nn  = 2
             ku2 = kun(nri(nn))                      ! can we interpolate in ku and ku2?
             call dcross (xz(kd), yz(kd), xz(k), yz(k), xz(ku), yz(ku), xz(ku2), yz(ku2),JACROS,SL,SM,XCR,YCR,CRP)
             if (sl < 1.2) jacros = 0 ! int point too close to xz(k)
          endif

          if (n >= 3 .and. jacros == 0) then
             nn  = 3
             ku2 = kun(nri(nn))
             call dcross (xz(kd), yz(kd), xz(k), yz(k), xz(ku), yz(ku), xz(ku2), yz(ku2),JACROS,SL,SM,XCR,YCR,CRP)
             if (sl < 1.2) jacros = 0 ! int point too close to xz(k)
          endif

          if (n >= 4 .and. jacros == 0) then
             nn  = 4
             ku2 = kun(nri(nn))
             call dcross (xz(kd), yz(kd), xz(k), yz(k), xz(ku), yz(ku), xz(ku2), yz(ku2),JACROS,SL,SM,XCR,YCR,CRP)
             if (sl < 1.2) jacros = 0 ! int point too close to xz(k)
          endif

          if (jacros == 1) then

             if (L > lnx1D) then                           ! switch of when intersecting fixed weir flagged by iadv type 6 or 8
                do kk = 1,nd(k)%lnx                        !
                   LL = iabs(nd(k)%ln(kk))                 ! see testcase transport harbour
                   k2 = ln(1,LL) + ln(2,LL) - k
                   if (k2 == ku .or. k2 == ku2) then
                       if (iadv(LL) == 6 .or. iadv(LL) == 8) then
                          ku = 0; ku2 = 0
                       endif
                   endif
                enddo
             endif

             klnup(2+3*(k12-1),L) = ku2
             slnup(2+3*(k12-1),L) = sm

             klnup(1+3*(k12-1),L) = ku
             slnup(1+3*(k12-1),L) = 1d0 - sm

!             dxx  = getdx(xz(k), yz(k), xcr, ycr )
!             dyy  = getdy(xz(k), yz(k), xcr, ycr )
!             dxk  = sqrt(dxx*dxx + dyy*dyy)
              dxk = dbdistance(xz(k),yz(k),xcr,ycr, jsferic, jasfer3D, dmiss)

             dxl  = dx(L)
             slnup(3+3*(k12-1),L) = dxL/dxk         ! slope weigths in 3 or 6

             if (size(nd(k)%x) == 3 .or. size(nd(kd)%x) == 3) then ! flag links connected to triangle on either side as negative through klnup(2,*)
                klnup(2+3*(k12-1),L) = -iabs( klnup(2+3*(k12-1),L) ) ! for maxlimontris
             endif

          endif

      endif

    enddo
    !plotlin(L) = klnup(2,L)
 enddo



 if ( jsferic.eq.1 .and. jasfer3D.eq.1 ) then
!   compute orientation
    do L=1,Lnx
       do k12=1,2
          do i=1,2
             iup = (k12-1)*3 + i
             ib  = (k12-1)*2 + i
             k = iabs(klnup(iup,L))
             if ( k.gt.0 ) then
                call spher2locvec(xz(k),yz(k),1,(/xu(L)/),(/yu(L)/),(/1d0/),(/0d0/),csbup(ib,L),snbup(ib,L),jsferic, jasfer3D, dmiss)
             end if
          end do
       end do
    end do
 end if


 goto 1234

! allocate ( xzu(lnx), yzu(lnx), zzu(lnx), kcuu(lnx), indxn(3,lnx), wfn(3,lnx) , stat=ierr)
! call aerr('xzu(lnx), yzu(lnx), zzu(lnx), kcuu(lnx), indxn(3,lnx), wfn(3,lnx)', ierr, 9*lnx)
!
!
! allocate ( zz(ndx), kcz(ndx) , stat=ierr   ) ; zz= 0 ; kcz = 1
! call aerr('zz(ndx), kcz(ndx)', ierr, 2*ndx )
!
! do k12  = 1,2
!
!    kcuu = 0 ; xzu = 0 ; yzu = 0 ; zzu = 0
!    do L = 1,lnx
!
!       xzup = 2d0*xz( ln(1,L) ) - xz( ln(2,L) )     ! upwind position for which cell centre interpolated values
!       yzup = 2d0*yz( ln(1,L) ) - yz( ln(2,L) )     ! need be found
!       if (k12 == 2) then
!          dxn = -dxn ; dyn = -dyn
!          xzup = 2d0*xz( ln(2,L) ) - xz( ln(1,L) )
!          yzup = 2d0*yz( ln(2,L) ) - yz( ln(1,L) )
!       endif
!       xzu(L) = xzup + 0.1d0 ; yzu(L) = yzup + 0.1d0 ; kcuu(L) = 1
!
!    enddo
!
!    jdla  = 1
!    indxn = 0
!    wfn   = 0
!    call triint( xz  , yz  ,  zz, kcz , ndx,                     &
!                 xzu , yzu , zzu, kcuu, 1, lnx, jdla, indxn, wfn )
!
!    do L = 1,lnx
!       if (klnup(1+3*(k12-1),L) == 0) then
!           slnupmax = 0  ; nlnupmax = 0
!           do n = 1,3
!              klnup(n+3*(k12-1),L) = indxn(n,L)
!              slnup(n+3*(k12-1),L) =   wfn(n,L)
!              sum = sum + slnup(n+3*(k12-1),L)
!              if (slnup(n+3*(k12-1),L) > slnupmax ) then
!                  slnupmax = slnup(n+3*(k12-1),L)
!                  nlnupmax = n
!              endif
!              sum = sum - slnupmax
!           enddo
!           do n = 1,3
!              if (n == nlnupmax) then
!                 slnup(n+3*(k12-1),L) = 1 - sum
!              endif
!           enddo
!       endif
!    enddo
! enddo
!
! deallocate ( xzu, yzu, zzu, kcuu, indxn, wfn)
! deallocate ( zz, kcz )

1234 continue

 if ( jaupwindsrc.eq.1 ) then
!  disable higher-order reconstruction at all flowlinks connected to source/sink flownodes
   call disable_higherorder_at_sorsin()
 end if

 do ng = 1,ngatesg  ! loop over gate signals
    do n  = L1gatesg(ng), L2gatesg(ng)
       LL  = kgate(3,n)
       klnup(:,LL) = 0
    enddo
 enddo

 end subroutine setupwslopes

 double precision function dslim(d1,d2,limtyp)
 implicit none
 double precision d1, d2                             ! voorslope, naslope
 integer limtyp
 double precision :: dminmod, dvanleer, dkoren,dcentral,dcminmod, dsuperbee
 double precision :: rminmod,rvanleer,rkoren,rcentral
 double precision :: dlimiter,dlimitercentral

 ! In order to translate psi to limiter, you have to multiply the psi function with ds2
 ! e.g. lax wendroff central: psi=1, dslimiter=d2

 if (limtyp .eq. 0) then
    dslim = 0
 else if (limtyp .eq. 1) then                        ! codering guus, met voorslope
    dslim = d1*dminmod(d1,d2)
 else if (limtyp .eq. 2) then                        ! codering guus, met voorslope
    dslim = d1*dvanleer(d1,d2)
 else if (limtyp .eq. 3) then                        ! codering guus, met voorslope
    dslim = d1*dkoren(d1,d2)
 else if (limtyp .eq. 4) then                        ! monotonized central no division
    dslim = dcentral(d1,d2)
 else if (limtyp .eq. 5) then                        ! monotonized central Sander with division
    dslim = dlimiter(d1,d2,limtyp) * d2
 else if (limtyp .eq. 6) then                        ! monotonized central Sander with division, upwind slope ds1 at central cel
    dslim = dlimitercentral(d1,d2,limtyp)
  else if (limtyp .eq. 11) then                      ! standaard codering
    dslim = d2*dminmod(d1,d2)
 else if (limtyp .eq. 12) then                       ! standaard codering
    dslim = d2*dvanleer(d1,d2)
 else if (limtyp .eq. 13) then                       ! standaard codering
    dslim = d2*dkoren(d1,d2)
 else if (limtyp .eq. 14) then                       ! monotonized central, == 4
    dslim = dcentral(d2,d1)
 else if (limtyp .eq. 15) then                       ! minmod central
    dslim = dcminmod(d2,d1)
 else if (limtyp .eq. 20) then                       ! leftbiased, beam&warming
    dslim = d1
 else if (limtyp .eq. 21) then                       ! central
    dslim = d2
 else if (limtyp .eq. 22) then                       ! superbee
    dslim = dsuperbee(d1,d2)
 else
    dslim = 0d0
 endif
 return
end function dslim

double precision function dsuperbee(ds1, ds2)
   implicit none
   double precision     :: ds1, ds2, r

   if (ds1*ds2>0d0) then
      r = ds1/ds2
      dsuperbee = max(0d0, min(2d0*r,1d0),min(r,2d0))
      dsuperbee = dsuperbee*ds2
   else
      dsuperbee = 0d0
   end if
end function


 double precision function dkoren(d1,d2)                       ! nog naar kijken
 implicit none
 double precision d1, d2, r
 if (d1*d2 > 0d0) Then
    r=d2/d1
    dkoren=max(0d0,min(r+r,min((1d0+r+r)/3d0,2d0)))
 else
    dkoren=0d0
 endif
 return
 end function dkoren

 double precision function dvanleer(d1,d2)                     ! twee maal vergroot vanwege acl
 implicit none
 double precision d1, d2
 if (d1*d2 > 0d0) then
   dvanleer = 2d0*d2/(d1+d2)
 else
   dvanleer = 0d0
 endif
 return
 end function dvanleer

 double precision function dminmod(d1,d2)                      ! twee maal vergroot vanwege acl
 implicit none
 double precision d1, d2
 if (d1*d2 > 0d0) then
   dminmod =min(1d0,d2/d1)
 else
   dminmod =0d0
 endif
 return
 end function dminmod

 double precision function dcentral(d1,d2)                     ! twee maal vergroot vanwege acl
 implicit none
 double precision d1, d2, dcminmod
 if (d1*d2 > 0d0) then
   dcentral = dcminmod( (d1+d2)*0.5d0 , dcminmod( 2d0*d1, 2d0*d2) )
 else
   dcentral = 0d0
 endif
 return
 end function dcentral

 double precision function dcminmod(d1,d2)                     ! basic minmod definition
 implicit none
 double precision d1, d2
 if (d1*d2 > 0) then
    if (abs(d1) < abs(d2)) then
       dcminmod = d1
    else
       dcminmod = d2
    endif
 else
    dcminmod = 0d0
 endif
 return
 end function dcminmod



 double precision function rslim(d1,d2,limtyp)
 implicit none
 double precision :: d1, d2
 double precision :: rminmod,rvanleer,rkoren,rcentral
 integer :: limtyp

 if (limtyp .eq. 0) then
    rslim = 0
 else if (limtyp .eq. 1) then                        ! codering guus, met voorloper
    rslim = d1*rminmod(d1,d2)
 else if (limtyp .eq. 2) then                        ! codering guus, met voorloper
    rslim = d1*rvanleer(d1,d2)
 else if (limtyp .eq. 3) then                        ! codering guus, met voorloper
    rslim = d1*rkoren(d1,d2)
 else if (limtyp .eq. 4) then                        ! monotonized central
    rslim = rcentral(d1,d2)
 endif
 return
 end function rslim

 double precision function rkoren(sl1,sl2)                       ! nog naar kijken
 implicit none
 double precision :: sl1, sl2
 double precision :: r
 if (sl1*sl2.GT.0d0) Then
    r=sl2/sl1
    rkoren=max(0d0,min(r+r,min((1d0+r+r)/3d0,2d0)))
 else
    rkoren=0d0
 endif
 return
 end function rkoren

 double precision function rvanleer(sl1,sl2)                     ! twee maal vergroot vanwege acl
 implicit none
 double precision :: sl1, sl2
 if (sl1*sl2.GT.1.0d-2) then
   rvanleer=2*sl2/(sl1+sl2)
 else
   rvanleer=0d0
 endif
 return
 end function rvanleer

 double precision function rminmod(sl1,sl2)                      ! twee maal vergroot vanwege acl
 implicit none
 double precision :: sl1, sl2
 if (sl1*sl2.GT.0d0) then
   rminmod=min(1d0,sl2/sl1)
 else
   rminmod=0d0
 endif
 return
 end function rminmod

 double precision function rcentral(sl1,sl2)                     ! twee maal vergroot vanwege acl
 implicit none
 double precision :: sl1, sl2
 double precision :: tminmod
 if (sl1*sl2.GT.0d0) then
   rcentral=tminmod( (sl1+sl2)*0.5d0 , tminmod( 2*sl1, 2*sl2) )
 else
   rcentral=0d0
 endif
 return
 end function rcentral


 double precision function tminmod(sl1,sl2)                      ! basic minmod definition
 implicit none
 double precision :: sl1, sl2
 if (sl1*sl2 > 0) then
    if (abs(sl1) < abs(sl2)) then
       tminmod = sl1
    else
       tminmod = sl2
    endif
 else
    tminmod = 0d0
 endif
 return
 end function tminmod

 double precision function sminmod(sl1,sl2)
 implicit none
 double precision :: sl1, sl2
 double precision :: r
 r = sl1/sl2
 sminmod = max(0d0,min(1d0,r))
 return
 end function sminmod

 double precision function svanleer(sl1,sl2)
 implicit none
 double precision :: sl1, sl2
 double precision :: r
 r = sl1/sl2
 svanleer = (r + abs(r))/(1d0 + r)
 return
 end function svanleer

 double precision function skoren(sl1,sl2)
 implicit none
 double precision :: sl1, sl2
 double precision :: r
 r = sl1/sl2
 skoren = max(0d0,min(r+r,min((1d0+r+r)/3d0,2d0)))
 return
 end function skoren

double precision function upwsalslope(L,k,ds2)          ! k is upwind cell for link L, find slope upwind of k
 use m_flowgeom                                          ! limit upwind slopes for all inflowing links
 use m_flow
 implicit none
 integer          :: L, k
 double precision :: ds2


 integer                    :: kk,ku,LL,LLL,jap
 double precision           :: ds1
 double precision, external :: dcminmod

 upwsalslope = -1d9
 if (ds2 < 0) upwsalslope = 1d9

 jap = -1
 if (ln(1,L) == k) jap = 1

 do kk = 1,nd(k)%lnx
    LLL= nd(k)%ln(kk)
    LL = iabs(LLL)
    if (LL .ne. L .and. q1(LL)*LLL > 0) then
       ku = ln(1,LL)
       if (ku == k) ku = ln(2,LL)

       ds1 = (sa0(k) - sa0(ku))*jap

       if (ds2 > 0) then
          upwsalslope = dcminmod(ds1,ds2)
       else if (ds2 < 0) then
          upwsalslope = dcminmod(ds1,ds2)
       endif
    endif
 enddo
 end function upwsalslope


 double precision function upwsal(L,k12)                        ! upwind salinity
 use m_flowgeom
 use m_flow
 implicit none
 integer :: L, k12

 double precision :: cl, sl, rl, ql, qls
 integer :: k, kk, LL, LLL, ku

 cl = csu(L)  ; sl = snu(L)
 if (k12 == 2) then
     cl = -cl ; sl = -sl
 endif

 k    = ln(k12,L)

 ql   = 0
 qls  = 0
 do kk  = 1,nd(k)%lnx
    LL  = nd(k)%ln(kk)
    LLL = iabs(LL)
    ku  = ln(1,LLL)
    if (ku == k) ku = ln(2,LLL)

    rl = cl*csu(LLL) + sl*snu(LLL)
    if      (LL > 0 .and. q1(LLL) > 0) then
         if (rl > 0) then
            ql  = ql  + rl*q1(LLL)
            qls = qls + rl*q1(LLL)*sa0(ku)
         endif
    else if (LL < 0 .and. q1(LLL) < 0) then
         if (rl < 0) then
            ql  = ql  + rl*q1(LLL)
            qls = qls + rl*q1(LLL)*sa0(ku)
         endif
    endif
 enddo

 if (ql > 0) then
    upwsal = qls/ql
 else
    upwsal = sa0(k)
 endif

 end function upwsal



 subroutine checkspeed(rr)
 use unstruc_messages
 implicit none
 double precision :: mult0, mult1, mult, divt0, divt1, divt
 double precision :: t, ti, r, rr, rrm, rrd
 integer :: k, key

 call klok(mult0)


 do k   = 1,10000
    t   = 1d0*k - 1d0*k + 1.5155155d0
    ti  = 1d0/t
    r   = 0
    rrm = 0
    do key = 1,1000000
       r   = r + 1d0
       rr  = r*ti
       rrm = rrm + rr            ! remove this line and both loops will have identical perf on compaq visual
    enddo
 enddo

 call klok(mult1)

 call klok(divt0)

 do k   = 1,10000
    t   = 1d0*k - 1d0*k + 1.5155155d0
    ti  = 1d0/t
    r   = 0
    rrd = 0
    do key = 1,1000000
       r   = r + 1d0
       rr  = r/t
       rrd = rrd + rr
    enddo
 enddo

 call klok(divt1)

 mult = mult1-mult0
 divt = divt1-divt0

 write(msgbuf,*) 'mult ', mult
 call msg_flush()
 write(msgbuf,*) 'divt ', divt
 call msg_flush()
 write(msgbuf,*) 'divt/mult ', divt/mult
 call msg_flush()
 write(msgbuf,*) 'rrm, rrd, rrd-rrm ', rrm, rrd, rrd-rrm
 call msg_flush()

 end subroutine checkspeed

 subroutine carrier( ndx, time1)
 implicit none
 double precision :: time1
 integer          :: ndx
 double precision :: J0(100),J1(100),A1(100),A3(100), ahh
 double precision :: h0, T0, s, etinbr,dc,tol,etabr,etain,a,a2
 double precision :: omega,sg,osg,osg2,rl0,c,dt,t,uold,u,x,xster,hh,uu,xx
 double precision :: pi, g
 integer :: ic1,ic2,nt,ic,iter,it
 double precision :: bessj0,bessj1
 common /signal/ ahh

 !open(1,file='carrier.inp')
 !open(2,file='carrier.out')
 !open(3,file='carrier.env')
 !open(4,file='carrier.u')
 !open(5,file='carrier.tx')


 h0     = 5
 T0     = 32
 s      = .04
 etinbr = 0.5d0          ! eta in /eta br
 dc     = .09906
 ic1    = 1
 ic2    = 100
 nt     = 21
 tol    = .0001


 pi=4.*atan(1.)
 g=9.81d0

 etabr=1./sqrt(128.)/(pi**3)*s**2.5d0*T0**2.5d0*g**1.25d0*h0**(-.25)
 etain=etinbr*etabr
 A=etain*pi/sqrt(.125*s*T0*sqrt(g/h0))

! write(*,*)' eta in     = ',etain
! write(*,*)' A/ eta in  = ',A/etain
! write(*,*)' eta br     = ',etabr
! write(*,*)' etain/etabr= ',etain/etabr

 omega=2.*pi/T0
 sg=s*g
 osg=omega/sg
 osg2=2.*osg

 rl0 = T0*sqrt(sg)

 do ic=ic1,ic2
    C=ic*dc
    J0(ic)=BESSj0(osg2*C)
    J1(ic)=BESSj1(osg2*C)
    A1(ic)=A*g/C*J1(ic)
 enddo

 A2=osg
 dt=T0/(Nt-1)
 t=-dt
 t = time1
 it = 1
 ! do it=1,Nt
    ! t=t+dt
    A3(it)=omega*t
    do ic=ic1,ic2
       C=ic*dc
       do iter=1,100
          uold=u
          u=A1(ic)*cos(A2*u-A3(it))
          if(abs(uold-u).lt.tol) exit
       enddo
       x=.5*u*u/sg+C*C/sg-A/s*J0(ic)*sin(A2*u-A3(it))


       xster=x*4./(sg*T0*T0)

       hh = (C*C/g-s*x)/A
       uu = u/(A*omega/s)

       xx = 125d0 - x/2

       ahh = a*hh
       if (ic == ic1) then
          call movabs(xx,ahh)
       else
          call lnabs(xx,ahh)
       endif

!       write(2,'(2f10.4)')xster,(C*C/g-s*x)/A
!       write(3,'(2f10.4)')xster,(A/pi*sqrt(.5*s*T0*g/C))/A
!       write(4,'(2f10.4)')xster,u/(A*omega/s)

!       if (ic.eq.ic1) write(5,'(2f10.4)')t,x
    enddo
 ! enddo

 end subroutine carrier

 double precision FUNCTION BESSJ0(X)
 implicit none
 double precision :: X
 double precision :: Y,P1,P2,P3,P4,P5,Q1,Q2,Q3,Q4,Q5,R1,R2,R3,R4,R5,R6,S1,S2,S3,S4,S5,S6
 DATA P1,P2,P3,P4,P5/1.D0,-.1098628627D-2,.2734510407D-4,                &
     -.2073370639D-5,.2093887211D-6/, Q1,Q2,Q3,Q4,Q5/-.1562499995D-1,    &
     .1430488765D-3,-.6911147651D-5,.7621095161D-6,-.934945152D-7/
 DATA R1,R2,R3,R4,R5,R6/57568490574.D0,-13362590354.D0,651619640.7D0,    &
     -11214424.18D0,77392.33017D0,-184.9052456D0/,                       &
     S1,S2,S3,S4,S5,S6/57568490411.D0,1029532985.D0,                     &
     9494680.718D0,59272.64853D0,267.8532712D0,1.D0/
 double precision :: ax, z, xx

 IF(ABS(X).LT.8d0)THEN
   Y=X**2
   BESSJ0=(R1+Y*(R2+Y*(R3+Y*(R4+Y*(R5+Y*R6))))) /(S1+Y*(S2+Y*(S3+Y*(S4+Y*(S5+Y*S6)))))
 ELSE
   AX=ABS(X)
   Z=8./AX
   Y=Z**2
   XX=AX-.785398164
   BESSJ0=SQRT(.636619772d0/AX)*(COS(XX)*(P1+Y*(P2+Y*(P3+Y*(P4+Y*P5))))-Z*SIN(XX)*(Q1+Y*(Q2+Y*(Q3+Y*(Q4+Y*Q5)))))
 ENDIF
 RETURN
 END FUNCTION BESSJ0

 double precision FUNCTION BESSJ1(X)
 implicit none
 double precision :: x
 double precision :: Y,P1,P2,P3,P4,P5,Q1,Q2,Q3,Q4,Q5,R1,R2,R3,R4,R5,R6,S1,S2,S3,S4,S5,S6
 DATA R1,R2,R3,R4,R5,R6/72362614232.D0,-7895059235.D0,242396853.1D0, &
     -2972611.439D0,15704.48260D0,-30.16036606D0/,                   &
     S1,S2,S3,S4,S5,S6/144725228442.D0,2300535178.D0,                &
     18583304.74D0,99447.43394D0,376.9991397D0,1.D0/
 DATA P1,P2,P3,P4,P5/1.D0,.183105D-2,-.3516396496D-4,.2457520174D-5, &
     -.240337019D-6/, Q1,Q2,Q3,Q4,Q5/.04687499995D0,-.2002690873D-3, &
     .8449199096D-5,-.88228987D-6,.105787412D-6/
 double precision :: ax, z, xx
 IF(ABS(X).LT.8d0)THEN
   Y=X**2
   BESSJ1=X*(R1+Y*(R2+Y*(R3+Y*(R4+Y*(R5+Y*R6))))) /(S1+Y*(S2+Y*(S3+Y*(S4+Y*(S5+Y*S6)))))
 ELSE
   AX=ABS(X)
   Z=8./AX
   Y=Z**2
   XX=AX-2.356194491d0
   BESSJ1=SQRT(.636619772/AX)*(COS(XX)*(P1+Y*(P2+Y*(P3+Y*(P4+Y*P5))))- &
           Z*SIN(XX)*(Q1+Y*(Q2+Y*(Q3+Y*(Q4+Y*Q5))))) *SIGN(1.d0,X)
 ENDIF
 RETURN
 END FUNCTION BESSJ1

 subroutine belanger()
 use m_physcoef

 use m_flowexternalforcings

 use m_flowgeom, only : xz, bl, dxi, ln
 use m_flow    , only : s1, iadvec


 implicit none
 double precision   :: chezy,cf,h0,h1,x0,x1,q,u,constant,bot,a,x,hav,slope,h,h3,hc,hc3,he,he3
 integer            :: k , kb, L
 integer, parameter :: mmax = 100000 , num = 200
 double precision, allocatable  :: xx(:), ss(:), uu(:)


 allocate ( xx(0:mmax), ss(0:mmax), uu(0:mmax) )


 x0    = 0d0      ! left

 kb    = kbndz(1,1)
 x1    = xz(kb)   ! right
 bot   = bl(kb)

 h1    = s1(kb) - bot ! exact    right
 h0    = 20d0         ! geschat  left

 slope = abs (  ( bl(ln(1,3)) - bl(ln(2,3)) ) * dxi(3) )

 ! slope = 1d-4

 hav = 0.5*(h0+h1)
 call getcz(hav, frcuni, ifrctypuni, Chezy,L)
 cf    = ag/Chezy**2

 q     = 1500d0/50d0
 hc3   = q*q/ag
 hc    = hc3**0.333333333d0

 constant = 0.25d0*h1**4 - h1*hc**3 + x1*cf*hc**3


 call movabs(x1, h1+bot )
 x = x1 ; h = h1
 xx(mmax) = x1 ; ss(mmax) = h1 + bot

 if (slope == 0d0 ) then  ! analytic

    do k = 1, -num
       a = 1d0 - dble(k-1) / dble(num-1)
       h = h0*(1d0-a) + h1*a
       x = ( constant - 0.25d0*h**4 + h*hc**3 ) / ( cf * hc**3 )
       if (x > x0) then
          call lnabs(x, h+bot )
       endif
    enddo

 else
    he3   = cf*hc3/slope
 endif


 do k  = mmax-1, 0 , -1
    x  = x - 1d0
    h3 = h**3
    if (slope == 0d0 ) then
       if (iadvec == 0) then
          h = h + (cf*hc**3)/h3 !  - hc**3)
       else
          h = h + (cf*hc**3)/(h3 - hc3)
       endif
    else
       h  = h - slope*(h3-he3)/(h3 - hc3)
    endif
    bot = bot + slope
    call lnabs(x, h + bot )
    xx(k) = x; ss(k) = h+bot
 enddo

 call compareanalytic(ss,uu,xx,mmax)

 end subroutine belanger


 subroutine drybed(time)
 implicit none
 double precision :: time, xm, xmx, h0, dxw
 integer, parameter :: mmax = 601 !  3000
 double precision:: s(0:mmax),u(0:mmax),xx(0:mmax)
 double precision :: g, t, cw, xl, xr,sa,ua, x
 integer :: m


 g   = 9.81 ! 10.0
 t   = time
 h0  = 2
 cw  = sqrt(9.81*h0)
 dxw = 100.
 xl  = -cw*t
 xr  = t*2*cw

 xmx = -9999
 do m=2, 600 ! ndx
    xm = m*dxw - 50  ! xz(m)
    x  = xm - 300*dxw
    if (x.gt.xl.and.x.lt.xr) then
       sa=(((2*cw-x/t)/3.0)**2)/g
       ua=2*(cw+x/t)/3.0
       xmx = max (xmx, xm)
    else if (x.lt.xl) then
       sa=h0
       ua=0.0
    else
       sa=0.0
       ua=0.0
    endif
    s(m) = sa ; u(m) = ua; xx(m) = xm
    if (m == 2) then
       call movabs(xm,sa)
    else
       call lnabs(xm,sa)
    endif
 enddo
 call movabs(xmx,0.1d0*h0)
 call  lnabs(xmx,0.2d0*h0)

 call compareanalytic(s,u,xx,mmax)
 end subroutine drybed

 subroutine wetbed(time)

 use m_flowparameters
 implicit none

 integer, parameter :: mmax = 601 !  3000
 double precision:: s(0:mmax),u(0:mmax),x(0:mmax)


 double precision :: time, dxw, xc
 double precision :: g, t, dt, xd, x0, xu, h1,h0,eps, c1, c0, u20, z0, c20, &
                        aa, ab, ac, ad, ba, bb, bc, bd, ca, cb, cc, cd, dd, d1, d2, d3, dz, &
                        dc2, du2, z, c2, h2, u2, xm, c, si1
 integer :: itmax, mc, i,iter, m, n


!c
!c initialise
!c

        g=9.81
        t=time
        dt=1.0
        xd=0.0
        x0=0.0
        xu=0.0
        dxw=100.0
        h1=2.0
        h0=0.0000000001
        h0=hwetbed
        itmax=3600
        itmax=1
        eps=1.0e-6
        mc = 301
        xc = (mc-1)*dxw
        do i=0,mmax
          x(i)=(i-0.5)*dxw - xc
        enddo
        do i=0,mmax
          if (x(i).lt.0.0) then
            s(i)=h1
          else
            s(i)=h0
          endif
          u(i)=0.0
        enddo
!c
!c initialise
!c
        c1=sqrt(g*h1)
        c0=sqrt(g*h0)
        u20=c0
        z0=c0
        c20=c0
        iter=0
10      continue
        iter=iter+1
!c
!c Newton iteration for correct coefficients of exact solution
!c
        aa=2*z0-u20
        ab=-c20
        ac=-z0
        ad=0.5*c0**2+u20*z0-z0**2+0.5*(c20)**2
        ba=-c20**2+c0**2
        bb=2*c20*u20-2*c20*z0
        bc=c20**2
        bd=-c20**2*u20+c20**2*z0-c0**2*z0
        ca=0.0
        cb=2.0
        cc=1.0
        cd=2*c1-u20-2*c20
        dd=aa*(bb*cc-bc*cb)-ab*(ba*cc-bc*ca)+ac*(ba*cb-bb*ca)
        d1=ad*(bb*cc-bc*cb)-ab*(bd*cc-bc*cd)+ac*(bd*cb-bb*cd)
        d2=aa*(bd*cc-bc*cd)-ad*(ba*cc-bc*ca)+ac*(ba*cd-bd*ca)
        d3=aa*(bb*cd-bd*cb)-ab*(ba*cd-bd*ca)+ad*(ba*cb-bb*ca)
        dz=d1/dd
        dc2=d2/dd
        du2=d3/dd
        z0=z0+dz
        c20=c20+dc2
        u20=u20+du2
        if (abs(dz).gt.eps) goto 10
        if (abs(dc2).gt.eps) goto 10
        if (abs(du2).gt.eps) goto 10
!c
!c correct shock speeds (z, c2 and u2) are found
!c
        z=z0
        c2=c20
        h2=c2**2/g
        u2=u20
       ! WRITE(*,*) 'H2, Z, U2', H2, Z, U2

!       do itime=1,itmax
!         t=t+dt
!c
!c determination of various zones with different solutions
!c
          xd=-c1*t
          xm=(u2-c2)*t
          xu=z*t
          do i=0,mmax
            if (x(i).lt.xd) then
              u(i)=0.0
              s(i)=h1
            else if (x(i).ge.xd.and.x(i).lt.xm) then
              c=(2*c1-x(i)/t)/3.0
              s(i)=c**2/g
              u(i)=2.0/3.0*(c1+x(i)/t)
            else if (x(i).ge.xm.and.x(i).lt.xu) then
              u(i)=2.0/3.0*(c1+xm/t)
              s(i)=h2
            else if (x(i).ge.xu) then
              u(i)=0.0
              s(i)=h0
            endif
          enddo
!       enddo

!        open(unit=33,file='wetbed.prn')
        do m=2,mmax
            if (m == 2) then
                call movabs(x(m)+xc, s(m))
            else
                call lnabs(x(m)+xc, s(m))
            endif
        enddo

        do m=2,0 ! mmax-1
            if (m == 2) then
                call movabs(x(m)+xc, 0.1d0*U(m))
            else
                call lnabs(x(m)+xc, 0.1d0*U(m))
            endif
        enddo



!        write (33,'(3e15.4)') x(m)+xc, s(m), u(m)

        ! call htext(dble(h2), dble(xu+xc), dble(h2) )

        x =  x + xc
        call compareanalytic(s,u,x,mmax)

        end  subroutine wetbed

subroutine compareanalytic(s,u,x,mmax)

use m_flowgeom
use m_flow
use gridoperations

implicit none
integer :: mmax
double precision :: s(0:mmax),u(0:mmax),x(0:mmax)
double precision :: alf, dif, si, aa
integer          :: n, i, ii

call statisticsnewstep()

call setcol(221)
do n = 1,ndx

   if (.not. inview( xz(n), yz(n) ) ) cycle

   i = 0
   do ii = 1, mmax-1
      if ( x(ii) <= xz(n) .and. xz(n) < x(ii+1) ) then
         i = ii
         exit
      endif
   enddo
   !i = (xz(n) + 0.5*dxw) / dxw
   if  ( i > 2 .and. i < mmax-1 ) then
       alf = (xz(n) - x(i) ) / ( x(i+1) - x(i) )
       if (alf < 0d0 .or. alf > 1d0) then
           si  = 0
       else
           si  = (1-alf)*s(i) + alf*s(i+1)
           dif = abs(s1(n) - si)
           call statisticsonemorepoint(dif)
        !   call ptabs(xz(n), bl(n) + 100d0*dif)
       endif
   endif
enddo
call statisticsfinalise()

end subroutine compareanalytic

      subroutine weirexact()
      use unstruc_colors
      implicit none
      integer, parameter :: mx = 32
      double precision   :: dp(mx), s1(mx), s0(mx), u1(mx), u0(mx), q1(mx), q0(mx), se(mx), ue(mx), xe(mx), wh
      integer :: m, m0, m1
      double precision :: g, hexact, uexact, zexact, energy, z0, z1, z2, h0, h1, h2, &
                          fh0, fh1, fh2, fhx, zx, sem, uem, test0, he2, he1, test1, h00

      integer :: mmax

      do m = 1,mx
         xe(m) = 5 + (m-1)*10
      enddo

      mmax = mx-1
      m0   = 14
      m1   = 14
      wh   = 1.0
      dp   = wh ; dp(m0:m1) = 0.0
      q0   = 1.71
      s1(mx) = 0.0


      g=9.81
      hexact=(q0(1)**2/g)**(1.0/3.0)
      uexact=sqrt(g*hexact)
      zexact=hexact-minval(dp)


      energy=0.5*uexact**2+g*zexact

      ! energy=0.5*u1(1)*u1(1) + g*s1(1)

      z0=zexact
      z1=zexact+3.0
      h00=dp(1)+z0
      h1=dp(1)+z1
      fh0=0.5*(q0(1)/h00)**2+g*z0-energy
      fh1=0.5*(q0(1)/h1)**2+g*z1-energy
      z0=0.5
      z1=zexact+1.0
      z2=0.5*(z0+z1)
      do m=1,mmax
        if (m>=m0.and.m<=m1) then
          se(m)=zexact
          ue(m)=uexact
        else
          if (m>=m1) then
            z0=-dp(m)-0.1
            z1=z1+0.0001
          else
            z0=zexact
            z1=zexact+0.0001
          endif
        do
          h1=dp(m)+z1
          h0=dp(m)+z0
          fh1=0.5*(q0(1)/h1)**2+g*z1-energy
          fh0=0.5*(q0(1)/h0)**2+g*z0-energy
          if (fh1*fh0<0.0) then
            if (fh0>0.0) then
              fhx=fh0
              zx=z0
              fh0=fh1
              z0=z1
              z1=zx
              fh1=fhx
            endif
            exit
          endif
          z1=z1+0.0001
          z0=z0+0.0001
        enddo
10      z2=0.5*(z0+z1)
        h2=dp(m)+z2
        fh2=0.5*(q0(1)/h2)**2+g*z2-energy
        if (fh2<0.0) then
          z0=z2
          fh0=fh2
        else
          z1=z2
          fh1=fh2
        endif
        if (abs(fh2)>1.0d-6) goto 10
        se(m)=z2
        if (dp(m)+z2<0.0) then
          write(*,*) m,dp(m)+z2
          stop
        endif
        ue(m)=q1(m)/(dp(m)+se(m))
      endif
      enddo
      se(m1+1)=0.5*(se(m1)+se(m1+2))
      sem=s1(mmax+1)
      uem=q1(1)/(sem+dp(mmax+1))
      ue(mmax+1)=uem
      se(mmax+1)=sem
      h2=sem+dp(mmax+1)
      h1=se(mmax)+dp(mmax)
      energy=0.5*ue(mmax+1)**2+g*sem
      test0=0.5*g*h1*h2*(h1+h2)-q1(1)**2
      m=mmax+1
      do
      m=m-1
      z1=sem+0.1
      z0=z1-0.001
        do
          h1=dp(m)+z1
          h0=dp(m)+z0
          fh1=0.5*(q0(1)/h1)**2+g*z1-energy
          fh0=0.5*(q0(1)/h0)**2+g*z0-energy
          if (fh1*fh0<0.0) then
            if (fh0>0.0) then
              fhx=fh0
              zx=z0
              fh0=fh1
              z0=z1
              z1=zx
              fh1=fhx
            endif
            exit
          endif
          z1=z1-0.001
          z0=z0-0.001
        enddo
        do
          z2=0.5*(z0+z1)
          h2=dp(m)+z2
          fh2=0.5*(q0(1)/h2)**2+g*z2-energy
          if (fh2<0.0) then

            z0=z2
            fh0=fh2
          else
            z1=z2
            fh1=fh2
          endif
          if (abs(fh2)<1.0d-5) exit
        enddo
        sem=z2
        uem=q1(1)/(dp(m)+se(m))
        he2=dp(m)+sem
        he1=dp(m)+se(m)
        test1=g*0.5*he1*he2*(he1+he2)-q1(1)**2
        if (test1*test0>0.and.m>m1) then
          se(m)=sem
          ue(m)=uem
          cycle
        else
          exit
        endif
      enddo

      call setcol(NCOLANA)
      call movabs(xe(1), se(1)+wh)
      do m=2,mx
         call lnabs(xe(m), se(m) + wh)
      enddo
      return
      end subroutine weirexact

subroutine weirtheory(zupstream,zdownstream,crestheight,zcrestperfect,zminsub,zcrest, &
                      qweir,uupstream,ucrest,udownstream,regime, qfree, gateheight)
implicit none
double precision :: zupstream,zdownstream,crestheight,zcrestperfect,zminsub,zcrest,&
                    qweir,uupstream,ucrest,udownstream, qfree, gateheight
double precision :: pi, g, d, z1, h1, p, q, cosfi,fi, zc1, zc2, zc3, &
                    res1, res2, res3, z2, z2critical,h2, u1, u2, u3, qd, ff, z3, z3critical, &
                    h3, fz2, z3inp, z2a, fz2a, z2b, fz2b, z2c, fz2c, za, zb, fa, fb, zc, fc, &
                    fr1, fr2, fr3
character(len=*) :: regime

! input variables:
!   zupstream     : upstream water level
!   zdownstream   : downstream water level
!   crestheight   : crestheight
! outputvariables :
!   zcrestperfect : waterlevel on crest for critical flow
!   zminsub       : minimum down stream waterlevel for submerged flow
!   zcrest        : waterlevel on crest
!   qweir         : discharge/m
!   uupstream     : upstream velocity
!   ucrest        : velocity on crest
!   udownstream   : downstream velocity        :

! open(5,file='weirtheory.dia')


qweir = 0 ; uupstream = 0 ; ucrest = 0;  udownstream = 0

regime = 'subcritical'

if (zupstream < zdownstream) return

pi=4.0d0*atan(1.0d0)
g=9.81d0
d=crestheight
z1=zupstream
h1=z1+d

! compute critical depth on crest by solving: z^3-3*h1^z+2*h1^2*zupstream=0
! equation is solved analytically method of Gardano

p=3.0d0*(h1**2)
q=2.0d0*(h1**2)*z1
cosfi=z1/h1
fi=acos(cosfi)
zc1=-2.0d0*h1*cos(fi/3.0d0)
zc2=-2.0d0*h1*cos(fi/3.0d0+2.0d0*pi/3.0d0)
zc3=-2.0d0*h1*cos(-fi/3.0d0+2.0d0*pi/3.0d0)

if (zc3 < 0) return
! write(5,'(3e14.5)') zc1,zc2,zc3
res1=zc1**3-p*zc1+q
res2=zc2**3-p*zc2+q
res3=zc3**3-p*zc3+q
! write(5,'(3d14.5)') res1,res2,res3

z2=zc3
z2critical=z2
h2=z2+d
u2=sqrt(g*z2)
qd=z2*u2

qfree = qd

! compute maximum down stream water level for perfect weir or minimum water level for submerged weir
! for this the equation F=q^2/h3+0.5*g*h3^2 is solved analytically with Gardano

ff=qd*u2+0.5d0*g*h2*h2
p=2.0d0*ff/g
q=2.0d0*qd**2/g
cosfi=0.5*q/sqrt((p/3.0d0)**3)
cosfi=max(-1d0,min(cosfi,1d0))
fi=acos(cosfi)
zc1=-2.0d0*sqrt(p/3.0d0)*cos(fi/3.0d0)
zc2=-2.0d0*sqrt(p/3.0d0)*cos(fi/3.0d0+2.0d0*pi/3.0d0)
zc3=-2.0d0*sqrt(p/3.0d0)*cos(-fi/3.0d0+2.0d0*pi/3.0d0)
!write(5,'(3e14.5)') zc1-d,zc2-d,zc3-d
res1=zc1**3-p*zc1+q
res2=zc2**3-p*zc2+q
res3=zc3**3-p*zc3+q
!write(5,'(3d14.5)') res1,res2,res3

z3=zc2-d
z3critical=z3
zminsub=z3
zcrestperfect=z2critical
h3=d+z3

fz2=4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3

!write(5,'(d15.5)') fz2

! compute subcritical weir by solving:
! 4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3=0

z3inp=zdownstream

if (z3inp<z3critical) then
  qweir=qd
  zcrest=zcrestperfect
  uupstream=qd/h1
  ucrest=qd/ zcrest
  h3=zdownstream+crestheight
  udownstream=qd/h3
  regime = 'supercritical'
  return
endif

z3=z3inp
h3=z3inp+d
z2a=z2
fz2a=4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3
z2b=z3inp
h2=z2b+d
z2=z2b
fz2b=4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3
z2c=z1
z2=z2c
h2=z2c+d
fz2c=4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3
! write(5,'(3d14.5)') fz2a,fz2b,fz2c

! apply bisection

if (fz2a*fz2b<0) then
  za=z2a
  zb=z2b
  fa=fz2a
  fb=fz2b
  zc=0.5*(z2a+z2b)
  z2=zc
  h2=zc+d
  fc=4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3
else if (fz2b*fz2c<0) then
  za=z2b
  zb=z2c
  fa=fz2b
  fb=fz2c
  zc=0.5*(za+zb)
  z2=zc
  h2=zc+d
  fc=4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3
endif

do while (abs(fc)>1.0d-10)
  if (fa*fc<0) then
    zb=zc
    fb=fc
    zc=0.5*(za+zb)
    z2=zc
    h2=zc+d
    fc=4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3
  else if (fb*fc<0) then
    za=zc
    fa=fc
    zc=0.5*(za+zb)
    z2=zc
    h2=zc+d
    fc=4.0d0*(z2-z1)*h1**2*z2*(h3-z2)-(h3**2-h2**2)*(z2**2-h1**2)*h3
  endif
enddo


! write(5,'('' water levels:'',3d15.5)') z1,z2,z3
h1=z1+d
h2=z2  ! +d
h3=z3+d
qd=sqrt((2.0d0*g*(z2-z1)*h1**2*z2**2)/(z2**2-h1**2))
! qdb=sqrt(0.5d0*g*(h3**2-h2**2)*z2*h3/(h3-z2))

! write(5,'('' discharge/m:'',d15.5)') qd


u1=qd/h1;u2=qd/h2;u3=qd/h3
! write(5,'('' velocities:'',3d15.5)') u1,u2,u3
fr1=u1/sqrt(g*h1);fr2=u2/sqrt(g*h2);fr3=u3/sqrt(g*h3)
! write(5,'('' Froude numbers:'',3d15.5)') fr1,fr2,fr3

zcrest=z2
qweir=qd
uupstream=u1
ucrest=u2
udownstream=u3

return

end subroutine weirtheory

subroutine findqorifice12(gateheight,crestheight,h1,h2,q,hg,regime,num,qcrit)     ! bepaal q en hg waterstand links = h1, rechts= h2
implicit none
double precision   :: gateheight                   ! gate height above crest
double precision   :: crestheight                  ! crest height above bed
double precision   :: h1                           ! upstream waterheight above crest
double precision   :: q                            ! flux m3/s                                    (out)
double precision   :: h2                           ! pressure height above crest       after gate (out)
double precision   :: hg                           ! vena contracta height above crest after gate (out)
double precision   :: qcrit                        ! critical discharge m2/s                      (out)
character(len=*)   :: regime                       !                                              (out)
double precision   :: g, dh, qmax, hkmin,ha,hb,qa,qb,ha0,qa0,hb0,qb0,qc,hc,a,d, qda, qdb, qdc, hga, hgb, hgc
integer            :: num, k, kk, nummin
double precision   :: coeffs(5), ccx(4), cc, alfa = 0.02d0, qf,hgf,h2f,qer,qermin
double precision   :: aa, bb
g  = 9.81                                          ! h1 = waterhoogte bovenstrooms
h2 = min(h2,h1-0.0001)                             ! hg = gateheight * contractie = effectieve keeldoorsnee
d  = crestheight
a  = gateheight
h1 = max(h1,   0.00010)
h2 = max(h2,   0.00001)

hg     = gateheight*0.5d0                          ! lower boundary
hg     = max(hg ,   0.0001)

if (gateheight >= h1) then                         ! gate above water
   q      =  11111d0
   regime = 'gate above water'
   return
else if (gateheight < 0.001) then
   q      =  0d0
   regime = 'gate closed, a<0.001 '
   return
endif

qcrit = sqrt( 2d0*g*(h1-hg) / (hg**(-2)-h1**(-2)) )

ha = hg ; hb = h2
call qorifdif12(ha,d,a,h1,h2,qda)
call qorifdif12(hb,d,a,h1,h2,qdb)

num = 0 ; qdc = 1d9
do while ( abs(qdc) > 1d-6 .and. abs(qda-qdb) > 1d-6 .and. num < 50 )

   num = num + 1

   hc  = ha - qda*(ha-hb)/(qda-qdb)      ! regula falsi
   hc  = max(hc,hg)
   hc  = min(hc,h2)
   call qorifdif12(hc,d,a,h1,h2,qdc)
   if (qda*qdc > 0) then
      ha = hc ; qda = qdc
   else if (qdb*qdc > 0) then
      hb = hc ; qdb = qdc
   endif

enddo

hg = hc
call getq3(hg,d,a,h1,h2,q)

return

do k = 1, 10

   a = 0.1d0*dble(k)*h1

   aa =  2d0*(h1-a)
   bb = -2d0*h1**2
   cc =  a*h1*h1

   hgb = (-bb + sqrt(bb*bb -4d0*aa*cc))/ (2d0*aa)
   hgc = (-bb - sqrt(bb*bb -4d0*aa*cc))/ (2d0*aa)

   hgb = hgb / h1
   hgc = hgc / h1

enddo

end subroutine findqorifice12

subroutine findqorifice(gateheight,crestheight,h1,h3,q,h2,hg,regime,num,qcrit)     ! bepaal q en hoogte h2 achter schuif, waterstand links = h1, rechts= h4, schuif = a, alles tov bodem
implicit none
double precision   :: gateheight                   ! gate height above crest
double precision   :: crestheight                  ! crest height above bed
double precision   :: h1                           ! upstream waterheight above crest
double precision   :: h3                           ! downstream waterheight above crest
double precision   :: q                            ! flux m3/s                                    (out)
double precision   :: h2                           ! pressure height above crest       after gate (out)
double precision   :: hg                           ! vena contracta height above crest after gate (out)
double precision   :: qcrit                        ! critical discharge m2/s                      (out)
character(len=*)   :: regime                       !                                              (out)
double precision   :: g, dh, qmax, hkmin,ha,hb,qa,qb,ha0,qa0,hb0,qb0,qc,hc,a,d, qda, qdb, qdc, hga, hgb, hgc
integer            :: num, k, kk, nummin
double precision   :: coeffs(5), ccx(4), cc, alfa = 0.02d0, qf,hgf,h2f,qer,qermin
g  = 9.81                                          ! h1 = waterhoogte bovenstrooms
h3 = min(h3,h1-0.0001)                             ! hg = gateheight * contractie = effectieve keeldoorsnee
d  = crestheight
a  = gateheight
h1 = max(h1,   0.0001)
h3 = max(h3,   0.00001)
h2 = h3
qermin = 1d9

hg     = gateheight*0.5d0                             ! lower boundary
hg     = max(hg ,   0.0001)



if (gateheight >= h1) then                         ! gate above water
   q      =  11111d0
   regime = 'gate above water'
     return
else if (gateheight < 0.001) then
     q      = 0d0
     regime = 'gate closed, a<0.001 '
     return
endif

qcrit  = sqrt( 2d0*g*(h1-hg) / (hg**(-2)-h1**(-2)) )
if (h3 < 0.60*h1) then
   regime = 'free gate flow '
   q      = qcrit
   return
endif


do k = 1, 50

  ha = hg ; hb = h3 ; hgc = hg
  call qorifdif(hg,d,h1,h3,ha,qda)
  call qorifdif(hg,d,h1,h3,hb,qdb)

  num = 0 ; qdc = 1d9
  do while ( abs(qdc) > 1d-6 .and. abs(qda-qdb) > 1d-6 .and. num < 50 )

        num = num + 1

 !    if (ha >= h2) then
 !       regime = 'free weir flow' ; return
 !    endif

      hc = ha - qda*(ha-hb)/(qda-qdb)      ! regula falsi
      hc = max(hc,hg)
      hc = min(hc,h3)
      call qorifdif(hg,d,h1,h3,hc,qdc)
      if (qda*qdc > 0) then
         ha = hc ; qda = qdc
      else if (qdb*qdc > 0) then
         hb = hc ; qdb = qdc
        endif

     enddo

  h2 = hc
  call getq1(hg,d,h1,h2,qa)
  call getq2(hg,d,h2,h3,qb)
  call getq3(hg,d,a,h1,h2,qc)
  q   = 0.5d0*(qa+qb)
  qer = abs(q-qc)
  if (qer < qermin) then
      qermin = qer ; qf = q ; hgf = hg ; h2f = h2; nummin = num
  endif

  hg = hg + 0.01d0*a

  regime = 'submerged gate flow '

enddo

h2  = h2f
hg  = hgf
q   = qf
num = nummin

end subroutine findqorifice

subroutine gethg(q,a,h1,h2,hg)
implicit none
double precision :: q,a,h1,h2,hg, g = 9.81d0
hg = h1*q**2 / (q**2 - g*a**h1*(h2-h1)  )
end subroutine gethg

subroutine getq1(hg,d,h1,h2,q)                   ! energiebehoud bovenstrooms
implicit none                                   ! bepaal q gegeven hg,h1,h2
double precision :: hg, d, h1, h2, q
double precision :: g, t, r, tr

g  = 9.81d0
t  = 2d0*g*(h1-h2)
r  = 1d0/hg**2 - 1d0/(h1+d)**2
tr = t/r
if (tr .gt. 0) then
     q = sqrt(tr)
else
     q = h1*sqrt(g*h1)
endif
end subroutine getq1

subroutine getq2(hg,d,h2,h3,q)                  ! momentumbehoud benedenstrooms
implicit none                                   ! bepaal q gegeven a,h2,h3
double precision :: hg,d,h2,h3,q
double precision :: g, t, r, tr
g  = 9.81d0
t  = 0.5d0*g*(h3**2 - h2**2)
r  = 1d0/hg - 1d0/h3
tr = t/r
q  = sqrt(tr)
end subroutine getq2

subroutine getq3(hg,d,a,h1,h2,q)                  ! momentumbehoud bovenstrooms
implicit none                                   ! bepaal q gegeven a,hg,h1,h2
double precision :: hg,d,a,h1,h2,q
double precision :: g, t, r, tr, h2d
g   = 9.81d0
t   = g*a*(h2 - h1)
r   = 1.0/h1 - 1d0/hg
tr  = t/r
q   = sqrt(tr)
end subroutine getq3

subroutine qorifdif(hg,d,h1,h3,h2,qd)
implicit none
double precision :: hg, d, h1, h3, h2, qd
double precision :: ql, qr

call getq1(hg,d,h1,h2,ql)
call getq2(hg,d,h2,h3,qr)
qd = ql-qr
end

subroutine qorifdif12(hg,d,a,h1,h2,qd)
implicit none
double precision :: hg,d,a,h1,h2,qd
double precision :: ql, qr

call getq1(hg,d,h1,h2,ql)
call getq3(hg,d,a,h1,h2,qr)
qd = ql-qr
end


 subroutine interpdivers(naar)

 use m_netw
 use M_FLOWGEOM
 use m_flow
 use m_samples
 use m_flowparameters
 use m_ec_interpolationsettings
 use m_missing
 use m_grid
 use kdtree2Factory
 use m_polygon, only: NPL, xpl, ypl, zpl
 use m_ec_basic_interpolation, only: triinterp2, averaging2
 use m_sferic, only: jsferic, jasfer3D
 use gridoperations

 implicit none

 DOUBLE PRECISION, ALLOCATABLE :: XX(:,:), YY(:,:)
 DOUBLE PRECISION, ALLOCATABLE :: XXX(:),  YYY(:)
 INTEGER         , ALLOCATABLE :: NNN (:)

 integer, intent(in) :: naar !< 1: To flow nodes, 2: to zk net nodes.
 integer :: N,NN,L,LK,K,KK, N6, mnx, md,mu, n1,n2
 integer :: i, ierror
 integer :: jdla, jakdtree = 1
 double precision           :: xn, yn, dist

 if (NAAR == 1 .AND. ndx == 0) then
    call qnerror('First reinitialise flow model, current dimensions are 0',' ',' ')
    return
 endif

 ! get sample permutation array (increasing x-coordinate order)
 if ( IPSTAT.ne.IPSTAT_OK ) then
    call tidysamples(xs,ys,zs,ipsam,NS,MXSAM,MYSAM)
    call get_samples_boundingbox()

    IPSTAT = IPSTAT_OK
 end if


 if ( ( (naar.eq.1) .and. (interpolationtype.ne.1) ) .or.  &
      ( (naar.eq.2) .and. (interpolationtype.eq.2) ) .or.  &
      ( (naar.eq.3) .and. (interpolationtype.ne.1) ) ) then
    if ( jakdtree.eq.1 ) then
!      initialize kdtree
       call build_kdtree(treeglob, Ns,xs,ys, ierror, jsferic, dmiss)
       if ( ierror.ne.0 ) then
!         disable kdtree
          call delete_kdtree2(treeglob)
          jakdtree = 0
       end if
    end if
 end if

 if (naar == 2 .and. interpolationtype == 2) then
    ! Only do this when not in flowgeom mode.
    call findcells(0)
 endif

 JDLA = 1
 if (naar == 1) then
    if (ibedlevtyp == 1) then
       IF (INTERPOLATIONTYPE == 1) THEN
          CALL triinterp2(XZ,YZ,BL,NDX,JDLA, &
                          XS, YS, ZS, NS, dmiss, jsferic, jins, jasfer3D, NPL, MXSAM, MYSAM, XPL, YPL, ZPL, transformcoef) ! to flownodes bl, tiledepth approach
       ELSE
          N6 = MAXVAL(NETCELL%N)
          ALLOCATE( XX(N6,NDX), YY(N6,NDX), NNN(NDX) )
          DO N = 1,NDX
             NNN(N) = NETCELL(N)%N
             DO NN = 1, NNN(N) ! make search cells based on net cell contour + RCEL search radius factor
                XX(NN,N) = xzw(N) + RCEL*(XK(NETCELL(N)%NOD(NN))-xzw(N))
                YY(NN,N) = yzw(N) + RCEL*(YK(NETCELL(N)%NOD(NN))-yzw(N))
             ENDDO
          ENDDO
          call averaging2(1,NS,XS,YS,ZS,IPSAM,XZ,YZ,BL,NDX,XX,YY,N6,NNN,jakdtree, &
                          dmiss, jsferic, jasfer3D, JINS, NPL, xpl, ypl, zpl)
          DEALLOCATE(XX,YY,NNN)
       ENDIF
    else if (ibedlevtyp == 2) then                             ! to flowlinks bottomlevel blu will be phased out but not yet..
       if (INTERPOLATIONTYPE == 1) THEN
          CALL triinterp2(Xu,Yu,Blu,LNX,JDLA, &
                          XS, YS, ZS, NS, dmiss, jsferic, jins, jasfer3D, NPL, MXSAM, MYSAM, XPL, YPL, ZPL, transformcoef)
       else
          N6 = 4
          ALLOCATE( XX(N6,lnx), YY(N6,lnx), NNN(lnx) )
          do L = 1,lnx
             xx(1,L) = xz(ln(1,L))  ; yy(1,L) = yz(ln(1,L))
             xx(3,L) = xz(ln(2,L))  ; yy(3,L) = yz(ln(2,L))
             Lk      = ln2lne(L)
             xx(2,L) = xk(kn(1,Lk)) ; yy(2,L) = yk(kn(1,Lk))
             xx(4,L) = xk(kn(2,Lk)) ; yy(4,L) = yk(kn(2,Lk))
          enddo
          nnn = 4 ! array nnn
          call averaging2(1,NS,XS,YS,ZS,IPSAM,Xu,Yu,BLu,lnx,XX,YY,N6,NNN,jakdtree, &
                          dmiss, jsferic, jasfer3D, JINS, NPL, xpl, ypl, zpl)  ! interpdivers
          DEALLOCATE(XX,YY,NNN)
       endif
    endif

 else if (naar == 2) then                                      ! to network ZK

    if (INTERPOLATIONTYPE == 1) THEN
       CALL triinterp2(Xk,Yk,Zk,Numk,JDLA, &
                       XS, YS, ZS, NS, dmiss, jsferic, jins, jasfer3D, NPL, MXSAM, MYSAM, XPL, YPL, ZPL, transformcoef)
    ELSE IF (INTERPOLATIONTYPE == 2) THEN
       n6 = 3*maxval(nmk)   ! 2: safe upper bound , 3 : even safer!
       ALLOCATE( XX(N6,NUMK), YY(N6,NUMK), NNN(NUMK), xxx(N6), yyy(N6) )
       do K = 1,NUMK
!         get the celllist
          call make_dual_cell(k, n6, rcel, xxx, yyy, nnn(k), Wu1Duni)
          do i=1,nnn(k)
             xx(i,k) = xxx(i)
             yy(i,k) = yyy(i)
          enddo
       enddo
       call averaging2(1,NS,XS,YS,ZS,IPSAM,XK,YK,ZK,NUMK,XX,YY,N6,NNN,jakdtree, &
                       dmiss, jsferic, jasfer3D, JINS, NPL, xpl, ypl, zpl)
       DEALLOCATE(XX,YY,xxx,yyy,NNN)
    ELSE IF (INTERPOLATIONTYPE == 3 ) THEN
      call sam2net_curvi(numk,xk,yk,zk)
    ENDIF
 else if (naar == 3) then                                      ! to waterlevels S1
    s1 = dmiss
    if (INTERPOLATIONTYPE == 1) THEN
       CALL triinterp2(Xz,Yz,s1,Ndx,JDLA, &
                       XS, YS, ZS, NS, dmiss, jsferic, jins, jasfer3D, NPL, MXSAM, MYSAM, XPL, YPL, ZPL, transformcoef)
    ELSE
       N6 = 6
       ALLOCATE( XX(N6,Ndx), YY(N6,Ndx), NNN(Ndx) )
       do K = 1,Ndx
          NN = nd(k)%lnx
          XX(1:nn,K) = xzw(k) + RCEL*(nd(k)%x-xzw(k))
          yy(1:nn,K) = yzw(k) + RCEL*(nd(k)%y-yzw(k))
          nnn(K) = NN  ! array nnn
       enddo
       call averaging2(1,NS,XS,YS,ZS,IPSAM,Xz,Yz,s1,Ndx,XX,YY,N6,NNN,jakdtree, &
                       dmiss, jsferic, jasfer3D, JINS, NPL, xpl, ypl, zpl)
       DEALLOCATE(XX,YY,NNN)
    ENDIF
    do k = 1,ndx
       if (s1(k) == dmiss) then
           s1(k) = bl(k)
       endif
       s1(k) = max(s1(k), bl(k))
    enddo

 else if (naar == 4) then                                       ! to curvilinear grid ZC

    mnx = mmax*nmax
    IF (INTERPOLATIONTYPE == 1) THEN
       ! TODO: UNST-1770: triinterp2 interface temporarily cannot be used for Interacter-interpolate to ZCcurvigrid values
       ! Needs fix.
       !CALL triinterp2(Xc,Yc,Zc,mnx,JDLA, &
       !                   XS, YS, ZS, NS, dmiss, jsferic, jins, jasfer3D, NPL, MXSAM, MYSAM, XPL, YPL, ZPL,transformcoef)
    ELSE
       N6 = 4
       ALLOCATE( XX(N6,mnx), YY(N6,mnx), NNN(mnx) )
       DEALLOCATE(XX,YY,NNN)
       !k = 0
       !do n = 1,nc
       !   do m = 1,mc
       !      md = max(1 ,m-1); nd = max(1, n-1)
       !      mu = min(mc,m+1); nu = min(nc,n+1)
       !      k = k + 1
       !      XX(1,K) = 0.25*(
       !
       call qnerror('not implemented yet',' ',' ')
       return
    ENDIF
 endif

 if ( jakdtree.eq.1 ) then
    call delete_kdtree2(treeglob)
 end if

 END subroutine interpdivers

 subroutine pixcount(xs,ys,zs,jatel)

 USE M_FLOWGEOM
 use m_missing, only: jins, dmiss
 use geometry_module, only: pinpok

 implicit none

 double precision :: xs, ys, zs
 integer :: jatel

 double precision :: xmn, xmx, ymn, ymx
 integer :: nn, k, in
 integer, allocatable, save :: itel(:)
 double precision, allocatable, save :: ztel(:)

 if (jatel == 1) then
    if (.not. allocated (itel) ) then
       allocate(itel(ndx), ztel(ndx) ) ; itel = 0 ; ztel = 0
    endif

    do k  = 1,ndx
       xmn = minval(nd(k)%x) ; xmx = maxval(nd(k)%x)
       ymn = minval(nd(k)%y) ; ymx = maxval(nd(k)%y)
       if (xs <= xmx .and. xs >= xmn .and. ys <= ymx .and. ys >= ymn ) then
          nn = size(nd(k)%x)
          call PINPOK(Xs, Ys, Nn, nd(k)%x, nd(k)%y, IN, jins, dmiss)
          if (IN == 1) then
             itel(k) = itel(k) + 1
             ztel(k) = ztel(k) + zs
             return
          endif
       endif
    enddo
 else
    do k  = 1,ndx
       if (itel(k) .ne. 0) then
          bl(k) =  ztel(k) / dble( itel(k) )
       endif
    enddo
    if (allocated(itel) ) deallocate (itel, ztel)
 endif

 end subroutine pixcount

 subroutine wriblu(mout)                                ! write bottom level u points
 USE M_FLOWGEOM
 implicit none

 integer :: mout, L

 write(mout,'(A,I12)') 'NR of FLOWlinks = ', lnx

 do L  = 1,lnx
    write(mout,* )  xu(L), yu(L), blu(L)
 enddo
 call doclose(mout)

 end subroutine wriblu

 subroutine reablu(mout)                             ! read bottom level u points
 USE M_FLOWGEOM
 implicit none
 integer            :: mout
 character(len=256) :: rec

 integer            :: L, L1
 integer            :: lnxr
 double precision   :: rd
 read(mout,'(a)') rec
 L1 = index(rec,'=') + 1
 read (rec(L1:), *, err = 888) lnxr
 if (lnxr .ne. lnx) then
    call doclose(mout)
    call qnerror('nr of flowlinks read .ne. nr of flowlinks', ' ',' ')
    return
 endif

 do L  = 1,lnx
    read(mout,* ) rd, rd, blu(L)
 enddo
 call doclose(mout)

 call setbobs()

 return

888 call qnreaderror('trying to read nr of flowlinks but getting',rec,mout)
 call doclose(mout)

 end subroutine reablu

 subroutine wribl(mout)                                  ! write bottom level
 USE M_FLOWGEOM
 implicit none

 integer :: mout, k

 write(mout,'(A,I12)') 'NR of internal FLOWCELLS = ', ndxi

 do k  = 1,ndxi
    write(mout,* )  xz(k), yz(k), bl(k)
 enddo
 call doclose(mout)

 end subroutine wribl

 subroutine reabl(mout)                              ! read bottom level
 use m_flowgeom
 use M_samples
 use m_missing
 implicit none
 integer            :: mout
 character(len=256) :: rec

 integer            :: K, L1
 integer            :: ndxr
 double precision   :: rd

 CALL reasam(mout,0)

 bl = dmiss

 call interpdivers(1)

 call delsam(-1) ! deallocate

 return

888 call qnreaderror('trying to read nr of internal flow nodes but getting',rec,mout)
 call doclose(mout)

   end subroutine reabl


!> Reads and sets cell-centered bed levels directly from the net file (when present).
!! _net.nc file should contain a variable with standard_name=altitude
subroutine setbedlevelfromnetfile()
   use m_flowgeom
   use m_flowparameters
   use M_samples
   use m_missing
   use netcdf
   use unstruc_netcdf
   use unstruc_model
   use io_netcdf
   use m_ec_interpolationsettings
   implicit none

   integer :: ierr, ioncid, iconvtype, ncid, nmesh, im, id_bl, networkid
   double precision :: bl_fillvalue
   double precision :: convversion
   integer :: nflownode
   integer :: k
   type(t_ug_meshgeom) :: meshgeom
   logical :: jawel

   inquire(file = md_netfile, exist=jawel)
   jawel = jawel .and. (len_trim(md_netfile) > 0) ! strange behavior on some Linux systems if file name is empty, but reported exist=.true.

   if (.not. jawel) then ! only set tile depth data if bl data is present in net file
      return
   end if

   ! Try and read bed level values on cells (flow nodes) from NetFile (only for UGRID >= 1.0)
   if (ibedlevtyp == 1) then
      ierr = ionc_open(trim(md_netfile), NF90_NOWRITE, ioncid, iconvtype, convversion) ! md_netfile
      if (ierr == ionc_noerr .and. iconvtype == IONC_CONV_UGRID .and. convversion >= 1.0) then
         ierr = ionc_get_ncid(ioncid, ncid)

         !bl = dmiss

         ierr = ionc_get_mesh_count(ioncid, nmesh)
         do im=1,nmesh
            networkid = 0
            ierr = ionc_get_meshgeom(ioncid, im, networkid, meshgeom) !This call is only used to get the dimension (later on when we use UGrid format we might use other fields of the meshgeom structure)
            if (ierr /= ionc_noerr) then
               cycle
            end if

            if (meshgeom%dim /= 1 .and. meshgeom%dim /= 2) then ! Only support 1D network and 2D grid
               cycle
            end if

            ierr = ionc_inq_varid_by_standard_name(ioncid, im, UG_LOC_FACE, 'altitude', id_bl) ! Searches for var with standard_name='altitude' on cell centres.
            if (ierr /= ionc_noerr) then
               ierr = ionc_inq_varid(ioncid, im, 'flowelem_bl', id_bl) ! Fallback: searches for var with name 'mesh2d_flowelem_bl'
            end if
            if (ierr /= ionc_noerr) then
               cycle
            end if

            if (meshgeom%dim == 1) then
               nflownode = meshgeom%numnode
               call increasesam(nflownode)
               ierr = ionc_get_node_coordinates(ioncid, im, xs(1:nflownode), ys(1:nflownode))
            else if (meshgeom%dim == 2) then
               nflownode = meshgeom%numface
               call increasesam(nflownode)
               ierr = ionc_get_face_coordinates(ioncid, im, xs(1:nflownode), ys(1:nflownode))
            end if

            ierr = nf90_get_var(ncid, id_bl, zs, count = (/ nflownode /))
            if (ierr /= nf90_noerr) then
               cycle
            end if

            ierr = nf90_get_att(ncid, id_bl, '_FillValue', bl_fillvalue)
            if (ierr /= nf90_noerr) then
               cycle
            end if

            do k = 1,nflownode
                if (zs(k) == bl_fillvalue) then
                    zs(k) = dmiss
                endif
            enddo

            ! NOTE: associate cell bl's from file with our model's flowgeom cells via nearest neighbour matching.
            NS = nflownode
            INTERPOLATIONTYPE = 2
            IAV = 2
            call interpdivers(1)

         end do ! nummesh
      end if ! UGRID >= 1.0
   end if ! ibedlevtyp == 1

   call delsam(-1) ! deallocate

end subroutine setbedlevelfromnetfile


subroutine setbedlevelfromextfile()    ! setbedlevels()  ! check presence of old cell centre bottom level file
 use timespace_data
 use timespace
 use unstruc_model
 use m_flowgeom
 use m_flow
 use m_netw !  only : xk, yk, zk
 use m_missing
 use system_utils, only: split_filename
 use unstruc_files, only: resolvePath
 use string_module, only: strcmpi
 use unstruc_inifields, only: readIniFieldProvider, checkIniFieldFileVersion
 use dfm_error

 use unstruc_netcdf
 implicit none

 logical, external :: timespaceinitialfield_mpi

 logical :: jawel
 logical :: bl_set_from_zkuni = .false.
 integer              :: mxyb, ja, ja1, ja2, method, iprimpos
 integer              :: k, L, k1, k2, mx
 integer, allocatable :: kcc(:), kc1D(:), kc2D(:)
 integer              :: ibathyfiletype
 integer              :: kc_size_store

 character(len=256) :: filename
 character(len=64)  :: varname
! character(len=1)   :: operand
! double precision   :: transformcoef(25) !< Transform coefficients a+b*x

 type(tree_data),  pointer       :: inifield_ptr        !< tree of inifield-file's [Initial] or [Parameter] blocks
 type(tree_data),  pointer       :: node_ptr
 integer                         :: istat
 integer                         :: num_items_in_file
 integer, parameter              :: ini_key_len   = 32
 integer, parameter              :: ini_value_len = 256
 character(len=ini_key_len)      :: groupname
 character(len=255)              :: fnam
 character(len=255)              :: basedir
 integer :: major, minor
 integer :: i, iLocType


 kc_size_store = 0
 inifield_ptr => null()

 inquire(file = md_xybfile, exist=jawel)
 jawel = jawel .and. (len_trim(md_xybfile) > 0) ! strange behavior on some Linux systems if file name is empty, but reported exist=.true.

 if (jawel) then                                   ! set tegeldiepte optie als bl file aanwezig
     call oldfil(mxyb,md_xybfile)
     call reabl(mxyb)
     call mess(LEVEL_INFO, 'setbedlevelfromextfile: Setting bedlevel from file '''//trim(md_xybfile)//'''.')
 else
     ! When no BathymetryFile, attempt to read cell centred bed levels directly from net file:
     call setbedlevelfromnetfile()
     call mess(LEVEL_INFO, 'setbedlevelfromextfile: Using bedlevel as specified in net-file.')
 endif

 ! ibedlevtyp determines from which source data location the bed levels are used to derive bobs and bl.
 ! These types need to be mapped to one of three possible primitive locations (center/edge/corner).
 select case (ibedlevtyp)
 case (1)       ! position = waterlevelpoint, cell centre
    iprimpos = 2 ; mx = max(numk, ndx)
 case (2)       ! position = velocitypoint, cellfacemid
    iprimpos = 1 ; mx = max(numk, lnx)
 case (3,4,5,6) ! position = netnode, cell corner
    iprimpos = 3 ; mx = numk
 end select

 if (mext > 0 .or. len_trim(md_inifieldfile) > 0) then
    ! 0.a Prepare masks for 1D/2D distinctions
    kc_size_store = size(kc)
    allocate(kcc(mx),kc1d(mx),kc2d(mx)) ; kcc = 1; kc1D = 0 ; kc2D = 0
    call realloc(kc, mx, keepExisting = .false., fill = 0)

    do L = 1, numL1D
       if (kn(3,L) == 1 .or. kn(3,L) == 6) then ! TODO: AvD: why not also type 3/4/5/7?
           k1 = kn(1,L) ; k2 = kn(2,L)
           if (nmk(k1) > 1) kc1D(k1) = 1
           if (nmk(k2) > 1) kc1D(k2) = 1
       endif
    enddo

    if (iprimpos == 3) then
       do L = 1, numL
          if (kn(3,L) == 2) then
              k1 = kn(1,L) ; k2 = kn(2,L)
              kc2D(k1) = 1
              kc2D(k2) = 1
          endif
       enddo
    else if (iprimpos == 1) then
       kc2D(lnx1d+1:lnxi) = 1
    else if (iprimpos == 2) then
       kc2D(1:ndx2D) = 1
    endif

    ja = 0
    ja1= 0
    ja2= 0
    ! 0.b Prepare loop across old ext file:
    if (mext > 0) then
       rewind(mext)
       ja1 = 1
    end if

    ! 0.c Prepare loop across new initial field file:
    if (len_trim(md_inifieldfile) > 0) then
       call tree_create(trim(md_inifieldfile), inifield_ptr)
       call prop_file('ini',trim(md_inifieldfile),inifield_ptr,istat)
       call split_filename(md_inifieldfile, basedir, fnam)
       istat = checkIniFieldFileVersion(md_inifieldfile, inifield_ptr)
       if (istat /= DFM_NOERR) then
          num_items_in_file = 0
       end if
       if (associated(inifield_ptr%child_nodes)) then
           num_items_in_file = size(inifield_ptr%child_nodes)
       endif
       if (num_items_in_file > 0) then
          i  = 1
          ja2 = 1
       end if
    end if

    ! Trick: loop across the 2 supported file types (*.ext and *.ini), most inner do-loop code is the same for both.
bft:do ibathyfiletype=1,2
    if (ibathyfiletype == 1) then
       call split_filename(md_extfile,      basedir, fnam) ! Remember base dir of *.ext file, to resolve all refenced files below w.r.t. that base dir.
       if (ja1 .eq. 1) then
          ja = 1
       end if
    else if (ibathyfiletype == 2) then
       call split_filename(md_inifieldfile, basedir, fnam) ! Remember base dir of *.ini file, to resolve all refenced files below w.r.t. that base dir.
       if (ja2 .eq. 1) then
          ja = 1
       end if
    end if

    do while (ja .eq. 1)
       if (ibathyfiletype == 1) then       ! read *.ext file
          call delpol()
          call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname)
       else if (ibathyfiletype == 2) then  ! read *.ini file
          if (i > num_items_in_file) then
             ja = 0
             exit
          end if
          node_ptr => inifield_ptr%child_nodes(i)%node_ptr
          call readIniFieldProvider(md_inifieldfile, node_ptr,groupname,qid,filename,filetype,method,iLocType,operand,transformcoef,ja,varname) !,smask, maxSearchRadius)
          i = i + 1
          if (.not. strcmpi(groupname, 'Initial')) then
             cycle
          end if
       end if

       ! Initialize bedlevel based on the read provider info
       if (ja == 1) then
          call resolvePath(filename, basedir, filename)
          if (index(qid,'bedlevel') > 0 .and. ibathyfiletype == 1 .and. len_trim(md_inifieldfile) > 0) then
             ! Don't support bedlevel in *.ext file when there is ALSO a *.ini file.
             call mess(LEVEL_WARN, 'Bed level info should be defined in file '''//trim(md_inifieldfile)//'''. Quantity '//trim(qid)//' ignored in external forcing file '''//trim(md_extfile)//'''.')
             cycle bft ! Try ini field file next
          end if
          if (strcmpi(qid, 'bedlevel1D') .or. (strcmpi(qid, 'bedlevel') .and. ibathyfiletype == 2 .and. iLocType == ILATTP_1D)) then
             call mess(LEVEL_INFO, 'setbedlevelfromextfile: Setting 1D bedlevel from file '''//trim(filename)//'''.')
             kc(1:mx) = kc1D
             success = timespaceinitialfield_mpi(xk, yk, zk, numk, filename, filetype, method, operand, transformcoef, 3, kc) ! zie meteo module
          else if (strcmpi(qid,'bedlevel', 8)) then
             if ((strcmpi(qid, 'bedlevel') .and. ibathyfiletype == 1) .or. (strcmpi(qid, 'bedlevel') .and. ibathyfiletype == 2 .and. iLocType == ILATTP_ALL))  then
                call mess(LEVEL_INFO, 'setbedlevelfromextfile: Setting both 1D and 2D bedlevel from file '''//trim(filename)//'''.')
                kc(1:mx) = kcc
             else if (strcmpi(qid, 'bedlevel2D') .or. (strcmpi(qid, 'bedlevel') .and. ibathyfiletype == 2 .and. iLocType == ILATTP_2D)) then
                call mess(LEVEL_INFO, 'setbedlevelfromextfile: Setting 2D bedlevel from file '''//trim(filename)//'''.')
                kc(1:mx) = kc2D
             endif

             if (ibedlevtyp == 3) then
                success = timespaceinitialfield_mpi(xk, yk, zk, numk, filename, filetype, method, operand, transformcoef, iprimpos, kc) ! zie meteo module
             else if (ibedlevtyp == 2) then
                success = timespaceinitialfield_mpi(xu, yu, blu, lnx, filename, filetype, method, operand, transformcoef, iprimpos, kc) ! zie meteo module
             else if (ibedlevtyp == 1) then
                success = timespaceinitialfield_mpi(xz, yz, bl, ndx, filename, filetype, method, operand, transformcoef, iprimpos, kc) ! zie meteo module
             endif
          endif
       endif

    end do ! ja==1 provider loop
    end do bft ! ibathyfiletype=1,2

    ! Clean up *.ext file
    rewind (mext)

    ! Clean up *.ini file.
    call tree_destroy(inifield_ptr)

    ! Interpreted values for debugging.
    if ( md_jasavenet.eq.1 ) then
!      save network
       select case (ibedlevtyp)
          case (3,4,5,6) ! primitime position = netnode, cell corner
             call unc_write_net('DFM_interpreted_network_'//trim(md_ident)//'_net.nc')
       end select
    end if

    deallocate(kcc,kc1d,kc2d)

 endif



 if (ibedlevtyp == 1) then
    do k = 1, ndxi
        if (bl(k) == dmiss) then
           bl(k) = zkuni
           bl_set_from_zkuni = .true.
        endif
    enddo
    if (bl_set_from_zkuni) then
        call mess(LEVEL_INFO, 'setbedlevelfromextfile: Unspecified bedlevels replaced using value from BedlevUni.')
    endif

    ! To improve: bed levels at boundary to be set from net file, instead of mirroring
    do L = Lnxi + 1, Lnx
        k1 = ln(1,L)
        k2 = ln(2,L)
        bl(k1) = bl(k2)
    enddo
    call mess(LEVEL_INFO, 'setbedlevelfromextfile: Mirroring input bedlevels at open boundaries.')

 endif

 if ( kc_size_store.gt.0 ) then
    call realloc(kc, kc_size_store, keepExisting = .false., fill = 0)
 endif


 end subroutine setbedlevelfromextfile ! setbottomlevels



   !> perform interpolation on rank 0 only (and save some memory with multiple ranks on one node)
   !>   note: only methods "4" (in polygon) and "5" (trangulation) supported, averaging (method "6") not supported
   function timespaceinitialfield_mpi(x, y, z, N, filename, filetype, method, operand, transformcoef, iprimpos, kc) result(success)
      use m_partitioninfo
      use timespace, only : timespaceinitialfield
      use m_flowexternalforcings, only: NTRANSFORMCOEF
#ifdef HAVE_MPI
      use mpi
#endif
      implicit none

      logical                                                    :: success

      integer,                                     intent(in)    :: N      !< data size
      double precision, dimension(N),              intent(in)    :: x(N)   !< x-coordinates
      double precision, dimension(N),              intent(in)    :: y(N)   !< y-coordinates
      double precision, dimension(N),              intent(out)   :: z(N)   !< interpolated values
      integer         , dimension(N),              intent(in)    :: kc(N)  !< 0=no, 1 = yes

      character(*),                                intent(in)    :: filename        !< name of data file
      integer,                                     intent(in)    :: filetype        !< file type
      integer,                                     intent(in)    :: method          !< interpolation method, only "4" and "5" supported
      character(1),                                intent(in)    :: operand         !< override, add
      double precision, dimension(NTRANSFORMCOEF), intent(in)    :: transformcoef   !< Transformation coefficients
      integer,                                     intent(in)    :: iprimpos        !< only needed for averaging, but not supported

      double precision, dimension(:),              allocatable   :: xall, yall, zall

      integer,          dimension(:),              allocatable   :: nums, offset,kcall

      integer                                                    :: numtot
      integer                                                    :: i, ierror


#ifdef HAVE_MPI
      if ( ( method.eq.4 .or. method.eq.5 ) .and. ( jampi.eq.1 ) ) then
!        ( inside polygon or triangulation ) and parallel run

!        allocate
         allocate(nums(0:ndomains-1))

!        communicate array size to rank 0
         call mpi_gather(N, 1, MPI_INTEGER, nums, 1, MPI_INTEGER, 0, DFM_COMM_DFMWORLD, ierror)

         if ( my_rank.eq.0 ) then
            numtot = sum(nums(0:ndomains-1))
         else
            numtot = 0
         end if

         allocate(xall(numtot))
         allocate(yall(numtot))
         allocate(zall(numtot))
         allocate(kcall(numtot))
         allocate(offset(0:ndomains-1))

         offset(0) = 0
         do i=0,ndomains-2
            offset(i+1) = offset(i) + nums(i)
         end do

!        communicate coordinates to rank 0 (split for simplicity)
         call mpi_gatherv(x,N,MPI_DOUBLE_PRECISION,xall,nums,offset,MPI_DOUBLE_PRECISION,0,DFM_COMM_DFMWORLD,ierror)
         call mpi_gatherv(y,N,MPI_DOUBLE_PRECISION,yall,nums,offset,MPI_DOUBLE_PRECISION,0,DFM_COMM_DFMWORLD,ierror)
         call mpi_gatherv(z,N,MPI_DOUBLE_PRECISION,zall,nums,offset,MPI_DOUBLE_PRECISION,0,DFM_COMM_DFMWORLD,ierror)
         call mpi_gatherv(kc,N,MPI_INTEGER       ,kcall,nums,offset,MPI_INTEGER,         0,DFM_COMM_DFMWORLD,ierror)

         if ( my_rank.eq.0 ) then
!           perform interpolation on rank 0
            success = timespaceinitialfield(xall, yall, zall, numtot, filename, filetype, method, operand, transformcoef, iprimpos, kcall)
         else
            success = .true.
         end if

!        send interpolated data to other ranks
         call mpi_scatterv(zall,nums,offset,MPI_DOUBLE_PRECISION,z,N,MPI_DOUBLE_PRECISION,0,DFM_COMM_DFMWORLD,ierror)

!        deallocate local arrays
         deallocate(nums)
         deallocate(xall)
         deallocate(yall)
         deallocate(zall)
         deallocate(kcall)
         deallocate(offset)
      else
         success = timespaceinitialfield(x, y, z, N, filename, filetype, method, operand, transformcoef, iprimpos, kc)
      endif

#else
      success = timespaceinitialfield(x, y, z, N, filename, filetype, method, operand, transformcoef, iprimpos, kc)
#endif

      return
   end function timespaceinitialfield_mpi

 subroutine setbobs()                    ! and set blu, weigthed depth at u point
 use m_netw
 use m_flowgeom
 use m_flow
 ! DEBUG
 use m_flowtimes
 use m_sediment
 use m_oned_functions
 use unstruc_channel_flow
 !\ DEBUG
 use m_missing

 implicit none

 integer L, k1, k2, n1, n2, LK, n, k, k3, LL, kk, Ls, mis
 double precision           :: bl1, bl2, blv, bln, zn1, zn2, zn3, wn, alf, banow, xnow, ynow, skewn, xt, yt, xn, yn
 ! double precision, external :: skewav

 ! First, prepare bed levels at pressure points:

 if (ibedlevmode == BLMODE_D3D) then
    ! DPSOPT=MAX equivalent: deepest zk/corner point
    do k = 1,ndx2d ! TODO: [TRUNKMERGE] WO: I restored ndx2d (was: ndx1db in sedmor)
       bl(k) = huge(1d0)
       do kk = 1,netcell(k)%n
          zn1 = zk(netcell(k)%nod(kk))   ; if (zn1 == dmiss) zn1 = zkuni
          bl(k) = min(bl(k), zn1)
       enddo
    enddo
 else
    ! Default: BLMODE_DFM, tiles or velocity point based, use ibedlevtyp only
    if (ibedlevtyp == 1) then ! Already delivered via ext file, only fill missing values here
       do k = 1,ndxi
          if (bl(k) == dmiss) then
             bl(k) = zkuni
          end if
       end do
    else if (ibedlevtyp > 1 .and. ibedlevtyp .le. 5) then
       bl = 1d30
    else if (ibedlevtyp == 6) then ! quick and dirty flownodes tile depth like taken from netnodes, to be able to at least run netnode zk defined models
       do k = 1,ndxi ! Was: ndx2d, but netcell includes 1D too
          bl(k) = 0d0
          mis   = 0
          do kk = 1,netcell(k)%n
             bl(k) = bl(k) + zk(netcell(k)%nod(kk))
             if ( zk(netcell(k)%nod(kk)) == dmiss ) mis = 1
          enddo
          if (mis == 1) then
             bl(k) = zkuni
          else
             bl(k) = bl(k) / netcell(k)%n
          endif
       enddo

    endif
 end if

 do L = lnx1D+1,lnx ! Intentional: includes boundaries, to properly set bobs based on net nodes here already

    if (iadv(L) > 20 .and. iadv(L) < 30) cycle ! skip update of bobs for structures ! TODO: [TRUNKMERGE]: JN/BJ: really structures on bnd?

    n1  = ln(1,L) ; n2  = ln(2,L)

    if (ibedlevtyp == 1 .or. ibedlevtyp == 6) then     ! tegeldieptes celcentra
       bl1      = bl(n1)
       bl2      = bl(n2)
       bob(1,L) = max( bl1, bl2 )
       bob(2,L) = bob(1,L)
    else if (ibedlevtyp == 2) then                     ! rechtstreeks op u punten interpoleren,
       k1  = ln(1,L) ; k2 = ln(2,L)                    ! haal waarde uit blu, gedefinieerd op xu,yu
       if (blu(L) == dmiss) then
          blv = zkuni
       else
          blv = blu(L)
       endif
       bob(1,L) = blv
       bob(2,L) = blv
       if (ibedlevmode == BLMODE_DFM) then
          bl(n1)   = min(bl(n1) , blv)
          bl(n2)   = min(bl(n2) , blv)
       end if
    else if (ibedlevtyp >= 3 .or. ibedlevtyp <= 5) then  ! dieptes uit netnodes zk
       k1  = lncn(1,L) ; k2 = lncn(2,L)
       zn1 = zk(k1)   ; if (zn1 == dmiss) zn1 = zkuni
       zn2 = zk(k2)   ; if (zn2 == dmiss) zn2 = zkuni
       if (jaconveyance2D >= 1) then                  ! left rigth
          blv      = min(zn1,zn2)
          bob(1,L) = zn1
          bob(2,L) = zn2
       else if (ibedlevtyp == 3) then                 ! mean
          blv = 0.5d0*( zn1 + zn2 )
          bob(1,L) = blv
          bob(2,L) = blv
       else if (ibedlevtyp == 4) then                 ! min
          blv = min( zn1, zn2 )
          bob(1,L) = blv
          bob(2,L) = blv
       else if (ibedlevtyp == 5) then                 ! max
          blv = max( zn1, zn2 )
          bob(1,L) = blv
          bob(2,L) = blv
       endif

       if (allocated(ibot)) then ! Local override of bottomleveltype
          if (ibot(L) == 4) then
             blv      = min(zn1,zn2)                    ! local override min
             bob(1,L) = blv
             bob(2,L) = blv
          else if (ibot(L) == 5) then                   ! local override max
             blv      = max(zn1,zn2)
             bob(1,L) = blv
             bob(2,L) = blv
          endif
       end if

       ! When in DFM mode (not D3D mode), get bed level from velocity point depth.
       if (ibedlevmode == BLMODE_DFM) then
          bl(n1)   = min(bl(n1) , blv)
          bl(n2)   = min(bl(n2) , blv)
       end if
    endif

    blu(L) = min(bob(1,L), bob(2,L) )

 enddo
 bob0(:,lnx1d+1:lnx) = bob(:,lnx1d+1:lnx)

 if (jaupdbobbl1d > 0) then
    call setbobs_1d()
    jaupdbobbl1d = 0 ! update bobs and bl only at initialization. After initialisation bobs should only follow from bl, in particular for morphological updating. When considering nodal relations, some special treatment may be required
 else

    do L = 1,lnx1D                                       ! 1D

       if (iadv(L) > 20 .and. iadv(L) < 30) cycle        ! skip update of bobs for structures

       n1  = ln(1,L)   ; n2 = ln(2,L)                    ! flow ref
       k1  = lncn(1,L) ; k2 = lncn(2,L)                  ! net  ref
       zn1 = zk(k1)    ; if (zn1 == dmiss) zn1 = zkuni
       zn2 = zk(k2)    ; if (zn2 == dmiss) zn2 = zkuni

       if ( kcu(L) == 1) then                            ! 1D link

          if (ibedlevtyp == 1 .or. ibedlevtyp == 6) then     ! tegeldieptes celcentra ! TODO: [TRUNKMERGE] WO/BJ: do we need stm_included in this if (consistent?)
             if (stm_included) then
                bl1      = bl(n1)
                bl2      = bl(n2)
                bob(1,L) = max( bl1, bl2 )
                bob(2,L) = bob(1,L)
             else ! Old non-MOR code for 1D in models with tiledepths
                bob(1,L)  = zn1
                bob(2,L)  = zn2
                bl(n1)    = zn1
                bl(n2)    = zn2
             end if
          else
             blv = 0.5d0*( zn1 + zn2 )                      ! same as 2D, based on network, but now in flow link dir. In 2D this is net link dir
             bob(1,L)  = blv
             bob(2,L)  = blv                                ! revisit
             bl(n1)    = min(bl(n1) , blv)
             bl(n2)    = min(bl(n2) , blv)
          endif
       endif
    enddo
    bob0(:, 1:lnx1d) =bob(:, 1:lnx1d)
 endif
 do L = 1,lnx1D                                       ! 1D
    n1  = ln(1,L)   ; n2 = ln(2,L)                    ! flow ref
    k1  = lncn(1,L) ; k2 = lncn(2,L)                  ! net  ref
    if (ibedlevtyp == 3) then
       zn1 = zk(k1)
       zn2 = zk(k2)
    else if(ibedlevtyp == 1 .or. ibedlevtyp == 6) then
       zn1 = bl(n1)
       zn2 = bl(n2)
    else
       zn1 = blu(L)
       zn2 = blu(L)
    endif
    if (zn1 == dmiss) zn1 = zkuni
    if (zn2 == dmiss) zn2 = zkuni

 if (kcu(L) == 3) then                             ! 1D2D internal link, bobs at minimum
    if (kcs(n1) == 21) then
       blv   = bl(n1)
       call get2Dnormal(n1,xn,yn)                  ! xn, yn = 2D land normal vector pointing upward, both zero = flat
       call get1Ddir(n2,xt,yt)                     ! xt, yt = 1D river tangential normal vector
    endif
    if (kcs(n2) == 21) then
       blv   = bl(n2)
       call get2Dnormal(n2,xn,yn)
       call get1Ddir(n1,xt,yt)
    endif
    skewn     = abs(xn*xt + yn*yt)
    bob(1,L)  = blv
    bob(2,L)  = blv    ! revisit later+ wu(L)*skewn ! TODO: HK: why wu here? Why not dx(L) or something similar?
    bob0(1,L)  = blv
    bob0(2,L)  = blv    ! revisit later+ wu(L)*skewn ! TODO: HK: why wu here? Why not dx(L) or something similar?
    bl(n1)    = min(bl(n1) , blv)
    bl(n2)    = min(bl(n2) , blv)
 else if (kcu(L) == 4) then                           ! left right
    blv       = min(zn1,zn2)
    bob(1,L)  = zn1
    bob(2,L)  = zn2
    bob0(1,L)  = zn1
    bob0(2,L)  = zn2
    bl(n1)    = min(bl(n1) , blv)
    bl(n2)    = min(bl(n2) , blv)
 else if (kcu(L) == 5 .or. kcu(L) == 7) then         ! keep 1D and 2D levels
    if (bl(n1) .ne. 1d30 ) then
       bob(1,L) = bl(n1)
    else
       bob(1,L) = zn1
    endif
    if (bl(n2) .ne. 1d30 ) then
       bob(2,L) = bl(n2)
    else
       bob(2,L) = zn2
    endif
    if (zk(k1) .ne. dmiss .and. nmk(k1) == 1) then   ! if zk specified at endpoint
        bob(1,L) = zk(k1)
    endif
    if (zk(k2) .ne. dmiss .and. nmk(k2) == 1) then   ! if zk specified at endpoint
        bob(2,L) = zk(k2)
    endif
    if (setHorizontalBobsFor1d2d) then
       bob(:,L) = max(bob(1,L), bob(2,L))
    endif
    bob0(:,L) = bob0(:,L)
    bl(n1) = min( bl(n1) , bob(1,L) )
    bl(n2) = min( bl(n2) , bob(2,L) )
 endif

 enddo

 do k = 1,ndx  !losse punten die geen waarde kregen
    if (bl(k) == 1d30) then
       bl(k) = zkuni
    endif
 enddo

 do L = lnxi+1, lnx                               ! randjes copieren

    if (iadv(L) > 20 .and. iadv(L) < 30) cycle ! skip update of bobs for structures

     n1       = ln(1,L) ; n2  = ln(2,L)
     if (jaupdbndbl == 1) then
        bl(n1)   = bl(n2)
     endif

     !if (stm_included .and. jawave>0) then
     !   bl(n1) = bl(n2)
     !end if

     if (kcu(L) == -1) then                       ! 1D randjes extrapoleren voor 1D straight channel convecyance testcase
        k1  = lncn(1,L) ; k2 = lncn(2,L)
        k3  = 0
        do k  = 1,nd(n2)%lnx
           LL = iabs(nd(n2)%ln(k))
           if (kcu(LL) == 1) then
              if (nd(n2)%ln(k) < 0) k3 = lncn(2,LL)
              if (nd(n2)%ln(k) > 0) k3 = lncn(1,LL)
           endif
        enddo

        if (ibedlevtyp == 1 .or. ibedlevtyp == 6) then
           bl2      = bl(n2)
           if (stm_included) then
              bl1   = bl(n1)
           else
              bl1   = bl2
           end if
           bl(n1)   = bl1
           bob(1,L) = max(bl(n1), bl(n2))
           bob(2,L) = bob(1,L)
        !elseif (bl(n1) == 1d30 .or. bl(n2) == 30) then
        else if (.not. network%loaded) then
!          SPvdP: previous expression is problematic when zk(k2) and/or zk(k3) have missing values
           zn2 = zk(k2)    ; if (zn2 == dmiss) zn2 = zkuni
           zn3 = zk(k3)    ; if (zn3 == dmiss) zn3 = zkuni
           zn1 = 1.5d0*zn2 - 0.5d0*zn3 ! note: actual locations of cells centers not taken into account

           bob(1,L)  = zn1
           bob(2,L)  = zn1
           bob0(:,L) = zn1
           bl(n1)   = min(bl(n1) , zn1)
           bl(n2)   = min(bl(n2) , zn1)
        endif

     else ! 2D boundary link
        if (ibedlevtyp == 1 .or. ibedlevtyp == 6) then ! Implicitly intended for: jaconveyance2D < 1
           bob(1,L) = bl(n1)                         ! uniform bobs only for tiledepths
           bob(2,L) = bl(n1)
           if (stm_included) then
              bob(1,L) = max( bl(n1), bl(n2) )
              bob(2,L) = bob(1,L)
              bob0(:,L) = bob(1,L)
           endif
        endif
     endif
 enddo

 call duikerstoprofs()

 if (blmeanbelow .ne. -999d0) then
    do n = 1,ndx2D
       wn = 0d0; bln = 0d0
       do LL = 1,nd(n)%lnx
          Ls  = nd(n)%ln(LL); L = iabs(Ls)
          bln = bln + wu(L)*0.5d0*( bob(1,L) + bob(2,L) )
          wn  = wn  + wu(L)
       enddo
       if (wn > 0d0) then
          bln = bln/wn
          alf = min (1d0, ( blminabove - bln ) /  ( blminabove-blmeanbelow ) )
          if (alf > 0d0) then
             bl(n) = alf*bln + (1d0-alf)*bl(n)
          endif
       endif
    enddo
 endif

 jaupdbndbl = 0    ! after first run of setbobs set to 0 = no update

 end subroutine setbobs

 subroutine get2Dnormal(n1,xn1,yn1)  ! get x and y components of land normal vector pointing upward.

 use m_flowgeom                      ! = ok for all internal cells
 use m_flow
 use m_netw
 use m_sferic, only: jsferic, jasfer3D
 use m_missing, only : dxymis
 use geometry_module, only: normalin

 implicit none
 integer          :: n1,   k, L, LL, k3, k4
 double precision :: xn1, yn1, a, aa, alf, xt, yt, slope

 xn1 = 0d0 ; yn1 = 0d0; a = 0d0
 do k = 1, size(nd(n1)%ln)
    LL  = nd(n1)%ln(k)
    L   = iabs(LL)
    if (LL < 0) then ! incoming link has positive LL
       alf = acL(L)
    else
       alf = 1d0 - acL(L)
    endif
    aa = alf*wu(L)*dx(L) ; a  = a + aa
    k3 = lncn(1,L)       ; k4 = lncn(2,L)
    call normalin(xk(k3), yk(k3), xk(k4), yk(k4), xt, yt, xu(L), yu(L),jsferic, jasfer3D, dxymis)
    slope = ( zk(k4) - zk(k3) ) / wu(L)
    xn1   = xn1 + aa*xt*slope
    yn1   = yn1 + aa*yt*slope
 enddo
 if (aa > 0d0) then
    xn1 = xn1 / aa
    yn1 = yn1 / aa
 endif
 end subroutine get2Dnormal

 !> Gets the tangential direction vector for a 1D flow node,
 !! based on direction of the last regular 1D link connected to it.
 !! NOTE: only makes sense when there's only one single regular 1D
 !! link connected (i.e., 1D endpoint, maybe connected with kcu=3
 !! type link to 2D grid cell).
 subroutine get1Ddir(n1,xt,yt)
 use m_flowgeom
 use m_flow
 use m_sferic, only : jsferic, jasfer3D
 use m_missing, only :dxymis
 use geometry_module, only: normalin

 implicit none
 integer          :: n1, n2, k, L, LL, ka, kb, k1, k2
 double precision :: xt, yt

 xt = 0d0 ; yt = 0d0; ka = 0; kb = 0
 do k = 1, size(nd(n1)%ln)
    LL  = nd(n1)%ln(k)
    L   = iabs(LL)
    if (kcu(L) .ne. 3) then
       k1 = ln(1,L) ; k2 = ln(2,L)
       n2 = k2
       if (k1 .ne. n1) n2 = k1
       if (ka == 0) then
          ka = n2
       else
          kb = n2
       endif
    endif
 enddo
 if (kb == 0) kb = n1

 call normalin(xz(n1), yz(n1), xz(n2), yz(n2), xt, yt, xu(L), yu(L), jsferic, jasfer3D, dxymis)
 end subroutine get1Ddir


!> Sets the bob values on the flow links that are overridden by a fixed weir.
!! This is based on the interpolated pliz values from the fixed weir definition.
subroutine setbobs_fixedweirs()
use m_flowgeom
use m_fixedweirs
implicit none

integer                       :: i, ip, iL, Lf
double precision              :: alpha, zc


if ( nfxw == 0 ) return

do i = 1,nfxw
    do iL=1,fxw(i)%lnx
        Lf = abs(fxw(i)%ln(iL))
        ip = fxw(i)%indexp(iL)
        alpha = fxw(i)%wfp(iL)
        zc = alpha * fxw(i)%zp(ip) + (1d0-alpha)*fxw(i)%zp(ip+1)
        bob(1,Lf) = max( zc,bob(1,Lf) ) ; bob(2,Lf) = max( zc,bob(2,Lf) )
    end do
end do
end subroutine setbobs_fixedweirs

 subroutine othercell(k1,L,k2)
 USE M_FLOWGEOM
 implicit none
 integer :: k1,k2,L
 k2 = ln(1,L) + ln(2,L) - k1
 end subroutine othercell

 subroutine solve_jacobi(s1,ndx,itsol)               ! uses both s0 and s1
 use m_flowgeom, only : lnx, ln, kfs, kcs, nd
 use m_flowtimes
 use m_jacobi
 use m_reduce

 implicit none

 double precision                  :: ds, rrn        ! max error
 integer                           :: L, n, k1, k2, ndx, itsol, nn, La, n1, n2, ni
 double precision                  :: s1(ndx)

 !$OMP PARALLEL DO                                          &
 !$OMP PRIVATE(n)
 do n = 1,ndx
    if (kfs(n) == 1) then
       bbi(n)   = 1d0/bbr(n)
       db(n)    = ddr(n)*bbi(n)
    endif
 enddo
 !$OMP END PARALLEL DO

 itmxjac = 100000
 itsol   = 0
 ds      = 1d10

 do while (ds > epscg)                              ! Jacobi

    if (mod(itsol, 2) == 0) then
       n1 = 1 ; n2 = ndx; ni =  1
    else
       n2 = 1 ; n1 = ndx; ni = -1
    endif


    !$OMP PARALLEL DO                                          &
    !$OMP PRIVATE(n,nn,L,La)
    do n = n1,n2,ni
       if (kfs(n) == 1) then
          s1(n) = db(n)
          do nn = 1,nd(n)%lnx
             L  = nd(n)%ln(nn) ; La = iabs(L)
             if ( ccr(Lv2(La)) < 0d0) then
                if (L > 0) then
                   s1(n) = s1(n) - ccr(Lv2(La))*s1(ln(1,La))*bbi(n)
                else
                   s1(n) = s1(n) - ccr(Lv2(La))*s1(ln(2,La))*bbi(n)
                endif
             endif
          enddo
       endif
    enddo
    !$OMP END PARALLEL DO

    ds = 1e10                                      ! some big nr
    if (mod(itsol,100) == 0) then
       !$xOMP PARALLEL DO                                          &
       !$xOMP PRIVATE(n,nn,L,La,rrn)
       do n = 1,ndx
          if (kfs(n) == 1) then
             rrn   = ddr(n) - bbr(n)*s1(n)                               ! For explicit points db = s0, so this does won't hurt
             do nn = 1,nd(n)%lnx
                L  = nd(n)%ln(nn) ; La = iabs(L)
                if ( ccr(Lv2(La)) < 0d0) then
                   if (L > 0) then
                      rrn = rrn - ccr(Lv2(La))*s1(ln(1,La))
                   else
                      rrn = rrn - ccr(Lv2(La))*s1(ln(2,La))
                   endif
                endif
             enddo
             ds = abs(rrn)
             if (ds > epscg) exit
          endif
       enddo
       !$xOMP END PARALLEL DO
    endif

    itsol = itsol + 1
    if (itsol == itmxjac) then
       exit
    endif

 enddo
 end subroutine solve_jacobi

 subroutine setkfs()                                 ! set kfs
 use m_flow
 use m_flowgeom
 use m_flowtimes

 implicit none

 integer :: i, L, LL
 integer :: n, kb, ki, ndn

 kfs = 0

 ! open all grid points with positive lateral inflow
 do ndn = 1, ndx
   if (qin(ndn)>1d-12) then
     kfs(ndn) = 1
   endif
 enddo

 if (ivariableteta<=1) then                          ! fully implicit and teta=constant

    do L=1,lnx                                       ! implicit points
       if (hu(L)> 0) then
           kfs(ln(1,L))=1
           kfs(ln(2,L))=1
       endif
    enddo

 else                                                ! set kfs ic. teta; 0=not, 1 =impl, 2 = expl

    do L=1,lnx                                       ! explicit points
       if (hu(L)> 0) then
           if (teta(L) == 0) then
              kfs(ln(1,L))=2
              kfs(ln(2,L))=2
           else if (teta(L) > 0) then
              kfs(ln(1,L))=1                         ! todo: or bnd, randjes ook altijd impliciet
              kfs(ln(2,L))=1
          endif
       endif
    enddo

 endif

! water-level Neumann boundaries: add boundary cells whose corresponding internal cell is wet (but boundary face is inactive)
 do n=1, nbndz
    kb = kbndz(1,n)
    ki = kbndz(2,n)
    if ( kfs(ki).eq.1 ) then
         kfs(kb) = 1
    end if
 end do

 ! velocity boundaries: Neumann water-level boundaries are applied
 do n=1,nbndu
    kb = kbndu(1,n)
    ki = kbndu(2,n)
    if ( kfs(ki).eq.1 ) then
       kfs(kb) = 1
    end if
 end do

 end subroutine setkfs

 subroutine setship()
 use m_netw
 use m_flowgeom
 use m_flow
 use m_flowtimes
 use m_missing
 use m_sferic
 use m_ship
 use m_physcoef
 use m_arcinfo
 use geometry_module, only: dbdistance

 implicit none
 integer          :: L, k, k1,k2, k3, k4, kk, LL, n, num, ierr, nav, i0, i1, j0, j1, m, nn, ixx, incentreorcorner
 integer          :: mmx, nnx, mm, ndraw, Lt, k1t, k2t
 double precision :: xu1,xu2,yu1,yu2,sx1,sx2,sy1,sy2,alf,alfy,eps
 double precision :: rela, dpx, dpy, fxx, fyy, frac, yf, yf2, corr, dvL, dp
 double precision :: sxr, syr, sxr2, syr2, css, sns, dss, prp, prop, volprop, prptot, volu, frb, a
 double precision :: frc,uxsh,uysh,uxw,uyw,uxd,uyd,umods,uud, uush, uushd, friL, frix, friy, frim, phi
 double precision :: FX, FY, XM, YM, armx, army, shvol, roeri, stuwc, stuwn, frixi, friyi, frimi, frcL, dzz

 double precision :: cb, chez, rman, s0shipav, xx, yy, dxx, dyy, dxsa, dysa, df, uk2, uk1, zspn, alfa, ai, bi, qz, az, qza, arm
 double precision, allocatable :: zsp2(:)
 double precision :: xxm, xf, delx, Clearance, Cf, Cf2, Rex, h1, h2, clear, vnu, Ar, aav, aa, fac, yyk, xxk, dxxx, zspk, exx, eyy
 integer, save :: mout

 COMMON /DRAWTHIS/  ndraw(50)

 if (nshiptxy == 0) return

 prptot = 0

 if (time0 == tstart_user .and. iniship == 0) then

    ! call newfil (mout, 'shipcf.xyz')

    shb(1)  = 60d0/2d0 - 0.1d0

    shL(1)  = 360d0/2d0

    shd(1)  = 17d0

    xmxs = maxval(xk (1:numk) ) - 20d0    ! domain extent, run on ground 20 m prior to land water border
    xmns = minval(xk (1:numk) ) + 20d0
    ymxs = maxval(yk (1:numk) ) - 20d0
    ymns = minval(yk (1:numk) ) + 20d0

    javiusp = 1
    if (allocated (viusp) ) deallocate(viusp)
    allocate ( viusp(lnx) , stat=ierr ); viusp = 0d0

    shu = 0d0
    shv = 0d0
    sho = 0d0

    fricx = 0d0; fricy = 0d0 ; fricm = 0d0
    fx2   = 0d0; fy2   = 0d0 ; fm2   = 0d0

    shx(1) = xmns + 0.6d0*(xmxs-xmns)          ! 5850.
    shy(1) = ymns + 0.3d0*(ymxs-ymns)          ! 450.
    shi(1) = pi

    fstuw   = 0d0 ; froer = 0d0

    stuwmx  = 120d0*rhog
    roermx  = 1d0

    stuw(1) = 0d0*stuwmx(1)  ! in ship direction

    roer(1) = 0              ! easy on the helm now

    ! cb    = deadw  / rhomean*shL*shb*shd*4d0 )          ! mass

    if (nshiptxy == 2) then
       shx(2) = xmns + 0.3d0*(xmxs-xmns)          ! 3300.
       shy(2) = ymns + 0.7d0*(ymxs-ymns)          ! 580.
       shi(2) = 0d0 ! pi
       stuw(2) = 0d0
       roer(2) = 0
       shb(2)  = 32.2d0/2d0 - 0.1d0
       shL(2)  = 278d0/2d0
       shd(2)  = 15d0
    endif

    call readshipdef()

    deadwi  = deadw*(4d0*shb**2 + 4d0*shL**2)/12d0     ! intertia vertical rotation axis
    ! return

 endif

 if (icontroltyp(1) >= 4) then
    call getshipcontrol()                    ! arrows + 5 = first ship  qawsd = second ship
 endif

 viusp = vicouv ! 0d0

 do n = 1, nshiptxy

    stuw(n)   = fstuw(n)*stuwmx(n)           ! arrays
    roer(n)   = froer(n)*roermx(n)

    if (stuw(n) >= 0d0) then
       roeri  = 0.5d0*roer(n)
       stuwc  = cos(roer(n))
    else
       roeri  = 0.06d0                       ! wheel effect especially in reverse => 6 degree dev to port => left turning screw
       stuwc  = 0.6d0                        ! less efficient in reverse
    endif
    css       = cos(shi(n) + roeri)   ; sns      = sin(shi(n) + roeri)
    stuwn     = stuwc*stuw(n)
    stuwx(n)  = stuwn*css             ; stuwy(n) = stuwn*sns         ; stuwm(n) = 0.8d0*shL(n)*stuwn*sin(-roeri)

    if (icontroltyp(n) == 1 .or. icontroltyp(n) == 2) then                           ! position from txy file
       if (iniship > 0) then
          shu(n) = ( xyship(2*(n-1)+1) - shx(n) ) /dts
          shv(n) = ( xyship(2*(n-1)+2) - shy(n) ) /dts
          if ( japhifromtxy == 1) then
             rela   = exp(-dts/Trelax )    ! time relax for force
             if ( .not. (abs(shv(n)) < 1d-8 .and. abs(shu(n)) < 1d-8) )  then
                phi    = atan2( shv(n), shu(n) )
                if (phi - shi(n) >= pi) phi = phi - twopi
                if (phi - shi(n) <=-pi) phi = phi + twopi
                shi(n) = (1d0-rela)*phi + rela*shi(n)
             endif
          endif
       endif
       shx(n) =   xyship(2*(n-1)+1)
       shy(n) =   xyship(2*(n-1)+2)
       ! write(mout,'(4F14.4)') time1, dts, shx(1), shu(1)
    else
       if (icontroltyp(n) == 3) then                                                 ! velocity from txy file
          shu(n) = xyship(2*(n-1)+1)   ! * 3.34D0/3.14D0
          shv(n) = xyship(2*(n-1)+2)
       else if( icontroltyp(n) == 4 .or. icontroltyp(n) == 5) then                   ! velocity computed from forces

          a      = (fx2(n) + fricxe(n) + stuwx(n) + fextx(n)) / deadw(n)
          shu(n) = (shu(n)  + a*dts)/(1D0 + dts*fricxi(n)/deadw(n) )
          a      = (fy2(n) + fricye(n) + stuwy(n) + fexty(n)) / deadw(n)
          shv(n) = (shv(n)  + a*dts)/(1D0 + dts*fricyi(n)/deadw(n) )
          if (icontroltyp(n) == 4) then                                              ! also compute gyring, rotation vertical axis
             a      = (fm2(n) + fricme(n) + stuwm(n) + fextm(n)) / deadwi(n)
             sho(n) = (sho(n)  + a*dts)/(1D0 + dts*fricmi(n)/deadwi(n) )
          endif

       endif

       shx(n) = shx(n) + shu(n)*dts
       shy(n) = shy(n) + shv(n)*dts
       shi(n) = shi(n) + sho(n)*dts

    endif
 enddo

 if (icontroltyp(1) > 3) then
    call afhouwendammit()
 endif

 if ( japressurehull >= 0 .and. iniship > 0) then   ! compute pressure force
    rela  = exp(-dts/Trelax)      ! time relax for force
    shvol = 0d0
    do n = 1,nshiptxy
       fx  = 0d0 ; fy = 0d0; xm = 0d0; ym = 0d0

       do L = 1,lnx
          k1  = ln(1,L)            ; k2  = ln(2,L)
          if (zsp(k1) .ne. 0d0 .or. zsp(k2) .ne. 0d0) then

               !dp  = -rhog* ( s1(k2) -  s1(k1) )                                    !       /dx(L)    !
               !dvL =  0.5d0*(zsp(k1) + zsp(k2) )*wu(L)                              !       *dx(L)    !
               !dpx = dp*csu(L)
               !fxx = dpx*dvl

               dp  = -rhog* ( s1(k2) - zsp(k2) - s1(k1) + zsp(k2)) /dx(L)
               dvL =  0.5d0*( v1ship(k1) + v1ship(k2) )
               dpx = dp*csu(L)
               fxx = dpx*dvl

               fx  = fx + fxx
               xm  = xm - fxx*(yu(L) - shy(n) )

               dpy = dp*snu(L)
               fyy = dpy*dvl
               fy  = fy + fyy
               ym  = ym + fyy*(xu(L) - ( shx(n)+dxcog(n) ) )

          endif
       enddo

       qz   = 0d0 ; qza = 0d0
       do k = 1,ndxi
          if ( zsp(k) .ne. 0d0 ) then
             arm = xz(k) - ( shx(n)+dxcog(n) )
             dzz = s1(k) + zsp(k)
             qz  = qz    + dzz*a1(k)*rhog
             qza = qza   - dzz*a1(k)*rhog*arm
          endif
       enddo

       if (fx .ne. 0) armx = xm/fx
       if (fy .ne. 0) army = ym/fy
       fx2(n) = (1d0-rela)*fx2(n) + rela*fx
       fy2(n) = (1d0-rela)*fy2(n) + rela*fy
       fm2(n) = (1d0-rela)*fm2(n) + rela*(ym + xm)
       squat(n)    = (1d0-rela)*squat(n)    + rela*qz
       squatbow(n) = (1d0-rela)*squatbow(n) + rela*qza
    enddo
 endif

 zsp  = 0d0
 zspc = 0d0

 do n = 1, nshiptxy                                    ! impose the ship hulls

    css = cos(shi(n))   ; sns  = sin(shi(n)) ;  checkdw(n) = 0d0

    !css    = 1d0
    !sns    = 0d0
    !shx(1) = 6.00d0
    !shy(1) = 3.20d0

    if (japressurehull == 0) then                   ! body force method for prescribed position sluice doors just blocking flow etc

        do L = 1,lnx

          syr = (yu(L) - shy(n))*css - (xu(L) - shx(n))*sns
          sxr = (xu(L) - shx(n))*css + (yu(L) - shy(n))*sns
          yf  = 1d0 ! - ( 0.1d0*abs( syr ) / shb(n) )

          if ( syr >  -shb(n)    .and. syr < shb(n)     .and. &
               sxr >  -shL(n)*yf .and. sxr < shL(n)*yf  ) then
               advi(L) = advi(L) + 1d4
          endif
       enddo

    else if (abs(japressurehull) == 1) then    ! in zeta points

       if (ihullmethod == 0) then                                  ! analytic function in zeta point

          do k = 1, ndx

             syr = (yz(k) - shy(n))*css - (xz(k) - shx(n))*sns
             sxr = (xz(k) - shx(n))*css + (yz(k) - shy(n))*sns
             yf  = 1d0 - ( 0.1d0*abs( syr ) / shb(n) )
             if ( syr >  -shb(n)    .and. syr < shb(n)     .and. &
                  sxr >  -shL(n)*yf .and. sxr < shL(n)*yf  ) then

                 alf  = 1d0
                 dss  = abs( sxr)  / (shL(n)*yf) ; frb = 0.40d0  ! 0.25d0
                 if (dss > frb) then
                     alf = 0.5d0*( cos(pi*(dss-frb)/(1d0-frb)) + 1d0)
                 endif

                 alfy = 1d0
                 dss  = abs(syr) / shb(n)
                 if (icontroltyp(n) < 4 ) then
                    frb = max(0.2d0, 0.8d0*alf)
                 else
                    frb = 0.6d0  ! relax man
                 endif
                 if (dss > frb) then
                     alfy = 0.5d0*( cos(pi*(dss-frb)/(1d0-frb)) + 1d0)
                 endif

                 if (zsp(k) == 0d0) then
                    zsp(k) = shd(n)*alf*alfy   ! 17d0
                 else
                    zsp(k) = 0.5d0*(zsp(k) + shd(n)*alf*alfy)
                 endif
              endif

           enddo

       else if (ihullmethod == 1) then   ! arcinfo cellcentre

           dxsa = 2d0*shL(n)/(mca-1)
           dysa = 2d0*shb(n)/(nca-1)

           do k = 1, ndx
              syr = (yz(k) - shy(n))*css - (xz(k) - shx(n))*sns
              sxr = (xz(k) - shx(n))*css + (yz(k) - shy(n))*sns

              if ( syr >  -shb(n) .and. syr < shb(n) .and. &   ! through arcinfo
                   sxr >  -shL(n) .and. sxr < shL(n)  ) then
                   xx  = sxr + shL(n)
                   i0  = 1 + (mca-1)*xx/(2d0*shL(n)) ; i1 = i0 + 1
                   dxx = (xx - (i0-1)*dxsa)/dxsa
                   yy  = syr + shB(n)
                   j0  = 1 + (nca-1)*yy/(2d0*shB(n)) ; j1 = j0 + 1
                   dyy = (yy - (j0-1)*dysa)/dysa
                   zsp(k) = D(i0,j0)*(1d0-dxx)*(1d0-dyy) + &
                            D(i1,j0)*(    dxx)*(1d0-dyy) + &
                            D(i0,j1)*(1d0-dxx)*(    dyy) + &
                            D(i1,j1)*(    dxx)*(    dyy)
              endif
          enddo

          do k = 1, numk
              syr = (yk(k) - shy(n))*css - (xk(k) - shx(n))*sns
              sxr = (xk(k) - shx(n))*css + (yk(k) - shy(n))*sns

              if ( syr >  -shb(n) .and. syr < shb(n) .and. &
                   sxr >  -shL(n) .and. sxr < shL(n)  ) then
                   xx  = sxr + shL(n)
                   i0  = 1 + (mca-1)*xx/(2d0*shL(n)) ; i1 = i0 + 1
                   dxx = (xx - (i0-1)*dxsa)/dxsa
                   yy  = syr + shB(n)
                   j0  = 1 + (nca-1)*yy/(2d0*shB(n)) ; j1 = j0 + 1
                   dyy = (yy - (j0-1)*dysa)/dysa
                   zspc(k) = D(i0,j0)*(1d0-dxx)*(1d0-dyy) + &
                             D(i1,j0)*(    dxx)*(1d0-dyy) + &
                             D(i0,j1)*(1d0-dxx)*(    dyy) + &
                             D(i1,j1)*(    dxx)*(    dyy)
               else
                   zspc(k) = 0d0
               endif
          enddo

       else if (ihullmethod == 2 .or. ihullmethod == 4) then   ! arcinfo corner

           dxsa = 2d0*shL(n)/(mca-1)
           dysa = 2d0*shb(n)/(nca-1)

           do k = 1, numk
              syr = (yk(k) - shy(n))*css - (xk(k) - shx(n))*sns
              sxr = (xk(k) - shx(n))*css + (yk(k) - shy(n))*sns

              if ( syr >  -shb(n) .and. syr < shb(n) .and. &
                   sxr >  -shL(n) .and. sxr < shL(n)  ) then
                   xx  = sxr + shL(n)
                   i0  = 1 + (mca-1)*xx/(2d0*shL(n)) ; i1 = i0 + 1
                   dxx = (xx - (i0-1)*dxsa)/dxsa
                   yy  = syr + shB(n)
                   j0  = 1 + (nca-1)*yy/(2d0*shB(n)) ; j1 = j0 + 1
                   dyy = (yy - (j0-1)*dysa)/dysa
                   zspc(k) = D(i0,j0)*(1d0-dxx)*(1d0-dyy) + &
                             D(i1,j0)*(    dxx)*(1d0-dyy) + &
                             D(i0,j1)*(1d0-dxx)*(    dyy) + &
                             D(i1,j1)*(    dxx)*(    dyy)
               else
                   zspc(k) = 0d0
               endif
           enddo

           do m  = 1, mxban                   ! transfer netnode node to net cell
              k  = nban(1,m)
              nn = nban(2,m)
              zsp(nn) = zsp(nn) + banf(m)*zspc(k)
           enddo
           zsp = zsp/ba

           if (ihullmethod == 4) then

              mmx  = 20
              dxxx = 1d0/dble(mmx)

              do k = 1, ndx

                 k1 = nd(k)%nod(1)
                 k2 = nd(k)%nod(2)
                 k3 = nd(k)%nod(3)
                 if ( size(nd(k)%nod) > 3) then
                    k4 = nd(k)%nod(4)
                 else
                    k4 = k1
                 endif

                 if (zspc(k1) == 0d0 .or. zspc(k2) == 0d0 .or. zspc(k3) == 0d0 .or. zspc(k4) == 0d0) then
                    zsp(k) = 0d0 ; ar = 0d0

                    do mm=1,mmx
                       exx = (mm-0.5d0)*dxxx
                       do nn = 1,mmx
                          eyy = (nn-0.5d0)*dxxx
                          xxk = xk(k1)*(1d0-exx)*(1d0-eyy) + &
                                xk(k2)*(    exx)*(1d0-eyy) + &
                                xk(k3)*(    exx)*(    eyy) + &
                                xk(k4)*(1d0-exx)*(    eyy)
                          yyk = yk(k1)*(1d0-exx)*(1d0-eyy) + &
                                yk(k2)*(    exx)*(1d0-eyy) + &
                                yk(k3)*(    exx)*(    eyy) + &
                                yk(k4)*(1d0-exx)*(    eyy)
                          syr = (yyk - shy(n))*css - (xxk - shx(n))*sns
                          sxr = (xxk - shx(n))*css + (yyk - shy(n))*sns
                          if ( syr >  -shb(n) .and. syr < shb(n) .and. &   ! through arcinfo
                               sxr >  -shL(n) .and. sxr < shL(n)  ) then
                              xx  = sxr + shL(n)
                              i0  = 1 + (mca-1)*xx/(2d0*shL(n)) ; i1 = i0 + 1
                              dxx = (xx - (i0-1)*dxsa)/dxsa
                              yy  = syr + shB(n)
                              j0  = 1 + (nca-1)*yy/(2d0*shB(n)) ; j1 = j0 + 1
                              dyy = (yy - (j0-1)*dysa)/dysa
                              zspk = D(i0,j0)*(1d0-dxx)*(1d0-dyy) + &
                                     D(i1,j0)*(    dxx)*(1d0-dyy) + &
                                     D(i0,j1)*(1d0-dxx)*(    dyy) + &
                                     D(i1,j1)*(    dxx)*(    dyy)
                              zsp(k) = zsp(k) + zspk
                          endif
                          ar = ar + 1d0
                       enddo
                    enddo

                    zsp(k) = zsp(k) / ar

                 endif

              enddo

           endif

       else if (ihullmethod == 3) then   ! cellcentre integral arcinfo value

           dxsa = 2d0*shL(n)/(mca-1)
           dysa = 2d0*shb(n)/(nca-1)

           mmx  = 20
           dxxx = 1d0/dble(mmx)

           do k = 1, ndx

              zsp(k) = 0d0 ; ar = 0d0

              k1 = nd(k)%nod(1)
              k2 = nd(k)%nod(2)
              k3 = nd(k)%nod(3)
              if ( size(nd(k)%nod) > 3) then
                 k4 = nd(k)%nod(4)
              else
                 k4 = k1
              endif

              do mm=1,mmx
                 exx = (mm-0.5d0)*dxxx
                 do nn = 1,mmx
                    eyy = (nn-0.5d0)*dxxx
                    xxk = xk(k1)*(1d0-exx)*(1d0-eyy) + &
                          xk(k2)*(    exx)*(1d0-eyy) + &
                          xk(k3)*(    exx)*(    eyy) + &
                          xk(k4)*(1d0-exx)*(    eyy)
                    yyk = yk(k1)*(1d0-exx)*(1d0-eyy) + &
                          yk(k2)*(    exx)*(1d0-eyy) + &
                          yk(k3)*(    exx)*(    eyy) + &
                          yk(k4)*(1d0-exx)*(    eyy)
                    syr = (yyk - shy(n))*css - (xxk - shx(n))*sns
                    sxr = (xxk - shx(n))*css + (yyk - shy(n))*sns
                    if ( syr >  -shb(n) .and. syr < shb(n) .and. &   ! through arcinfo
                         sxr >  -shL(n) .and. sxr < shL(n)  ) then
                        xx   = sxr + shL(n)
                        i0   = 1 + (mca-1)*xx/(2d0*shL(n)) ; i1 = i0 + 1
                        dxx  = (xx - (i0-1)*dxsa)/dxsa
                        yy   = syr + shB(n)
                        j0   = 1 + (nca-1)*yy/(2d0*shB(n)) ; j1 = j0 + 1
                        dyy  = (yy - (j0-1)*dysa)/dysa
                        zspk = D(i0,j0)*(1d0-dxx)*(1d0-dyy) + &
                               D(i1,j0)*(    dxx)*(1d0-dyy) + &
                               D(i0,j1)*(1d0-dxx)*(    dyy) + &
                               D(i1,j1)*(    dxx)*(    dyy)
                        zsp(k) = zsp(k) + zspk
                    endif
                    ar = ar + 1d0
                 enddo
              enddo

              zsp(k) = zsp(k) / ar

          enddo

       endif

   else if (japressurehull == 2) then                           ! arcinfo netnodes

       dxsa = 2d0*shL(n)/(mca-1)
       dysa = 2d0*shb(n)/(nca-1)

       do k = 1, numk
          syr = (yk(k) - shy(n))*css - (xk(k) - shx(n))*sns
          sxr = (xk(k) - shx(n))*css + (yk(k) - shy(n))*sns

          if ( syr >  -shb(n) .and. syr < shb(n) .and. &
               sxr >  -shL(n) .and. sxr < shL(n)  ) then
              xx  = sxr + shL(n)
              i0  = 1 + (mca-1)*xx/(2d0*shL(n)) ; i1 = i0 + 1
              dxx = (xx - (i0-1)*dxsa)/dxsa
              yy  = syr + shB(n)
              j0  = 1 + (nca-1)*yy/(2d0*shB(n)) ; j1 = j0 + 1
              dyy = (yy - (j0-1)*dysa)/dysa
              zspc(k) = D(i0,j0)*(1d0-dxx)*(1d0-dyy) + &
                        D(i1,j0)*(    dxx)*(1d0-dyy) + &
                        D(i0,j1)*(1d0-dxx)*(    dyy) + &
                        D(i1,j1)*(    dxx)*(    dyy)
              zspc(k) = -zspc(k)
          endif


           !if (zspc0(k) .ne. 0d0) then
           !   if (abs(zspc(k) -  zspc0(k)) > 1d-20) then
           !      j0 = 1
           !   endif
           !endif

       enddo

       zsp = 0d0
       do m  = 1, mxban                   ! transfer netnode node to net cell
          k  = nban(1,m)
          nn = nban(2,m)
          zsp(nn) = zsp(nn) + banf(m)*zspc(k)
       enddo
       zsp = zsp/ba

    endif

 enddo

 if (japressurehull == 1) then         ! pressure field
    allocate(zsp2(ndx))                ! smoothing
    do kk = 1,numsmo
       zsp2  = zsp
       Do L  = 1,lnx
          k1 = ln(1,L) ; k2 = ln(2,L)
          df      = wsmo*( zsp2(k2) - zsp2(k1) )
          zsp(k1) = zsp(k1) + df
          zsp(k2) = zsp(k2) - df
       enddo
    enddo
    deallocate(zsp2)

    if (iniship == 0) then
       if (jarestart == 0) then
          s0 = s0 - zsp ; s1 = s0
       endif
     else
       call setpressurehull()
    endif

 else if (japressurehull == 2) then    ! nested newton

    call volship()
    qinship = (v1ship-v0ship)/dts
    v0ship  = v1ship
    zspc0   = zspc

 else if (japressurehull == 3) then    ! nested newton

    call addship2d(0)
    qinship = (v1ship-v0ship)/dts
    v0ship  = v1ship

 endif

 do n = 1, nshiptxy

    css = cos(shi(n))   ; sns  = sin(shi(n)) ; cfav = 0d0; aav = 0d0

    if (icontroltyp(n) > 1) then

       volprop = 0d0 ; prop = 0.5d0*shb(n); prptot = 0d0

       do L = 1,lnx                ! establish propellor volume to later distribute stuw
          k1  = ln(1,L)            ; k2  = ln(2,L)

          syr  = (yz(k1) - shy(n))*css - (xz(k1) - shx(n))*sns
          sxr  = (xz(k1) - shx(n))*css + (yz(k1) - shy(n))*sns
          syr2 = (yz(k2) - shy(n))*css - (xz(k2) - shx(n))*sns
          sxr2 = (xz(k2) - shx(n))*css + (yz(k2) - shy(n))*sns

          yf   = 1d0 - ( 0.1d0*abs( syr ) / shb(n) )
          yf2  = 1d0 - ( 0.1d0*abs( syr2) / shb(n) )
          if (ihullmethod > 0) then
             yf = 1d0 ; yf2 = 1d0
          endif

          if ( syr  >  -shb(n)      .and. syr  < shb(n)      .and. &
               sxr  >  -shL(n)*yf   .and. sxr  <  shL(n)*yf  .or.  &
               syr2 >  -shb(n)      .and. syr2 < shb(n)      .and. &
               sxr2 >  -shL(n)*yf2  .and. sxr2 <  shL(n)*yf2 )  then

               prp = 0d0

               sxr = 0.5d0*(sxr + sxr2)
               syr = 0.5d0*(syr + syr2)

               dss = sqrt( (-0.8*shL(n) - sxr)**2 + syr**2)
               if (dss < prop) then
                   dss = dss/prop
                   prp = 0.5d0*( cos(pi*dss) + 1d0)

                   prptot = prptot + abs(csu(L))*prp
               endif
          endif
       enddo

       fricx (n)= 0d0  ; fricy (n) = 0d0 ; fricm (n) = 0d0
       fricxe(n) = 0d0 ; fricye(n) = 0d0 ; fricme(n) = 0d0
       fricxi(n) = 0d0 ; fricyi(n) = 0d0 ; fricmi(n) = 0d0

       do L = 1,lnx                                                           ! impose ship by pressure field
          plotlin(L) = 0d0
          k1  = ln(1,L)            ; k2  = ln(2,L)
          syr  = (yz(k1) - shy(n))*css - (xz(k1) - shx(n))*sns
          sxr  = (xz(k1) - shx(n))*css + (yz(k1) - shy(n))*sns
          syr2 = (yz(k2) - shy(n))*css - (xz(k2) - shx(n))*sns
          sxr2 = (xz(k2) - shx(n))*css + (yz(k2) - shy(n))*sns

          yf   = 1d0 - ( 0.1d0*abs( syr ) / shb(n) )
          yf2  = 1d0 - ( 0.1d0*abs( syr2) / shb(n) )
          if (ihullmethod > 0) then
             yf = 1d0 ; yf2 = 1d0
          endif

          if (vicuship .ne. 0d0) then
              vicushp(L) = 0d0
          endif

          if ( syr  >  -shb(n)      .and. syr  < shb(n)      .and. &
               sxr  >  -shL(n)*yf   .and. sxr  < shL(n)*yf   .or.  &
               syr2 >  -shb(n)      .and. syr2 < shb(n)      .and. &
               sxr2 >  -shL(n)*yf2  .and. sxr2 < shL(n)*yf2  ) then

               alf = 1d0

               sxr = 0.5d0*(sxr + sxr2)
               syr = 0.5d0*(syr + syr2)

               if (vicuship /= 0d0) then
                  if (vicuship > 0) then
                     if (sxr   > shL(n) - 2d0*shb(n) ) then
                        fac = min (shb(n), dbdistance(sxr,syr, shL(n) - shb(n), 0d0, jsferic, jasfer3D, dmiss) )  ; fac = 1d0 - fac / shb(n)
                     else if (sxr < -shL(n) + 2d0*shb(n) ) then
                        fac = min (shb(n), dbdistance(sxr,syr, -shL(n) + shb(n), 0d0, jsferic, jasfer3D, dmiss) ) ; fac = 1d0 - fac / shb(n)
                     else
                        fac = 0d0
                     endif
                     vicushp(L) = vicuship*fac
                  else
                     vicushp(L) = abs(vicuship)
                  end if

               else if (vicuship < 0d0) then
                  vicushp(L) = abs(vicuship)
               endif

               if (japrop == 1 .and. iniship > 0) then
                  prp = 0d0 ; prop = 0.5d0*shb(n)                                  ! add propellor
                  dss = sqrt( (-0.8*shL(n) - sxr)**2 + syr**2)
                  if (dss < prop) then
                      dss = dss/prop
                      prp = 0.5d0*( cos(pi*dss) + 1d0)
                  endif
                  if (prp > 0d0) then
                     volu    = acl(L)*vol1(k1) + (1d0-acl(L))*vol1(k2)
                     adve(L) = adve(L) + (prp/prptot)*(stuwx(n)*csu(L)+stuwy(n)*snu(L))*ag  / (rhog*volu)            ! normalised propellor
                  endif                                                            !
               endif

               if ( jafric > 0 .and. (zsp(k1) .ne. 0d0 .and. zsp(k2) .ne. 0d0)  .and. abs(shu(n)) > 1d-3) then                                                    ! add hull friction

                  xx    = max(1d-2,shL(n) - sxr)            ! local coordinate, 0 at bow, L at stern   F.M. White 1999 Turbulent boundary layer
                  vnu   = abs(shu(n))*1d6                   ! velocity divided bij viskin
                  Rex   = vnu*xx                            ! local Reynolds nr
                  if ( zsp(k1) .ne. 0d0 .and. zsp(k2) .ne. 0d0) then  ! under ship
                     if (Rex > Returb) then
                        delx = 0.16*xx*Rex**(-1d0/7d0)      ! local delta turbulent
                     else
                        ! delx = min(0.2d0*xx, 5d0*sqrt(xx/vnu) )             ! laminar
                        delx = 5d0*sqrt(xx/vnu)              ! laminar
                     endif
                     h1    = -(bl(k1) + zsp(k1))            !
                     h2    = -(bl(k2) + zsp(k2))            !
                     clear = min(h1,h2)                     ! local keelclearance
                     if (delx > clear) then
                         delx = clear                       ! not larger than keelclearance
                         Rex  = vnu*clear                   ! limited local Reynolds
                     endif
                     ! xxm = ( delx*vnu**(1d0/7d0)/0.16d0 )**(7d0/6d0)  ! highest xx
                     ! xf  = min(xx, xxm)                   ! local xx not larger than highest xx

                     Ar    = 1d0                            ! hull area / cell area
                  else
                     Ar    = wu(L)*(zsp(k1) + zsp(k2)) / ( ba(k1) + ba(k2) ) ! hull area / cell area  for side of ship
                  endif

                  if (jafric >= 3) then                     ! Skewness correction
                     k3 = lncn(1,L) ; k4 = lncn(2,L)
                     ai = (zspc(k4) - zspc(k3))*wui(L)
                     bi = (zsp (k2) - zsp (k1))*dxi(L)
                     Ar = Ar*sqrt(1d0 + ai*ai + bi*bi)
                  endif

                  if ( jafric == 1) then
                      Cf = Cfskin
                  else
                      if (Rex > Returb) then                 ! http://personalpages.manchester.ac.uk/staff/david.d.Apsley/lectures/turbbl/history.pdf
                         Cf  = 0.027d0*Rex**(-1d0/7d0)       ! smooth wall
                         if (jafric >= 4) then
                            Cf2 = 0.079d0 / Rex**0.25d0      ! whan, rothfus
                            if (delx == clear) then
                               Cf = Cf2
                            endif
                         endif
                      else
                         Cf  = 0.664d0 / sqrt(Rex)
                         if (jafric >= 4) then
                            Cf2 = 24d0 / Rex                 ! whan, rothfus
                            if (delx == clear) then
                               Cf = Cf2
                            endif
                         endif
                      endif
                      Cf = Cf*Cfskin                         ! and calibration
                  endif

                  aa      = Ar*0.5d0*( ba(k1) + ba(k2) )
                  cfav    = cfav + cf*aa ; aav = aav + aa

                  frc     = 0.5d0*Cf*Ar ! (shb(n)+shd(n)) / shb(n)                      ! 0.5 for this is non civil but official

                  if (ndraw(36) == 2) then
                     plotlin(L) = delx
                  else if (ndraw(36) == 3) then
                     plotlin(L) = Rex
                  else if (ndraw(36) == 4) then
                     plotlin(L) = Cf
                  else if (ndraw(36) == 5) then
                     if (delx == clear) then
                        plotlin(L) = 1d0
                     else
                        plotlin(L) = -1d0
                     endif
                  else if (ndraw(36) == 6) then
                        plotlin(L) = xxm
                  endif

                  uxsh    = shu(n)  - sho(n)*(yu(L) - shy(n))                           ! ship velocity x,y
                  uysh    = shv(n)  + sho(n)*(xu(L) - shx(n))

                  Lt      = Ltop(L)
                  k1t     = ln(1,Lt) ; k2t = ln(2,Lt)
                  uxw     = 0.5d0*(ucx(k1t)+ucx(k2t))                                   ! water velocity x,y
                  uyw     = 0.5d0*(ucy(k1t)+ucy(k2t))

                  uxd     = uxsh - uxw                                                  ! velocity difference
                  uyd     = uysh - uyw
                  umods   = sqrt( uxd*uxd + uyd*uyd )                                   ! friction velocity

                  uud     = uxd*csu(L) + uyd*snu(L)                                     ! component in (L)
                  friL    = frc*umods*uud

                  if (kmx > 0) then
                     ustw(L) = sqrt(frc)*umods
                  endif

                  uush    = uxsh*csu(L) + uysh*snu(L)
                  uushd   = uush - u1(Lt)

                  if (kmx == 0) then
                    ! adve(L)  = adve(L) - friL*huvli(L)                                    ! add skin friction explicit

                     adve(Lt) = adve(Lt) - frc*huvli(Lt)*umods*uushd                       ! add skin friction implicit
                     advi(Lt) = advi(Lt) + frc*huvli(Lt)*umods                             ! add skin friction

                  else
                     adve(Lt) = adve(Lt) - friL/( hu(Lt) - hu(Lt-1) )                      ! add skin friction explicit
                  endif


                  frcL    = frc*umods*0.5d0*dx(L)*wu(L)*rhomean                         ! Perot reconstruction not done. So factor 0.5
                  frix    = -uxd*frcL          ! =   -(shu(n) - sho(n)*(yu(L) - shy(n)) - uxw)*frcL             ! force on ship
                  friy    = -uyd*frcL          ! =   -(shv(n) + sho(n)*(xu(L) - shx(n)) - uxw)*frcL
                  frim    = friy*(xu(L) - (shx(n)+dxcog(n)) ) - frix*(yu(L) - shy(n))

                  fricx(n)  = fricx(n) + frix
                  fricy(n)  = fricy(n) + friy
                  fricm(n)  = fricm(n) + frim

                 ! fricxe(n) = fricx(n)
                 ! fricye(n) = fricy(n)  removed 02062016
                 ! fricme(n) = fricm(n)

                  if (jashfricimpl == 1) then                                           ! implicit

                     ! frix  = -uxd*frcL  =   -(shu(n) - sho(n)*(yu(L) - shy(n)) - uxw)*frcL             ! force on ship
                     ! friy  = -uyd*frcL  =   -(shv(n) + sho(n)*(xu(L) - shx(n)) - uxw)*frcL

                     frix =   -(0d0 - sho(n)*(yu(L) - shy(n)) - uxw)*frcL                                ! force on ship explicit part
                     friy =   -(0d0 + sho(n)*(xu(L) - shx(n)) - uxw)*frcL
                     frim = -(shv(n) + 0d0*(xu(L) - shx(n)) - uxw)*frcL*(xu(L) - shx(n)) -  &
                          ! TODO, double check this one 2 - after each other is not defined in fortran....
                            (-(shu(n) - 0d0*(yu(L) - shy(n)) - uxw)*frcL*(yu(L) - shy(n)))

                     frixi = frcL                                                                        ! force on ship implicit part
                     friyi = frcL
                     frimi = (xu(L) - shx(n))*frcL*(xu(L) - shx(n)) +   &
                             (yu(L) - shy(n))*frcL*(yu(L) - shy(n))


                     fricxe(n) = fricxe(n) + frix
                     fricye(n) = fricye(n) + friy
                     fricme(n) = fricme(n) + frim

                     fricxi(n) = fricxi(n) + frixi
                     fricyi(n) = fricyi(n) + friyi
                     fricmi(n) = fricmi(n) + frimi

                  endif

               endif

          endif
       enddo
    endif

    if (aav > 0d0) then
       cfav = cfav / aav
    endif

 enddo

 iniship = 1
 end subroutine setship

 subroutine addship2D(japerim)
 use m_ship
 use m_flowgeom
 use m_flow
 use m_arcinfo
 use m_sferic
 use m_flowtimes
 implicit none
 integer :: k, L, k1, k2, japerim, i0, i1, j0, j1, n, numi, kk
 double precision :: slotsav, h1, h2, dx2d, d2, css, sns, dxsa, dysa, dxx, dyy, xx, yy, sxr, syr, sxrL, sxrR, alfa
 double precision :: alf, alfy, dss, frb, yf, v1, v2, domp, omegadomp, za, zs1, zs2

 if (japressurehull == 2) then

    slotsav = slotw2D
    slotw2D = 0d0
    do L = lnx1D + 1, lnxi
       call addlinkship2D(L,japerim)                   ! substract the ship
    enddo
    slotw2D = slotsav

 else if (japressurehull == 3) then

    v1ship = 0d0 ; a1m = 0d0


    omegadomp = 1.0
    domp      = 0d0 ! 0.01*sin(time1*omegadomp)
    do n = 1,nshiptxy
       css  = cos(shi(n))
       sns  = sin(shi(n))
       dxsa = 2d0*shL(n)/(mca-1)
       dysa = 2d0*shb(n)/(nca-1)

       do k = 1, ndx
          dx2d = sqrt(ba(k)) ; d2 = 0.5d0*dx2d*css
          syr  = (yz(k) - shy(n))*css - (xz(k) - shx(n))*sns
          sxr  = (xz(k) - shx(n))*css + (yz(k) - shy(n))*sns
          sxrL = (xz(k) - d2 - shx(n))*css + (yz(k) - shy(n))*sns
          sxrR = (xz(k) + d2 - shx(n))*css + (yz(k) - shy(n))*sns
          yf   = 1d0 - ( 0.1d0*abs( syr ) / shb(n) )
          if ( syr  >  -shb(n) .and. syr  < shb(n) .and. &   ! within ship contours
               sxrR >  -shL(n) .and. sxrL < shL(n)  ) then

               if (ihullmethod == -1) then                     ! constant
                   zsp(k) = shd(n)
               else if (ihullmethod == 0) then                 ! cosine
                   zsp(k) = 0d0
                   numi   = 2
                   dxx    = dx2D/numsmo
                   do kk = 1,numsmo
                      sxr  = sxrL + (kk - 0.5d0)*dxx
                      alf  = 1d0
                      dss  = abs( sxr)  / (shL(n)*yf) ; frb = 0.40d0  ! 0.25d0
                      if (dss > frb) then
                          alf = 0.5d0*( cos(pi*(dss-frb)/(1d0-frb)) + 1d0)
                      endif

                      alfy = 1d0
                      dss  = abs(syr) / shb(n)
                      if (icontroltyp(n) < 4 ) then
                         frb = max(0.2d0, 0.8d0*alf)
                       else
                         frb = 0.6d0  ! relax man
                      endif
                      if (dss > frb) then
                          alfy = 0.5d0*( cos(pi*(dss-frb)/(1d0-frb)) + 1d0)
                      endif
                      zsp(k) = zsp(k) + shd(n)*alf*alfy   ! 17d0
                   enddo
                   zsp(k) = zsp(k) / numsmo
               else if (ihullmethod == 4) then                ! linear
                   if (sxrL >= 0d0) then
                      zsp(k) = shd(n)*(1d0 - sxr/shL(n))      ! bow
                   else if (sxrR <= 0d0) then
                      zsp(k) = shd(n)*(1d0 + sxr/shL(n))      ! stern
                   else
                      za     = -sxrL / (sxrR - sxrL)
                      zs1    =  shd(n)*(1d0 + 0.5d0*sxrL/shL(n)) ! stern
                      zs2    =  shd(n)*(1d0 - 0.5d0*sxrR/shL(n)) ! bow
                      zsp(k) = za*zs1 + (1d0-za)*zs2
                   endif
               else if (ihullmethod == 5) then                ! linear
                   if (sxr >= 0d0) then
                      zsp(k) = shd(n)*(1d0 - sxr/shL(n))      ! bow
                   else
                      zsp(k) = shd(n)*(1d0 + sxr/shL(n))      ! stern
                   endif
               else                                           ! arcinfo
                   xx  = sxr + shL(n)
                   i0  = 1 + (mca-1)*xx/(2d0*shL(n)) ; i1 = i0 + 1
                   dxx = (xx - (i0-1)*dxsa)/dxsa
                   yy  = syr + shB(n)
                   j0  = 1 + (nca-1)*yy/(2d0*shB(n)) ; j1 = j0 + 1
                   dyy = (yy - (j0-1)*dysa)/dysa
                   zsp(k)    = D(i0,j0)*(1d0-dxx)*(1d0-dyy) + &
                               D(i1,j0)*(    dxx)*(1d0-dyy) + &
                               D(i0,j1)*(1d0-dxx)*(    dyy) + &
                               D(i1,j1)*(    dxx)*(    dyy)
               endif
               alfa   = 1d0
               if ( sxrL < -shL(n) ) then
                  alfa = ( SxrR  - - shL(n) ) / dx2d
               else if (sxrR > shL(n) ) then
                  alfa = ( shL(n) - sxRL) / dx2d
               endif
               a1m(k)    = ba(k)*alfa
               zsp(k)    = zsp(k) + domp
               zsp(k)    = max(0.02d0*shd(n), zsp(k))
               v1ship(k) = (s1m(k) + zsp(k))*a1m(k)
          endif
       enddo
    enddo

    if (japerim == 1) then

       do L = lnx1D + 1, lnxi
          k1 = ln(1,L) ; k2 = ln(2,L)
          if (zsp(k1) .ne. 0d0 .or. zsp(k2) .ne. 0d0) then
             !h1    = s1(k1) + zsp(k1)
             !h2    = s1(k2) + zsp(k2)
             !h1    = zsp(k1)
             !h2    = zsp(k2)
             !au(L) = au(L) - 0.5d0*( h1 + h2 )*wu(L)

             v1    = v1ship(k1)
             v2    = v1ship(k2)
             au(L) = au(L) - 0.5d0*( v1 + v2 )/dx(L)
          endif
       enddo

    endif

 else
    if (japerim == 0) then
       do k = 1,ndx
          if (zsp(k) .ne. 0d0) then
             h1      = s1m(k) + zsp(k)
             vol1(k) = vol1(k) - ba(k)*h1
             a1m(k)  = ba(k)
          endif
       enddo
    else
       do L = lnx1D + 1, lnxi
          k1 = ln(1,L) ; k2 = ln(2,L)
          if (zsp(k1) .ne. 0d0 .or. zsp(k2) .ne. 0d0) then
             h1    = s1(k1) + zsp(k1)
             h2    = s1(k2) + zsp(k2)
             au(L) = au(L) - 0.5d0*( h1 + h2 )*wu(L)
          endif
       enddo
    endif
 endif

 end subroutine addship2D

 subroutine setpressurehull()
 use m_ship
 use m_flowgeom
 use m_flow
 implicit none
 integer :: L, LL, k1, k2
 double precision :: r1,r2
 do LL = 1,Lnx
    k1 = ln(1,LL) ; k2 = ln(2,LL)
    if (zsp(k1) .ne. 0d0 .or. zsp(k2) .ne. 0d0) then
       do L = Lbot(LL), Ltop(LL)
          adve(L) = adve(L) + ag*( zsp(k2) - zsp(k1) )*dxi(LL)          ! impose ship hull
       enddo
    endif
 enddo
 end subroutine setpressurehull


 subroutine readshipdef()
 use m_sferic
 use m_ship
 use unstruc_model
 use m_arcinfo
 use m_missing
 use m_flow
 use m_flowgeom
 implicit none
 integer :: minp, ja, n, nn, ic, i, j , ierr, L1
 logical jawel
 double precision, allocatable :: e(:,:)

 inquire (file = md_shipdeffile , exist = jawel)

 if (.not. jawel) then
    return
 endif

 call oldfil(minp, md_shipdeffile )

 call zoekinteger (minp, 'JAPRESSUREHULL'  , japressurehull, ja)
 call zoekinteger (minp, 'JAFRIC'          , jafric, ja)
 call zoekinteger (minp, 'JAPROP'          , japrop, ja)
 call zoekinteger (minp, 'JASHFRICIMPL'    , jashfricimpl,ja)
 call zoekinteger (minp, 'JAPHIFROMTXY'    , japhifromtxy, ja)
 call zoekdouble  (minp, 'TRELAX'          , Trelax,ja)
 call zoekdouble  (minp, 'CFSKIN'          , Cfskin,ja)
 call zoekdouble  (minp, 'ALFAHULL'        , alfahull,ja)    ! not used
 call zoekinteger (minp, 'ITHULLMX'        , ithullmx, ja)
 call zoekdouble  (minp, 'VICUSHIP'        , vicuship, ja)
 call zoekinteger (minp, 'NUMSMO'          , numsmo, ja)
 call zoekdouble  (minp, 'WSMO'            , wsmo, ja)
 call zoekdouble  (minp, 'RETURB'          , returb, ja)
 call zoekinteger (minp, 'IHULLMETHOD'     , ihullmethod, ja)

 rewind (minp)

 do N = 1,nshiptxy

    call zoekinteger (minp, 'NSHIPN'     , nn      , ja)
    call zoekinteger (minp, 'ICONTROLTYP', icontroltyp(n) , ja)
    call zoekdouble  (minp, 'SHL'     , shL(n)     , ja) ; if (ja == 1) shL(n)= 0.5d0*shL(n)                  ! shiplenght on input, then half length
    call zoekdouble  (minp, 'SHB'     , shB(n)     , ja) ; if (ja == 1) shB(n)= 0.5d0*shB(n)                  ! idem width
    call zoekdouble  (minp, 'SHD'     , shd(n)     , ja) ; if (ja == 1) chkadvd = min(chkadvd, 1d-2*shd(n))
    call zoekdouble  (minp, 'DEADW'   , deadw(n)   , ja) ; if (ja == 1) deadw(n)   = 1000d0*deadw(n)  !kg
    call zoekdouble  (minp, 'POWERMX' , powermx(n) , ja) ; if (ja == 1) powermx(n) = 1000d0*0.75d0*powermx(n) ! conversion hp to kw
    call zoekdouble  (minp, 'SPEEDMX' , speedmx(n) , ja) ; if (ja == 1) speedmx(n) = 0.514444d0*speedmx(n)    ! conversion knots to m/s

    if (ja == 1 .and. speedmx(n) .ne. 0d0) then
       stuwmx(n) =  0.65d0*powermx(n)/speedmx(n)    ! propellor efficiency 0.65
    endif

    call zoekdouble  (minp, 'FSTUW'   , fstuw(n)   , ja)
    call zoekdouble  (minp, 'FROER'   , froer(n)   , ja)

    call zoekdouble  (minp, 'SHX'     , shx(n)     , ja)
    call zoekdouble  (minp, 'SHY'     , shy(n)     , ja)
    call zoekdouble  (minp, 'SHI'     , shi(n)     , ja) ; if (ja == 1) shi(n) = shi(n)*dg2rd
    call zoekdouble  (minp, 'SHU'     , shu(n)     , ja)
    call zoekdouble  (minp, 'SHV'     , shv(n)     , ja)
    call zoekdouble  (minp, 'SHO'     , sho(n)     , ja)

    if (ja == 1 .and. sho(n) .ne. 0d0) then
       sho(n) = twopi/sho(n)
    endif

 enddo

 call doclose(minp)

 L1 = index(md_shipdeffile, '.') - 1

 inquire (file = trim(md_shipdeffile(1:L1))//'_hull.asc', exist = jawel)
 if (jawel ) then
    call oldfil(minp, trim(md_shipdeffile(1:L1))//'_hull.asc')
    call REAARC(MINP, -1)
    dxa = 1d0/(mca-1)
    dya = 1d0/(nca-1)
    do i = 1,mca
       do j = 1,nca
          if (d(i,j) == dmiss) then
             d(i,j) = 0d0
          else
             d(i,j) = d(i,j) * shD(1)
          endif
       enddo
    enddo
    if (1 == 0) then
       mca = mca + 2
       nca = nca + 2
       allocate ( e(mca,nca) ) ; e = 0d0
       do i = 2,mca-1
          do j = 2,nca-1
             e(i,j) = d(i-1, j-1)
          enddo
       enddo
       deallocate (d)
       allocate (d(mca,nca))
       d = e
       deallocate (e)
    endif
 endif

 if (vicuship /= 0d0) then
    if (allocated(vicushp) ) deallocate(vicushp)
    allocate  ( vicushp(lnx) , stat = ierr ) ; vicushp = 0d0
    call aerr ('vicushp(lnx)', ierr, lnx   )
 endif

 if (japressurehull >= 2 ) then
    nonlin2D = 2
 endif

 end subroutine readshipdef


 subroutine afhouwendammit()
 use m_ship
 implicit none
 integer          :: n, i, j
 double precision :: sx1, sy1, sx2, sy2, eas, easm, frc

 ! kinetic e = potential e
 ! 0.5*m*u*u = 0.5*eas*dx*dx, u   = 5m/s, dx = 10 m indeuking => eas = deadw   potential energy = kinetic energy
 ! 0.5*m*u*u = 0.5*frc*u*dx   frc = mu/dx                                      friction labour  = kinetic energy

 do n = 1,nshiptxy

    eas = 0.25d0*deadw(n) ; easm = 0.5d0*eas
    frc = 0.5d0*deadw(n)
    fextx(n) = 0d0 ; fexty(n) = 0d0 ; fextm(n) = 0d0

    sx1 = 0.9d0; sy1 = 0d0
    call shipcoor(n,sx1,sy1,sx2,sy2)  ! midvoor
    call inkade(sx2,sy2,i,j)
    if (i == 1) then
       fextx(n)  = fextx(n)  + eas*(xmxs - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmxs - sx2)*(sy2 - shy(n))
    endif

    if (i == -1) then
       fextx(n)  = fextx(n) + eas*(xmns - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmns - sx2)*(sy2 - shy(n))
    endif

    if (j == 1) then
       fexty(n)  = fexty(n) + eas*(ymxs - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymxs - sy2)*(sx2 - shx(n))
    endif

    if (j == -1) then
       fexty(n)  = fexty(n) + eas*(ymns - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymns - sy2)*(sx2 - shx(n))
    endif


    sx1 = 0.9d0; sy1 = 1d0
    call shipcoor(n,sx1,sy1,sx2,sy2)  ! linksvoor
    call inkade(sx2,sy2,i,j)
    if (i == 1) then
       fextx(n)  = fextx(n) + eas*(xmxs - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmxs - sx2)*(sy2 - shy(n))
    endif

    if (i == -1) then
       fextx(n)  = fextx(n) + eas*(xmns - sx2)
      fricxi(n)  = fricxi(n) + frc
        fextm(n) = fextm(n) - easm*(xmns - sx2)*(sy2 - shy(n))
    endif

    if (j == 1) then
       fexty(n)  = fexty(n) + eas*(ymxs - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymxs - sy2)*(sx2 - shx(n))
    endif

    if (j == -1) then
       fexty(n)  = fexty(n) + eas*(ymns - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymns - sy2)*(sx2 - shx(n))
    endif


    sx1 = 0.9d0; sy1 = -1d0
    call shipcoor(n,sx1,sy1,sx2,sy2)  ! rechtsvoor
    call inkade(sx2,sy2,i,j)
    if (i == 1) then
       fextx(n)  = fextx(n) + eas*(xmxs - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmxs - sx2)*(sy2 - shy(n))
    endif

    if (i == -1) then
       fextx(n)  = fextx(n) + eas*(xmns - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmns - sx2)*(sy2 - shy(n))
    endif

    if (j == 1) then
       fexty(n)  = fexty(n) + eas*(ymxs - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymxs - sy2)*(sx2 - shx(n))
    endif

    if (j == -1) then
       fexty(n)  = fexty(n) + eas*(ymns - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymns - sy2)*(sx2 - shx(n))
    endif


    sx1 = -1d0; sy1 = 1d0
    call shipcoor(n,sx1,sy1,sx2,sy2)  ! linksachter
    call inkade(sx2,sy2,i,j)
    if (i == 1) then
       fextx(n)  = fextx(n) + eas*(xmxs - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmxs - sx2)*(sy2 - shy(n))
    endif

    if (i == -1) then
       fextx(n)  = fextx(n) + eas*(xmns - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmns - sx2)*(sy2 - shy(n))
    endif

    if (j == 1) then
       fexty(n)  = fexty(n) + eas*(ymxs - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymxs - sy2)*(sx2 - shx(n))
    endif

    if (j == -1) then
       fexty(n)  = fexty(n) + eas*(ymns - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymns - sy2)*(sx2 - shx(n))
    endif


    sx1 = -1d0; sy1 = -1d0
    call shipcoor(n,sx1,sy1,sx2,sy2)  ! rechtsachter
    call inkade(sx2,sy2,i,j)
    if (i == 1) then
       fextx(n)  = fextx(n) + eas*(xmxs - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmxs - sx2)*(sy2 - shy(n))
    endif

    if (i == -1) then
       fextx(n)  = fextx(n) + eas*(xmns - sx2)
       fricxi(n) = fricxi(n) + frc
       fextm(n)  = fextm(n) - easm*(xmns - sx2)*(sy2 - shy(n))
    endif

    if (j == 1) then
       fexty(n)  = fexty(n) + eas*(ymxs - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymxs - sy2)*(sx2 - shx(n))
    endif

    if (j == -1) then
       fexty(n)  = fexty(n) + eas*(ymns - sy2)
       fricyi(n) = fricyi(n) + frc
       fextm(n)  = fextm(n) + easm*(ymns - sy2)*(sx2 - shx(n))
    endif

 enddo

 end subroutine afhouwendammit

 subroutine inkade(sx2,sy2,i,j)
 use m_ship
 implicit none
 integer          :: i, j
 double precision :: sx2, sy2
 i = 0 ; j = 0
 if (sx2 > xmxs) i =  1
 if (sx2 < xmns) i = -1
 if (sy2 > ymxs) j =  1
 if (sy2 < ymns) j = -1
 if (i .ne. 0 .or. j .ne. 0) then
    i = i + 1 ; i = i-1
 endif

 end subroutine inkade

 subroutine furu()                                   ! set fu, ru and kfs
 use m_flow                                          ! substitue u1 and q1
 use m_flowgeom
 use m_flowtimes
 use m_alloc
 use m_partitioninfo
 use m_xbeach_data, only: ust, vst, urms, swave, Lwave
 use m_waves, only: ypar, cfwavhi, hminlw, cfhi_vanrijn
 use m_sediment
 use unstruc_channel_flow
 use m_cross_helper
 use m_1d_structures
 use m_general_structure
 use m_weir
 use m_orifice
 use m_sferic
 use m_culvert
 use m_Universal_Weir
 use m_bridge
 use m_trachy, only: trachy_resistance
 use m_oned_functions
 use m_compound

 implicit none

 integer          :: L, Lf, n, k1, k2, kb, LL, k, itu1, Lb, Lt, itpbn, ns, nstrucsg, L0
 integer          :: kfu, istru, direction, i
 integer          :: state
 integer          :: mdown
 integer          :: ncompound

 double precision :: bui, cu, du, du0, gdxi, ds, riep, as, gdxids
 double precision :: slopec, hup, u1L, v2, frL, u1L0, rhof, zbndun, zbndu0n, bdmwrp, bdmwrs
 double precision :: qk0, qk1, dzb, hdzb, z00  !
 double precision :: as1, as2, qtotal, width, st2, cmustr, wetdown, dpt
 double precision :: maxwidth1, maxwidth2
 double precision :: twot = 2d0/3d0, hb, h23, ustbLL, agp, vLL
 double precision :: hminlwi,fsqrtt
 double precision :: perimeter, conv, czdum
 logical          :: firstiter
 type(t_structure), pointer :: pstru
 type(t_compound), pointer :: pcompound

 integer          :: np, L1     ! pumpstuff
 double precision :: ap, qp, vp ! pumpstuff

 double precision :: cfuhi3D, Cz    ! for bed friction

 integer          :: ierr, jaustarintsave
 double precision :: sqcfi
 logical          :: SkipDimensionChecks
 integer :: ispumpon

 hminlwi=1d0/hminlw
 fsqrtt = sqrt(0.5d0)
 call klok(cpufuru(1))

 if (kmx == 0 .or. ifixedweirscheme > 0)  then  ! original 2D coding

    !$OMP PARALLEL DO                       &
    !$OMP PRIVATE(L,k1,k2,slopec,hup,gdxi,cu,du,du0,ds,u1L,v2,itu1,frL,bui,u1L0,st2,agp)
    do L  = 1,lnx

       if (hu(L) > 0) then

          if (kmx > 0) then
             if (.not. (iadv(L) == 21 .or. iadv(L) >= 23 .and. iadv(L) <= 25) ) then  ! in 3D, only do this for weir points
                cycle
             endif
          endif

          k1  = ln(1,L) ; k2 = ln(2,L)

          slopec = 0d0
          if (L > lnx1D) then
             if (Slopedrop2D > 0) then           ! 2D droplosses at ridge points and at 2D/1D2D couplings
                if (iadv(L) == 8) then
                   hup = s0(k2) - ( min(bob(1,L), bob(2,L) ) + twot*hu(L) )
                   if (hup < 0) then
                       slopec = hup
                   else
                      hup = s0(k1) - ( min( bob(1,L), bob(2,L) ) + twot*hu(L) )
                      if (hup < 0) then
                          slopec = -hup
                      endif
                   endif
                endif
             endif
          else if (iadv(L) == 8) then            ! 1d or 1D2D droplosses, coding to avoid evaluating array iadv as long as possible,
             hup = s0(k2) - ( max(bob(1,L), bob(2,L) ) + twot*hu(L) )
             if (hup < 0) then
                slopec = hup
             else
                hup = s0(k1) - ( max( bob(1,L), bob(2,L) ) + twot*hu(L) )
                if (hup < 0) then
                    slopec = -hup
                endif
             endif
          else if (slopedrop1d) then            ! 1d droplosses, coding to avoid evaluating array iadv as long as possible,
             hup = s0(k2) - bob(2,L)
             if (hup < 0) then
                slopec = hup
             else
                hup = s0(k1) - bob(1,L)
                if (hup < 0) then
                    slopec = -hup
                endif
             endif
          endif

          agp = ag
          if (jahelmert > 0 .and. jsferic > 0) then
             st2  = sin(dg2rd*yu(L))**2
             agp  = 9.7803253359*(1d0+0.00193185265241*st2)/sqrt(1d0-0.00669437999013*st2)
          endif
          gdxi  = agp*dxi(L)
          cu    = gdxi*teta(L)
          du    = dti*u0(L) - adve(L) + gdxi*slopec
          ds    = s0(k2) - s0(k1)
          if (teta(L) /= 1d0) then
             du = du - (1d0-teta(L))*gdxi*ds
          endif
          du0 = du

          u1L = u0(L)

          if (jaconveyance2D >=3 .or. L <= lnx1D ) then
             v2 = 0d0
          else
             v2 = v(L)*v(L)
          endif

          if (jafrculin > 0) then
              advi(L) = advi(L) + frculin(L)/hu(L)
          endif


          itu1  = 0

10        continue

          if (jawave == 3 .or. (jawave.eq.4 .and. swave.eq.1)) then                ! Delft3D-Wave Stokes-drift correction
              ! D3D: Compare with taubsu computation (taubot.f90) and usage (cucnp.f90/uzd.f90)
              ! A3M:ok for c01-validation_3.1.6: frL = ypar(L)*(cfuhi(L)+cfwavhi(L))*wavmu(L)/hu(L)
              if (modind < 9) then
                 frL = ypar(L)*(cfuhi(L)+cfwavhi(L)) * sqrt((u1L-ustokes(L))**2 + (v(L)-vstokes(L))**2)
              elseif (modind==9) then
                 frL = cfhi_vanrijn(L) * sqrt((u1L-ustokes(L))**2 + (v(L)-vstokes(L))**2)
              elseif (modind==10) then   ! Ruessink 2003
                 frL = cfuhi(L)*sqrt((u1L-ustokes(L))**2 + (v(L)-vstokes(L))**2 + (1.16d0*uorb(L)*fsqrtt)**2)
              end if

              !bdmwrs = frL * wavmu(L)
              !bdmwrp = frL * hu(L)

              ! Bed shear due to flow and waves:
              ! A3M:ok for c01-validation_3.1.6: du = du + frL * sqrt((u1L-ustokes(L))**2 + (v(L)-vstokes(L))**2)
              !du = du0 + frL*wavmu(L)*huvli(L)
              du = du0 + frL*ustokes(L)

          else if ( ifxedweirfrictscheme > 0) then
              if (iadv(L) == 21) then
                 call fixedweirfriction2D(L,k1,k2,frL)
              else
                 frL = cfuhi(L)*sqrt(u1L*u1L + v2)   ! g / (H.C.C) = (g.K.K) / (A.A) travels in cfu
              endif
          else if ((jaBaptist >= 2) .or. trachy_resistance) then
              frL = ( cfuhi(L) + alfav(L) )*sqrt(u1L*u1L + v2)      ! g / (H.C.C) = (g.K.K) / (A.A) travels in cfu
          else
              frL = cfuhi(L)*sqrt(u1L*u1L + v2)      ! g / (H.C.C) = (g.K.K) / (A.A) travels in cfu
          endif

          bui   = 1d0 / ( dti + advi(L) + frL )
          fu(L) = cu*bui
          ru(L) = du*bui
          u1L0  = u1L
          u1L   = ru(L) - fu(L)*ds
          itu1  = itu1 + 1
          if (huvli(L) > 1d0 .and. itu1 < 4 .and. abs( u1L-u1L0 ) > 1d-2 ) then  ! less than 1 m deep
              goto 10
          endif

       endif

    enddo
    !$OMP END PARALLEL DO   ! todo check difference

    if (npump > 0) then ! model has at least one pump link
    do np = 1,npumpsg  ! loop over pump signals, sethu
       qp    = qpump(np)
       ap    = 0d0
       vp    = 0d0
       do n  = L1pumpsg(np), L2pumpsg(np)
          k1 = kpump(1,n)
          L1 = kpump(3,n)
          L  = iabs(L1)
          hu(L) = 0d0; au(L) = 0d0
          fu(L) = 0d0; ru(L) = 0d0
          if (hs(k1) > 1d-2 .and. ispumpon(np,s1(k1)) == 1) then
             hu(L) = 1d0
             au(L) = 1d0
             ap    = ap + au(L)
             vp    = vp + vol1(k1)
          endif
       enddo
       if (qp > 0.5d0*vp/dts) then
           qp = 0.5d0*vp/dts
       endif

       if (ap > 0d0) then
          do n  = L1pumpsg(np), L2pumpsg(np)
             k1 = kpump(1,n)
             if (hs(k1) > 1d-2) then
                L1 = kpump(3,n)
                L  = iabs(L1)
                fu(L) = 0d0
                if (L1 > 0) then
                    ru(L) =  qp/ap
                else
                    ru(L) = -qp/ap
                endif
             endif
          enddo
       endif
    enddo
    end if

    nstrucsg = network%sts%count
    do istru = 1, nstrucsg
       pstru => network%sts%struct(istru)
       if (pstru%type == ST_PUMP) then
          call computePump_all_links(pstru)
       else
          if (network%sts%struct(istru)%type == ST_GENERAL_ST )then
             SkipDimensionChecks = .false.
             if (pstru%numlinks == 1) then
                L = pstru%linknumbers(1)
                if (L <= lnx1D) then
                   if (network%adm%line2cross(L)%c1 < 0) then
                      SkipDimensionChecks = .true.
                   endif
                endif
             endif
             call update_widths(pstru%generalst, pstru%numlinks, pstru%linknumbers, wu, SkipDimensionChecks)
          endif

          do L0 = 1, pstru%numlinks
             L = iabs(pstru%linknumbers(L0))
             direction = sign(1, pstru%linknumbers(L0))
             if (hu(l) > 0) then
                k1 = ln(1,L)
                k2 = ln(2,L)

               select case(network%sts%struct(istru)%type)
               case (ST_WEIR)
                     ! Note: computeweir is not suitable for use in a compound structure
                      call computeweir(pstru%weir, fu(L), ru(L), au(L), width, kfu, s1(k1), s1(k2), &
                                       q1(L), q1(L), u1(L), u0(L), dx(L), dts, state)
                   case (ST_ORIFICE)
                     ! Note: ComputeOrifice is not suitable for use in a compound structure
                      call ComputeOrifice(pstru%orifice, fu(L), ru(L), au(L), width, kfu, s1(k1), s1(k2), q1(L), q1(L),   &
                       & u1(L), u0(L), dx(L), dts, state)
                   case (ST_GENERAL_ST)
                      firstiter = .true.
                      dpt = max(epshu, s1(k1) - bob0(1,L))
                      call GetCSParsFlow(network%adm%line2cross(L), network%crs%cross, dpt, as1, perimeter, width, maxFlowWidth = maxwidth1)
                      dpt = max(epshu, s1(k2) - bob0(2,L))
                      call GetCSParsFlow(network%adm%line2cross(L), network%crs%cross, dpt, as2, perimeter, width, maxFlowWidth = maxwidth2)
                      width = min(maxwidth1, maxwidth2)
                      wu(L) = width

                      call getcz(hu(L), frcu(L), ifrcutp(L), Cz, L)
                      au(L) = pstru%au(L0)
                      call computeGeneralStructure(pstru%generalst, direction, L0, wu(L), bob0(:,L), fu(L), ru(L), &
                          au(L), as1, as2, width, kfu, s1(k1), s1(k2), q1(L), Cz, dx(L), dts, SkipDimensionChecks)
                   case (ST_DAMBREAK)
                      continue
                   case (ST_CULVERT)
                      if (s1(k1) > s1(k2)) then
                         mdown = k2
                         dpt = s1(k2) - bob0(2,L)
                      else
                         mdown = k1
                         dpt = s1(k1) - bob0(1,L)
                      endif

                      call GetCSParsFlow(network%adm%line2cross(L), network%crs%cross, dpt, wetdown, perimeter, width)

                      wetdown = max(wetdown, 0.0001d0)
                      call computeculvert(pstru%culvert, fu(L), ru(L), au(L), width, kfu, cmustr, s1(k1), s1(k2), &
                          q1(L), q1(L), pstru%u1(L0), pstru%u0(L0), dx(L), dts, bob0(:,L), wetdown, .true.)
                      bl(k1) = min(bl(k1), bob0(1,L))
                      bl(k2) = min(bl(k2), bob0(2,L))

                   case (ST_UNI_WEIR)
                      fu(L) = pstru%fu(L0)
                      ru(L) = pstru%ru(L0)
                      au(L) = pstru%au(L0)
                      call computeUniversalWeir(pstru%uniweir,  fu(L), ru(L), au(L), width, bob0(:,L), kfu, s1(k1), s1(k2), &
                          q1(L), pstru%u1(L0), dx(L), dts)
                   case (ST_BRIDGE)
                      dpt = max(epshu, s1(k1) - bob0(1,L))
                      call GetCSParsFlow(network%adm%line2cross(L), network%crs%cross, dpt, as1, perimeter, width)
                      wu(L) = as1/dpt
                      dpt = max(epshu, s1(k2) - bob0(2,L))
                      call GetCSParsFlow(network%adm%line2cross(L), network%crs%cross, dpt, as2, perimeter, width)
                   ! WU(L) is the average width at the bridge (max of up/downstream side).
                      wu(L) = max(wu(L), as2/dpt)
                      call ComputeBridge(pstru%bridge, fu(L), ru(L), au(L), wu(L), kfu, s1(k1), s1(k2), pstru%u1(L0), dx(L), dts,                            &
                               as1, as2, bob0(:,L))
                   case default
                      write(msgbuf,'(''Unsupported structure type'', i5)') network%sts%struct(istru)%type
                      call err_flush()
                   end select

                ! store computed fu, ru and au in structure object. In case this structure
                ! is a part of a compound structure this data will be used in computeCompound
             else
                fu(L) = 0d0
                ru(L) = 0d0
                au(L) = 0d0
                if (pstru%type == ST_GENERAL_ST) then
                   pstru%generalst%fu(:,L0) = 0d0
                   pstru%generalst%ru(:,L0) = 0d0
                   pstru%generalst%au(:,L0) = 0d0
                endif
             endif
             call set_fu_ru_structure(pstru, L0, fu(L), ru(L), au(L))
             call check_for_changes_on_structures(LEVEL_WARN, pstru, bob0(:,L))
          enddo
       endif

    enddo

    ! Compute FU, RA and AU for compound structures
    ncompound = network%cmps%Count
    do i = 1, ncompound
       pcompound => network%cmps%compound(i)
       do L0 = 1, pcompound%numlinks
          L = pcompound%linknumbers(L0)
          if (hu(l) > 0) then
             call computeCompound(pcompound, network%sts%struct, L0, u0(L), teta(L), fu(L), ru(L), au(L))
          end if
       enddo
    enddo

 endif

 if (kmx > 0) then

    if ( jafilter.ne.0 ) then
      call comp_filter_predictor()
    end if

    call update_verticalprofiles()

          endif

 do n  = 1, nbndu
    LL    = kbndu(3,n)
    zbndu0(n) = u0(LL)
 enddo

 do n  = 1, nbndu                                    ! boundaries at u points

    k2    = kbndu(2,n)
    LL    = kbndu(3,n)
    itpbn = kbndu(4,n)
    call getLbotLtop(LL,Lb,Lt)

    ! DEBUG
    ! Original:
    !zbndun = zbndu( (n-1)*kmxd + 1 )
    if (kbndu(4,n) .ne.5) then
       zbndun = zbndu(n)
       zbndu0n = zbndu0(n)
    else
       zbndun  = u1(LL)     ! set in xbeach_absgen_bc
       zbndu0n = u0(LL)
    end if
    !\ DEBUG


    if (alfsmo < 1d0) then
       zbndun  = alfsmo*zbndun  + (1d0-alfsmo)*zbndu0n                     ! i.c. smoothing, start from 0
    endif

    if (itpbn == 8) then                             ! Criticaloutflowbnd
       if (hu(LL) > 0d0) then
          zbndun  = -sqrt(ag*( s1(k2) - min( bob(1,LL) , bob(2,LL) ) ) )
       endif
    else if (itpbn == 9) then                        ! Weiroutflowbnd 2/3h(sqrt
       if (hu(LL) > 0d0) then
          hb      = s1(k2) - min( bob(1,LL) , bob(2,LL) )
          h23     = twot*hb
          au(LL)  = twot*au(LL)
          zbndun  = -sqrt(ag*h23)
       endif
    endif

    if (Lt > Lb) then      ! true 3D
       u1(LL) = zbndun
       jaustarintsave = jaustarint
       if( jaustarint == 0 .or. jaustarint == 3 ) jaustarint = 1
       vLL = v(LL) ; v(LL) = 0d0
       call getustbcfuhi( LL,LL,ustbLL,cfuhi(LL),hdzb, z00, cfuhi3D)    ! call with Lb = LL => layer integral profile
       v(LL) = vLL
       jaustarint = jaustarintsave
       qk0 = 0d0
    endif

    do L = Lb,Lt
       fu(L) = 0d0
       ru(L) = zbndun

       if (Lt > Lb ) then
          if (jaLogprofatubndin == 2 .and. itpbn == 3) then
             ru(L) = zbndu( (n-1)*kmxd + L - Lb + 1 )*min(1d0,alfsmo)
          else if (abs(u1(Lb)) > 1d-4 .and. z00 > 0d0) then
             if( jaustarint == 0 .or. jaustarint == 3 .or. jaustarint == 1 ) then
                dzb   = hu(L) + c9of1*z00
                sqcfi = (log(dzb/z00)-1d0) / vonkar
             else if( jaustarint == 2 ) then
                dzb   = hu(L)/ee + c9of1*z00
                sqcfi = ( log(dzb/z00) ) / vonkar
             else if( jaustarint == 4 ) then
                dzb   = hu(L)/ee + c9of1*z00 *0.66d0
                sqcfi = ( log(dzb/z00) ) / vonkar
             else if( jaustarint == 5 ) then
                dzb   = hu(L)
                sqcfi = ( ( 1.0d0 + c9of1 * z00 / dzb ) * log(dzb/z00+c9of1) - c9of1 * z00/dzb * log(c9of1) - 1.0d0 ) / vonkar
             endif
             qk1   = hu(L)*ustbLL*sqcfi               ! integral flux till level k
             ru(L) = (qk1 - qk0) / ( hu(L) - hu(L-1) )
             if (zbndu(n) < 0d0) ru(L) = -1d0*ru(L)
             qk0   =  qk1
          endif
       endif

       if (kbndu(4,n) == 5) then                     ! JRE, to do: Riemann boundary
     !     kb    = kbndu(1,n)
     !     k2    = kbndu(2,n)
     !     riep  = s0(k2)*sqrt(ag*huvli(L))
     !     ru(L) = ru(L) - riep
     !     as    = 0.5d0*sqrt(ag*huvli(L))
     !!  fu(L) =  as
     !!  ru(L) = -2d0*as*s0(kb)  ! -2d0*sqrt(ag/huvli(L)) +2d0*sqrt(ag*5d0)
       endif
    enddo

 enddo

 call furusobekstructures()

 if ( jawave.eq.3 ) then
!   add wave-induced mass fluxes on boundaries
    do L=Lnxi+1,Lnx
       ru(L) = ru(L) + wavmubnd(L)
    end do
 end if

! BEGIN DEBUG
 if ( jampi.eq.1 ) then
!    call update_ghosts(ITYPE_U,1,Lnx,fu,ierr)
!    call update_ghosts(ITYPE_U,1,Lnx,ru,ierr)


!     call diff_ghosts(ITYPE_U,dxi)
!     call diff_ghosts(ITYPE_Sall,ucx)
 endif
! END DEBUG

 call klok(cpufuru(2)) ; cpufuru(3) = cpufuru(3) + cpufuru(2) - cpufuru(1)

 end subroutine furu

 integer function ispumpon(n,s1k)
 use m_flowexternalforcings
 use m_missing
 use m_structures

 integer, intent(in) :: n
 double precision, intent(in) :: s1k
 ! this is for safety, check arrays before dereference
 if (.not.allocated(pumponoff)) then
     ispumpon = 1
     return
 endif

 if (pumponoff(1,n) == dmiss .and. pumponoff(2,n) == dmiss) then
    ispumpon = 1 ; return
 endif
 if (pumponoff(1,n) .ne. dmiss .and. s1k > pumponoff(1,n) ) then
     pumponoff(5,n) = 1
 endif
 if (pumponoff(2,n) .ne. dmiss .and. s1k < pumponoff(2,n) ) then
     pumponoff(5,n) = 0
 endif
 ispumpon = int(pumponoff(5,n)) ! no change
end function ispumpon

 subroutine gate3D(jazerou1)
 use m_flow
 use m_flowgeom
 use m_flowexternalforcings
 implicit none
 integer          :: jazerou1 ! 1 set u1 zero above gate
 integer          :: L, LL, Lb, Lt, ng, n, k, kb, kt
 double precision :: zga, bup, zLu, fac

 do ng = 1, ngatesg
    zga   = zgate(ng)
    do n  = L1gatesg(ng), L2gatesg(ng)
       LL = kgate(3,n)
       if (hu(LL) > 0d0) then
         bup = 0.5d0*( bob(1,LL) + bob(2,LL) )

         call getLbotLtop(LL,Lb,Lt)
         do L   = Lb, Lt
            ZLu = bup + hu(L-1)
            fac =  (zga-zLu) / ( hu(L) - hu(L-1) )
            if (fac < 0.1d0) then
               Ltop(LL) = L - 1 ; exit
            else
               fac   = max(0d0, min(1d0, fac ) )
            endif
            hu(L) = hu(L-1) + fac*( hu(L) - hu(l-1) )
            au(L) = au(L)*fac
         enddo
         au( Ltop(LL)+1 : Lbot(LL)+kmxL(LL)-1 ) = 0d0  ! -12346d0 ! 6 not 5

      endif
   enddo
 enddo
 end subroutine gate3D

 subroutine getflowdir(L,iu)
 use m_flow
 use m_flowgeom
 implicit none
 integer :: L, iu, k1,k2

 if (u1(L) > 0d0) then
     iu =  1
 else if (u1(L) < 0d0) then
     iu = -1
 else
    k1 = ln(1,L) ; k2 = ln(2,L)
    if (s1(k1) > s1(k2) ) then
        iu = 1
    else
        iu = -1
    endif
 endif
 end subroutine getflowdir

 subroutine s1ini()                           ! links in continuity eq.
 use m_flow
 use m_flowgeom
 use m_flowtimes
 use m_reduce
 use m_ship
 use m_transport, only : constituents, itemp

 implicit none

 integer          :: L, k1, k2, k, kb, n, LL, kk, kt
 double precision :: aufu, auru, tetau
 double precision :: zb, dir, ds, qhs, hsk, buitje, Qeva, Qrain, Qext

 buitje = 0.013d0/300d0                                      ! 13 mm in 5 minutes

 bb = 0d0 ; ccr = 0d0 ; dd = 0d0

 if (jagrw > 0 .or. numsrc > 0 .or. infiltrationmodel > 0 .or. nshiptxy > 0) then
    jaqin = 1
 endif

 if (jatem > 0) then
     if (jatem > 1) then
        heatsrc = heatsrc0                                   ! heatsrc0 established in heatu at interval usertimestep
     else
        heatsrc = 0d0                                        ! just prior to setsorsin that may add to heatsrc
     endif
 endif

 if (jaqin > 0) then                                         ! sources and sinks through meteo

    qin = 0d0 ; qinrain = 0d0; qouteva = 0d0; qinlat = 0d0 ; qoutlat = 0d0
    if (jarain > 0) then
       if (rainuni > 0d0) then
          rain     = rainuni*24d0                             ! mm/hr  => mm/day
       endif

       do k = 1,ndxi
          Qrain = rain(k)*bare(k)*1d-3/(24d0*3600d0)          ! mm/day => m3/s
          if (Qrain  > 0) then
             qinrain = qinrain + Qrain                        ! rain can be pos or neg, to allow for prescribed evaporation
          else if (hs(k) > epshu) then
             Qrain   = - min(0.5d0*vol1(k)/dts , -Qrain)
             qouteva = qouteva - Qrain
          else
             Qrain   = 0d0
          endif
          qin(k) = Qrain
       enddo
    endif

    if (jaevap > 0) then                                      ! computed evaporation is always positive, must be extracted
       do k = 1,ndxi
          if (hs(k) > epshu) then
             Qeva    = -min( 0.5d0*vol1(k)/dts + qin(k) , -evap(k)*bare(k) )
             qin(k)  = qin(k)  + Qeva
             qouteva = qouteva - Qeva
          endif
       enddo
    endif

    if (jaQinext > 0) then
       do k = 1,ndxi
           if (qinext(k) > 0) then ! inflow is always possible
               Qext = qinext(k)
           else if (hs(k) > epshu) then
               Qext = - min(0.5d0*vol1(k)/dts , -qinext(k))
           else ! (almost) no water
               Qext = 0.0d0
           endif
           qinextreal(k) = Qext
           qin(k) = qin(k) + Qext
       enddo
    end if

    if (numlatsg > 0) then

       ! First accumulate all lateral discharges per grid cell
       QQLat(1:ndx) = 0d0
       do n = 1,numlatsg
          do k1=n1latsg(n),n2latsg(n)
             k = nnlat(k1)
             if (k > 0) then 
                QQLat(k) = QQLat(k) + QPlat(n)*ba(k)/baLat(n)
             end if
          end do
       end do

       ! Now, handle the total lateral discharge for each grid cell
       do k = 1,ndxi
          if (QQLat(k) > 0) then
             qinlat = qinlat + QQLat(k)                        ! Qlat can be pos or neg
          else if (hs(k) > epshu) then
             QQlat(k) = - min(0.5d0*vol1(k)/dts , -QQlat(k))
             qoutlat = qoutlat - QQlat(k)
          else
             QQlat(k) = 0d0
          endif
          qin(k) = qin(k) + QQlat(k)
       enddo
    endif

    if (jarain > 0 .or. jaevap > 0 .or. jaQinext > 0) then ! TODO: Qlat not here?
       do k  = 1,ndxi
          kt = ktop(k)
          if (kmx > 0) then
             qin(kt) = qin(kt) + qin(k)
          endif
          if (jatem >= 1) then
             if (qin(kt) > 0) then
                if (jatem > 1) then
                   heatsrc(kt) = heatsrc(kt) + qin(kt)*tair(k)                   ! rain has temp of air time varying specified
                else if (jatem == 1) then
                   heatsrc(kt) = heatsrc(kt) + qin(kt)*backgroundairtemperature  ! or constant
                endif
             else
                heatsrc(kt) = heatsrc(kt) + qin(kt)* constituents(itemp,kt)      ! extract top layer temp
             endif
          endif
       enddo
    endif

    if (jagrw > 0 .or. infiltrationmodel > 0) then
       call setgrwflowexpl()                                 ! add grw-flow exchange to the qin array
    endif

    if (numsrc > 0) then
       call setsorsin()                                      ! add sources and sinks
    endif

    if (nshiptxy > 0) then
       ! qin = qin - qinship
    endif

    qincel = 0d0 ; qoutcel = 0d0

    do k = 1,ndxi
       if (qin(k) > 0d0) then
              dd(k)  = qin(k)
       else if (qin(k) < 0d0) then

          hsk = s0(k) - bl(k)
          if (a1(k) > 0.0) then
             ds  = -dts*qin(k)/a1(k)                            ! altijd minder dan daling bij niet-lin volumes
          else
          ds  = -dts*qin(k)/ba(k)                            ! altijd minder dan daling bij niet-lin volumes
          endif
          if (kfs(k) == 0) then                              ! niet in matrix
             if (ds  < hsk) then                             ! er is genoeg
                s1(k) = s0(k) - ds
             else                                            ! leeg
                s1(k) = bl(k) ; ds = hsk
             endif
             qin(k) = -ds*ba(k)/dts

          else if (hsk > 0d0) then                            ! all explicit
             dd(k)  = -min( vol1(k)/dts, abs(qin(k) ) )
             qin(k) = dd(k)

          else                                               ! er is te weinig
             dd(k)  = 0 ; qin(k) = 0                         ! => wachten tot kfs=0 en expliciet scheppen
          endif
       else
          dd(k) = 0
       endif
       qincel = qincel + qin(k)
    enddo
 endif

 if (kmx < 1) then ! original 2D coding

    do L = 1,lnx
       if (hu(L) > 0) then
           tetau       = teta(L)*au(L)
           aufu        = tetau*fu(L)
           k1 = ln(1,L); k2 = ln(2,L)
           bb(k1)      = bb(k1)      + aufu
           bb(k2)      = bb(k2)      + aufu
           ccr(Lv2(L)) = ccr(Lv2(L)) - aufu

           auru        = tetau*ru(L) + (1d0 - teta(L))* au(L)*u0(L)  !     q1(L)
           dd(k1)      = dd(k1) - auru
           dd(k2)      = dd(k2) + auru
       endif
    enddo
    !
 else

    do LL = 1,lnx
       if (hu(LL) > 0) then
          k1 = ln(1,LL) ; k2 = ln(2,LL)

          do L = Lbot(LL), Ltop(LL)

             if (hu(L) > 0) then
                tetau        = teta(LL)*au(L)

                aufu         = tetau*fu(L)
                bb(k1)       = bb(k1)       + aufu
                bb(k2)       = bb(k2)       + aufu
                ccr(Lv2(LL)) = ccr(Lv2(LL)) - aufu

                auru         = tetau*ru(L) + (1d0 - teta(LL))*au(L)*u0(L)  !     q1(L)
                dd(k1)       = dd(k1) - auru
                dd(k2)       = dd(k2) + auru
             endif
          enddo
       endif

    enddo


 endif

 if (nonlin > 0) then
    ccrsav = ccr
 endif

 end subroutine s1ini

 subroutine s1nod()                                  ! nodes in continuity eq
 use m_flow
 use m_flowgeom
 use m_flowtimes
 use m_reduce
 use m_partitioninfo
 use m_missing
 use m_alloc
 use m_sobekdfm
 use unstruc_display, only : ntek, jaGUI

 implicit none

 integer          :: n
 integer          :: kb , k2 , L, k, LL, LS, itpbn
 integer          :: kbk, k2k, Lk
 double precision :: dtiba, hh, zb, dir, dtgh, alf
 double precision :: sqrtgfh, cffu, rowsum, fuL, ruL, huL, hep
 integer          :: i, ierr

 double precision, parameter :: HBMIN = 1d-3

 !bbr = bb + dti*a1     !m2/s
 !ddr = dd + dti*a1*s1  !m3/s

! BEGIN DEBUG
  !if ( jampi.eq.1 ) then
  !   call reduce_dt()
  !   call update_ghosts(ITYPE_Sall, Ndx, s1, ierr)
  !   call update_ghosts(ITYPE_Sall, Ndx, a1, ierr)
  !   call update_ghosts(ITYPE_Sall, Ndx, vol0, ierr)
  !   call update_ghosts(ITYPE_Sall, Ndx, vol1, ierr)
  !   call update_ghosts(ITYPE_U, 1,    Lnx, fu,   ierr)
  !   call update_ghosts(ITYPE_U, 1,    Lnx, ru,   ierr)
  !end if
! END DEBUG


 !! remove entries for 1d2d nodes in bb, dd and ccr
 !  do n  = 1, nbnd1d2d                                   ! 1D2D boundaries
 !   kb      = kbnd1d2d(1,n)
 !   k2      = kbnd1d2d(2,n)
 !   L       = kbnd1d2d(3,n)
 !   bb(k2) = bb(k2) -bb(kb)
 !   dd(k2) = dd(k2) + dd(kb)
 !   bb(kb) = 0d0
 !   dd(kb) = 0d0
 !   ccr(lv2(L)) = 0d0
 ! end do

 !$OMP PARALLEL DO           &
 !$OMP PRIVATE(n,dtiba)
 do n = 1,ndx                                        ! Waterlevels, = s1ini
    dtiba  = dti*a1(n)
    bbr(n) = bb(n) + dtiba                           ! need it also for kfs.ne.1 at the boundaries (for parallel runs, see partition_setkfs)
    if (nonlin == 2) then                            ! pressurised
        bbr(n)  = bbr(n) - dti*a1m(n)
    endif

    if (kfs(n) == 1) then                            ! only for implicit points
       if (nonlin > 0) then
          ddr(n) = dd(n)  + dtiba*s1(n)              !
          ddr(n) = ddr(n) + dti*( vol0(n) - vol1(n) )
          if (nonlin == 2) then                      ! pressurised
             ddr(n) = ddr(n) - s1m(n)*a1m(n)*dti
          endif
       else
          ddr(n) = dd(n)  + dtiba*s0(n)              ! Use s0 for the linear solver. Normally s0 = s1, however in
                                                     ! iterative couplings this might not be the case (e.g. 1d2d
                                                     ! SOBEK D-FlowFM coupling
       endif
    endif                                            ! then also setback s1 !
 enddo
 !$OMP END PARALLEL DO

 ! compute riemann bnd mean state
 ! call  riemann_setmean()

 ! compute right-hand sides
 do n  = 1, nbndz                                    ! overrides for waterlevel boundaries
    kb      = kbndz(1,n)
    k2      = kbndz(2,n)
    L       = kbndz(3,n)
    itpbn   = kbndz(4,n)
!    bbr(kb) = 1d0
    if (     itpbn == 1) then                        ! waterlevelbnd
       zb   = zbndz(n)
       if (alfsmo < 1d0) then
          zb = alfsmo*zb + (1d0-alfsmo)*zbndz0(n)
       endif
    else if (itpbn == 2) then                        ! neumannbnd, positive specified slope leads to inflow
       !zb   = s1(k2) + zbndz(n)*dx(L)
       zb    = -zbndz(n)*dx(L)*ccr(Lv2(L))            ! right-hand side
    else if (itpbn == 5) then                        ! Riemannbnd
!       hh   = max(epshs, 0.5d0*( hs(kb) + hs(k2) ) )
!       zb   = 2d0*zbndz(n) - zbndz0(n) - sqrt(hh/ag)*u1(L)
       zb   = 2d0*zbndz(n) - zbndz0(n)
    else if (itpbn == 6) then                        ! outflowbnd
       if (u0(L) > 0d0) then
          zb   = s1(k2)
       else
          hh   = max(epshs, 0.5d0*( hs(kb) + hs(k2) ) )
          dtgh = dts*( sqrt(ag*hh) )
          zb   = s1(kb) - dtgh*(  dxi(L)*( s1(kb) - s1(k2) ) - zbndz(n) )  ! verder testen
       endif
    else if (itpbn == 7) then                        ! qhbnd
       zb   = zbndz(n)
       if (alfsmo < 1d0) then
          zb = alfsmo*zb + (1d0-alfsmo)*zbndz0(n)
       endif
    endif

!   set matrix entries
    if ( itpbn.eq.2 ) then
!      Neumann boundary condition
       if ( ccr(Lv2(L)).eq.0d0 ) then  ! internal cell is wet, but boundary face is inactive (see setkfs)
          ccr(Lv2(L)) = -bbr(kb)
          bbr(k2) = bbr(k2) + bbr(kb)
          ddr(k2) = ddr(k2) + ccr(Lv2(L))*zbndz(n)*dx(L)
       end if

       bbr(kb)     = -ccr(Lv2(L))
       ddr(kb)     = -zbndz(n)*dx(L)*ccr(Lv2(L))      ! double for safety
    else if ( itpbn.eq.5 ) then
!      Riemann boundary condition (note: ccr= -Au theta fu)
       zb = max(zb,bl(kb)+HBMIN)
       if ( ccr(Lv2(L)).eq.0d0 ) then   ! internal cell is wet, but boundary face is inactive (see setkfs)
          ddr(kb) = bbr(kb) * zb ! u(L)=0 assumed
       else
          hh   = max(epshs, 0.5d0*( hs(kb) + hs(k2) ) )
          sqrtgfh = sqrt(ag/hh)
          if (kmx == 0) then
             fuL = fu(L)
             ruL = ru(L)
          else
             fuL = 0d0; ruL = 0d0; huL = 0d0
             do LL  = Lbot(L), Ltop(L)
                hep = max(epshu,hu(L)-hu(L-1))
                fuL = fuL + fu(LL)*hep
                ruL = ruL + ru(LL)*hep
                huL = huL +        hep
             enddo
             ful = fuL/huL ; ruL = ruL/huL
          endif
          cffu    = ccr(Lv2(L))/fuL
          bbr(kb) = -cffu*(fuL+sqrtgfh)
          ddr(kb) = -cffu*(sqrtgfh*zb-ruL)
       end if
    else
!      Dirichlet boundary condition

       if (japatm > 0 .and. PavBnd > 0) then
          zb = zb - ( patm(kb) - PavBnd )/(ag*rhomean)
       endif
       zb = max( zb, bl(kb) + HBMIN )

       ddr(kb)     = bbr(kb)*zb
       ddr(k2)     = ddr(k2) - ccr(Lv2(L)) * zb       ! met link(L) in s1ini
       ccr(Lv2(L)) = 0d0
    end if
 enddo

 do n  = 1, nbndu                                   ! velocity boundaries
    kb      = kbndu(1,n)
    k2      = kbndu(2,n)
    L       = kbndu(3,n)
 !   bbr(kb) = 1d0
 !   ddr(kb) = s1(k2)
 !     SPvdP: apply Neumann conditions to water level at velocity boundaries
       ccr(Lv2(L)) = -bbr(k2)            ! some non-zero value
       bbr(k2)     = bbr(k2) - ccr(Lv2(L))
       bbr(kb)     = -ccr(Lv2(L))   ! should not be zero
       ddr(kb)     = 0d0
 enddo

 if (nbnd1d2d > 0) then
   call compute_1d2d_boundaries()
 endif

 jacheckmatrix = 0
 if (jacheckmatrix > 0) then
    do k = 1,ndxi
       rowsum = 0
       do LL = 1, size( nd(n)%ln )
          L  = iabs( nd(n)%ln(LL) )
          rowsum = rowsum + abs(ccr(Lv2(L)))
       enddo
       if ( bbr(k) <= rowsum ) then
          call qnerror('checkmatrix = nocheck', ' ', ' ')
       endif
    enddo
 endif

! update overlapping ghost-parts of matrix
 if ( jampi.eq.1 .and. jaoverlap.eq.1 ) then
    call update_matrix(ierr)
 end if

 end subroutine s1nod

! update overlapping ghost-parts of matrix
 subroutine update_matrix(ierror)
!    use m_flow
    use m_flowgeom
    use m_reduce
    use m_partitioninfo
    use m_alloc
    implicit none

    integer, intent(out) :: ierror  ! error (1) or not (0)

    integer              :: i, k, L

    ierror = 0

!   allocate if necessary
    call realloc(workmatbd, (/2, Ndx/), keepExisting=.true., fill=0d0)
    call realloc(workmatc, (/2, Lnx/), keepExisting=.true., fill=0d0)

!   fill work arrays
    do i=1,numsend_sall
       k=isendlist_sall(i)
       workmatbd(1,k) = bbr(k)
       workmatbd(2,k) = ddr(k)
    end do

    do i=1,numsend_u
       L=isendlist_u(i)
       workmatc(1,L) = ccr(Lv2(L))
       workmatc(2,L) = 1d0   ! used to "undo" orientation correction in update_ghosts(ITYPE_U,...)
    end do

!   update work arrays
    call update_ghosts(ITYPE_SALL,2,Ndx,workmatbd,ierror)
    call update_ghosts(ITYPE_U,2,Lnx,workmatc,ierror)

!   copy from work array
    do i=1,numghost_sall
       k=ighostlist_sall(i)
       bbr(k) = workmatbd(1,k)
       ddr(k) = workmatbd(2,k)
    end do

    do i=1,numghost_u
       L=iabs(ighostlist_u(i))
       ccr(Lv2(L)) = workmatc(1,L) * workmatc(2,L)
    end do

    return
 end subroutine update_matrix

 !> apply Dirichlet conditions to non-overlapping ghost cells (i.e. effectively remove from the system)
 subroutine apply_ghost_bc(ierror)
    use m_flow
    use m_flowgeom
    use m_reduce
    use m_partitioninfo
    use m_alloc
    implicit none

    integer, intent(out) :: ierror  ! error (1) or not (0)

    integer              :: i, k, kother, L, LL

    do i=1,nghostlist_snonoverlap(ndomains-1)
       k = ighostlist_snonoverlap(i)
       do LL=1,nd(k)%lnx
          L = iabs(nd(k)%ln(LL))
          kother = ln(1,L)+ln(2,L)-k
          ddr(kother) = ddr(kother)-ccr(Lv2(L))*s1(k)
          ccr(Lv2(L)) = 0
          ddr(k) = ddr(k)-ccr(Lv2(L))*s1(k)
       end do
    end do

    ierror = 0

    return
 end subroutine apply_ghost_bc


 subroutine setgrwflowexpl() ! groundwater flow explicit
 use m_flowgeom
 use m_flow
 use m_flowtimes
 implicit none
 integer          :: k1, k2, L, k
 double precision :: z1, z2, h1, h2, dh, dQ, hunsat, hunsat1, hunsat2, fac, qgrw, h2Q
 double precision :: fc, conduct, dum, h_upw, Qmx, hintercept

 qingrw = 0d0 ; qoutgrw = 0d0; Volgrw = 0d0

 if (infiltrationmodel == 1) then  ! orig. interceptionmodel: no horizontal groundwater flow, and infiltration is instantaneous as long as it fits in unsat zone (called 'interception' here, but naming to be discussed)

     do k  = 1,ndx2D
        hunsat = bl(k) - sgrw1(k)
        if ( qin(k) > 0d0 .and. hunsat > 0d0 ) then
            h2Q      = ba(k)/dts
            dh       = min(hunsat, qin(k)/h2Q )
            dQ       = dh*h2Q
            sgrw1(k) = sgrw1(k) + dh              ! results in increase of sgrw
            qoutgrw  = qoutgrw  + dQ
            qin(k)   = qin(k)   - dQ
        endif
     enddo
     return

 else if (infiltrationmodel == 2 .and. jagrw == 0) then  ! spatially varying prescribed max infiltration capacity

    do k = 1,ndx2D
       Qmx       = max(0d0, vol1(k)/dts + qin(k) )
       infilt(k) = infiltcap(k)*ba(k)                    ! Prescribed infiltration flux m3/s
       infilt(k) = min(Qmx, infilt(k))
       qin(k)    = qin(k)   - infilt(k)
       qoutgrw   = qoutgrw  + infilt(k)
    enddo
    return

 else

 sgrw0 = sgrw1

 do L  = lnx1D+1, Lnxi      ! Horizontal Darcy flow in 2D only:

    !if (L =< Lnx1D) then
    !   if (kcu(L) == 5) cycle                                       ! pipe type 1D2D connection
    !   if ( prof1D(1,L) > 0 .and. prof1D(3,L) == 1) cycle           ! pipe profile
    !endif

    k1       = ln(1,L) ;  k2 = ln(2,L)
    hunsat1  = bl(k1) - sgrw0(k1)
    fac      = min ( 1d0, max(0d0,  hunsat1 / h_transfer  )  )      ! 0 at bed, 1 at sgrw
    z1       = sgrw1(k1)*fac + s1(k1)*(1d0-fac)
    pgrw(k1) = z1

    hunsat2  = bl(k2) - sgrw0(k2)
    fac      = min ( 1d0, max(0d0,  hunsat2 / h_transfer  )  )
    z2       = sgrw1(k2)*fac + s1(k2)*(1d0-fac)
    pgrw(k2) = z2

    h1       = sgrw1(k1) - bgrw(k1)
    h2       = sgrw1(k2) - bgrw(k2)
    h_upw    = max( 0d0, min(h1, h2) )                              ! safe, not upw

    Qgrw      = Conductivity*h_upw*wu(L)*(z1 - z2)*dxi(L)*dts       ! (m3/s)*s
    sgrw1(k1) = sgrw1(k1) - Qgrw*bai(k1)/porosgrw
    sgrw1(k2) = sgrw1(k2) + Qgrw*bai(k2)/porosgrw
 enddo

 do k = 1,ndx2D
     hunsat = bl(k) - sgrw1(k)
     h2Q    = porosgrw*ba(k)/dts
     if (hunsat <= 0) then                                          ! groundwater above bed => transfer to open water
         sgrw1(k) = sgrw1(k) + hunsat                               ! decrease sgrw to bedlevel
         qin(k)   = qin(k)   - hunsat*h2Q                           ! results in positive qin
         qingrw   = qingrw  - hunsat*h2Q
     else                                                           ! groundwater below bed => seepage from open water
         Qmx      = vol1(k)/dts + qin(k)
         fac      = min ( 1d0, max(0d0, ( hunsat / h_transfer ) ) ) ! 0 at bed, 1 at sgrw
         if (infiltrationmodel == 2) then
            Qgrw     = Infiltcap(k)*ba(k)                           ! Prescribed infiltration velocity m3/s
         else if (infiltrationmodel == 3) then
            fc       = min ( 1d0, max(0d0, ( sgrw1(k)+h_capillair - bl(k) ) / h_capillair  ) )
            Conduct  = Conductivity*(fc + unsatfac*(1-fc) )         ! lineair weight sat - unsat over capillair zone
            Qgrw     = Conduct*(sgrw1(k)-bgrw(k))*(s1(k) - bl(k))   ! Darcy in vertical m3/s
         endif
         Qgrw     = min(Qmx, Qgrw)
         qin(k)   = qin(k)   - Qgrw                                 ! negative qin
         qoutgrw  = qoutgrw  + Qgrw
         sgrw1(k) = sgrw1(k) + Qgrw/h2Q                             ! results in increase of sgrw
     endif
     Volgrw   = Volgrw + porosgrw*ba(k)*(sgrw1(k) - bgrw(k))
 enddo

 do L = lnxi+1,lnx                                                  ! copy bnd values only if open surface water
    if (hu(L) > 0) then
       k = ln(1,L)
       sgrw1(k) = s1(k)
       pgrw(k)  = s1(k)
    endif
 enddo

 end if

 end subroutine setgrwflowexpl


 subroutine addsorsin(filename, area, ierr)

 use m_flowexternalforcings
 use m_polygon
 use m_flow
 use m_GlobalParameters, only: INDTP_ALL

 use m_missing
 use unstruc_messages
 use dfm_error
 use geometry_module, only: normalin
 use m_sferic, only: jsferic, jasfer3D

 implicit none

 character (len=*), intent(in)  :: filename
 double precision,  intent(in)  :: area
 integer,           intent(out) :: ierr
 integer   :: minp, k, kk, kb, kt, kk2, n1, n2, i, jakdtree, kdum(1)
 character (len=40) :: tmpname(1)

 ierr = DFM_NOERR

 call oldfil(minp, filename)
 call reapol(minp, 0)

 if (npl == 0) return

 numsrc = numsrc + 1
 call reallocsrc(numsrc)

 ! set the coordinates of source/sink
 xsrc(numsrc,1:npl) = xpl(1:npl)
 ysrc(numsrc,1:npl) = ypl(1:npl)
 nxsrc(numsrc)      = npl
 kk = 0; kk2 = 0

 ! Strip off trailing file extension .pli
 n2  = index(filename,'.', .true.) - 1
 if (n2 < 0) then
    n2 = len_trim(filename)
 end if

 ! Strip off leading path /dir/name/bnd/
 n1  = index(filename(1:n2),'\', .true.) ! Win
 if (n1 == 0) then
     n1 = index(filename(1:n2),'/', .true.) ! Or try UX
 end if

 ! Store sink/source name for waq
 srcname(numsrc) = filename(n1+1:n2)

 ! call inflowcell(xpl(npl), ypl(npl), kk2) ! TO: Source
 tmpname(1) = filename(n1+1:n2) // ' source'
 jakdtree = 0
 kdum(1)  = 0
 if (xpl(npl) .ne. -999.999d0) then
    call find_flownode(1,xpl(npl),ypl(npl),tmpname(1),kdum(1),jakdtree,-1, INDTP_ALL) ; kk2 = kdum(1)
 endif

 ! Support point source/sinks in a single cell if polyline has just one point (npl==1)
 if (npl == 1) then

    kk = 0 ! Only keep the source-side (kk2), and disable momentum discharge
    if (area /= dmiss .and. area /= 0d0) then
       ! User specified an area for momentum discharge, but that does not apply to POINT sources.
       write (msgbuf, '(a,a,a,f8.2,a)') 'Source-sink for ''', trim(filename), ''' is a POINT-source. Nonzero area was specified: ', area, ', but area will be ignored (no momentum discharge).'
       call warn_flush()
    end if
    arsrc (numsrc) = 0d0
 else ! Default: linked source-sink, with polyline npl >= 2
    ! call inflowcell(xpl(1) , ypl(1)  , kk) ! FROM: sink
    tmpname = filename(n1+1:n2) // ' sink'
    kdum(1) = 0
    if (xpl(1) .ne. -999.999d0) then
       call find_flownode(1,xpl(1),ypl(1),tmpname(1),kdum(1),jakdtree,-1,INDTP_ALL) ; kk = kdum(1)
    endif

    if (kk.ne.0 .or. kk2.ne.0) then
       arsrc (numsrc) = area
    endif
 end if

 if (kk == 0 .and. kk2 == 0) then
    write (msgbuf, '(a,a)') 'Source+sink is outside model area for ', trim(filename)
    call warn_flush()
    ierr = DFM_NOERR
    goto 8888
 endif

 ksrc (1,numsrc) = kk
 zsrc (1,numsrc) = zpl(1)
 zsrc2(1,numsrc) = zpl(1)

 ksrc (4,numsrc) = kk2
 zsrc (2,numsrc) = zpl(npl)
 zsrc2(2,numsrc) = zpl(npl)

 if (kk > 0) then
    if ( allocated(dzL) ) then
       if (dzL(1) .ne. dmiss) then
           zsrc2(1,numsrc) = dzL(1)
       endif
    endif
    ! Determine angle (sin/cos) of 'from' link (=first segment of polyline)
    if (npl > 1) then
      call normalin (xpl(1), ypl(1), xpl(2), ypl(2), cssrc(1,numsrc), snsrc(1,numsrc), xpl(1), ypl(1), jsferic, jasfer3D, dxymis)
    end if

    do i = 1,numsrc-1
       if (      ksrc(1,i) .ne. 0 .and. kk == ksrc(1,i) ) then
          write (msgbuf, '(4a)')  'FROM point of ', trim (srcname(numsrc)),' coincides with FROM point of ', trim(srcname(i)) ;  call warn_flush()
       else if ( ksrc(4,i) .ne. 0 .and. kk == ksrc(4,i) ) then
          write (msgbuf, '(4a)')  'FROM point of ', trim (srcname(numsrc)),' coincides with TO   point of ', trim(srcname(i)) ;  call warn_flush()
       endif
    enddo

 endif

 if (kk2 > 0) then
    if ( allocated(dzL) ) then
       if (dzL(npl) .ne. dmiss) then
           zsrc2(2,numsrc) = dzL(npl)
       endif
    endif
    ! Determine angle (sin/cos) of 'to' link (=first segment of polyline)
    if (npl > 1) then
       call normalin (xpl(npl-1), ypl(npl-1), xpl(npl), ypl(npl), cssrc(2,numsrc), snsrc(2,numsrc), xpl(NPL), ypl(NPL), jsferic, jasfer3D, dxymis)
    endif

    do i = 1,numsrc-1
       if (      ksrc(1,i) .ne. 0 .and. kk2 == ksrc(1,i) ) then
          write (msgbuf, '(4a)')  'TO point of ', trim (srcname(numsrc)),' coincides with FROM point of ', trim(srcname(i)) ;  call warn_flush()
       else if ( ksrc(4,i) .ne. 0 .and. kk2 == ksrc(4,i) ) then
          write (msgbuf, '(4a)')  'TO point of ', trim (srcname(numsrc)),' coincides with TO   point of ', trim(srcname(i)) ;  call warn_flush()
       endif
    enddo

 endif

8888 continue

 end subroutine addsorsin

 !> Compute and set source and sink values for the 'intake-outfall' structures.
 subroutine setsorsin()                                ! links in continuity eq.
 use m_flow
 use m_flowgeom
 use m_flowtimes
 use m_missing
 use m_transport, only: NUMCONST, ISALT, ITEMP, ISED1, ITRA1, constituents
 use MessageHandling
 use m_partitioninfo
 implicit none
 integer          :: n, ierr, kk, k, kb, kt, k2, kk2, kb2, kkk, ku, numvals, L
 double precision :: qsrck, qsrckk, dzss
 double precision :: frac=0.5d0           ! cell volume fraction that can at most be extracted in one step

 if (jatransportmodule == 0) then         ! also just prior to setsorsin
    salsrc = 0d0
 endif

 srsn = 0d0; vcsrc = 0d0
 do n  = 1,numsrc
    kk       = ksrc(1,n)                  ! 2D pressure cell nr, From side, 0 = out of all, -1 = in other domain, > 0, own domain
    kk2      = ksrc(4,n)                  ! 2D pressure cell nr, To   side, 0 = out of all, -1 = in other domain, > 0, own domain
    qsrc(n)  = qstss((1+numconst)*(n-1) + 1)
    if ( kk > 0) then                     ! FROM point
       if (kmx > 0) then
          call getkbotktop(kk,kb,kt)
          if (zsrc(1,n) == dmiss) then
             k = kb ; ku = kt
          else
             do k = kb, kt
                if ( zws(k) > zsrc(1,n) .or. k == kt ) then
                   exit
                endif
             enddo
             if (zsrc2(1,n) == dmiss) then
                ku = k
             else
                do ku = kb, kt
                   if ( zws(ku) > zsrc2(1,n) .or. ku == kt ) then
                      exit
                   endif
                enddo
             endif
          endif
       else
          k = kk ; kt = kk ; ku = kk      ! in 2D, volume cell nr = pressure cell nr
       endif
       ksrc(2,n) = k                      ! store kb of src
       ksrc(3,n) = ku                     !
       if (qsrc(n) > 0) then              ! Reduce if flux pos

          do k  = ksrc(2,n) , kt
             srsn(1,n) = srsn(1,n) + vol1(k)
             do L = 1,numconst
                srsn(1+L,n) = srsn(1+L,n) + constituents(L,k)*vol1(k)
             enddo
             ksrc(3,n) = k
             if ( frac*srsn(1,n) / dts > abs(qsrc(n)) ) then
                  exit
             endif
          enddo
          if ( srsn(1,n) > 0d0 ) then
             do L = 1,numconst
                srsn(1+L,n) = srsn(1+L,n) / srsn(1,n)
             enddo
          endif
          do k = ksrc(2,n), ksrc(3,n)
              if (jasal > 0) sa1(k)  = srsn(1+isalt,n)
              if (jatem > 0) constituents(itemp,k) = srsn(1+itemp,n)
              do L = 1,numconst
                 constituents(L,k) = srsn(L+1,n)
              enddo
          enddo

       endif
    endif

    if ( kk2 > 0 ) then                   ! TO point
       if (kmx > 0) then
          call getkbotktop(kk2,kb,kt)
          if (zsrc(2,n) == dmiss) then
             k = kb ; ku = kt
          else
             do k   = kb, kt
                if ( zws(k) > zsrc(2,n) .or. k == kt ) then
                   exit
                endif
             enddo
             if (zsrc2(2,n) == dmiss) then
                ku = k
             else
                do ku = kb, kt
                   if ( zws(ku) > zsrc2(2,n) .or. ku == kt ) then
                      exit
                   endif
                enddo
             endif
          endif
       else
          k = kk2 ; kt = kk2 ; ku = kk2    ! in 2D, volume cell nr = pressure cell nr
       endif
       ksrc(5,n) = k
       ksrc(6,n) = ku
       if ( qsrc(n) < 0 ) then            ! Reduce if flux neg

          do k  = ksrc(5,n) , kt
             srsn(1+numconst+1,n) = srsn(1+numconst+1,n) + vol1(k)
             do L = 1,numconst
                srsn(1+numconst+1+L,n) = srsn(1+numconst+1+L,n) + constituents(L,k)*vol1(k)
             enddo
             ksrc(6,n) = k
             if ( frac*srsn(1+numconst+1,n) / dts > abs(qsrc(n)) ) then
                  exit
             endif
          enddo
          if ( srsn(1+numconst+1,n) > 0d0) then
             do L = 1,numconst
                srsn(1+numconst+1+L,n) = srsn(1+numconst+1+L,n) / srsn(1+numconst+1,n)
             enddo
          endif
          do k = ksrc(5,n), ksrc(6,n)
             if (jasal > 0) sa1(k)  = srsn(1+numconst+1+isalt,n)
             if (jatem > 0) constituents(itemp,k) = srsn(1+numconst+1+itemp,n)
             do L = 1,numconst
                constituents(L,k) = srsn(1+numconst+1+L,n)
             enddo
          enddo

       endif
    endif

 enddo

 if (jampi > 0) then
     numvals = 2*(1+numconst)
     call reduce_srsn(numvals, numsrc, srsn)
 endif

 jamess = 0
 do n  = 1,numsrc
    qsrc (n) = qstss((numconst+1)*(n-1) + 1)
    do L = 1,numconst
       ccsrc(L,n) = qstss( (numconst+1)*(n-1) + L + 1)
    enddo

    kk     = ksrc(1,n)                      ! 2D pressure cell nr
    qsrck  = qsrc(n)
    if (kk .ne. 0 .and. qsrck > 0) then     ! Extract FROM 1
       if ( frac*srsn(1,n) / dts < abs(qsrck) ) then
           qsrck  = frac*srsn(1,n) / dts  ; jamess(n) = 1
       endif
    endif

    kk2 = ksrc(4,n)                         ! 2D pressure cell nr
    if (kk2 .ne. 0 .and. qsrck < 0) then    ! Extract From 2
       if ( frac*srsn(1+numconst+1,n) / dts < abs(qsrck) ) then
           qsrck = - frac*srsn(1+numconst+1,n) / dts ; jamess(n) = 2
       endif
    endif

    qsrc(n) = qsrck

    if (kk*kk2 .ne. 0) then             ! Coupled stuff
        if (qsrck     > 0) then         ! FROM k to k2
           do L = 1,numconst
              ccsrc(L,n) = ccsrc(L,n) + srsn(1+L,n)
           enddo
        else if  (qsrck  < 0) then      ! FROM k2 to k
           do L = 1,numconst
              ccsrc(L,n) = ccsrc(L,n) + srsn(1+numconst+1+L,n)
           enddo
        endif
    endif

    if (kk > 0) then                    ! FROM Point
       qsrckk  = qsrc(n)
       qin(kk) = qin(kk) - qsrckk       ! add to 2D pressure cell nr
       do k = ksrc(2,n), ksrc(3,n)
          if (kmx > 0) then
             dzss  = zws(ksrc(3,n)) - zws(ksrc(2,n)-1)
             if (dzss > epshs) then
                qsrck = qsrckk*( zws(k) - zws(k-1) ) / dzss
             else
                qsrck = qsrckk / (ksrc(3,n) - ksrc(2,n) + 1)
             endif
             qin(k)  = qin(k)  - qsrck
          endif
          if (jatransportmodule == 0) then
              if (qsrck > 0) then              ! FROM k to k2
                 if (jasal > 0) salsrc(k)  = salsrc (k) - qsrck*sa1 (k)
                 if (jatem > 0) heatsrc(k) = heatsrc(k) - qsrck*constituents(itemp,k)
              else if  (qsrck  < 0) then       ! FROM k2 to k
                 if (jasal > 0) salsrc(k)  = salsrc (k) - qsrck*sasrc(n)
                 if (jatem > 0) heatsrc(k) = heatsrc(k) - qsrck*tmsrc(n)
              endif
          endif
       enddo
    endif

    if (kk2 > 0) then                   ! TO Point
       qsrckk   = qsrc(n)
       qin(kk2) = qin(kk2) + qsrckk      ! add to 2D pressure cell nr
       do k = ksrc(5,n), ksrc(6,n)
          if (kmx > 0) then
             dzss  = zws(ksrc(6,n)) - zws(ksrc(5,n)-1)
             if (dzss > epshs) then
                qsrck = qsrckk*( zws(k) - zws(k-1) ) / dzss
             else
                qsrck = qsrckk / (ksrc(6,n) - ksrc(5,n) + 1)
             endif
             qin(k) = qin(k) + qsrck
          endif
          if (jatransportmodule == 0) then
             if (qsrck > 0) then
                if (jasal > 0) salsrc (k) = salsrc (k) + qsrck*sasrc(n)
                if (jatem > 0) heatsrc(k) = heatsrc(k) + qsrck*tmsrc(n)
             else if  (qsrck  < 0) then
                if (jasal > 0) salsrc (k) = salsrc (k) + qsrck*sa1 (k)
                if (jatem > 0) heatsrc(k) = heatsrc(k) + qsrck*constituents(itemp,k)
             endif
          endif
       enddo
    endif

 enddo

 if (wrwaqon) then ! Update waq output
    call update_waq_sink_source_fluxes()
 end if

 do n  = 1,numsrc
    if (jamess(n) == 1) then
        write(msgbuf, *) 'Extraction flux larger than cell volume at point 1 of : ', trim( srcname(n) )
        call mess(LEVEL_WARN, msgbuf)
     else if (jamess(n) == 2) then
        write(msgbuf, *) 'Extraction flux larger than cell volume at point 2 of : ', trim( srcname(n) )
        call mess(LEVEL_WARN, msgbuf)
    endif
 enddo

   end subroutine setsorsin


!> Update the cumulative waq sink source fluxes for the just set timestep.
!!
!! Should be called at the end of each computational timestep. In the waq-output, the cumulative values should be divided
!! by ti_waq, as the cumulative values are multiplied by each timestep dts (necessary because of non-constant timestep).
!!
!! The code uses similair ways to distribute discharges over layers as the calling subroutine setsorsin. Changes in the
!! calling subroutine should also be taken over in this routine!

subroutine update_waq_sink_source_fluxes()
use waq
use m_flow
use m_flowgeom
use m_flowtimes
implicit none

integer :: k, k1, k2, isrc, ip, ilaysin, ilaysor
integer :: kksin, kbsin, ktsin, kksor, kbsor, ktsor
integer :: kkksin, kkbsin, kktsin, kktxsin, kkksor, kkbsor, kktsor, kktxsor
real(8) :: dzss, qsrck, fsor, fsorlay
real(8), allocatable :: fsin(:)

do isrc = 1, numsrc
   if (ksrcwaq(isrc).ge.0) then
      ! If ksrcwaq < 0, then the sink source is not in the current domain
      if (waqpar%kmxnxa == 1) then
         ! 2D case
         ip = ksrcwaq(isrc) + 1
         if ( ip.gt.0 ) then
            qsrcwaq(ip) = qsrcwaq(ip) + dts*qsrc(isrc)
         end if
      else
         ! 3D case
         kksin = ksrc(1,isrc) ! 2D segment number of sink
         kbsin = ksrc(2,isrc) ! actual kbot of sink
         ktsin = ksrc(3,isrc) ! actual ktop of sink
         kksor = ksrc(4,isrc) ! 2D segment number of source
         kbsor = ksrc(5,isrc) ! actual kbot of source
         ktsor = ksrc(6,isrc) ! actual ktop source
         if(kksin==0.and.kksor/=0) then
            ! there is only a source side
            call getkbotktopmax(kksor,kkbsor,kktsor,kktxsor)
            dzss  = zws(ktsor) - zws(kbsor-1)
            do k = kbsor , ktsor
               if (dzss > epshs) then
                  qsrck = qsrc(isrc)*( zws(k) - zws(k-1) ) / dzss
               else
                  qsrck = qsrc(isrc)/( ktsor - kbsor + 1)
               endif
               ip = ksrcwaq(isrc) + waqpar%ilaggr(kktxsor - k + 1)
               qsrcwaq(ip) = qsrcwaq(ip) + dts*qsrck
            enddo
         else if (kksin/=0.and.kksor==0) then
            ! there is only a sink side (used?)
            call getkbotktopmax(kksin,kkbsin,kktsin,kktxsin)
            dzss  = zws(ktsin) - zws(kbsin-1)
            do k = kbsin , ktsin
               if (dzss > epshs) then
                  qsrck = qsrc(isrc)*( zws(k) - zws(k-1) ) / dzss
               else
                  qsrck = qsrc(isrc)/( ktsin - kbsin + 1)
               endif
               ip = ksrcwaq(isrc) + waqpar%ilaggr(kktxsin - k + 1)
               qsrcwaq(ip) = qsrcwaq(ip) + dts*qsrck
            enddo
         else if(kksin/=0.and.kksor/=0) then
            call getkbotktopmax(kksin,kkbsin,kktsin,kktxsin)
            call getkbotktopmax(kksor,kkbsor,kktsor,kktxsor)
            if(kbsin==ktsin) then
               ! sink side has only one layer
               dzss  = zws(ktsor) - zws(kbsor-1)
               do k = kbsor , ktsor
                  if (dzss > epshs) then
                     qsrck = qsrc(isrc)*( zws(k) - zws(k-1) ) / dzss
                  else
                     qsrck = qsrc(isrc)/( ktsor - kbsor + 1)
                  endif
                  ip = ksrcwaq(isrc) + waqpar%ilaggr(kktxsin - kbsin + 1) + waqpar%kmxnxa * (waqpar%ilaggr(kktxsor - k + 1) - 1)
                  qsrcwaq(ip) = qsrcwaq(ip) + dts*qsrck
               enddo
            else if(kbsor==ktsor) then
               ! sor side has only one layer
               dzss  = zws(ktsin) - zws(kbsin-1)
               do k = kbsin , ktsin
                  if (dzss > epshs) then
                     qsrck = qsrc(isrc)*( zws(k) - zws(k-1) ) / dzss
                  else
                     qsrck = qsrc(isrc)/( ktsin - kbsin + 1)
                  endif
                  ip = ksrcwaq(isrc) + waqpar%ilaggr(kktxsin - k + 1) + waqpar%kmxnxa * (waqpar%ilaggr(kktxsor - kbsor + 1) - 1)
                  qsrcwaq(ip) = qsrcwaq(ip) + dts*qsrck
               enddo
            else
               ! multiple layers on both side... it's a bit more complicated...
               ! determine fractions on sink side
               call realloc(fsin, kmx, keepExisting=.false., fill=0.0d0)
               dzss  = zws(ktsin) - zws(kbsin-1)
               do k = kbsin , ktsin
                  ilaysin = kktxsin - k + 1
                  if (dzss > epshs) then
                     fsin(ilaysin) = ( zws(k) - zws(k-1) ) / dzss
                  else
                     fsin(ilaysin) = 1.0d0 /( ktsin - kbsin + 1)
                  endif
               enddo
               ! distribute sink side fractions over source side
               do k1 = kbsor , ktsor
                  ilaysor = kktxsor - k1 + 1
                  dzss  = zws(ktsor) - zws(kbsor-1)
                  if (dzss > epshs) then
                     fsor = ( zws(k1) - zws(k1-1) ) / dzss
                  else
                     fsor = 1.0d0/( ktsor - kbsor + 1)
                  endif
                  do k2 = kbsin , ktsin
                     ilaysin = kktxsin - k2 + 1
                     fsorlay = min (fsin(ilaysin), fsor)
                     fsin(ilaysin) = fsin(ilaysin) - fsorlay
                     fsor = fsor - fsorlay
                     ip = ksrcwaq(isrc) + waqpar%ilaggr(ilaysin) + waqpar%kmxnxa * (waqpar%ilaggr(ilaysor) - 1)
                     qsrcwaq(ip) = qsrcwaq(ip) + dts*fsorlay*qsrc(isrc)
                  enddo
               enddo
            endif
         endif
      endif
   endif
enddo

end subroutine update_waq_sink_source_fluxes


subroutine reallocsrc(n)
 use m_transport, only: NUMCONST, ISALT, ITEMP, ISED1, ITRA1, itrac2const
 use m_flowexternalforcings
 use m_alloc
 use m_missing
 use m_polygon, only: npl
 implicit none
 integer :: n

 msrc = max(msrc, npl)
 call realloc (ksrc , (/ 6,n /), keepexisting=.true., fill=0 )
 call realloc (qsrc , n,         keepExisting = .true., fill=0d0)
 call realloc (tmsrc, n,         keepExisting = .true., fill=0d0)
 call realloc (sasrc, n,         keepExisting = .true., fill=0d0)
 call realloc (CCsrc,  (/ NUMCONST,n /), keepExisting = .true., fill=0d0)
 call realloc (arsrc, n,         keepExisting = .true., fill=0d0)
 call realloc (cssrc, (/ 2,n /), keepExisting = .true.)
 call realloc (snsrc, (/ 2,n /), keepExisting = .true.)
 call realloc (zsrc , (/ 2,n /), keepExisting = .true.)
 call realloc (zsrc2, (/ 2,n /), keepExisting = .true.) ; zsrc2 = dmiss
 ! call realloc (srsn , (/ 6,n /), keepExisting = .true.)
 call realloc (srsn , (/ 2*(NUMCONST+1),n /), keepExisting = .true.)
 call realloc (jamess, n,        keepExisting = .true.)
 call realloc (kdss , 3*n,       keepExisting = .true., fill=1)
 ! call realloc (qstss, 3*n,       keepExisting = .true., fill=0d0)
 call realloc (qstss, (NUMCONST+1)*n, keepExisting = .true., fill=0d0)
 call realloc (srcname, n,       keepExisting = .true., fill=' ')
 call realloc (xsrc , (/n, msrc/),keepExisting = .true., fill=dmiss)
 call realloc (ysrc , (/n, msrc/),keepExisting = .true., fill=dmiss)
 call realloc (nxsrc, n,          keepExisting = .true., fill=0)
 end subroutine reallocsrc

 subroutine u1q1()
 use m_flow                                          ! substitute u1 and q1
 use m_flowgeom
 use m_flowtimes
 use m_partitioninfo
 use m_timer
 use unstruc_channel_flow
 use m_1d_structures

 implicit none

 integer          :: L0, L, k1, k2, k01, k02, LL, k, n, nn, km, n1, n2, Ld, kb, kt, ks, Lb, Lt, kmxLL, ng, istru
 double precision :: qt, zws0k
 double precision :: accur = 1e-30, wb, ac1, ac2, dsL, sqiuh, qwb, qsigma
 double precision :: qwave
 type(t_structure), pointer :: pstru
 integer          :: ierror

 squ = 0d0 ; sqi = 0d0 ; qinbnd = 0d0 ; qoutbnd = 0d0
 ! u1  = 0d0 ; q1  = 0d0 ;  qa = 0d0

 if (kmx < 1) then ! original 2D coding              ! 1D2D

    if ( jampi.eq.0 ) then
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(L,k1,k2)
       do L = 1,lnx
          if (hu(L) > 0) then
             k1 = ln(1,L) ; k2 = ln(2,L)
             u1(L) = ru(L) - fu(L)*( s1(k2) - s1(k1) )
             q1(L) = au(L)*( teta(L)*u1(L) + (1d0-teta(L))*u0(L) )
             qa(L) = au(L)*u1(L)
          else
             call reset_fu_ru_for_structure_link(L, network%adm%lin2str, network%sts%struct)
             u1(L) = 0d0
             q1(L) = 0d0
             qa(L) = 0d0
          endif
       enddo
      !$OMP END PARALLEL DO
     else
!      parallel: compute u1, update u1, compute remaining variables

!      compute u1
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(L,k1,k2)
       do L=1,Lnx
          if ( hu(L).gt.0 ) then
             k1 = ln(1,L)
             k2 = ln(2,L)
             u1(L) = ru(L) - fu(L)*( s1(k2) - s1(k1) )
          else
             u1(L) = 0d0
          end if
       end do
      !$OMP END PARALLEL DO

!      update u1
       if ( jatimer.eq.1 ) call starttimer(IUPDU)
       call update_ghosts(ITYPE_U, 1, Lnx, u1, ierror)
       if ( jatimer.eq.1 ) call stoptimer(IUPDU)

!      compute q1 and qa
       !$OMP PARALLEL DO           &
       !$OMP PRIVATE(L,k1,k2)
       do L=1,Lnx
          if ( hu(L).gt.0 ) then
             k1 = ln(1,L)
             k2 = ln(2,L)
             q1(L) = au(L)*( teta(L)*u1(L) + (1d0-teta(L))*u0(L) )
             qa(L) = au(L)*u1(L)
          else
             q1(L) = 0d0
             qa(L) = 0d0
          end if
       end do
      !$OMP END PARALLEL DO
    end if  ! jampi

    if (jaqaisq1 == 1) then ! tetaad
       qa = q1
    endif

    do L = 1,lnx

       if (q1(L) > 0) then
          k1 = ln(1,L) ; k2 = ln(2,L)
          squ(k1) = squ(k1) + q1(L)
          sqi(k2) = sqi(k2) + q1(L)
       else if (q1(L) < 0) then
          k1 = ln(1,L) ; k2 = ln(2,L)
          squ(k2) = squ(k2) - q1(L)
          sqi(k1) = sqi(k1) - q1(L)
       endif

       if (ti_waq > 0d0) then
           q1waq(L) = q1waq(L) + q1(L)*dts
       endif

    enddo

    if (iadvec == 40) then
       voldhu = 0d0
       do L = 1,lnx

          if (q1(L) > 0) then
             k1 = ln(1,L)
             voldhu(k1) = voldhu(k1) + q1(L)*hu(L)
          else if (q1(L) < 0) then
             k2 = ln(2,L)
             voldhu(k2) = voldhu(k2) - q1(L)*hu(L)
          endif
       enddo

       do k = 1, ndxi
          if (squ(k) > 0d0) then
             voldhu(k) = ba(k)*voldhu(k) / squ(k)
          else
             voldhu(k) = vol1(k)
          endif
       enddo
       voldhu(ndxi+1:ndx) = vol1(ndxi+1:ndx)
    endif

    if (jaqin > 0) then
        do k = 1, ndxi
           if (qin(k) > 0d0) then
               sqi(k) = sqi(k) + qin(k)
           else
               squ(k) = squ(k) - qin(k)
           endif
        enddo
    endif

    if ( itstep.eq.4 ) then ! explicit time-step
       sqwave = 0d0
       do L=1,Lnx
          k1 = ln(1,L); k2 = ln(2,L)
          qwave = 2d0*sqrt(hu(L)*ag)*Au(L)   ! 2d0: safety
          sqwave(k1) = sqwave(k1) + max(q1(L)+qwave,0d0)
          sqwave(k2) = sqwave(k2) - min(q1(L)-qwave,0d0)
       end do
    end if

    do L = lnxi+1,lnx

       if ( jampi.ne.0 ) then
!         do not include boundaries in the ghost region
          if ( idomain(ln(2,L)).ne.my_rank ) then
             cycle
          end if
       end if

       if (q1(L) > 0) then
          qinbnd  = qinbnd  + q1(L)
       else
          qoutbnd = qoutbnd - q1(L)
       endif
    enddo


 else                                     ! 3D

    do LL = 1,lnx

       k1  = ln(1,LL) ; k2 = ln(2,LL)
       dsL = ( s1(k2) - s1(k1) )

       Lb  = Lbot(LL) ; Lt = Ltop(LL) ; kmxLL = kmxL(LL)
       if ( hu(LL) > 0d0 ) then

          do L = Lb, Lt
             u1(L) = ru(L) - fu(L)*dsL
          enddo

          do L = Lt+1, Lb + kmxLL - 1  ! copy top inactive part of column == utop
             u1(L) = u1(Lt)
          enddo

       else

          u1(Lb:Lb + kmxLL - 1) = 0d0

       endif

    enddo

    do ng = 1,ngatesg
       do n = L1gatesg(ng), L2gatesg(ng)
          L = kgate(3,n)
          do LL = Lbot(L), Lbot(L)+kmxL(L)-1
             if (au(LL) == 0) then
                u1(LL) = 0
             endif
          enddo
       enddo
    enddo

    do ng = 1, ncgensg      ! loop over generalstruc signals, sethu
       do n = L1cgensg(ng), L2cgensg(ng)
          L = kcgen(3,n)
          do LL = Lbot(L), Lbot(L)+kmxL(L)-1
             if (au(LL) == 0) then
                u1(LL) = 0
             endif
          enddo
       enddo
    enddo

    if ( jampi.eq.1 ) then
!      update u1
       if ( jatimer.eq.1 ) call starttimer(IUPDU)
!       call update_ghosts(ITYPE_U, 1, Lnx, u1, ierror)
       call update_ghosts(ITYPE_U3D, 1, Lnkx, u1, ierror)
       if ( jatimer.eq.1 ) call stoptimer(IUPDU)
    end if

    do LL = 1,lnx
       n1 = ln(1,LL) ; n2 = ln(2,LL)
       q1(LL) = 0d0  ; u1(LL) = 0d0 ; au(LL) = 0d0
       Lb = Lbot(LL) ; Lt = Ltop(LL)
       do L = Lb, Lt                       ! flux update after velocity update
          if (au(L) > 0d0) then
             q1(L)  = au(L)*( teta(LL)*u1(L) + (1d0-teta(LL))*u0(L) )
             qa(L)  = au(L)*u1(L)
             q1(LL) = q1(LL) + q1(L)       ! depth integrated result
             qa(LL) = qa(LL) + qa(L)       ! depth integrated result
             au(LL) = au(LL) + au(L)
             k1     = ln(1,L)
             k2     = ln(2,L)
             if (q1(L) > 0) then
                squ(k1) = squ(k1) + q1(L)
                sqi(k2) = sqi(k2) + q1(L)
                squ(n1) = squ(n1) + q1(L)
                sqi(n2) = sqi(n2) + q1(L)
             else
                sqi(k1) = sqi(k1) - q1(L)
                squ(k2) = squ(k2) - q1(L)
                sqi(n1) = sqi(n1) - q1(L)
                squ(n2) = squ(n2) - q1(L)
             endif
             if (ti_waq > 0d0) then
                q1waq(L) = q1waq(L) + q1(L)*dts
                if (layertype.ne.LAYTP_SIGMA) then
!                  check for differences with original linkage in cases other than sigma models
                   k01 = ln0(1,L) ; k02 = ln0(2,L)
                   if (k01.ne.k1.or.k02.ne.k2) then
                      if (k01.ne.k1) then
!                        diferences in from node, positive extra discharges in the vertical
                         do k=k1,k01-1
                             qwwaq(k) = qwwaq(k) + q1(L)*dts
                         enddo
                      endif
                      if (k02.ne.k2) then
!                        diferences in to node, negative extra discharges in the vertical
                         do k=k2,k02-1
                             qwwaq(k) = qwwaq(k) - q1(L)*dts
                         enddo
                      endif
                   end if
                end if
             endif
          else
             q1(L)  = 0d0
             qa(L)  = 0d0
          endif
       enddo
       if (au(LL) > 0d0 ) then          ! depth averaged velocity
          u1(LL) = q1(LL) / au(LL)
       else
          u1(LL) = 0d0
          q1(LL) = 0d0
          qa(LL) = 0d0
       endif

    enddo

    if (ja_timestep_auto == 3 .or. ja_timestep_auto == 4) then      ! 2D timestep
       squ2d = squ
       if (ja_timestep_auto == 4) then
           squ2d = squ2d + sqi
       endif
    endif

    do LL = Lnxi+1, Lnx

       if ( jampi.ne.0 ) then
!         do not include boundaries in the ghost region
          if ( idomain(ln(2,LL)).ne.my_rank ) then
             cycle
          end if
       end if

       if (q1(LL) > 0) then
           qinbnd  = qinbnd  + q1(LL)
       else
           qoutbnd = qoutbnd - q1(LL)
       endif
    enddo

    do nn = ndxi,1,-1                                   ! close vertical fluxes
       kb = kbot(nn)
       kt = ktop(nn)


       if (a1(nn) > 0) then
          do k  = kb, kb + kmxn(nn) - 1

             if ( k <= kt ) then

                if (jaqin > 0) then
                   if (qin(k) > 0d0) then
                       sqi(k) = sqi(k) + qin(k)
                   else
                       squ(k) = squ(k) - qin(k)
                   endif
                endif

                km = k-1
                if (k == kb) then
                   wb  = 0d0     ; qwb = 0d0
                else
                   wb  = ww1(km) ; qwb = qw(km)
                endif

                sqiuh  = sqi(k) - squ(k)
                qw (k) = qwb + sqiuh
                ww1(k) = wb  + sqiuh / a1(nn)

!               BEGIN DEBUG
!                ww1(k) = min(max(ww1(k),-1d0), 1d0)
!                qw(k)  = ww1(k) * a1(nn)
!               END DEBUG
             else
                qw(k)  = 0d0
                ww1(k) = 0d0
             endif
          enddo
       else
          qw (kb:kt) = 0d0
          ww1(kb:kt) = 0d0
       endif
       do k = kb, kt
          if (k == kt) then
             zws0k = zws0(ktop0(nn))
          else
             zws0k = zws0(k)
          endif
          qsigma  = a1(nn)*(zws(k) - zws0k)/dts

          qw(k)   = qw(k) - qsigma

          if (ti_waq > 0) then
             qwwaq(k) = qwwaq(k) + qw(k)*dts
          endif

          if (qw(k) > 0) then
              squ(k)   = squ(k)      + qw(k)
              if (k < kt) then
                 sqi(k+1) = sqi(k+1) + qw(k)
              endif
          else
              sqi(k)   = sqi(k)      - qw(k)
              if (k < kt) then
                 squ(k+1) = squ(k+1) - qw(k)
              endif
          endif

       enddo

    enddo

 endif

 sq = sqi-squ                                        ! arrays, later put in loop anyway

 ! u1q1 for flow1d structures on links
 do istru=1,network%sts%count
    pstru => network%sts%struct(istru)
    do L0=1,pstru%numlinks
       L = pstru%linknumbers(L0)
       k1 = ln(1,L)
       k2 = ln(2,L)
       if (hu(L) > 0) then
          call set_u1q1_structure(pstru, L0, s1(k1), s1(k2), teta(L))
       else
          pstru%u1(L0) = 0d0
       end if
    end do
 end do

 end subroutine u1q1

 subroutine a1vol1tot()
 use m_flowgeom
 use m_flow
 use m_partitioninfo
 use m_flowtimes
 use precision_basics
 implicit none

 double precision, dimension(1) :: dum

 integer :: k

 if ( jampi.ne.1 ) then
    a1tot     = sum(a1  (1:ndxi))
    vol1tot   = sum(vol1(1:ndxi))
 else
    a1tot  = 0d0
    vol1tot = 0d0

    do k=1,Ndxi
       if ( idomain(k).eq.my_rank ) then
          a1tot   = a1tot + a1(k)
          vol1tot = vol1tot + vol1(k)
       end if
    end do

    !a1tot     = sum(a1  (1:ndxi), mask=idomain(1:Ndxi).eq.my_rank)
    !vol1tot   = sum(vol1(1:ndxi), mask=idomain(1:Ndxi).eq.my_rank)

!   begin debug
!    call reduce_double_sum(vol1tot)
!   end debug
 end if

 if (jagrw > 0) then
    if (volgrw > 0 .and. volgrwini <= 0) then
       volgrwini = volgrw
    endif
 endif

 if (comparereal(time1, tstart_user, eps10)== 0) then
    volcur(IDX_VOLTOT) = vol1tot
    volcur(IDX_STOR)   = vol1tot
    vol1ini = vol1tot
!   vol1ini needs to be global
    if ( jampi.eq.1 ) then
       call reduce_double_sum(1, (/ vol1ini /), dum)
       vol1ini = dum(1)
    end if
 endif

! begin debug
!  if ( my_rank.eq.0 ) write(6,*) 'vol1tot =', vol1tot
! end debug

 end subroutine a1vol1tot

 subroutine flow_f0isf1()                            ! Todo: make pointer stucture and reset pointers
 use m_flowgeom
 use m_flow
 use m_flowtimes
 use m_partitioninfo
 use m_sediment
 use m_strucs
 use m_sobekdfm , only: nbnd1d2d, kbnd1d2d

 implicit none

 integer :: ierror, k,kk,kb,kt, Lf, i, k1, k2,ll
 integer :: ndraw
 COMMON /DRAWTHIS/ ndraw(50)


 call a1vol1tot()

    ! TODO: UNST-904: sum only across *own* cells
    !           if ( idomain(n).ne.my_rank ) cycle
    ! UNST-904: AND, create some reduce_bal() subroutine



 hsaver    = 0d0
 if (a1tot .ne. 0) then
    hsaver = vol1tot / a1tot
 endif


 ! basis spul
 vinbnd      = qinbnd  *dts  ! do *dts here to avoid inconsistencies
 voutbnd     = qoutbnd *dts
 vincel      = qincel  *dts  ! do *dts here to avoid inconsistencies
 voutcel     = qoutcel *dts
 !volerr      = vol1tot - vol0tot - vinbnd + voutbnd - vincel + voutcel

 vinbndcum   = vinbndcum    + vinbnd
 voutbndcum  = voutbndcum   + voutbnd
 vincelcum   = vincelcum    + vincel
 voutcelcum  = voutcelcum   + voutcel


 if (jamorf == 1 .and. .not. stm_included) then
    !volerrcum = volerrcum + dvolbot
 endif

 !if (stm_included) then
 !   dvolbot = 0d0
 !   do ll=1,stmpar%lsedtot
 !      dvolbot = dvolbot + sum(sedtra%dbodsd(ll,:)/stmpar%sedpar%cdryb(ll)*ba)
 !   enddo
 !   !volerrcum = volerrcum + dvolbot
 !end if
 volerr      = vol1tot - vol0tot - vinbnd + voutbnd - vincel + voutcel !+ dvolbot
 volerrcum   = volerrcum    + volerr

if (jahisbal > 0) then
    ! extra
    vinrain     = qinrain *dts
    vouteva     = qouteva *dts
    vinlat      = qinlat  *dts
    voutlat     = qoutlat *dts
    vingrw      = qingrw  *dts
    voutgrw     = qoutgrw *dts

    qinsrc  = 0d0
    qoutsrc = 0d0
    do i = 1,numsrc
       if ( qsrc(i).gt.0d0) then
          k1 = ksrc(1,i)
          k2 = ksrc(4,i)
       else
          k1 = ksrc(4,i)
          k2 = ksrc(1,i)
       end if

       if ( k1.gt.0 ) then
          qoutsrc = qoutsrc + abs(qsrc(i))
       end if
       if ( k2.gt.0 ) then
          qinsrc = qinsrc + abs(qsrc(i))
       end if
    enddo

    vinsrc  = qinsrc  * dts
    voutsrc = qoutsrc * dts

    ! Time-summed cumulative volumes (nowhere used)
    vinraincum  = vinraincum   + vinrain
    voutevacum  = voutevacum   + vouteva
    vinlatcum   = vinlatcum    + vinlat
    voutlatcum  = voutlatcum   + voutlat
    vingrwcum   = vingrwcum    + vingrw
    voutgrwcum  = voutgrwcum   + voutgrw
    vinsrccum   = vinsrccum    + vinsrc
    voutsrccum  = voutsrccum   + voutsrc

    ! Volume totals at current time (for his output)
    volcur(IDX_STOR  ) = vol1tot
    volcur(IDX_VOLTOT)  = vol1tot
    volcur(IDX_VOLERR)  = volerr
    volcur(IDX_BNDIN )  = vinbnd
    volcur(IDX_BNDOUT)  = voutbnd
    volcur(IDX_BNDTOT)  = (vinbnd - voutbnd)
    volcur(IDX_EXCHIN ) = 0d0
    volcur(IDX_EXCHOUT) = 0d0
    volcur(IDX_EXCHTOT) = 0d0
    do i = 1,nbnd1d2d
      Lf = kbnd1d2d(3,i)
      volcur(IDX_EXCHTOT) = volcur(IDX_EXCHTOT) + q1(Lf)*dts
      if (q1(Lf) > 0) then
         volcur(IDX_EXCHIN) = volcur(IDX_EXCHIN) + q1(Lf)*dts
      else
         volcur(IDX_EXCHOUT) = volcur(IDX_EXCHOUT) - q1(Lf)*dts
      endif
    end do
    volcur(IDX_PRECIP) = vinrain
    volcur(IDX_EVAP)   = vouteva
    volcur(IDX_SOUR  ) = vinsrc - voutsrc

    if ( jaFrcInternalTides2D.eq.1 ) then
       volcur(IDX_InternalTidesDIssipation) = DissInternalTides*dts
    else
       volcur(IDX_InternalTidesDIssipation) = 0d0
    end if

    if ( jatidep.eq.1 .or. jaselfal.gt.0 ) then
       volcur(IDX_GravInput) = GravInput*dts
    else
       volcur(IDX_GravInput) = 0d0
    end if

    if ( jaselfal.gt.0 ) then
       volcur(IDX_SALInput)  = SALInput *dts
       volcur(IDX_SALInput2) = SALInput2*dts
    else
       volcur(IDX_SALInput)  = 0d0
       volcur(IDX_SALInput2) = 0d0
    end if
    volcur(IDX_GRWIN )  = vingrw
    volcur(IDX_GRWOUT)  = voutgrw
    volcur(IDX_GRWTOT)  = (vingrw - voutgrw)

    volcur(IDX_LATIN )  = vinlat
    volcur(IDX_LATOUT)  = voutlat
    volcur(IDX_LATTOT)  = (vinlat - voutlat)

   ! cumulate
    cumvolcur = cumvolcur + volcur
 end if

 if (NDRAW(28) == 34) then ! Display values at flow nodes: volerror
    if (kmx == 0) then
       do kk = 1,ndxi
          if ( jampi == 1) then
             if (idomain(kk).ne.my_rank ) cycle
          end if
          volerror(kk) = vol1(kk) - vol0(kk) - dts*(sqi(kk) - squ(kk))           ! array transfer
       enddo
    else
       do kk = 1,ndxi
          if ( jampi == 1) then
             if (idomain(kk).ne.my_rank ) cycle
          end if

          call getkbotktop(kk,kb,kt)
          do k = kb,kt
             volerror(k) = vol1(k) - vol0(k) - dts*(sqi(k) - squ(k))
          enddo
       enddo
    endif
 end if

 vol0    = vol1                                      ! array

 vol0tot = vol1tot                                   ! scalar
 a0tot   = a1tot


 end subroutine flow_f0isf1




! =================================================================================================
! =================================================================================================
   subroutine structure_parameters
      use m_flowgeom , only : ln, wu, bob
      use m_flow
      use m_structures
      use m_flowexternalforcings, only: ngenstru
      use m_partitioninfo
      use m_flowtimes
      use m_missing, only: dmiss
      use unstruc_channel_flow, only: network
      use m_1d_structures
      use m_compound
      implicit none
      integer                       :: i, n, L, Lf, La, ierr, ntmp, k, ku, kd, istru, nlinks
      double precision              :: dir
      integer                       :: jaghost, idmn_ghost
      double precision, save        :: timprev = -1d0
      double precision              :: timstep
      type(t_structure), pointer    :: pstru
      type(t_compound),  pointer    :: pcmp

      if (jampi > 0) then
         if( .not.allocated( reducebuf ) ) then
            nreducebuf = npumpsg*NUMVALS_PUMP + ngatesg*NUMVALS_GATE + ncdamsg*NUMVALS_CDAM + ncgensg*NUMVALS_CGEN &
                       + ngategen*NUMVALS_GATEGEN + nweirgen*NUMVALS_WEIRGEN + ngenstru*NUMVALS_GENSTRU + ngenstru*NUMVALS_GENSTRU &
                       + ndambreaksg * NUMVALS_DAMBREAK
            allocate ( reducebuf  ( nreducebuf ) , stat = ierr      )
            call aerr('reducebuf  ( nreducebuf )', ierr, nreducebuf ) ; reducebuf  = 0d0
         endif
      endif

      if (ti_his <= 0) return
      ! in order to compute the cumulative discharge, we have to compute the time step (see update updateValuesOnCrossSections)
      if (timprev == -1d0) then
        timstep  = 0d0
      else
        timstep  = time1 - timprev
      end if
      !
      ! === Pumps
      !
      if (allocated(valpump)) then
         do n = 1,npumpsg
            valpump(1:5,n) = 0d0
            valpump(6:NUMVALS_PUMP,n) = dmiss
            if (allocated(pumpsWithLevels)) then
               istru = pumpsWithLevels(n)
            else
               istru = -1
            end if
         
            do L = L1pumpsg(n),L2pumpsg(n)
               Lf = kpump(3,L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = 1d0
               if( Ln(1,La) /= kpump(1,L) ) then
                  dir = -1d0
               end if
               call fill_valstruct_perlink(valpump(:,n), La, dir, ST_PUMP, istru, L-L1pumpsg(n)+1)
            enddo
            call average_valstruct(valpump(:,n), ST_UNSET, 0, 0, 0) ! TODO: UNST-2705: move code above and below to valstruct routines.
            if (istru > 0) then ! TODO: UNST-2587: once all pump code is done, remove this temp IF.
            pstru => network%sts%struct(istru)
            valpump(6,n) = GetPumpCapacity(pstru)
            valpump(12,n) = sign(1,pstru%pump%direction) * valpump(2,n) ! Discharge w.r.t. pump direction (same sign as capacity)
            valpump(7,n) = GetPumpStage(pstru)
            if (valpump(7,n) < 0d0) then
               valpump(7,n) = dmiss ! Set to fill value if stage is irrelevant.
            end if
            valpump(10,n) = getPumpDsLevel(pstru)
            valpump(11,n) = getPumpSsLevel(pstru)
            valpump(8,n) = valpump(10,n) - valpump(11,n) ! Pump head
            valpump(9,n) = GetPumpReductionFactor(pstru)
            end if
         enddo
      end if
      !
      ! === Gates
      !
      if (allocated(valgate)) then
         do n = 1,ngatesg
            valgate(:,n) = 0d0
            do L = L1gatesg(n), L2gatesg(n)
               Lf = kgate(3,L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = 1d0
               ku = ln(1,La)
               kd = ln(2,La)
               if( Ln(1,La) /= kgate(1,L) ) then
                  dir = -1d0
                  ku = ln(2,La)
                  kd = ln(1,La)
               end if
               valgate(1,n) = valgate(1,n) + wu(La)
               valgate(2,n) = valgate(2,n) + q1(La) * dir
               valgate(3,n) = valgate(3,n) + s1(ku) * wu(La)
               valgate(4,n) = valgate(4,n) + s1(kd) * wu(La)
            enddo
            if( jampi == 0 ) then
               if( valgate(1,n) == 0d0 ) then
                  valgate(2,n) = dmiss
                  valgate(3,n) = dmiss
                  valgate(4,n) = dmiss
               else
                  valgate(3,n) = valgate(3,n) / valgate(1,n)
                  valgate(4,n) = valgate(4,n) / valgate(1,n)
               endif
            endif
         enddo
      end if
      !
      ! === Dams
      !
      if (allocated(valcdam)) then
         do n = 1,ncdamsg
            valcdam(:,n) = 0d0
            do L = L1cdamsg(n), L2cdamsg(n)
               Lf = kcdam(3,L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = 1d0
               ku = ln(1,La)
               kd = ln(2,La)
               if( Ln(1,La) /= kcdam(1,L) ) then
                  dir = -1d0
                  ku = ln(2,La)
                  kd = ln(1,La)
               end if
               valcdam(1,n) = valcdam(1,n) + wu(La)
               valcdam(2,n) = valcdam(2,n) + q1(La) * dir
               valcdam(3,n) = valcdam(3,n) + s1(ku) * wu(La)
               valcdam(4,n) = valcdam(4,n) + s1(kd) * wu(La)
            enddo
            if( jampi == 0 ) then
               if( valcdam(1,n) == 0d0 ) then
                  valcdam(2,n) = dmiss
                  valcdam(3,n) = dmiss
                  valcdam(4,n) = dmiss
               else
                  valcdam(3,n) = valcdam(3,n) / valcdam(1,n)
                  valcdam(4,n) = valcdam(4,n) / valcdam(1,n)
               endif
            endif
         enddo
      end if
      !
      ! === General structures (from old ext file)
      !
      if (allocated(valcgen)) then
         do n = 1,ncgensg
            i = n
            valcgen(:,n) = 0d0
            do L = L1cgensg(i),L2cgensg(i)
               Lf = kcgen(3,L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = 1d0
               ku = ln(1,La)
               kd = ln(2,La)
               if( Ln(1,La) /= kcgen(1,L) ) then
                  dir = -1d0
                  ku = ln(2,La)
                  kd = ln(1,La)
               end if
               valcgen(1,n) = valcgen(1,n) + wu(La)
               valcgen(2,n) = valcgen(2,n) + q1(La) * dir
               valcgen(3,n) = valcgen(3,n) + s1(ku) * wu(La)
               valcgen(4,n) = valcgen(4,n) + s1(kd) * wu(La)
            enddo
            if( jampi == 0 ) then
               if( valcgen(1,n) == 0d0 ) then
                  valcgen(2,n) = dmiss
                  valcgen(3,n) = dmiss
                  valcgen(4,n) = dmiss
               else
                  valcgen(3,n) = valcgen(3,n) / valcgen(1,n)
                  valcgen(4,n) = valcgen(4,n) / valcgen(1,n)
               endif
            endif
         enddo
      end if
      !
      ! === Gates (new)
      !
      if (allocated(valgategen)) then
         do n = 1,ngategen
            i = gate2cgen(n)
            valgategen(:,n) = 0d0
            do L = L1cgensg(i), L2cgensg(i)
               Lf = kcgen(3,L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = 1d0
               ku = ln(1,La)
               kd = ln(2,La)
               if( Ln(1,La) /= kcgen(1,L) ) then
                  dir = -1d0
                  ku = ln(2,La)
                  kd = ln(1,La)
               end if
               valgategen(1,n) = valgategen(1,n) + wu(La)
               valgategen(2,n) = valgategen(2,n) + q1(La) * dir
               valgategen(3,n) = valgategen(3,n) + s1(ku) * wu(La)
               valgategen(4,n) = valgategen(4,n) + s1(kd) * wu(La)
               k = kcgen(1,L) ; if( q1(La) < 0d0 ) k = kcgen(2,L)
               valgategen(5,n) = valgategen(5,n) + s1(k) * wu(La)
            enddo
            if (L1cgensg(i) <= L2cgensg(i)) then ! At least one flow link in this domain is affected by this structure.
               valgategen(6,n) = 1               ! rank contains the gate.
               valgategen(7,n) = zcgen(3*i  )    ! id_gategen_openw.
               valgategen(8,n) = zcgen(3*i-1)    ! id_gategen_edgel.
               valgategen(9,n) = zcgen(3*i-2)    ! id_gategen_sillh.
            end if
            if( jampi == 0 ) then
               if( valgategen(1,n) == 0d0 ) then
                  valgategen(2,n) = dmiss
                  valgategen(3,n) = dmiss
                  valgategen(4,n) = dmiss
                  valgategen(5,n) = dmiss
               else
                  valgategen(3,n) = valgategen(3,n) / valgategen(1,n)
                  valgategen(4,n) = valgategen(4,n) / valgategen(1,n)
                  valgategen(5,n) = min( zcgen(3*i-1)-zcgen(3*i-2), valgategen(5,n)/valgategen(1,n)-zcgen(3*i-2) )
               endif
            endif
         enddo
      end if
      !
      ! === Weirs
      !
      if (allocated(valweirgen)) then
         if (network%sts%numWeirs > 0) then ! new weir
            do n = 1, nweirgen
               valweirgen(1:NUMVALS_WEIRGEN,n) = 0d0
               istru = network%sts%weirIndices(n)
               pstru => network%sts%struct(istru)
               nlinks = pstru%numlinks
               do L = 1, nlinks
                  Lf = pstru%linknumbers(L)
                  La = abs( Lf )
                  if( jampi > 0 ) then
                     call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                     if ( jaghost.eq.1 ) cycle
                  endif
                  dir = sign(1d0,dble(Lf))
                  call fill_valstruct_perlink(valweirgen(:,n), La, dir, ST_WEIR, istru, L)
               enddo
               call average_valstruct(valweirgen(:,n), ST_WEIR, istru, nlinks, NUMVALS_WEIRGEN)
            enddo
         else
            ! old weir, do not compute the new extra fileds
            do n = 1, nweirgen
               i = weir2cgen(n)
               valweirgen(1:NUMVALS_WEIRGEN,n) = 0d0
               do L = L1cgensg(i),L2cgensg(i)
                  Lf = kcgen(3,L)
                  La = abs( Lf )
                  if( jampi > 0 ) then
                     call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                     if ( jaghost.eq.1 ) cycle
                  endif
                  dir = 1d0
                  if( Ln(1,La) /= kcgen(1,L) ) then
                     dir = -1d0
                  end if
                  call fill_valstruct_perlink(valweirgen(:,n), La, dir, ST_UNSET, 0, 0)
               enddo
               call average_valstruct(valweirgen(:,n), ST_UNSET, 0, 0, 0)
               if (L1cgensg(i) <= L2cgensg(i)) then  ! At least one flow link in this domain is affected by this structure.
                  valweirgen(NUMVALS_WEIRGEN,n) = 1  ! rank contains the weir.
                  valweirgen(10,n) = zcgen(3*i  )    ! id_weirgen_crestw.
                  valweirgen(9,n) = zcgen(3*i-2)     ! id_weirgen_cresth.
               end if
            enddo
         end if
      end if

      !
      ! === Orifice
      !
      if (allocated(valorifgen)) then
         do n = 1, network%sts%numOrifices
            valorifgen(1:NUMVALS_ORIFGEN,n) = 0d0
            istru = network%sts%orificeIndices(n)
            pstru => network%sts%struct(istru)
            nlinks = pstru%numlinks
            do L = 1, nlinks
               Lf = pstru%linknumbers(L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = sign(1d0,dble(Lf))
               call fill_valstruct_perlink(valorifgen(:,n), La, dir, ST_ORIFICE, istru, L)
            enddo
            call average_valstruct(valorifgen(:,n), ST_ORIFICE, istru, nlinks, NUMVALS_ORIFGEN)
         enddo
      end if

      !
      ! === Bridge
      !
      if (allocated(valbridge)) then
         do n = 1, network%sts%numBridges
            valbridge(1:NUMVALS_BRIDGE,n) = 0d0
            istru = network%sts%bridgeIndices(n)
            pstru => network%sts%struct(istru)
            nlinks = pstru%numlinks
            do L = 1, nlinks ! Currently bridges have always only 1 link.
               Lf = pstru%linknumbers(L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = sign(1d0,dble(Lf))
               call fill_valstruct_perlink(valbridge(:,n), La, dir, ST_BRIDGE, istru, L)
            enddo
            call average_valstruct(valbridge(:,n), ST_BRIDGE, istru, nlinks, NUMVALS_BRIDGE)
         enddo
      end if

      !
      ! === Culvert
      !
      if (allocated(valculvert)) then
         do n = 1, network%sts%numCulverts
            valculvert(1:NUMVALS_CULVERT,n) = 0d0
            istru = network%sts%culvertIndices(n)
            pstru => network%sts%struct(istru)
            nlinks = pstru%numlinks
            do L = 1, nlinks
               Lf = pstru%linknumbers(L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = sign(1d0,dble(Lf))
               call fill_valstruct_perlink(valculvert(:,n), La, dir, ST_CULVERT, istru, L)
            enddo
            call average_valstruct(valculvert(:,n), ST_CULVERT, istru, nlinks, NUMVALS_CULVERT) ! TODO: UNST-2719: move code aboe/below to valstruc* routines
            if (valculvert(1,n) == 0) then
               valculvert(8:NUMVALS_CULVERT,n) = dmiss
            else
               valculvert(8,n) = get_crest_level(pstru)
               valculvert(9,n) = dble(get_culvert_state(pstru))
               valculvert(10,n) = get_gle(pstru)
               valculvert(11,n) = get_opening_height(pstru)
            end if
         enddo
      end if

      !
      ! === Universal weir
      !
      if (allocated(valuniweir)) then
         do n = 1, network%sts%numuniweirs
            valuniweir(1:NUMVALS_UNIWEIR,n) = 0d0
            istru = network%sts%uniweirIndices(n)
            pstru => network%sts%struct(istru)
            nlinks = pstru%numlinks
            do L = 1, nlinks
               Lf = pstru%linknumbers(L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = sign(1d0,dble(Lf))
               call fill_valstruct_perlink(valuniweir(:,n), La, dir, ST_UNI_WEIR, istru, L)
            enddo
            call average_valstruct(valuniweir(:,n), ST_UNI_WEIR, istru, nlinks, NUMVALS_UNIWEIR)
            if (valuniweir(1,n) == 0) then
               valuniweir(8:NUMVALS_UNIWEIR,n) = dmiss
            else
               valuniweir(8,n) = get_crest_level(pstru)
            end if
         enddo
      end if

      !
      ! == dambreak
      !
      if (allocated(valdambreak)) then
         do n = 1, ndambreaksg
            ! valdambreak(NUMVALS_DAMBREAK,n) is the cumulative over time, we do not reset it to 0
            valdambreak(1:NUMVALS_DAMBREAK-1,n) = 0d0
            istru = dambreaks(n)
            do L = L1dambreaksg(n),L2dambreaksg(n)
               if (activeDambreakLinks(L) /= 1) then
                  cycle
               end if
         
               Lf = kdambreak(3,L)
               La = abs( Lf )
               if( jampi > 0 ) then
                  call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                  if ( jaghost.eq.1 ) cycle
               endif
               dir = 1d0
               if( Ln(1,La) /= kdambreak(1,L) ) then
                  dir = -1d0
               end if
               valdambreak(1,n) = valdambreak(1,n) + wu(La)
               valdambreak(2,n) = valdambreak(2,n) + q1(La)*dir
               valdambreak(6,n) = valdambreak(6,n) + au(La) ! flow area
               valdambreak(9,n) = valdambreak(9,n) + wu(La)
            enddo
            valdambreak(3,n)  = waterLevelsDambreakUpStream(n)
            valdambreak(4,n)  = waterLevelsDambreakDownStream(n)
            valdambreak(5,n)  = valdambreak(3,n) - valdambreak(4,n)
            valdambreak(7,n)  = normalVelocityDambreak(n)
            if (network%sts%struct(istru)%dambreak%width > 0d0) then
               valdambreak(8,n) = network%sts%struct(istru)%dambreak%crl ! crest level
            else
               La = abs(kdambreak(3,LStartBreach(n)))
               valdambreak(8,n) = bob(1,La)                              ! No breach started yet, use bob as 'crest'.
            end if
            valdambreak(10,n) = waterLevelJumpDambreak(n)
            valdambreak(11,n) = breachWidthDerivativeDambreak(n)
            valdambreak(12,n) = valdambreak(12,n) + valdambreak(2,n) * timstep ! cumulative discharge
         enddo
      end if
      !
      ! === General structures (from new ext file)
      !
      if (allocated(valgenstru)) then
         if (network%sts%numGeneralStructures > 0) then
            do n = 1, ngenstru
               valgenstru(1:NUMVALS_GENSTRU,n) = 0d0
               istru = network%sts%generalStructureIndices(n)
               pstru => network%sts%struct(istru)
               nlinks = pstru%numlinks
               do L = 1, nlinks
                  Lf = pstru%linknumbers(L)
                  La = abs( Lf )
                  if( jampi > 0 ) then
                     call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                     if ( jaghost.eq.1 ) cycle
                  endif
                  dir = sign(1d0,dble(Lf))
                  call fill_valstruct_perlink(valgenstru(:,n), La, dir, ST_GENERAL_ST, istru, L)
               enddo
               call average_valstruct(valgenstru(:,n), ST_GENERAL_ST, istru, nlinks, NUMVALS_GENSTRU)
            enddo
         else
            ! old general structure, do not compute the new extra fileds
            do n = 1,ngenstru
               i = genstru2cgen(n)
               valgenstru(1:NUMVALS_GENSTRU,n) = 0d0
               do L = L1cgensg(i),L2cgensg(i)
                  Lf = kcgen(3,L)
                  La = abs( Lf )
                  if( jampi > 0 ) then
                     call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                     if ( jaghost.eq.1 ) cycle
                  endif
                  dir = 1d0
                  if( Ln(1,La) /= kcgen(1,L) ) then
                     dir = -1d0
                  end if
                 call fill_valstruct_perlink(valgenstru(:,n), La, dir, ST_UNSET, 0, 0)
               enddo
               call average_valstruct(valgenstru(:,n), ST_UNSET, 0, 0, 0)
               if (L1cgensg(i) <= L2cgensg(i)) then  ! At least one flow link in this domain is affected by this structure.
                  valgenstru(NUMVALS_GENSTRU,n) = 1  ! rank contains the general structure.
                  valgenstru(13,n) = zcgen(3*i  )    ! id_genstru_openw.
                  valgenstru(14,n) = zcgen(3*i-1)    ! id_genstru_edgel.
                  valgenstru(9,n)  = zcgen(3*i-2)    ! id_genstru_cresth.
               end if
            enddo
         end if
      end if

      !
      ! === compound structure
      !
      if (allocated(valcmpstru)) then
         if (network%cmps%count > 0) then
            do n = 1, network%cmps%count
               valcmpstru(1:NUMVALS_CMPSTRU,n) = 0d0
               pcmp => network%cmps%compound(n)
               nlinks = pcmp%numlinks
               do L = 1, nlinks
                  Lf = pcmp%linknumbers(L)
                  La = abs( Lf )
                  if( jampi > 0 ) then
                     call link_ghostdata(my_rank,idomain(ln(1,La)), idomain(ln(2,La)), jaghost, idmn_ghost)
                     if ( jaghost.eq.1 ) cycle
                  endif
                  dir = sign(1d0,dble(Lf))
                  call fill_valstruct_perlink(valcmpstru(:,n), La, dir, ST_COMPOUND, 0, L)
               enddo
               call average_valstruct(valcmpstru(:,n), ST_COMPOUND, 0, nlinks, NUMVALS_CMPSTRU)
            enddo
         end if
      end if
      !
      ! === Reduction of structur parameters for parallel
      !
      if( jampi > 0 .and. ti_his > 0 ) then
         nreducebuf = 0
         reducebuf  = 0d0
         n = 0
         if( npumpsg > 0 .and. allocated(valpump) ) then
            call fill_reduce_buffer( valpump   , npumpsg*NUMVALS_PUMP     )
            n = 1
         endif
         if( ngatesg > 0 .and. allocated(valgate) ) then
            call fill_reduce_buffer( valgate   , ngatesg*NUMVALS_GATE     )
            n = 1
         endif
         if( ncdamsg > 0 .and. allocated(valcdam) ) then
            call fill_reduce_buffer( valcdam   , ncdamsg*NUMVALS_CDAM     )
            n = 1
         endif
         if( ncgensg > 0 .and. allocated(valcgen) ) then
            call fill_reduce_buffer( valcgen   , ncgensg*NUMVALS_CGEN     )
            n = 1
         endif
         if( ngategen > 0 .and. allocated(valgategen) ) then
            call fill_reduce_buffer( valgategen, ngategen*NUMVALS_GATEGEN )
            n = 1
         endif
         if( nweirgen > 0 .and. allocated(valweirgen) ) then
            call fill_reduce_buffer( valweirgen, nweirgen*NUMVALS_WEIRGEN )
            n = 1
         endif
         if( ngenstru > 0 .and. allocated(valgenstru) ) then
            call fill_reduce_buffer( valgenstru, ngenstru*NUMVALS_GENSTRU )
            n = 1
         endif
         if( ndambreaksg > 0 .and. allocated(valdambreak) ) then
            call fill_reduce_buffer( valdambreak, ndambreaksg*NUMVALS_DAMBREAK )
            n = 1
         endif
         if( n == 1 ) then
            call reduce_crs(reducebuf,nreducebuf,1)
            !call reduce_struc(reducebuf,nreducebuf)
         endif


         if( ngenstru > 0 .and. allocated(valgenstru) ) then
            call subsitute_reduce_buffer( valgenstru, ngenstru*NUMVALS_GENSTRU )
            do n = 1,ngenstru
               if( valgenstru(1,n) == 0d0 ) then
                  valgenstru(2:NUMVALS_GENSTRU,n) = dmiss
               else
                  valgenstru(3,n)  = valgenstru(3,n) / valgenstru(1,n)
                  valgenstru(4,n)  = valgenstru(4,n) / valgenstru(1,n)
                  valgenstru(13,n) = valgenstru(13,n) / valgenstru(NUMVALS_GENSTRU,n)    ! id_genstru_openw
                  valgenstru(14,n) = valgenstru(14,n) / valgenstru(NUMVALS_GENSTRU,n)    ! id_genstru_edgel
                  valgenstru(9,n)  = valgenstru(9,n) / valgenstru(NUMVALS_GENSTRU,n)     ! id_genstru_crestl
                  valgenstru(11,n) = valgenstru(11,n) / valgenstru(NUMVALS_GENSTRU,n)    ! id_genstru_stat
                  if (network%sts%numGeneralStructures > 0) then ! new general structure
                     valgenstru(5,n)  = valgenstru(5,n) / valgenstru(1,n)
                     valgenstru(10,n) = valgenstru(10,n) / valgenstru(NUMVALS_GENSTRU,n)    ! id_genstru_crestw
                     if (valgenstru(6,n) > 0d0) then
                        valgenstru(7,n) = valgenstru(2,n) / valgenstru(6,n)  ! velocity
                     else
                        valgenstru(7,n) = 0d0
                     end if
                     valgenstru(8,n) = valgenstru(8,n) / valgenstru(1,n)     ! water level on crest
                     valgenstru(12,n)= valgenstru(12,n)/ valgenstru(1,n)      ! force difference per unit width
                     valgenstru(15,n) = valgenstru(15,n) / valgenstru(NUMVALS_GENSTRU,n)    ! id_genstru_openw
                     valgenstru(16,n) = valgenstru(16,n) / valgenstru(NUMVALS_GENSTRU,n)    ! id_genstru_edgel
                     if (valgenstru(19,n) > 0) then
                        valgenstru(21,n) = valgenstru(21,n) / valgenstru(19,n) ! velocity through gate opening
                     end if
                     if (valgenstru(20,n) > 0) then
                        valgenstru(22,n) = valgenstru(22,n) / valgenstru(20,n) ! velocity over gate upper edge level
                     end if
                  end if
               endif
            enddo
         endif

         if( nweirgen > 0 .and. allocated(valweirgen) ) then
            call subsitute_reduce_buffer( valweirgen, nweirgen*NUMVALS_WEIRGEN )
            do n = 1,nweirgen
               if( valweirgen(1,n) == 0d0 ) then
                  valweirgen(2:NUMVALS_WEIRGEN,n) = dmiss
               else
                  valweirgen(3,n) = valweirgen(3,n) / valweirgen(1,n)
                  valweirgen(4,n) = valweirgen(4,n) / valweirgen(1,n)
                  valweirgen(10,n) = valweirgen(10,n) / valweirgen(NUMVALS_WEIRGEN,n)    ! id_weirgen_crestw
                  valweirgen(9,n) = valweirgen(9,n) / valweirgen(NUMVALS_WEIRGEN,n)      ! id_weirgen_crestl
                  valweirgen(11,n) = valweirgen(11,n) / valweirgen(NUMVALS_WEIRGEN,n)    ! id_weirgen_stat
                  if (network%sts%numWeirs > 0) then ! new weir
                     valweirgen(5,n) = valweirgen(5,n) / valweirgen(1,n)
                     if (valweirgen(6,n) > 0d0) then
                        valweirgen(7,n) = valweirgen(2,n) / valweirgen(6,n)  ! velocity
                     else
                        valweirgen(7,n) = 0d0
                     end if
                     valweirgen(8,n) = valweirgen(8,n) / valweirgen(1,n)     ! water level on crest
                     valweirgen(12,n)= valweirgen(12,n)/ valweirgen(1,n)      ! force difference per unit width
                  end if

               endif
            enddo
         endif

         if( ngategen > 0 .and. allocated(valgategen) ) then
            call subsitute_reduce_buffer( valgategen, ngategen*NUMVALS_GATEGEN )
            do n = 1,ngategen
               if( valgategen(1,n) == 0d0 ) then
                  valgategen(2,n) = dmiss
                  valgategen(3,n) = dmiss
                  valgategen(4,n) = dmiss
                  valgategen(5,n) = dmiss
                  valgategen(7,n) = dmiss
                  valgategen(8,n) = dmiss
                  valgategen(9,n) = dmiss
               else
                  i = gate2cgen(n)
                  valgategen(3,n) = valgategen(3,n) / valgategen(1,n)
                  valgategen(4,n) = valgategen(4,n) / valgategen(1,n)
                  valgategen(5,n) = min( zcgen(3*i-1)-zcgen(3*i-2), valgategen(5,n)/valgategen(1,n)-zcgen(3*i-2) )
                  valgategen(7,n) = valgategen(7,n) / valgategen(6,n) !id_gategen_openw
                  valgategen(8,n) = valgategen(8,n) / valgategen(6,n) !id_gategen_edgel
                  valgategen(9,n) = valgategen(9,n) / valgategen(6,n) !id_gategen_sillh
               endif
            enddo
         endif

         if( ncgensg > 0 .and. allocated(valcgen) ) then
            call subsitute_reduce_buffer( valcgen, ncgensg*NUMVALS_CGEN     )
            do n = 1,ncgensg
               if( valcgen(1,n) == 0d0 ) then
                  valcgen(2,n) = dmiss
                  valcgen(3,n) = dmiss
                  valcgen(4,n) = dmiss
               else
                  valcgen(3,n) = valcgen(3,n) / valcgen(1,n)
                  valcgen(4,n) = valcgen(4,n) / valcgen(1,n)
               endif
            enddo
         endif

         if( ncdamsg > 0 .and. allocated(valcdam) ) then
            call subsitute_reduce_buffer( valcdam   , ncdamsg*NUMVALS_CDAM     )
            do n = 1,ncdamsg
               if( valcdam(1,n) == 0d0 ) then
                  valcdam(2,n) = dmiss
                  valcdam(3,n) = dmiss
                  valcdam(4,n) = dmiss
               else
                  valcdam(3,n) = valcdam(3,n) / valcdam(1,n)
                  valcdam(4,n) = valcdam(4,n) / valcdam(1,n)
               endif
            enddo
         endif

         if( ngatesg > 0 .and. allocated(valgate) ) then
            call subsitute_reduce_buffer( valgate   , ngatesg*NUMVALS_GATE     )
            do n = 1,ngatesg
               if( valgate(1,n) == 0d0 ) then
                  valgate(2,n) = dmiss
                  valgate(3,n) = dmiss
                  valgate(4,n) = dmiss
               else
                  valgate(3,n) = valgate(3,n) / valgate(1,n)
                  valgate(4,n) = valgate(4,n) / valgate(1,n)
               endif
            enddo
         endif

         if( npumpsg > 0 .and. allocated(valpump) ) then
            call subsitute_reduce_buffer( valpump   , npumpsg*NUMVALS_PUMP     )
            do n = 1,npumpsg
               if( valpump(1,n) == 0d0 ) then
                  valpump(2,n) = dmiss
                  valpump(3,n) = dmiss
                  valpump(4,n) = dmiss
                  valpump(5,n) = dmiss
               else
                  valpump(3,n) = valpump(3,n) / valpump(1,n)
                  valpump(4,n) = valpump(4,n) / valpump(1,n)
               endif
            enddo
         endif
         ! === Dambreak
         if( ndambreaksg > 0 .and. allocated(valdambreak) ) then
            call subsitute_reduce_buffer( valdambreak, ndambreaksg*NUMVALS_DAMBREAK )
         endif
      endif

      !update timeprev
      timprev = time1

 end subroutine structure_parameters




subroutine reconstructucz(k)
    ! Perot reconstruction of the vertical velocity, by Willem
    use m_flow
    use m_flowgeom
    use m_flowtimes
    implicit none

    integer, intent(in)  :: k

    integer k1, k2       ! flow node counters (ndx)
    integer kk, kk1, kk2 ! flow node counter (ndkx)
    integer kb, kb1, kb2 ! bottom level flow node counters
    integer kt, kt1, kt2 ! top level flow node counters
    integer ko           ! flow nodeat other side of flow link
    integer L, Lidx      ! flow link counter (2D)
    integer LL           ! flow link counter (3D)
    integer Lb, Lt       ! counter of bottom/top level link
    integer Ls           ! flow link counter (<0 indicates the flow link starts at the current flow node;
                                       !      >0 indicates the flow link ends at the current flow node  )
    integer ndlnx        ! number of neighbouring flow links

    double precision dx1, dx2, dz1, dz2
    double precision dzL, dzL1, dzL2
    double precision zlc, zlc1, zlc2
    double precision zlu, dzhu
    double precision Lsign, Lsign1, Lsign2
    double precision wsigma1, wsigma2        ! interface velocity at lower and upper interface
    !
    if (k == 0) then
    !
    ! reconstruct ucz for whole domain
    !
       !initialize for flow nodes
       do k1 = 1,ndxi
           call getkbotktop(k1,kb,kt)
           dzL = zws(kb)-bl(k1);
           wsigma2 = (zws(kb) - zws0(kb))/dts
           ucz(kb) = (ww1(kb)+wsigma2)*0.5d0*dzL*ba(k1)                ! ww1 at bed level = 0
           do kk = kb+1, kt
           !
           dzL = zws(kk)-zws(kk-1);
           wsigma1 = (zws(kk-1) - zws0(kk-1))/dts
           wsigma2 = (zws(kk) - zws0(kk))/dts
           ucz(kk) =         + (ww1(kk-1)+wsigma1)*0.5d0*dzL*ba(k1)    ! add velocity at surface level (kk-1)
           ucz(kk) = ucz(kk) + (ww1(kk)  +wsigma2)*0.5d0*dzL*ba(k1)    ! add velocity at surface level (kk)
           !
           end do
       end do
       !loop over flow links
       do L = 1,Lnx
          k1 = LN(1,L)
          k2 = LN(2,L)
          call getkbotktop(k1,kb1,kt1)
          call getkbotktop(k2,kb2,kt2)
          Lb = Lbot(L);
          Lt = Ltop(L);
          zLc1 = bl(k1)
          zLc2 = bl(k2)
          kk1 = kb1
          kk2 = kb2
          Lsign1 =  1d0
          Lsign2 = -1d0
          do LL = Lb, Lt
             zlu  = min( bob(1,L), bob(2,L) ) + hu(LL)*0.5d0+hu(LL-1)*0.5d0   ! update flow link elevation
             !
             ! update first flow node
             !
             dzL1 = zws(kk1)-zws(kk1-1)
             zlc1 = zlc1 + 0.5d0*dzL1
             dz1 = zlu-zlc1
             ucz(kk1) = ucz(kk1) + Lsign1*u1(LL)*wu(L)*(hu(LL)-hu(LL-1))*dz1
             !
             zlc1 = zlc1 + 0.5d0*dzL1
             !
             ! update second flow node
             !
             dzL2 = zws(kk2)-zws(kk2-1)
             zlc2 = zlc2 + 0.5d0*dzL2
             dz2 = zlu-zlc2
             ucz(kk2) = ucz(kk2) + Lsign2*u1(LL)*wu(L)*(hu(LL)-hu(LL-1))*dz2
             !
             zlc2 = zlc2 + 0.5d0*dzL2
             !
             ! update vertical counters
             !
             kk1 = kk1+1
             kk2 = kk2+1
          end do
       end do
       !finalize for flow nodes
       do k1 = 1,ndxi
          call getkbotktop(k1,kb,kt)
          do kk = kb, kt
             if (vol1(kk) > 0d0) then
                ucz(kk) = ucz(kk)/vol1(kk)   ! divide by volume
             endif
          end do
       end do
    else
    !
    ! reconstruct ucz for single flow node
    !
       call getkbotktop(k,kb,kt)
       !ucz(kb) = 0.0d0
       dzL = zws(kb)-zws(kb-1)
       wsigma2 = (zws(kb) - zws0(kb))/dts
       ucz(kb) = (ww1(kb)+wsigma2)*0.5d0*dzL*ba(k)                ! ww1 at bed level = 0
       do kk = kb+1, kt
          !
          dzL = zws(kk)-zws(kk-1);
          wsigma1 = (zws(kk-1) - zws0(kk-1))/dts
          wsigma2 = (zws(kk) - zws0(kk))/dts
          ucz(kk) =         + (ww1(kk-1)+wsigma1)*0.5d0*dzL*ba(k)    ! add velocity at surface level (kk-1)
          ucz(kk) = ucz(kk) + (ww1(kk)  +wsigma2)*0.5d0*dzL*ba(k)    ! add velocity at surface level (kk)
          !
       end do
       !get neighbouring flow links
       ndlnx = nd(k)%lnx               ! number of flowlinks associated with current flow node.
       do Lidx = 1,ndlnx
          Ls = nd(k)%ln(Lidx)          ! link number including its direction (<0 indicates the flow link starts at the current flow node;
                                       !                                      >0 indicates the flow link ends at the current flow node   )
          L  = abs(nd(k)%ln(Lidx))     ! link numbers
          if (L == Ls) then            ! determine horizontal distance dx1 from flow link to u point
             Lsign = -1d0              ! Lsign (velocity directed towards current flow node)
             dx1 = dx(L)*(1d0-acl(L))  !
             dx2 = acl(L)*dx(L)        !
             ko = LN(1,L)              ! outside associated flow node number
          else
             Lsign = 1d0               ! Lsign (velocity directed away from current flow node)
             dx1 = dx(L)*acl(L)        !
             dx2 = dx(L)*(1d0-acl(L))  !
             ko = LN(2,L)              ! outside flow node number
          end if

          !k2 = LN(2,L)                 ! second associated flow node number
              Lb = Lbot(L)                  ! --
          Lt = Ltop(L)
          kk = kb
          zlc = bl(k)                       ! bed level in flow node
          dzhu = hu(Lb)                     ! height of the bottom layer at flow link
          do LL = Lb, Lt                    ! get link numbers in the vertical
             dzL = zws(kk)-zws(kk-1);
             zlc = zlc + 0.5d0*dzL
             !zlu = dx2*bl(k)*dxi(L) + dx1*bl(ko)*dxi(L) + hu(LL)*0.5+hu(LL-1)*0.5  (interpolated bed level at u-point)
             zlu = min( bob(1,L), bob(2,L) ) + hu(LL)*0.5d0+hu(LL-1)*0.5d0
             !
             ! u_vertical,new  =  u_vertical,old + Lsign*u_horizontal*width*depth_layer
             !
             dz1 = zlu-zlc
             ucz(kk) = ucz(kk) + Lsign*u1(LL)*wu(L)*(hu(LL)-hu(LL-1))*dz1
             !
             zlc = zlc + 0.5d0*dzL
             kk = kk+1                 ! update vertical counter
             !
          end do
       end do
       do kk = kb, kt
          if (vol1(kk) > 0) then
             ucz(kk) = ucz(kk)/vol1(kk)   ! divide by volume
          endif
       end do

    end if

end subroutine reconstructucz

!    Secondary Flow
subroutine get_curvature         ! Find the curvature of the bend, to be used in secondary flow
    use m_flow
    use m_flowgeom
    use m_netw

    implicit none
    integer :: k, k1, k2, L, LL, n
    double precision :: cofa, cofb, cofc, cofd, cofe, coff, cofg, cofw, cofx, cofy, cofu, cofv, cof0
    double precision :: dudx, dudy, dvdx, dvdy

    do k = 1,ndx
       spirucm(k) = 0d0
       if( hs(k) < epshu ) cycle
       spirucm(k) = sqrt( ucx(k) * ucx(k) + ucy(k) * ucy(k) )
    enddo

    do k = 1,ndxi
       if( spirucm(k) < 1.0d-3 .or. hs(k) < epshu ) then
          spircrv(k) = 0.0d0
          cycle
       endif
       cofa = 0.0d0
       cofb = 0.0d0
       cofc = 0.0d0
       cofd = 0.0d0
       cofe = 0.0d0
       coff = 0.0d0
       cofg = 0.0d0
       n = 0
       do LL = 1,nd(k)%lnx
          L = abs( nd(k)%ln(LL) )
          k2 = ln(1,L) + ln(2,L) - k
          !if( hs(k2) < epshu ) cycle
          n = n + 1
          cofx = xz(k2) - xz(k)
          cofy = yz(k2) - yz(k)
          cofu = ucx(k2) - ucx(k)
          cofv = ucy(k2) - ucy(k)
          if( hs(k2) < epshu ) then
             cofu = - ucx(k)
             cofv = - ucy(k)
          endif
          cof0 = sqrt( cofx * cofx + cofy * cofy )
          cofw = 1.0d0 / cof0
          if( cof0 < 1.0d-6 ) cofw = 1.0d6
          cofx = cofw * cofx
          cofy = cofw * cofy
          cofu = cofw * cofu
          cofv = cofw * cofv
          cofa = cofa + cofx * cofx
          cofb = cofb + cofx * cofy
          cofc = cofc + cofy * cofy
          cofd = cofd + cofu * cofx
          cofe = cofe + cofu * cofy
          coff = coff + cofv * cofx
          cofg = cofg + cofv * cofy
       enddo
       cof0 = cofa * cofc - cofb * cofb
       spircrv(k) = 0.0d0
       if( cof0 < 1d-6 .or. n < 2 ) cycle
       dudx = ( cofd * cofc - cofb * cofe ) / cof0
       dudy = ( cofa * cofe - cofd * cofb ) / cof0
       dvdx = ( coff * cofc - cofb * cofg ) / cof0
       dvdy = ( cofa * cofg - coff * cofb ) / cof0
       spircrv(k) = ucx(k) * ucx(k) * dvdx - ucy(k) * ucy(k) * dudy + ucx(k) * ucy(k) * ( dvdy - dudx )
       spircrv(k) = - spircrv(k) / spirucm(k)**3
    enddo

    do L = lnxi+1,lnx                     ! Boundary condtions as Neumann for the curvature
       k1 = ln(1,L) ; k2 = ln(2,L)
       spircrv(k1)  = spircrv(k2)
    enddo

end subroutine get_curvature

subroutine get_spiralforce    ! Effect of secondary flow on momentum equations
                              ! This subroutine calculates the forces fx and fy for momentum equations
   use m_flow
   use m_flowgeom

   implicit none
   integer :: k, k1, k2, LL, L, n
   double precision :: cofa, cofb, cofc, cofd, cofe, coff, cofg, cofw, cofx, cofy, coftxx, coftxy, coftyy, cof0
   double precision :: dtxxdx, dtxxdy, dtxydx, dtxydy
   double precision :: betas, beta, alfa
   double precision :: fx, fy, fxl

   ht_xx = 0d0 ; ht_xy = 0d0

   do k = 1,ndxi
      ht_xx(k) = 0d0
      ht_xy(k) = 0d0
      if( spirucm(k) < 1.0d-3 ) cycle
      if( hs(k) < epshu ) cycle
      alfa  = sag / vonkar / czssf(k)
      betas = spirbeta * ( 5.0d0 * alfa - 15.6d0 * alfa**2 + 37.5d0 * alfa**3 )
      beta = betas * spirint(k) / spirucm(k)
      ht_xx(k) = -2.0d0 * hs(k) * beta * ucx(k) * ucy(k)
      ht_xy(k) = hs(k) * beta * ( ucx(k) * ucx(k) - ucy(k) * ucy(k) )
   enddo

   do L = lnxi+1,lnx                        ! Boundary conditions for spiral flow forces
      k1 = ln(1,L) ; k2 = ln(2,L)
      ht_xy(k1) = 0d0
      ht_xy(k1) = 0d0
      if( hs(k2) < epshu ) cycle
      ht_xx(k1) = ht_xx(k2)
      ht_xy(k1) = ht_xy(k2)
   enddo

   do k = 1,ndxi
      k1 = k
      spirfx(k1) = 0d0
      spirfy(k1) = 0d0
      if( hs(k1) < epshu ) cycle
      cofa = 0.0d0
      cofb = 0.0d0
      cofc = 0.0d0
      cofd = 0.0d0
      cofe = 0.0d0
      coff = 0.0d0
      cofg = 0.0d0
      n = 0
      do LL = 1,nd(k1)%lnx
         L = abs( nd(k1)%ln(LL) )
         k2 = ln(1,L) + ln(2,L) - k1
         !if( hs(k2) < epshu ) cycle
         n = n + 1
         cofx = xz(k2) - xz(k1)
         cofy = yz(k2) - yz(k1)
         coftxx = ht_xx(k2) - ht_xx(k1)
         coftxy = ht_xy(k2) - ht_xy(k1)
         cof0 = sqrt( cofx * cofx + cofy * cofy )
         cofw = 1.0d0 / cof0
         if( cof0 < 1.0d-6 ) cofw = 1.0d6
         cofx = cofw * cofx
         cofy = cofw * cofy
         coftxx = cofw * coftxx
         coftxy = cofw * coftxy
         cofa = cofa + cofx   * cofx
         cofb = cofb + cofx   * cofy
         cofc = cofc + cofy   * cofy
         cofd = cofd + coftxx * cofx
         cofe = cofe + coftxx * cofy
         coff = coff + coftxy * cofx
         cofg = cofg + coftxy * cofy
      enddo
      cof0   = cofa * cofc - cofb * cofb

      if( cof0 == 0d0 .or. n < 2 ) cycle
      dtxxdx = ( cofd * cofc - cofb * cofe ) / cof0
      dtxxdy = ( cofa * cofe - cofd * cofb ) / cof0
      dtxydx = ( coff * cofc - cofb * cofg ) / cof0
      dtxydy = ( cofa * cofg - coff * cofb ) / cof0
      spirfx(k1) = ( dtxxdx + dtxydy ) / hs(k1)
      spirfy(k1) = ( dtxydx - dtxxdy ) / hs(k1)
   enddo

   do L = lnxi+1,lnx                        ! Boundary conditions for spiral flow forces
      k1 = ln(1,L) ; k2 = ln(2,L)
      spirfx(k1) = spirfx(k2)
      spirfy(k1) = spirfy(k2)
   enddo

   do L = 1,lnx                             ! Mapping forces from global coordinates to local
      k1    = ln(1,L) ; k2 = ln(2,L)
      fx = acl(L) * spirfx(k1) + ( 1.0d0 - acl(L) ) * spirfx(k2)
      fy = acl(L) * spirfy(k1) + ( 1.0d0 - acl(L) ) * spirfy(k2)
      fxl = csu(L) * fx + snu(L) * fy
      adve(L) = adve(L) - fxl               ! Adding the local forces to the momentum equation
   enddo

end subroutine get_spiralforce

! =================================================================================================
! =================================================================================================
subroutine equili_spiralintensity()
   use m_flow
   use m_flowgeom
   use m_sferic, only: jsferic, fcorio
   implicit none
   integer          :: kk
   double precision :: spir_ce, spir_be, fcoriocof

   do kk = 1,ndx
      fcoriocof = fcorio
      if( icorio > 0 .and. jsferic == 1 ) fcoriocof = fcoris(kk)
      spir_ce = fcorio * hs(kk) * 0.5d0
      spir_be = hs(kk) * spircrv(kk) * spirucm(kk)
      spirint(kk) = spir_be - spir_ce
   enddo

end subroutine equili_spiralintensity



!> count number of 2D links and 1D endpoints
subroutine count_links(mx1Dend, Nx)
   use network_data, only: numL, numL1D, kn, lne, nmk
   implicit none

   integer, intent(out) :: mx1Dend  !< number of 1D endpoints
   integer, intent(out) :: Nx       !< number of 2D links and 1D endpoints

   integer              :: k1, k2, L

   mx1Dend = 0                                        ! count MAX nr of 1D endpoints
   do L = 1,numl1D
      if ( kn(3,L) == 1 .or. kn(3,L) == 6) then       ! zeker weten
         k1 = kn(1,L) ; k2 = kn(2,L)
         if (nmk(k1) == 1 .and. nmk(k2) == 2 .and. lne(1,L) < 0 .or. &
             nmk(k2) == 1 .and. nmk(k1) == 2 .and. lne(2,L) < 0 ) then
             mx1Dend = mx1Dend + 1
         endif
      endif
   enddo


   Nx = numL + mx1Dend

   return
end subroutine count_links

!> make the mirror cells for open boundaries
subroutine make_mirrorcells(Nx, xe, ye, xyen, kce, ke, ierror)
   use network_data, only: numL, kn, lne, nmk, xk, yk
   implicit none

   integer,                           intent(in)    :: Nx      !< number of links
   double precision, dimension(Nx),   intent(out)   :: xe, ye  !< inner cell center coordinates
   double precision, dimension(2,Nx), intent(out)   :: xyen    !< mirror cell center coordinates
   integer,          dimension(Nx),   intent(inout) :: kce     !< flag
   integer,          dimension(Nx),   intent(out)   :: ke      !< inner cell number

   integer,                           intent(out)   :: ierror   !< error (1) or not (0)

   logical, external                                :: is_1d_boundary_candidate

   double precision, dimension(4)                   :: xx, yy  ! (half) mirror cell contour

   double precision                                 :: xci, yci, xcb, ycb, xce2, yce2

   integer                                          :: ind, k1, k2, k3, k4, L

   ierror = 1

   do L  = 1,numL                                      ! kandidate points and distance tolerance of closed (u) points
      k3 = kn(1,L)  ; k4 = kn(2,L)

!      if ( abs(xk(k3)+11.5d0)+abs(xk(k4)+11.5d0) .lt. 1d-8 ) then
!         continue
!      end if

      if (kn(3,L) == 2 .and. &     ! 2D links
          (lne(1,L) == 0 .and. lne(2,L) /= 0 .or. &     ! boundary links
           lne(1,L) /= 0 .and. lne(2,L) == 0)) then
         ind = lne(1,L)+lne(2,L)                      ! i.e., the nonzero cell nr.

         call mirrorcell( ind, xk(k3), yk(k3), xk(k4), yk(k4), xci, yci, xcb, ycb, xce2, yce2, xx, yy)  ! voetje uitsteken tussen xz intern (xci) en xz rand (xcb)
         xe(L)     = xci
         ye(L)     = yci
         xyen(1,L) = xce2
         xyen(2,L) = yce2
         kce(L)    = 1
         ke(L)     = ind
      else if (kn(3,L) == 1 .or. kn(3,L) == 6) then                      ! 1D links
         k1 = k3 ; k2 = k4
         if (is_1d_boundary_candidate(L,1)) then
            xe(L)     = xk(k1)
            ye(L)     = yk(k1)
            xyen(1,L) = 2d0*xk(k1) - xk(k2)
            xyen(2,L) = 2d0*yk(k1) - yk(k2)
            kce(L)    = 1
            ke(L)     = -lne(1,L)
         else if (is_1d_boundary_candidate(L,2)) then
            xe(L)     = xk(k2)
            ye(L)     = yk(k2)
            xyen(1,L) = 2d0*xk(k2) - xk(k1)
            xyen(2,L) = 2d0*yk(k2) - yk(k1)
            kce(L)    = 1
            ke(L)     = -lne(2,L)
         endif
      endif
   enddo

   ierror = 0
1234 continue

   return
end subroutine make_mirrorcells


 !> Adds administration for an open boundary segment, intended
 !! for postprocessing.
 !!
 !! An open boundary section is associated with one polyline
 !! and consists of one or more netlink numbers.
 subroutine addopenbndsection(nbnd, netlinknrs, plifilename, ibndtype)
 use m_alloc
 use m_flowexternalforcings
 implicit none
    integer,          intent(in) :: nbnd             !< Nr. of net links in this open bnd section.
    integer,          intent(in) :: netlinknrs(nbnd) !< Net link nrs in this open bnd section (in any order)
    character(len=*), intent(in) :: plifilename      !< File name of the original boundary condition definition polyline.
    integer,          intent(in) :: ibndtype         !< Type of this boundary section (one of IBNDTP_ZETA, etc...)
    integer, external :: get_dirsep
    integer :: maxopenbnd, istart, i, n1, n2

    ! Start index (-1) of net link numbers for this net boundary section:
    if (nopenbndsect >= 1) then
        istart = nopenbndlin(nopenbndsect)
    else
        istart = 0
    end if

    nopenbndsect = nopenbndsect + 1
    maxopenbnd = max(size(nopenbndlin), int(1.2*nopenbndsect)+1, 5)
    call realloc(openbndname, maxopenbnd, fill = ' ')
    call realloc(openbndfile, maxopenbnd, fill = ' ')
    call realloc(openbndtype, maxopenbnd, fill = IBNDTP_UNKNOWN)
    call realloc(nopenbndlin, maxopenbnd)
    call realloc(openbndlin,  istart+nbnd)

    ! Strip off trailing file extension .pli
    n2  = index(plifilename,'.', .true.) - 1
    if (n2 < 0) then
       n2 = len_trim(plifilename)
    end if

    ! Strip off leading path /dir/name/bnd/
    n1  = index(plifilename(1:n2),'\', .true.) ! Win
    if (n1 == 0) then
       n1  = index(plifilename(1:n2),'/', .true.) ! Or try UX
    end if

    openbndfile(nopenbndsect) = trim(plifilename)
    openbndname(nopenbndsect) = plifilename(N1+1:N2)
    openbndtype(nopenbndsect) = ibndtype

    do i = 1,nbnd
        openbndlin(istart+i) = netlinknrs(i)
    end do

    nopenbndlin(nopenbndsect) = istart + nbnd

 end subroutine addopenbndsection

 subroutine addexternalboundarypoints
 use m_netw
 use m_flow
 use m_flowgeom
 use unstruc_messages
 use m_alloc
 use timespace, only: polyindexweight
 use m_missing
 use m_sobekdfm
 use m_sferic, only: jsferic, jasfer3D
 use geometry_module, only: half

 implicit none

 logical, external                                :: is_1d_boundary_candidate

 integer :: i, k, k1, k2, L, Lf, lb, nn, ierr, ja, k3, k4, id, istart, num1d2d, kL, kR, mpliz

 double precision :: x0,y0,x1,y1,x2,y2,xn,yn, dis, wL, wR
 double precision :: rtol, xci, yci, xcb, ycb, xce2, yce2, xx(4), yy(4)
 integer, allocatable :: kdum(:)


 ! Update Mar'15: 1D/2D bnds points/links used to be mixed, now all 1D bnds nodes/links come first,
 ! followed by 2D bnd.
 ! So: links: 1..lnx1d..lnxi..lnx1db..lnx
 !     nodes: 1..ndx2d..ndxi..ndx1db..ndx  (notice how 1D bnds nodes go before 2D bnds, while 2D internal go before 1D internal).
 Lf = lnxi
 k  = ndxi
 lnx1db = lnxi ! Counter for last 1D boundary link (==lnxi if no 1D bnds)
 ndx1db = ndxi ! Counter for last 1D boundary node (==ndxi if no 1D bnds)
 do id=1,2 ! 1D and 2D treated after one another
 do Lb = 1,nbndz                                    ! add boundary link and update ln array waterlevel bnds
    L  = kez(Lb)
    !if (    (id == 1 .and. (kn(3,L) .ne. 1 .and. kn(3,L) .ne. 4)) &     !    we're in 1D loop, so skip this 2D boundary cell for the moment.
    !   .or. (id == 2 .and. (kn(3,L) .eq. 1 .or. kn(3,L) .eq. 4))) then  ! or we're in 2D loop, so skip this 1D boundary cell for the moment.
    ! Wijzigingsvoorstel:
    if (    id == 1 .and. kn(3,L) .ne. 1 .and. kn(3,L) .ne. 6    &     !    we're in 1D loop, so skip this 2D boundary cell for the moment.
      .or.  id == 2 .and. kn(3,L) .ne. 2  ) then  ! or we're in 2D loop, so skip this 1D boundary cell for the moment.
       cycle
    end if

    k  = k  + 1
    Lf = Lf + 1
    if (id == 1) then ! Increment 1D boundary node & link counters
       lnx1db = Lf
       ndx1db = k
    end if

    k1 = k                                          ! external point
    k2 = iabs(lne(1,L))                             ! internal point

    ln(1,Lf)   = k1
    ln(2,Lf)   = k2

    ln2lne(Lf) = L
    lne2ln(L)  = Lf                                 ! after this, only closed edges will still have a (negative)
                                                    ! reference to an inside node

    nn = 4
    allocate ( nd(k1)%x(nn), nd(k1)%y(nn) , stat=ierr )
    call aerr('nd(k1)%x(nn), nd(k1)%y(nn)', ierr, nn*2)

    k3 = kn(1,L); k4 = kn(2,L)
    if (kn(3,L) == 2) then  ! in 2D mirror cell
        call mirrorcell( k2, xk(k3), yk(k3), xk(k4), yk(k4), xci, yci, xz(k1), yz(k1), xce2, yce2, nd(k1)%x, nd(k1)%y)
        xzw(k1) = xz(k1) ; yzw(k1) = yz(k1)

        if (izbndpos == 0) then                    ! as in D3DFLOW

        else if (izbndpos == 1) then               ! on network boundary
!           xz(k1)  = 0.5d0*( xk(k3) + xk(k4 ) )
!           yz(k1)  = 0.5d0*( yk(k3) + yk(k4 ) )
           call half(xk(k3),yk(k3),xk(k4),yk(k4),xz(k1),yz(k1), jsferic, jasfer3D)
        else if (izbndpos == 2) then               ! on specified boundary polyline

        endif


        kcu(Lf) = -2
        kcs(k1) = -2
    else                                               ! in 1D mirror point
         if (is_1d_boundary_candidate(L,1)) then
            if (izbndpos == 0) then                    ! as in D3DFLOW
!               xz(k1)  = 2d0*xk(k3) - xk(k4)
!               yz(k1)  = 2d0*yk(k3) - yk(k4)
                call a1x1a2x2(xk(k3),yk(k3),xk(k4),yk(k4),2d0,-1d0,xz(k1),yz(k1))
            else if (izbndpos == 1) then               ! on network boundary
!               xz(k1)  = 1.5d0*xk(k3) - 0.5d0*xk(k4)
!               yz(k1)  = 1.5d0*yk(k3) - 0.5d0*yk(k4)
               call a1x1a2x2(xk(k3),yk(k3),xk(k4),yk(k4),1.5d0,-0.5d0,xz(k1),yz(k1))
            else if (izbndpos == 2) then               ! on specified boundary polyline

            endif
            ln(2,Lf) = iabs(lne(1,L))  ! this overrides previous k2
            kcu(Lf)  = -1
            kcs(k1)  = -1
            nd(k1)%x = xz(k1) ; nd(k1)%y = yz(k1)  ! todo, naar allocateandset1D nodestuff
            xzw(k1) = xz(k1); yzw(k1) = yz(k1)
         else if (is_1d_boundary_candidate(L,2)) then
            if (izbndpos == 0) then                    ! as in D3DFLOW
!               xz(k1) = 2d0*xk(k4) - xk(k3)
!               yz(k1) = 2d0*yk(k4) - yk(k3)
               call a1x1a2x2(xk(k3), yk(k3), xk(k4), yk(k4), -1d0, 2d0, xz(k1), yz(k1))
            else if (izbndpos == 1) then               ! on network boundary
!               xz(k1) = 1.5d0*xk(k4) - 0.5d0*xk(k3)
!               yz(k1) = 1.5d0*yk(k4) - 0.5d0*yk(k3)
               call a1x1a2x2(xk(k3), yk(k3), xk(k4), yk(k4), -0.5d0, 1.5d0, xz(k1), yz(k1))
            else if (izbndpos == 2) then               ! on specified boundary polyline

            endif
            ln(2,Lf) = iabs(lne(2,L))
            kcu(Lf)  = -1
            kcs(k1)  = -1
            nd(k1)%x = xz(k1) ; nd(k1)%y = yz(k1)  ! todo, naar allocateandset1D nodestuff
            xzw(k1) = xz(k1); yzw(k1) = yz(k1)
        endif
    endif

 enddo
! enddo ! id=1,2

! do id=1,2 ! 1D and 2D treated after one another
 do Lb = 1,nbndu                                    ! idem u bnds, duplicatie niet top in elegantie

    L  = keu(Lb)
    !if (    (id == 1 .and. (kn(3,L) .ne. 1 .and. kn(3,L) .ne. 4)) &      !    we're in 1D loop, so skip this 2D boundary cell for the moment.
    !   .or. (id == 2 .and. (kn(3,L) .eq. 1 .or. kn(3,L) .eq. 4))) then  ! or we're in 2D loop, so skip this 1D boundary cell for the moment.
    ! Wijzigingsvoorstel:
    if (    id == 1 .and. kn(3,L) .ne. 1 .and. kn(3,L) .ne. 6    &     !    we're in 1D loop, so skip this 2D boundary cell for the moment.
      .or.  id == 2 .and. kn(3,L) .ne. 2  ) then  ! or we're in 2D loop, so skip this 1D boundary cell for the moment.
       cycle
    end if

    k  = k  + 1
    Lf = Lf + 1
    if (id == 1) then ! Increment 1D boundary node & link counters
       lnx1db = Lf
       ndx1db = k
    end if
    k1 = k                                          ! external point
    k2 = iabs(lne(1,L))                             ! internal point

    ln(1,Lf)   = k1
    ln(2,Lf)   = k2
    ln2lne(Lf) = L
    lne2ln(L)  = Lf


    nn = 4
    allocate ( nd(k1)%x(nn), nd(k1)%y(nn) , stat=ierr )
    call aerr('nd(k1)%x(nn), nd(k1)%y(nn)', ierr, nn*2)
    k3 = kn(1,L); k4 = kn(2,L)
    if (kn(3,L) == 2) then  ! in 2D mirror cell
        call mirrorcell( k2, xk(k3), yk(k3), xk(k4), yk(k4), xci, yci, xz(k1), yz(k1), xce2, yce2, nd(k1)%x, nd(k1)%y)
        xzw(k1) = xz(k1) ; yzw(k1) = yz(k1)

        kcu(Lf) = -2
        kcs(k1) = -2
    else                      ! in 1D mirror point
         if (is_1d_boundary_candidate(L,1)) then
!            xz(k1)  = 2d0*xk(k3) - xk(k4)
!            yz(k1)  = 2d0*yk(k3) - yk(k4)
            call a1x1a2x2(xk(k3), yk(k3), xk(k4), yk(k4), 2d0, -1d0, xz(k1), yz(k1))
            ln(2,Lf) = iabs(lne(1,L))  ! this overrides previous k2
            kcu(Lf) = -1
            kcs(k1) = -1
            nd(k1)%x = xz(k1) ; nd(k1)%y = yz(k1)  ! todo: JN: naar allocateandset1D nodestuff
            xzw(k1) = xz(k1); yzw(k1) = yz(k1)
         else if (is_1d_boundary_candidate(L,2)) then
!            xz(k1)  = 2d0*xk(k4) - xk(k3)
!            yz(k1)  = 2d0*yk(k4) - yk(k3)
            call a1x1a2x2(xk(k3), yk(k3), xk(k4), yk(k4), -1d0, 2.0d0, xz(k1), yz(k1))
            ln(2,Lf) = iabs(lne(2,L))
            kcu(Lf) = -1
            kcs(k1) = -1
            nd(k1)%x = xz(k1) ; nd(k1)%y = yz(k1)  ! todo: JN: naar allocateandset1D nodestuff
            xzw(k1) = xz(k1); yzw(k1) = yz(k1)
        endif
    endif

 enddo
 enddo ! id=1,2

 do Lb = 1,nbnd1d2d                                    ! add boundary link and update ln array 1d2dbnds
    L  = ke1d2d(Lb)

    k  = k  + 1
    Lf = Lf + 1
    k1 = k                                          ! external point
    k2 = iabs(lne(1,L))                             ! internal point

    ln(1,Lf)   = k1
    ln(2,Lf)   = k2

    ln2lne(Lf) = L
    lne2ln(L)  = Lf                                 ! after this, only closed edges will still have a (negative)
                                                    ! reference to an inside node

    nn = 4
    allocate ( nd(k1)%x(nn), nd(k1)%y(nn) , stat=ierr )
    call aerr('nd(k1)%x(nn), nd(k1)%y(nn)', ierr, nn*2)

    k3 = kn(1,L); k4 = kn(2,L)
    if (kn(3,L) .ne. 1) then  ! in 2D mirror cell
        call mirrorcell( k2, xk(k3), yk(k3), xk(k4), yk(k4), xci, yci, xz(k1), yz(k1), xce2, yce2, nd(k1)%x, nd(k1)%y)
        xzw(k1) = xz(k1) ; yzw(k1) = yz(k1)

        !xz(k1)  = 0.5d0*( xk(k3) + xk(k4 ) )
        !yz(k1)  = 0.5d0*( yk(k3) + yk(k4 ) )

        kcu(Lf) = -2
        kcs(k1) = -2
    else                                               ! in 1D mirror point
      ! non-sensible: 1D internal point that accidentally lies on 2DFM -- 1DSOBEK boundary (should not happen)
    endif
 enddo

 write(msgbuf, '(a,i0,a)') 'addexternalboundarypoints: added ', nbnd1d2d, ' bnd points for SOBEK1D-FM2D connections.'
 call dbg_flush()

 ! Special for 1D2D: interpolate zpl crest levels for each open boundary link u-point
 if (nbnd1d2d > 0) then
    call realloc(zcrest1d2d, nbnd1d2d, keepExisting=.false.)
    call savepol()
    istart = 0
    num1d2d = 0 ! local counter for 1D2D open boundary points (should be identical to ordering inside zbnd1d2d array, etc. If not, programming error!)
    do i=1,nopenbndsect
       if (openbndtype(i) == IBNDTP_1D2D) then
          call oldfil(mpliz, trim(openbndfile(i))) ! The original .pli(z) file as listed in the external forcings file.
          call reapol(mpliz, 0)
          call realloc(kdum, maxpol, keepExisting=.false.)
          kdum = 1 ! Mask all pli points as valid for interpolation: each pli point should have a zpl crest value.

          do Lb=istart+1,nopenbndlin(i)
             num1d2d = num1d2d + 1
             L  = openbndlin(Lb) ! Net link
             Lf = lne2ln(L)      ! Flow link

             if (Lf > 0 .and. Lf <= lnx) then
                k1 = ln(1,Lf)
                k2 = ln(2,Lf)

                k3 = kn(1,L); k4 = kn(2,L)
                ! NOTE: UNST-1324: do this once more, so we have the "probe" point xce2, yce2 for the proper intersection.
                ! TODO: AvD: remove dupliacy by merging this loop 1:nopenbndsect and the preceding loop 1:nbnd1d2d.
                call mirrorcell( k2, xk(k3), yk(k3), xk(k4), yk(k4), xci, yci, xz(k1), yz(k1), xce2, yce2, nd(k1)%x, nd(k1)%y)

                call polyindexweight(xce2, yce2, xz(k2), yz(k2), xpl, ypl, kdum, npl, kL, wL, kR, wR) ! xz(k1), yz(k1),
                if (.not.(kL > 0 .and. kR > 0)) then
                   call polyindexweight(xz(k2), yz(k2), 2*xz(k2)-xce2, 2*yz(k2)-yce2, xpl, ypl, kdum, npl, kL, wL, kR, wR)
                endif
                if (kL > 0 .and. kR > 0) then
                   if (zpl(kL) == dmiss) then
                      write(msgbuf, '(a,a,a,i0)') 'Missing crest level for SOBEK1D-FM2D boundary ''', trim(openbndname(i)), ''': missing value found on point #', kL
                      call err_flush()
                   elseif (zpl(kR) == dmiss) then
                      write(msgbuf, '(a,a,a,i0)') 'Missing crest level for SOBEK1D-FM2D boundary ''', trim(openbndname(i)), ''': missing value found on point #', kR
                      call err_flush()
                   else
                      zcrest1d2d(num1d2d) = wL*zpl(kL) + wR*zpl(kR)
                   end if
                else
                   ! Should not happen for any model, only for debugging
                   write(msgbuf,'(a,i0,a,f12.4,a,f12.4,a)') 'Could not find crest level for SOBEK1D-FM2D boundary '''//trim(openbndname(i))//''': no overlap found for net link ', &
                                                           L, ' [',(xce2+xz(k2))/2.,',',(yce2+yz(k2))/2.,']'
                   call err_flush()
                end if
             else
                ! Should not happen for any model, only for debugging
                write(msgbuf, '(a,a,a,i0)') 'Could not set crest level for SOBEK1D-FM2D boundary ''', trim(openbndname(i)), ''': no flow link found for net link ', L
                call err_flush()
             end if
          end do
          call doclose(mpliz)
       end if
       istart = nopenbndlin(i)
    end do
    call restorepol()
    if (allocated(kdum)) deallocate(kdum)
 end if ! nbnd1d2d > 0
    end subroutine addexternalboundarypoints

!< Returns true when a 1d node can be used as a boundary. By default
!< the connecting edge should not lead to a bifurcation, unless
!< the flag jaAllowBndAtBifurcation is true
pure logical function is_1d_boundary_candidate(L,i)
    use network_data
    use m_flowgeom

    implicit none

    integer, intent(in)     :: L    !<  net link to check for boundary candidate
    integer, intent(in)     :: i    !<  node to check, equals 1 or 2

    logical                 :: isEndNode

    is_1d_boundary_candidate = nmk(kn(i,L)) == 1 .and. nmk(kn(3-i,L)) == 2 .and. lne(i,L) < 0
    if (jaAllowBndAtBifurcation == 1) then
        is_1d_boundary_candidate = nmk(kn(i,L)) == 1 .and. nmk(kn(3-i,L)) >= 2 .and. lne(i,L) < 0
    endif

    return
end function is_1d_boundary_candidate


 !> Initializes boundaries and meteo for the current model.
 !! @return Integer result status (0 if successful)
 integer function flow_initexternalforcings() result(iresult)              ! This is the general hook-up to wind and boundary conditions
 use unstruc_boundaries
 use m_alloc
 use m_flowexternalforcings
 use m_flowparameters
 use m_flowtimes                                     ! Two stages: 1 = collect elsets for which data is provided
 use m_flowgeom                                      !             2 = add relations between elsets and their providers
 use m_inquire_flowgeom, only: IFLTP_1D, IFLTP_ALL
 use m_netw
 use unstruc_model
 use unstruc_messages
 use unstruc_files, only: resolvePath, basename
 use timespace
 use m_missing
 use m_ship
 use m_flow ! , only : frcu, frculin, jafrculin, viusp, javiusp, diusp, jadiusp, vicouv, dicouv,   &
            !        ifrcutp, frcuni, ifrctypuni, s1, sa1, tem1, u1, zws, satop, kmx, kmxd, ndkx, kmxn, Cdwusp, &
            !        frcInternalTides2D, lnkx
 use m_observations
 use m_alloc
 use m_structures
 use m_meteo
 use m_ec_instance
 use m_grw
 use m_alloc
 use m_sediment
 use m_transport
 use m_fm_wq_processes
 use m_strucs
 use dfm_error
 use m_sobekdfm
 use m_partitioninfo
 use m_storage
 use m_crosssections
 use m_ec_spatial_extrapolation, only : init_spatial_extrapolation
 use m_sferic, only: jsferic
 use m_trachy, only: trachy_resistance
 use unstruc_inifields, only: initInitialFields
 ! use m_vegetation

 implicit none
 character(len=256)            :: filename, sourcemask
 integer                       :: L, Lf, mout, kb, LL, Lb, Lt, ierr, k, k1, k2, ja, method, n1, n2, kbi, Le, n, j, mx, n4, kk, kt, lenqidnam
 character (len=256)           :: fnam, rec, filename0
 character (len=64)            :: varname
 character (len=NAMTRACLEN)    :: tracnam, qidnam
 character (len=NAMWAQLEN)     :: wqbotnam
 ! JRE DEBUG
 character (len=NAMSFLEN)      :: sfnam, qidsfnam
 ! \DEBUG
 integer                       :: minp0, npli, inside, filetype0, iad
 integer, allocatable          :: ihu(:)             ! temp
 integer, allocatable          :: lnxbnd(:)          ! temp
 double precision, allocatable :: viuh(:)            ! temp
 double precision, allocatable :: tt(:)
 logical :: exist
 integer                       :: numz, numu, numq, numg, numd, numgen, npum, numklep, numvalv, nlat, jaifrcutp
 integer                       :: numnos, numnot, numnon ! < Nr. of unassociated flow links (not opened due to missing z- or u-boundary)

 double precision, allocatable :: xdum(:), ydum(:), xy2dum(:,:)
 integer, allocatable          :: kdum(:)
 integer, dimension(:), pointer:: pkbot, pktop

 double precision, allocatable :: grainlayerthickness(:,:) ! help array grain layer thickness

 double precision, allocatable :: sah(:)  ! temp
 double precision              :: fff     ! help
 double precision, allocatable :: hulp(:,:) ! hulp
 double precision, allocatable :: widths(:) ! hulp

 integer                       :: inivelx, inively !< set to 1 when initial velocity x or y component is available in *.ext file
 double precision, allocatable :: uxini(:), uyini(:) !< optional initial velocity fields on u points in x/y dir.

 integer                       :: iconst, itrac, iwqbot, janew, idum, isf, isednum, itp
 real(kind=hp)                 :: maxSearchRadius

 integer, external             :: findname
 double precision,  external   :: ran0
 logical, external             :: flow_init_structurecontrol

 integer                       :: L1, L2
 integer                       :: ilattype
 integer                       :: ifun
 character(len=20)             :: wqinput
 character(len=20)             :: wqbotunit
 logical                       :: hyst_dummy(2)
 double precision              :: area, width, hdx
 type(t_storage), pointer      :: stors(:)
 integer                       :: i, nstor

 iresult = DFM_NOERR

 success = .true.    ! default if no valid providers are present in *.ext file (m_flowexternalforcings::success)

 if (allocated(xdum  )) deallocate(xdum, ydum, kdum, xy2dum)
 allocate ( xdum(1), ydum(1), kdum(1), xy2dum(2,1) , stat=ierr)
 call aerr('xdum(1), ydum(1), kdum(1), xy2dum     ', ierr, 3)
 xdum = 1d0 ; ydum = 1d0; kdum = 1; xy2dum = 0d0

 call settimespacerefdat(refdat, julrefdat, Tzone, Timjan)

 inivel = 0 ! no initial velocity field loaded
 inivelx = 0
 inively = 0

 call initialize_ec_module()

 ! First initialize new-style StructureFile quantities.
 if (.not.flow_init_structurecontrol()) then
    iresult = DFM_EXTFORCERROR
    goto 888
 endif

 ! First initialize new-style IniFieldFile quantities.
 if (len_trim(md_inifieldfile) > 0) then
    inquire (file = trim(md_inifieldfile), exist = exist)
    if (exist) then
       iresult = initInitialFields(md_inifieldfile)
       if (iresult /= DFM_NOERR) then
          goto 888
       end if
    else
       call qnerror( 'Initial fields and parameters file '''//trim(md_inifieldfile)//''' not found.', '  ', ' ')
       write(msgbuf, '(a,a,a)') 'Initial fields and parameters file ''', trim(md_inifieldfile), ''' not found.'
       call warn_flush()
       iresult = DFM_EXTFORCERROR
       goto 888
    endif
 end if


 if (jatimespace == 0) goto 888                      ! Just cleanup and close ext file.

 !if (allocated(wx))           deallocate(wx,wy)              ! wind arrays are not deallocated here for use with bmi
 if (allocated(ec_pwxwy_x))   deallocate(ec_pwxwy_x)
 if (allocated(ec_pwxwy_y))   deallocate(ec_pwxwy_y)
 if (allocated(kcw))          deallocate(kcw)
 if (allocated(patm))         deallocate(patm)
 if (allocated(kbndz))        deallocate(xbndz,ybndz,xy2bndz,zbndz,kbndz,zbndz0)
 if (allocated(zkbndz))       deallocate(zkbndz)
 if(allocated(lnxbnd))        deallocate(lnxbnd)
 id_first_wind =  huge(id_first_wind)
 id_last_wind  = -huge(id_last_wind)

 allocate(lnxbnd(lnx-lnxi))

 n4 = 6
 if (nbndz > 0) then                                 ! now you know the elementsets for the waterlevel bnds
    allocate ( xbndz(nbndz), ybndz(nbndz), xy2bndz(2,nbndz), zbndz(nbndz), kbndz(n4,nbndz), zbndz0(nbndz), kdz(nbndz) , stat=ierr     )
    call aerr('xbndz(nbndz), ybndz(nbndz), xy2bndz(2,nbndz), zbndz(nbndz), kbndz(n4,nbndz), zbndz0(nbndz), kdz(nbndz)', ierr, nbndz*10 )
    if (jased > 1 .and. jaceneqtr == 2 .and. .not. stm_included) then
       if (allocated(zkbndz) ) deallocate (zkbndz, kbanz)
       allocate ( zkbndz(2,nbndz) ,stat= ierr    )
       call aerr('zkbndz(2,nbndz)',ierr, 2*nbndz )
       allocate ( kbanz(2,nbndz) ,stat= ierr    ) ; kbanz = 0
       call aerr('kban2(2,nbndz)',ierr, 2*nbndz )
    endif

    kbndz = 0 ; kdz = 1

    do k = 1, nbndz
       L          = kez(k)
       Lf         = lne2ln(L)
       kb         = ln(1,Lf)
       kbi        = ln(2,LF)

       xbndz(k)     = xe(L) ! xz(kb)
       ybndz(k)     = ye(L) ! yz(kb)
       zbndz0(k)    = dmiss
       xy2bndz(:,k) = xyen(:,L)

       kbndz(1,k) = kb
       kbndz(2,k) = kbi
       kbndz(3,k) = Lf
       kbndz(4,k) = itpez(k)
       kbndz(5,k) = itpenz(k)
       kbndz(6,k) = ftpet(k)

       !! hier vullen

       lnxbnd(Lf-lnxi) = itpenz(k)

       do n = 1,nd(kbi)%lnx
          L = iabs(nd(kbi)%ln(n))
          teta(L) = 1d0
       enddo

       if (iadvec /=0 .and. kcu(L) == -1) then
          iad = iadvec1D
       else
          iad = iadvec
       endif
       if (iad .ne. 0) then
           iadv(Lf) = 6   ! piaczeck upw
       else
           iadv(Lf) = 0
       endif

       if (jased > 1 .and. jaceneqtr == 2 .and. .not. stm_included) then
           zkbndz(1,k) = zk(lncn(1,Lf) )
           zkbndz(2,k) = zk(lncn(2,Lf) )
       endif


    enddo

    do k = 1,nbndz
       kbi = kbndz(2,k)
       Lf  = kbndz(3,k)
       if (iadvec /=0 .and. kcu(Lf) == -1) then
          iad = iadvec1D
       else
          iad = iadvec
       endif

       do k2 = 1,nd(kbi)%lnx
          L  = abs(nd(kbi)%ln(k2))
          if (L .ne. Lf) then
             if (iad .ne. 0) then
                iadv(L) = 6  ! piaczeck upw
             else
                iadv(L) = 0
             endif
          endif
       enddo
    enddo

 endif

 if (allocated(kbndu)) deallocate(  xbndu,ybndu,xy2bndu,zbndu,kbndu,zbndu0)
 if (allocated(zkbndu)) deallocate( zkbndu)
 if (allocated(zbndq)) deallocate(  zbndq)
 !if (allocated(zbndu_store)) deallocate(zbndu_store)
 if (allocated(sigmabndu)) deallocate(sigmabndu)
 if (allocated(zminmaxu)) deallocate(zminmaxu)
 if (nbndu > 0) then                                 ! similar for u bnd's
    allocate ( xbndu(nbndu), ybndu(nbndu), xy2bndu(2,nbndu), kbndu(n4,nbndu), kdu(nbndu) , stat=ierr)
    call aerr('xbndu(nbndu), ybndu(nbndu), xy2bndu(2,nbndu), kbndu(n4,nbndu), kdu(nbndu)', ierr, nbndu*(n4+5) )
    if (jased > 1 .and. jaceneqtr == 2 .and. .not. stm_included) then
       if (allocated (zkbndu) ) deallocate(zkbndu, kbanu)
       allocate ( zkbndu(2,nbndu) ,stat= ierr    )
       call aerr('zkbndu(2,nbndu)',ierr, 2*nbndu )
       allocate ( kbanu(2,nbndu) ,stat= ierr    ) ; kbanu = 0
       call aerr('kbanu(2,nbndu)',ierr, 2*nbndu )
    endif
    if (kmx >= 1) then
       allocate ( sigmabndu(kmx*nbndu) , stat=ierr )
       call aerr('sigmabndu(kmx*nbndu)', ierr, kmx*nbndu )
       allocate ( zminmaxu(2*nbndu) , stat=ierr )
       call aerr('zminmaxu(2*nbndu)', ierr, 2*nbndu )
       allocate(zbndu(nbndu*kmxd), stat=ierr)
       call aerr('zbndu(nbndu*kmxd)', ierr, nbndu*kmxd )
       allocate(zbndu0(nbndu*kmxd), stat=ierr) ! TODO: Spee/Reyns: the zbndu array was made 3D by Spee, but Reyns's zbndu0 changes have not been updated for this yet.
       call aerr('zbndu0(nbndu*kmxd)', ierr, nbndu*kmxd )
       allocate(zbndq(nbndu*kmxd), stat=ierr)
       call aerr('zbndq(nbndu*kmxd)', ierr, nbndu*kmxd )
    else
       allocate(zbndu(nbndu), stat=ierr)
       call aerr('zbndu(nbndu)', ierr, nbndu )
       allocate(zbndu0(nbndu), stat=ierr)
       call aerr('zbndu0(nbndu)', ierr, nbndu )
       allocate(zbndq(nbndu), stat=ierr)
       call aerr('zbndq(nbndu)', ierr, nbndu )
    endif

    !allocate ( zbndu_store(nbndu) , stat=ierr   )
    !call aerr('zbndu_store(nbndu)', ierr, nbndu )

    kbndu = 0 ; kdu = 1
    do k = 1, nbndu
       L          = keu(k)
       Lf         = lne2ln(L)
       kb         = ln(1,Lf)
       kbi        = ln(2,Lf)
       xbndu(k)   = xe(L) ! xz(kb)
       ybndu(k)   = ye(L) ! yz(kb)
       xy2bndu(:,k) = xyen(:,L)

       kbndu(1,k) = kb
       kbndu(2,k) = kbi
       kbndu(3,k) = Lf
       kbndu(4,k) = itpeu(k)
       kbndu(5,k) = itpenu(k)
       kbndu(6,k) = ftpet(k)       ! riemann relaxation time

       lnxbnd(Lf-lnxi) = itpenu(k)

      do n = 1,nd(kbi)%lnx
         L = iabs(nd(kbi)%ln(n))
         teta(L) = 1d0
      enddo

      iadv(Lf)   = -1                              ! switch off adv at open u-bnd's

      if (jased > 1 .and. jaceneqtr == 2 .and. .not. stm_included) then
          zkbndu(1,k) = zk(lncn(1,Lf) )
          zkbndu(2,k) = zk(lncn(2,Lf) )
      endif

    enddo

 endif

 if ( allocated   (kbnds) )  deallocate(  xbnds,ybnds,xy2bnds,zbnds,kbnds)
 if (jasal > 0) then
    if ( allocated(sigmabnds) ) deallocate(sigmabnds)
    if ( allocated(zminmaxs) ) deallocate(zminmaxs)
    if (nbnds > 0) then                                 ! salinity as for waterlevel bnds, but no kcs = -1
       numnos = 0
       allocate ( xbnds(nbnds), ybnds(nbnds), xy2bnds(2,nbnds), zbnds(kmxd*nbnds), kbnds(5,nbnds), kds(nbnds), stat=ierr     )
       call aerr('xbnds(nbnds), ybnds(nbnds), xy2bnds(2,nbnds), zbnds(kmxd*nbnds), kbnds(5,nbnds), kds(nbnds)', ierr, nbnds*9 )
       if ( kmx.gt.0 ) then   ! also allocate 3D-sigma bnd distribution for EC
          allocate ( sigmabnds(kmx*nbnds) )
          call aerr('sigmabnds(kmx*nbnds)', ierr, kmx*nbnds )
          allocate ( zminmaxs(2*nbnds) )
          call aerr('zminmaxs(2*nbnds)', ierr, 2*nbnds )
       end if

       zbnds   = DMISS ; kbnds = 0 ; kds = 1
       do k = 1, nbnds
          L          = kes(k)
          Lf         = lne2ln(L)
          if (Lf <= 0 .or. Lf > lnx) then
             numnos = numnos + 1
             cycle
          end if
          kb         = ln(1,Lf)
          kbi        = ln(2,Lf)
          if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's
             xbnds(k)   = xe(L) ! xz(kb)
             ybnds(k)   = ye(L) ! yz(kb)
             xy2bnds(:,k) = xyen(:,L)

             kbnds(1,k) = kb
             kbnds(2,k) = kbi
             kbnds(3,k) = Lf
             kbnds(5,k) = lnxbnd(Lf-lnxi)

          endif

       enddo
       if (numnos > 0) then
           rec = ' '
           write (rec, '(a,i6,a)') '(', numnos, ' points)'
           call qnerror('Salinity boundary (partially) unassociated. ', trim(rec), ' Open boundary required.')
           iresult = DFM_WRONGINPUT
           goto 888
           !nbnds = 0
           !jasal = 0
       end if

    endif

 endif

 if ( allocated   (kbndTM) )  deallocate(  xbndTM,ybndTM,xy2bndTM,zbndTM,kbndTM)
 if (jatem > 0) then
    if ( allocated(sigmabndTM) ) deallocate(sigmabndTM)
    if ( allocated(zminmaxTM) ) deallocate(zminmaxTM)
    if (nbndTM > 0) then                                 ! salinity as for waterlevel bnds, but no kcs = -1
       numnos = 0
       allocate ( xbndTM(nbndTM), ybndTM(nbndTM), xy2bndTM(2,nbndTM), zbndTM(kmxd*nbndTM), kbndTM(5,nbndTM), kdTM(nbndTM) , stat=ierr     )
       call aerr('xbndTM(nbndTM), ybndTM(nbndTM), xy2bndTM(2,nbndTM), zbndTM(kmxd*nbndTM), kbndTM(5,nbndTM), kdTM(nbndTM)', ierr, nbndTM*9 )
       if ( kmx.gt.0 ) then   ! also allocate 3D-sigma bnd distribution for EC
          allocate ( sigmabndTM(kmx*nbndTM) , stat=ierr )
          call aerr('sigmabndTM(kmx*nbndTM)', ierr, kmx*nbndTM )
          allocate ( zminmaxTM(2*nbndTM) , stat=ierr )
          call aerr('zminmaxTM(2*nbndTM)', ierr, 2*nbndTM )
       end if
       zbndTM = DMISS ;  kbndTM = 0 ; kdTM = 1
       do k = 1, nbndTM
          L = keTM(k)
          Lf = lne2ln(L)
          if (Lf <= 0 .or. Lf > lnx) then
             numnos = numnos + 1
             cycle
          end if
          kb         = ln(1,Lf)
          kbi        = ln(2,Lf)
          if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's

             xbndTM(k)     = xe(L) ! xz(kb)
             ybndTM(k)     = ye(L) ! yz(kb)
             xy2bndTM(:,k) = xyen(:,L)

             kbndTM(1,k)   = kb
             kbndTM(2,k)   = kbi
             kbndTM(3,k)   = Lf
             kbndTM(5,k) = lnxbnd(Lf-lnxi)

          else
             call qnerror("flow_initexternalforcings/TM: boundary not opened yet", ' ', ' ')
             continue
          endif

       enddo
       if (numnos > 0) then
           rec = ' '
           write (rec, '(a,i6,a)') '(', numnos, ' points)'
           call qnerror('Temperature boundary (partially) unassociated. ', trim(rec), ' Open boundary required.')
           iresult = DFM_WRONGINPUT
           goto 888
           !nbnds = 0
           !jasal = 0
       end if

    endif

 endif

 call init_1d2d()


! JRE ================================================================
 if (nbndw > 0 .and. .not. (jawave .eq. 4)) then
    call qnerror('Wave energy boundary defined without setting correct wavemodelnr. Wavemodelnr=4 required.',' ',' ')
    iresult = DFM_WRONGINPUT
 end if
 if (nbndw > 0) then
    numnos = 0
    !jawave = 4
    call mess(LEVEL_INFO, 'Enabled wave forcing while reading external forcings.')
    if (allocated   (kbndw) ) deallocate(  xbndw,ybndw,xy2bndw,zbndw,kbndw)
    allocate ( xbndw(nbndw), ybndw(nbndw), xy2bndw(2,nbndw), zbndw(ntheta,nbndw), kbndw(4,nbndw), kdw(nbndw) , stat=ierr     )
    call aerr('xbndw(nbndw), ybndw(nbndw), xy2bndw(2,nbndw), zbndw(ntheta,nbndw), kbndw(4,nbndw), kdw(nbndw)', ierr, nbndw*(9 + ntheta) )
    kbndw = 0 ; kdw = 1
    do k = 1, nbndw
       L          = kew(k)
       Lf         = lne2ln(L)
       if (Lf <= 0 .or. Lf > lnx) then
          numnos = numnos + 1
          cycle
       end if
       kb         = ln(1,Lf)
       kbi        = ln(2,Lf)
       if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's
          xbndw(k)   = xe(L) !xz(kb)
          ybndw(k)   = ye(L) !yz(kb)
          !xbndw(k) = xu(Lf)
          !ybndw(k) = yu(Lf)
          xy2bndw(:,k) = xyen(:,L)

          kbndw(1,k) = kb
          kbndw(2,k) = kbi
          kbndw(3,k) = Lf

       endif

    enddo
    if (numnos > 0) then
       rec = ' '
       write (rec, '(a,i6,a)') '(', numnos, ' points)'
       call qnerror('Wave energy boundary (partially) unassociated. ', trim(rec), ' Open boundary required.')
       iresult = DFM_WRONGINPUT
       goto 888
    end if

 endif
! ========================

 if (allocated(kbndsd)) deallocate(xbndsd,ybndsd,xy2bndsd,zbndsd,kbndsd)
 if (allocated   (sigmabndsd) ) deallocate(sigmabndsd)
 if (allocated   (zminmaxsd) ) deallocate(zminmaxsd)
 if (nbndsd > 0) then                                 ! sediment bnds as for waterlevel bnds, but no kcs = -1
    numnos = 0
    allocate ( xbndsd(nbndsd), ybndsd(nbndsd), xy2bndsd(2,nbndsd), zbndsd(nbndsd), kbndsd(5,nbndsd), kdsd(nbndsd) , stat=ierr     )
    call aerr('xbndsd(nbndsd), ybndsd(nbndsd), xy2bndsd(2,nbndsd), zbndsd(nbndsd), kbndsd(5,nbndsd), kdsd(nbndsd)', ierr, nbndsd*9 )
    if ( kmx.gt.0 ) then   ! also allocate 3D-sigma bnd distribution for EC
       allocate ( sigmabndsd(kmx*nbndsd) , stat=ierr )
       call aerr('sigmabndsd(kmx*nbndsd)', ierr, kmx*nbndsd )
       allocate ( zminmaxsd(2*nbndsd) , stat=ierr )
       call aerr('zminmaxsd(2*nbndsd)', ierr, 2*nbndsd )
    end if

    kbndsd = 0 ; kdsd = 1

    do k = 1, nbndsd
       L          = kesd(k)
       Lf         = lne2ln(L)
       if (Lf <= 0 .or. Lf > lnx) then
          numnos = numnos + 1
          cycle
       end if
       kb         = ln(1,Lf)
       kbi        = ln(2,Lf)
       if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's
          xbndsd(k)   = xe(L) ! xz(kb)
          ybndsd(k)   = ye(L) ! yz(kb)
          xy2bndsd(:,k) = xyen(:,L)

          kbndsd(1,k) = kb
          kbndsd(2,k) = kbi
          kbndsd(3,k) = Lf
          kbndsd(5,k) = lnxbnd(Lf-lnxi)

        endif

    enddo
    if (numnos > 0) then
        rec = ' '
        write (rec, '(a,i6,a)') '(', numnos, ' points)'
        call qnerror('Sediment boundary (partially) unassociated. ', trim(rec), ' Open boundary required.')
        iresult = DFM_WRONGINPUT
        goto 888
        !nbndsd = 0
        !jased  = 0
    end if

 endif


! tracers
 if (nbndtr_all > 0) then                                 ! sediment bnds as for waterlevel bnds, but no kcs = -1

!   deallocate
    call dealloc_bndarr(bndtr)

!   allocate
    allocate(bndtr(numtracers))

    do itrac=1,numtracers
       numnos = 0

       call alloc_bnd(nbndtr(itrac), kmx, bndtr(itrac))

       do k = 1, nbndtr(itrac)
          L          = ketr(k,itrac)
          Lf         = lne2ln(L)
          if (Lf <= 0 .or. Lf > lnx) then
             numnos = numnos + 1
             cycle
          end if
          kb         = ln(1,Lf)
          kbi        = ln(2,Lf)
          if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's

             bndtr(itrac)%name   = trim(trnames(itrac))
             bndtr(itrac)%x(k)   = xe(L) ! xz(kb)
             bndtr(itrac)%y(k)   = ye(L) ! yz(kb)
             bndtr(itrac)%xy2(:,k) = xyen(:,L)

             bndtr(itrac)%k(1,k) = kb
             bndtr(itrac)%k(2,k) = kbi
             bndtr(itrac)%k(3,k) = Lf
             bndtr(itrac)%k(5,k) = lnxbnd(Lf-lnxi)


           endif

           if (numnos > 0) then
              rec = ' '
              write (rec, '(a,i6,a)') '(', numnos, ' points)'
              call qnerror('Tracer boundary for '''//trim(bndtr(itrac)%name)//''' (partially) unassociated. ', trim(rec), ' Open boundary required.')
              iresult = DFM_WRONGINPUT
              goto 888
   !           nbndtr(itrac) = 0
   !           jatr  = 0
           end if

       enddo

    end do   ! itrac

 endif

 ! JRE DEBUG sedfracbnds
 if (stm_included) then
     if (nbndsf_all > 0) then
   !   deallocate
       call dealloc_bndarr(bndsf)
   !   allocate
       allocate(bndsf(numfracs))

       do isf=1,numfracs
          numnos = 0

          call alloc_bnd(nbndsf(isf), kmx, bndsf(isf))         ! 2D only for now

          do k = 1, nbndsf(isf)
             L          = kesf(k,isf)
             Lf         = lne2ln(L)
             if (Lf <= 0 .or. Lf > lnx) then
                numnos = numnos + 1
                cycle
             end if
             kb         = ln(1,Lf)
             kbi        = ln(2,Lf)
             if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's

                bndsf(isf)%name     = trim(sfnames(isf))
                bndsf(isf)%x(k)     = xe(L) ! xz(kb)
                bndsf(isf)%y(k)     = ye(L) ! yz(kb)
                bndsf(isf)%xy2(:,k) = xyen(:,L)

                bndsf(isf)%k(1,k)   = kb
                bndsf(isf)%k(2,k)   = kbi
                bndsf(isf)%k(3,k)   = Lf
                bndsf(isf)%k(5,k)   = lnxbnd(Lf-lnxi)
              endif

              if (numnos > 0) then
                  rec = ' '
                  write (rec, '(a,i6,a)') '(', numnos, ' points)'
                  call qnerror('Sediment fraction boundary for '''//trim(bndsf(isf)%name)//''' (partially) unassociated. ', trim(rec), ' Open boundary required.')
                  iresult = DFM_WRONGINPUT
                  goto 888
              end if
          enddo ! nbndsf(isf)
       end do   ! ised
    endif
 endif
 !\DEBUG


 if (allocated   (kbndt) ) deallocate(xbndt, ybndt, xy2bndt, zbndt, kbndt)
 if (nbndt > 0) then                                 ! Tangential velocity boundaries as u bnds
    numnos = 0
    allocate ( xbndt(nbndt), ybndt(nbndt), xy2bndt(2,nbndt), zbndt(nbndt), kbndt(4,nbndt), kdt(nbndt) , stat=ierr     )
    call aerr('xbndt(nbndt), ybndt(nbndt), xy2bndt(2,nbndt), zbndt(nbndt), kbndt(4,nbndt), kdt(nbndt)', ierr, nbndt*10 )
    kbndt = 0 ; kdt= 1
    do k = 1, nbndt
       L          = ket(k)
       Lf         = lne2ln(L)
       if (Lf <= 0 .or. Lf > lnx) then
          numnos = numnos + 1
          cycle
       end if
       kb         = ln(1,Lf)
       kbi        = ln(2,Lf)
       if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's
          xbndt(k)   = xe(L) ! xz(kb)
          ybndt(k)   = ye(L) ! yz(kb)
          xy2bndt(:,k) = xyen(:,L)

          kbndt(1,k) = kb
          kbndt(2,k) = kbi
          kbndt(3,k) = Lf

        endif
    enddo
    if (numnos > 0) then
        rec = ' '
        write (rec, '(a,i6,a)') '(', numnos, ' points)'
        call qnerror('Tangential boundary (partially) unassociated. ', trim(rec), ' Open boundary required.')
        iresult = DFM_WRONGINPUT
        goto 888
        !nbndt = 0
    end if
 endif

 if (allocated   (kbnduxy) ) deallocate(  xbnduxy,ybnduxy,xy2bnduxy,zbnduxy,kbnduxy)
 if (allocated   (sigmabnduxy) ) deallocate(sigmabnduxy)
 if (allocated   (zminmaxuxy) ) deallocate(zminmaxuxy)
 if (nbnduxy > 0) then                                 ! Tangential velocity boundaries as u bnds
    numnos = 0
    allocate ( xbnduxy(nbnduxy), ybnduxy(nbnduxy), xy2bnduxy(2,nbnduxy), zbnduxy(2*kmxd*nbnduxy), kbnduxy(4,nbnduxy), kduxy(nbnduxy) , stat=ierr     )
    call aerr('xbnduxy(nbnduxy), ybnduxy(nbnduxy), xy2bnduxy(2,nbnduxy), zbnduxy(2*kmxd*nbnduxy), kbnduxy(4,nbnduxy), kduxy(nbnduxy)', ierr, nbnduxy*10 )
    if ( kmx.gt.0 ) then   ! also allocate 3D-sigma bnd distribution for EC
       allocate ( sigmabnduxy(kmx*nbnduxy) , stat=ierr )
       call aerr('sigmabnduxy(kmx*nbnduxy)', ierr, kmx*nbnduxy )
       allocate ( zminmaxuxy(2*nbnduxy) , stat=ierr )
       call aerr('zminmaxuxy(2*nbnduxy)', ierr, 2*nbnduxy )
    end if

    kbnduxy= 0 ; kduxy= 1
    do k = 1, nbnduxy
       L          = keuxy(k)
       Lf         = lne2ln(L)
       if (Lf <= 0 .or. Lf > lnx) then
          numnos = numnos + 1
          cycle
       end if
       kb         = ln(1,Lf)
       kbi        = ln(2,Lf)
       if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's
          xbnduxy(k)   = xe(L) ! xz(kb)
          ybnduxy(k)   = ye(L) ! yz(kb)
          xy2bnduxy(:,k) = xyen(:,L)

          kbnduxy(1,k) = kb
          kbnduxy(2,k) = kbi
          kbnduxy(3,k) = Lf

        endif
    enddo
    if (numnos > 0) then
        rec = ' '
        write (rec, '(a,i6,a)') '(', numnos, ' points)'
        call qnerror('UxUy velocity boundary (partially) unassociated. ', trim(rec), ' Open boundary required.')
        iresult = DFM_WRONGINPUT
        goto 888
    end if
 endif

 if (allocated   (kbndn) ) deallocate(  xbndn,ybndn,xy2bndn,zbndn,kbndn)
 if (nbndn > 0) then                                 ! Normal velocity boundaries as z bnds
    numnos = 0
    allocate ( xbndn(nbndn), ybndn(nbndn), xy2bndn(2,nbndn), zbndn(nbndn), kbndn(4,nbndn), kdn(nbndn) , stat=ierr     )
    call aerr('xbndn(nbndn), ybndn(nbndn), xy2bndn(2,nbndn), zbndn(nbndn), kbndn(4,nbndn), kdn(nbndn)', ierr, nbndn*10 )
    kbndn = 0 ; kdn= 1
    do k = 1, nbndn
       L          = ken(k)
       Lf         = lne2ln(L)
       if (Lf <= 0 .or. Lf > lnx) then
          numnos = numnos + 1
          cycle
       end if
       kb         = ln(1,Lf)
       kbi        = ln(2,Lf)
       if (kcs(kb)   < 0 ) then                      ! if already opened by flow bnd's
          xbndn(k)   = xe(L) ! xz(kb)
          ybndn(k)   = ye(L) ! yz(kb)
          xy2bndn(:,k) = xyen(:,L)

          kbndn(1,k) = kb
          kbndn(2,k) = kbi
          kbndn(3,k) = Lf

          iadv(Lf)   = 77

        endif
    enddo
    if (numnos > 0) then
        rec = ' '
        write (rec, '(a,i6,a)') '(', numnos, ' points)'
        call qnerror('Normal boundary (partially) unassociated. ', trim(rec), ' Open boundary required.')
        iresult = DFM_WRONGINPUT
        goto 888
        !nbndn = 0
    end if
 endif

 if ( allocated(xe) ) then
    deallocate (xyen, xe, ye)
 endif
 if ( allocated(lnxbnd) ) then
    deallocate(lnxbnd)
 endif

 if (nshiptxy > 0) then
    if (allocated(shx) )   deallocate ( xyship, shx, shy, shu, shv, shi, sho )
    allocate ( xyship(2*nshiptxy), shx(nshiptxy), shy(nshiptxy), shu(nshiptxy), shv(nshiptxy), shi(nshiptxy), sho(nshiptxy) , stat= ierr)
    call aerr('xyship(2*nshiptxy), shx(nshiptxy), shy(nshiptxy), shu(nshiptxy), shv(nshiptxy), shi(nshiptxy), sho(nshiptxy)', ierr, 4*nshiptxy)
    iniship = 0 ; nshiptxy = 0 ; shx = 0d0 ; shy = 0d0; xyship = dmiss
 endif

 if (jased > 0) then
    mx = size(grainlay,2)
    allocate ( grainlayerthickness  (mx,mxgr) , stat=ierr) ; grainlayerthickness   = dmiss
 else
    mxgr = 0          ! jre dangerous...
 endif

 call setzminmax(); call setsigmabnds() ! our side of preparation for 3D ec module

 ! First initialize new-style ExtForceFileNew quantities.
 if (len_trim(md_extfile_new) > 0) then
    success = initboundaryblocksforcings(md_extfile_new)
    if (.not. success) then
      iresult = DFM_WRONGINPUT
      call mess(LEVEL_WARN, 'Error in external forcings file '''//trim(md_extfile_new)//'''.')
      call qnerror('Error occurred while running, please inspect your diagnostic output.',' ', ' ')
      goto 888
    end if
    if (.false.) then ! DEBUG
       call ecInstancePrintState(ecInstancePtr,callback_msg,LEVEL_DEBUG)
    end if
 endif

 ! Finish with all remaining old-style ExtForceFile quantities.
if (mext > 0) then
 ja = 1

 do while (ja .eq. 1)                                ! read *.ext file
    call delpol()                                    ! ook jammer dan
    maxSearchRadius = -1
    call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname,sourcemask,maxSearchRadius)
    if (ja == 1) then
        call resolvePath(filename, md_extfile_dir, filename)

        call mess(LEVEL_INFO, 'External Forcing or Initialising '''//trim(qid)//''' from file '''//trim(filename)//'''.')
        ! Initialize success to be .false.
        success = .false.

        qidnam = qid
        call get_tracername(qid, tracnam, qidnam)
        call get_sedfracname(qid, sfnam, qidnam)
        call get_waqinputname(qid, wqinput, qidnam)

        lenqidnam = len_trim(qidnam)
        if (filetype == 7 .and. method == 4) then
           method = 5                                   ! upward compatible fix
        endif

        kx  = 1                                      ! voorlopig vectormax = 1

        call init_spatial_extrapolation(maxSearchRadius, jsferic)

        if (qid == 'frictioncoefficient') then
           if (len_trim(md_inifieldfile) > 0) then
              call mess(LEVEL_WARN, 'Friction coefficients should be defined in file '''//trim(md_inifieldfile)//'''. Quantity '//trim(qid)//' ignored in external forcing file '''//trim(md_extfile)//'''.')
              cycle
           end if

            success = timespaceinitialfield(xu, yu, frcu, lnx, filename, filetype, method,  operand, transformcoef, 1) ! zie meteo module
            if (success) then
               if (transformcoef(3) .ne. -999d0 .and. int(transformcoef(3)) .ne. ifrctypuni .and. operand == 'O') then
                  do L = 1,lnx
                     if (frcu(L) .ne. dmiss) then
                         ! type array only must be used if different from uni
                         ifrcutp(L) = int( transformcoef(3) )
                     endif
                  enddo
               endif
            endif

        else if (qid == 'frictiontrtfactor') then

            if (jatrt /= 1) then
               call mess(LEVEL_WARN, 'Reading *.ext forcings file '''//trim(md_extfile)//''', getting QUANTITY '//trim(qid)//', but [trachytopes] is not switched on in MDU file. Ignoring this block.')
            else
               if (.not. allocated(cftrtfac) ) then
                  allocate ( cftrtfac(lnx), stat=ierr) ; cftrtfac = 1d0
                  call aerr('cftrtfac(lnx)', ierr, lnx)
               endif

               success = timespaceinitialfield(xu, yu, cftrtfac, lnx, filename, filetype, method,  operand, transformcoef, 1) ! zie meteo module
               if (success) then
                  jacftrtfac = 1
               endif
            end if

        else if (qid == 'linearfrictioncoefficient') then

            jafrculin = 1
            success = timespaceinitialfield(xu, yu, frculin, lnx, filename, filetype, method, operand, transformcoef, 1) ! zie meteo module

        else if (qid == 'internaltidesfrictioncoefficient') then
           if ( jaFrcInternalTides2D.ne.1 ) then   ! not added yet
!             (re)allocate
              if ( allocated(frcInternalTides2D) ) deallocate(frcInternalTides2D)
              allocate(  frcInternalTides2D(Ndx), stat=ierr)
              call aerr('frcInternalTides2D(Ndx)', ierr, Ndx)
              frcInternalTides2D = DMISS

              if ( allocated( DissInternalTidesPerArea) ) deallocate( DissInternalTidesPerArea)
              allocate(   DissInternalTidesPerArea(Ndx), stat=ierr)
              call aerr(' DissInternalTidesPerArea(Ndx)', ierr, Ndx)
              DissInternalTidesPerArea = 0d0

              jaFrcInternalTides2D = 1
           end if
           success = timespaceinitialfield(xz,yz, frcInternalTides2D, Ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module

        else if (qid == 'horizontaleddyviscositycoefficient') then

            if (javiusp == 0) then
               if (allocated (viusp) ) deallocate(viusp)
               allocate ( viusp(lnx) , stat=ierr )
               call aerr('viusp(lnx)', ierr, lnx ) ; viusp = dmiss
               javiusp = 1
            endif

            success = timespaceinitialfield(xu, yu, viusp, lnx, filename, filetype, method,  operand, transformcoef, 1) ! zie meteo module

        else if (qid == 'horizontaleddydiffusivitycoefficient') then

            if (jadiusp == 0) then
               if (allocated (diusp) ) deallocate(diusp)
               allocate ( diusp(lnx) , stat=ierr )
               call aerr('diusp(lnx)', ierr, lnx ) ; diusp = dmiss
               jadiusp = 1
            endif

            success = timespaceinitialfield(xu, yu, diusp, lnx, filename, filetype, method,  operand, transformcoef, 1) ! zie meteo module

        else if (qid == 'windstresscoefficient') then

            if (jaCdwusp == 0) then
               if (allocated (Cdwusp) ) deallocate(Cdwusp)
               allocate ( Cdwusp(lnx) , stat=ierr )
               call aerr('Cdwusp(lnx)', ierr, lnx ) ; Cdwusp = dmiss
               jaCdwusp = 1
            endif

            iCdtyp  = 1 ! only 1 coeff
            success = timespaceinitialfield(xu, yu, Cdwusp, lnx, filename, filetype, method,  operand, transformcoef, 1) ! zie meteo module

        else if (qid == 'windspeedfactor') then

            if (jawindspeedfac == 0) then
               if (allocated (Windspeedfac) ) deallocate(Windspeedfac)
               allocate ( Windspeedfac(lnx) , stat=ierr )
               call aerr('Windspeedfac(lnx)', ierr, lnx ) ; Windspeedfac = dmiss
            endif

            jawindspeedfac = 1 
            success = timespaceinitialfield(xu, yu, Windspeedfac, lnx, filename, filetype, method,  operand, transformcoef, 1) ! zie meteo module

        else if (qid == 'secchidepth') then

            if (jaSecchisp == 0) then
               if (allocated (Secchisp) ) deallocate(Secchisp)
               allocate ( Secchisp(ndx) , stat=ierr )
               call aerr('Secchisp(ndx)', ierr, lnx ) ; Secchisp = dmiss
               jaSecchisp = 1
            endif

            success = timespaceinitialfield(xz, yz, Secchisp, ndx, filename, filetype, method,  operand, transformcoef, 1) ! zie meteo module

        else if (qid == 'advectiontype') then

            success = timespaceinitialfield_int(xu, yu, iadv, lnx, filename, filetype, method, operand, transformcoef) ! zie meteo module

        else if (qid == 'ibedlevtype') then ! Local override of bottomleveltype

            success = timespaceinitialfield_int(xu, yu, ibot, lnx, filename, filetype, method, operand, transformcoef) ! zie meteo module

        else if (qid(1:17) == 'initialwaterlevel') then
           if (len_trim(md_inifieldfile) > 0) then
              call mess(LEVEL_WARN, 'Initial water level should be defined in file '''//trim(md_inifieldfile)//'''. Quantity '//trim(qid)//' ignored in external forcing file '''//trim(md_extfile)//'''.')
              cycle
           end if

           call realloc(kcsini, ndx, keepExisting=.false.)

           ! NOTE: we intentionally re-use the lateral coding here for selection of 1D and/or 2D flow nodes
           select case (trim(qid(18:)))
           case ('1d')
              ilattype = ILATTP_1D ; call prepare_lateral_mask(kcsini, ilattype)
           case ('2d')
              ilattype = ILATTP_2D ; call prepare_lateral_mask(kcsini, ilattype)
            case default
              kcsini = 1
           end select

           success = timespaceinitialfield(xz, yz, s1, ndx, filename, filetype, method, operand, transformcoef, 2, kcsini) ! zie meteo module

        else if (qid == 'initialvelocity') then ! both ucx and ucy component from map file in one QUANTITY

           if (filetype /= ncflow) then ! only from our own map files
              success = .false.
           else
              call realloc(uxini, lnx, fill=dmiss)
              qid = 'initialvelocityx'
              success = timespaceinitialfield(xu, yu, uxini, lnx, filename, filetype, method, operand, transformcoef, 1) ! zie meteo module
              if (success) then
                 call realloc(uyini, lnx, fill=dmiss)
                 qid = 'initialvelocityy'
                 success = timespaceinitialfield(xu, yu, uyini, lnx, filename, filetype, method, operand, transformcoef, 1) ! zie meteo module
                 if (success) then
                    inivel = 1
                 end if
              end if
           end if


        else if (qid == 'initialvelocityx') then

           call realloc(uxini, lnx, fill=dmiss)
           success = timespaceinitialfield(xu, yu, uxini, lnx, filename, filetype, method, operand, transformcoef, 1) ! zie meteo module
           if (success) then
              inivelx = 1
              if (inively == 1) then
                 inivel = 1
              end if
           end if

        else if (qid == 'initialvelocityy') then

           call realloc(uyini, lnx, fill=dmiss)
           success = timespaceinitialfield(xu, yu, uyini, lnx, filename, filetype, method, operand, transformcoef, 1) ! zie meteo module
           if (success) then
              inively = 1
              if (inivelx == 1) then
                 inivel = 1
              end if
           end if

        else if (qid == 'initialunsaturedzonethickness' .or. qid == 'interceptionlayerthickness') then

            if (.not. allocated (h_unsat) ) then
               allocate (h_unsat(ndx)) ; h_unsat = -999d0
            endif
            success = timespaceinitialfield(xz, yz, h_unsat, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
            where (h_unsat == -999d0) h_unsat = 0d0
            if ( qid == 'interceptionlayerthickness' ) then
               jaintercept2D = 1
            endif

        else if (qid == 'infiltrationcapacity') then
            if (infiltrationmodel >= 2) then
               success = timespaceinitialfield(xz, yz, infiltcap, ndx, filename, filetype, method,  operand, transformcoef, 1) ! zie meteo module
               infiltcap = infiltcap*1d-3/(24d0*3600d0)            ! mm/day => m/s
            else
               call mess(LEVEL_WARN, 'flow_initexternalforcings: quantity ' // trim(qid) // ' requires ''InfiltrationModel = 2'' in MDU. Skipping file '''//trim(filename)//'''.')
            end if

        else if (qid == '__bathymetry__') then ! this is for the D-Flow FM User interface!!!

            success = timespaceinitialfield(xk, yk, zk, numk, filename, filetype, method, operand, transformcoef, 3) ! zie meteo module

        else if (index(qid,'bedlevel') > 0) then  ! to suppress error message while actually doing this in geominit

            success = .true.

        else if (qid(1:15) == 'initialsediment') then

            if (jased > 0) then
               if (.not. allocated(sedh) ) then
                   allocate(sedh(ndx))
               endif
               isednum = 1
               if (qid(16:16) == '2') isednum = 2
               if (qid(16:16) == '3') isednum = 3
               if (qid(16:16) == '4') isednum = 4
               if (qid(16:16) == '5') isednum = 5
               if (qid(16:16) == '6') isednum = 6
               if (qid(16:16) == '7') isednum = 7
               if (qid(16:16) == '8') isednum = 8
               if (qid(16:16) == '9') isednum = 9

               sedh(1:ndx) = sed(isednum,1:ndx)
               success = timespaceinitialfield(xz, yz, sedh, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
               if (success) then
                  do kk = 1,ndx
                     if (sedh(kk) .ne. dmiss) then
                        do k = kbot(kk), kbot(kk) + kmxn(kk) - 1
                           sed(isednum,k) = sedh(kk)
                        enddo
                     endif
                  enddo
               endif
            else
               success = .true. ! We allow to disable salinity without removing the quantity.
            end if

        else if (qid == 'initialsalinity') then

            if (jasal > 0) then
               success = timespaceinitialfield(xz, yz, sa1, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
               if (success) then
                   inisal2D = 1
               endif
            else
               success = .true. ! We allow to disable salinity without removing the quantity.
            end if

        else if (qid == 'initialsalinitytop') then

            if (jasal > 0) then
               if (.not. allocated(satop) ) then
                  allocate(satop(ndx)) ; satop = dmiss
               endif
               success = timespaceinitialfield(xz, yz, satop, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
               if (success) then
                   inisal2D = 2 ; uniformsalinityabovez = transformcoef(3)
               endif
            else
               success = .true. ! We allow to disable salinity without removing the quantity.
            endif

        else if (qid == 'initialsalinitybot') then

            if (jasal > 0) then
               if (.not. allocated(sabot) ) then
                  allocate(sabot(ndx)) ; sabot = dmiss
               endif
               success = timespaceinitialfield(xz, yz, sabot, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
               if (success .and. transformcoef(3) .ne. dmiss) then
                   inisal2D = 3 ; uniformsalinitybelowz = transformcoef(3)
               endif
            else
               success = .true. ! We allow to disable salinity without removing the quantity.
            endif


        else if (jatem > 0 .and. qid == 'initialtemperature') then

            success = timespaceinitialfield(xz, yz, tem1, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
            if (success) then
                initem2D = 1
            endif

        else if (jatem > 0 .and. qid == 'initialverticaltemperatureprofile' .and. kmx > 0) then

            call setinitialverticalprofile(tem1, ndkx, filename) ; success = .true.

        else if (jasal > 0 .and. qid == 'initialverticalsalinityprofile' .and. kmx > 0) then

            call setinitialverticalprofile(sa1 , ndkx, filename) ; success = .true.

        else if (janudge > 0 .and. qid == 'nudgetime' ) then

            success = timespaceinitialfield(xz, yz, nudge_time, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module

        else if (janudge > 0 .and. qid == 'nudgerate' ) then

            success = timespaceinitialfield(xz, yz, nudge_rate, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module

        else if (stm_included .and. qid(1:14) == 'initialsedfrac') then
           call get_sedfracname(qid, sfnam, qidnam)
           iconst = 0
           if ( ISED1.gt.0 .and. trim(sfnam).ne.'') then
              iconst = findname(NUMCONST, const_names, sfnam)
           end if
           if (iconst>0) then
              if ( allocated(viuh) ) deallocate(viuh)     ! dummy array
              allocate(viuh(Ndkx))

              !          copy existing values (if they existed) in temp array
              !          this assumes uniform vertical distribution
              do kk=1,Ndx
                 viuh(kk) = constituents(iconst,kk)
                 call getkbotktop(kk,kb,kt)
                 do k=kb,kb+kmxn(kk)-1
                    viuh(k) = constituents(iconst,k)
                 end do
              end do

              success = timespaceinitialfield(xz, yz, viuh, Ndx, filename, filetype, method, operand, transformcoef, 2)

              if (success) then
                 do kk = 1,Ndx
                    if (viuh(kk) .ne. dmiss) then
                       sed(iconst-ISED1+1,kk) = viuh(kk)
                       call getkbotktop(kk,kb,kt)
                       do k=kb,kb+kmxn(kk)-1
                          sed(iconst-ISED1+1,k) = sed(iconst-ISED1+1,kk)     ! fill array with vertically uniform values
                       end do
                    endif
                 enddo
              endif
              deallocate(viuh)
           else
              call mess(LEVEL_WARN, 'Reading *.ext forcings file '''//trim(md_extfile)//''', getting unknown sediment fraction '''//trim(sfnam)//''' from QUANTITY '''//trim(qid)//'''.')
              call qnerror('Reading *.ext forcings file '''//trim(md_extfile)//''', getting unknown sediment fraction '''//trim(sfnam)//''' from QUANTITY '''//trim(qid)//'''.',' ',' ')
           end if
           
        else if (stm_included .and. qid(1:29) == 'initialverticalsedfracprofile' .and. kmx > 0) then
           call get_sedfracname(qid, sfnam, qidnam)
           iconst = 0
           if ( ISED1.gt.0 .and. trim(sfnam).ne.'') then
              iconst = findname(NUMCONST, const_names, sfnam)
           end if
           if (iconst>0) then
              allocate(tt(1:ndkx))
              tt = dmiss
              call setinitialverticalprofile(tt, ndkx, filename) ; success = .true.
              sed(iconst-ISED1+1,:)=tt
              deallocate(tt)
           endif
           
        else if (stm_included .and. qid(1:34) == 'initialverticalsigmasedfracprofile' .and. kmx > 0) then
           call get_sedfracname(qid, sfnam, qidnam)
           iconst = 0
           if ( ISED1.gt.0 .and. trim(sfnam).ne.'') then
              iconst = findname(NUMCONST, const_names, sfnam)
           end if
           if (iconst>0) then
              allocate(tt(1:ndkx))
              tt = dmiss
              call setinitialverticalprofilesigma(tt, ndkx, filename) ; success = .true.
              sed(iconst-ISED1+1,:)=tt
              deallocate(tt)
           endif

        else if (qid(1:13) == 'initialtracer') then
           call get_tracername(qid, tracnam, qidnam)
           call add_tracer(tracnam, iconst)  ! or just gets constituents number if tracer already exists
           itrac = findname(numtracers, trnames, tracnam)

           if ( itrac.eq.0 ) then
              call mess(LEVEL_ERROR, 'flow_initexternalforcings: tracer ' // trim(tracnam) // ' not found')
           end if
           iconst = itrac2const(itrac)

           if ( allocated(viuh) ) deallocate(viuh)
           allocate(viuh(Ndkx))

!          copy existing tracer values (if they existed) in temp array
           do kk=1,Ndx
              call getkbotktop(kk,kb,kt)
              viuh(kk) = constituents(iconst,kk)
              do k=kb,kb+kmxn(kk)-1
                 viuh(k) = constituents(iconst,k)
              end do
           end do

!          will only fill 2D part of viuh
           success = timespaceinitialfield(xz, yz, viuh, Ndx, filename, filetype, method, operand, transformcoef, 2)

           if (success) then
              do kk = 1,Ndx
                 if (viuh(kk) .ne. dmiss) then
                    constituents(iconst,kk) = viuh(kk)
                    call getkbotktop(kk,kb,kt)
                    do k=kb,kb+kmxn(kk)-1
!                       fff = constituents(iconst,k)
!                       call operate(fff, viuh(kk) , operand)
!                       constituents(iconst,k) = fff
                       constituents(iconst,k) = constituents(iconst,kk)
                    end do
                 endif
              enddo
           endif
           deallocate(viuh)

        else if (qid(1:13) == 'initialwaqbot') then
           iwqbot = findname(numwqbots, wqbotnames, wqinput)

           if ( iwqbot.eq.0 ) then
              call mess(LEVEL_ERROR, 'flow_initexternalforcings: water quality bottom variable ' // trim(wqinput) // ' not found')
           end if

           if ( allocated(viuh) ) deallocate(viuh)
           allocate(viuh(Ndxi))

!          copy existing tracer values (if they existed) in temp array
           do kk=1,Ndxi
              viuh(kk) = wqbot(iwqbot,kk)
           end do

!          will only fill 2D part of viuh
           success = timespaceinitialfield(xz, yz, viuh, Ndxi, filename, filetype, method, operand, transformcoef, 2)

           if (success) then
              do kk = 1,Ndxi
                 if (viuh(kk) .ne. dmiss) then
                    wqbot(iwqbot,kk) = viuh(kk)
                 endif
              enddo
           endif
           deallocate(viuh)

        else if (qid == 'stemdiameter') then

           if (.not. allocated(stemdiam) ) then
              allocate ( stemdiam(ndx) , stat=ierr ) ; stemdiam = dmiss
              call aerr('stemdiam(ndx)', ierr, ndx )
           endif
           success = timespaceinitialfield(xz, yz, stemdiam, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module

        else if (qid == 'stemdensity') then

           if (.not. allocated(stemdens) ) then
              allocate ( stemdens(ndx) , stat=ierr ) ; stemdens = dmiss
              call aerr('stemdens(ndx)', ierr, ndx )
           endif
           success = timespaceinitialfield(xz, yz, stemdens, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module

        else if (qid == 'stemheight') then

           if (.not. allocated(stemheight) ) then
              allocate ( stemheight(ndx) , stat=ierr ) ; stemheight = dmiss
              call aerr('stemheight(ndx)', ierr, ndx )
           endif
           success = timespaceinitialfield(xz, yz, stemheight, ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module

           if (stemheightstd > 0d0) then
              do k = 1,ndx
                 if (stemheightstd .ne. dmiss) then
                    stemheight(k) = stemheight(k)*( 1d0 + stemheightstd*( ran0(idum) - 0.5d0 ) )
                 endif
              enddo
           endif
        else if (qid == 'groundlayerthickness') then

           success = timespaceinitialfield(xu, yu, grounlay, Lnx1D, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
           if (success ) jagrounlay = 1

        else if (.not. stm_included .and. qid == 'erodablelayerthicknessgrainsize1' .and. mxgr >= 1) then

            if (jaceneqtr == 1) then
               success = timespaceinitialfield(xz, yz, grainlayerthickness(1,1), ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
            else
               mx = size(grainlay,2)
               success = timespaceinitialfield(xk, yk, grainlayerthickness(1,1), mx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
            endif
            jagrainlayerthicknessspecified = 1

        else if (.not. stm_included .and. qid == 'erodablelayerthicknessgrainsize2' .and. mxgr >= 2) then

            if (jaceneqtr == 1) then
               success = timespaceinitialfield(xz, yz, grainlayerthickness(1,2), ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
            else
               mx = size(grainlay,2)
               success = timespaceinitialfield(xk, yk, grainlayerthickness(1,2), mx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
            endif
            jagrainlayerthicknessspecified = 1

        else if (.not. stm_included .and. qid == 'erodablelayerthicknessgrainsize3' .and. mxgr >= 3) then

            if (jaceneqtr == 1) then
               success = timespaceinitialfield(xz, yz, grainlayerthickness(1,3), ndx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
            else
               mx = size(grainlay,2)
               success = timespaceinitialfield(xk, yk, grainlayerthickness(1,3), mx, filename, filetype, method, operand, transformcoef, 2) ! zie meteo module
            endif
            jagrainlayerthicknessspecified = 1

        else if (qid == 'windx' .or. qid == 'windy' .or. qid == 'windxy' .or. qid == 'stressxy') then

           jawindstressgiven = merge(1, 0, qid == 'stressxy')
           success = (.not. (jawindstressgiven == 1 .and. kmx > 0))
           if (.not. success) then
              msgbuf = "Quantity 'stressxy' not implemented for 3D (yet)"
              call err_flush()
           endif

           if (.not. allocated(kcw)) then
              call realloc(kcw, lnx, stat=ierr, keepExisting=.false.)
              call aerr('kcw(lnx)', ierr, lnx)
              kcw = 1
           endif
           if (.not. allocated(wx) ) then
              allocate ( wx(lnx), stat=ierr)
              call aerr('wx(lnx)', ierr, lnx)
              wx = 0.0_hp
           endif
           if (.not. allocated(wy) ) then
              allocate ( wy(lnx), stat=ierr)
              call aerr('wy(lnx)', ierr, lnx)
              wy = 0.0_hp
           endif

           if (len_trim(sourcemask)>0)  then
              success = ec_addtimespacerelation(qid, xu(1:lnx), yu(1:lnx), kcw, kx, filename, filetype, method, operand, srcmaskfile=sourcemask, varname=varname)
           else
              success = ec_addtimespacerelation(qid, xu(1:lnx), yu(1:lnx), kcw, kx, filename, filetype, method, operand, varname=varname)
           endif

           if (success) jawind = 1

        else if (qid == 'airpressure_windx_windy' .or. &
                 qid == 'airpressure_stressx_stressy' .or. &
                 qid == 'airpressure_windx_windy_charnock') then

           jawindstressgiven = merge(1, 0, qid == 'airpressure_stressx_stressy')
           jaspacevarcharn   = merge(1, 0, qid == 'airpressure_windx_windy_charnock')

           success = (.not. (jawindstressgiven == 1 .and. kmx > 0))

           if (.not. success) then
              msgbuf = "Quantity 'airpressure_stressx_stressy' not implemented for 3D (yet)"
              call err_flush()
           else
              if (.not. allocated(patm) ) then
                 allocate ( patm(ndx) , stat=ierr)
                 call aerr('patm(ndx)', ierr, ndx)
                 patm = 100000d0
              endif
              if (.not. allocated(wx) ) then
                 allocate ( wx(lnx), wy(lnx) , stat=ierr)
                 call aerr('wx(lnx), wy(lnx)', ierr, 2*lnx)
                 wx = 0d0 ; wy = 0d0
              endif
              if (.not. allocated(ec_pwxwy_x) ) then
                 allocate ( ec_pwxwy_x(ndx) , ec_pwxwy_y(ndx)  , stat=ierr)
                 call aerr('ec_pwxwy_x(ndx) , ec_pwxwy_y(ndx)' , ierr, 2*ndx)
                 ec_pwxwy_x = 0d0 ; ec_pwxwy_y = 0d0
              endif
              if (jaspacevarcharn == 1) then
                 if (.not. allocated(ec_pwxwy_c) ) then
                    allocate ( ec_pwxwy_c(ndx) , wcharnock(lnx), stat=ierr)
                    call aerr('ec_pwxwy_c(ndx), wcharnock(lnx)' , ierr, ndx+lnx)
                    ec_pwxwy_c = 0d0
                 endif
              endif
              call realloc(kcw, ndx, stat=ierr)
              call aerr('kcw(ndx)', ierr, ndx)
              kcw = 1

              if (len_trim(sourcemask)>0)  then
                 success = ec_addtimespacerelation(qid, xz(1:ndx), yz(1:ndx), kcw, kx, filename, filetype, method, operand, srcmaskfile=sourcemask, varname=varname)
              else
                 success = ec_addtimespacerelation(qid, xz(1:ndx), yz(1:ndx), kcw, kx, filename, filetype, method, operand, varname=varname)
              endif
           endif

           if (success) then
              jawind = 1
              japatm = 1
           endif

        else if (qid == 'humidity_airtemperature_cloudiness') then

           ! Meteo1
           kx = 3 ; itempforcingtyp = 1
           if (allocated (kcw) ) deallocate(kcw) ; allocate( kcw(ndx) ) ; kcw = 1
           jatair = 3 ; jarhum = 3 ; jaclou = 3 ; jasol = 2    ! flag all three in one line

           success = ec_addtimespacerelation(qid, xz(1:ndx), yz(1:ndx), kcw, kx, filename, filetype, method, operand, varname=varname) ! vectormax=3

        else if (qid == 'dewpoint_airtemperature_cloudiness') then

           ! Meteo1
           kx = 3 ; itempforcingtyp = 3
           if (allocated (kcw) ) deallocate(kcw) ; allocate( kcw(ndx) ) ; kcw = 1
           jatair = 3 ; jarhum = 4 ; jaclou = 3 ;   ! flag all four in one line
           ! nb: jarhum = 3 means relative humidity is being read directly as a fraction
           !     jarhum = 4 means dewpoint is read directly and still needs conversion to RH
           !     jarhum = 5 means wetbulb is read directly and still needs conversion to RH
           ! The relative-humidity arrays is used as (temporary) storage for the input

           success = ec_addtimespacerelation(qid, xz(1:ndx), yz(1:ndx), kcw, kx, filename, filetype, method, operand, varname=varname) ! vectormax = 3


        else if (qid == 'humidity_airtemperature_cloudiness_solarradiation') then

           ! Meteo1
           kx = 4 ; itempforcingtyp = 2
           if (allocated (kcw) ) deallocate(kcw) ; allocate( kcw(ndx) ) ; kcw = 1
           jatair = 3 ; jarhum = 3 ; jaclou = 3 ; jasol = 1    ! flag all four in one line

           success = ec_addtimespacerelation(qid, xz(1:ndx), yz(1:ndx), kcw, kx, filename, filetype, method, operand, varname=varname) ! vectormax = 4

        else if (qid == 'dewpoint_airtemperature_cloudiness_solarradiation') then

           ! Meteo1
           kx = 4 ; itempforcingtyp = 4
           if (allocated (kcw) ) deallocate(kcw) ; allocate( kcw(ndx) ) ; kcw = 1
           jatair = 3 ; jarhum = 4 ; jaclou = 3 ; jasol = 1    ! flag all four in one line
           ! nb: jarhum = 3 means relative humidity is being read directly as a fraction
           !     jarhum = 4 means dewpoint is read directly and still needs conversion to RH
           !     jarhum = 5 means wetbulb is read directly and still needs conversion to RH
           ! The relative-humidity arrays is used as (temporary) storage for the input

           success = ec_addtimespacerelation(qid, xz(1:ndx), yz(1:ndx), kcw, kx, filename, filetype, method, operand, varname=varname) ! vectormax = 4

        else if (qid == 'nudge_salinity_temperature') then
           kx = 2
           pkbot => kbot
           pktop => ktop

           if (allocated (kcw) ) deallocate(kcw) ; allocate( kcw(ndx) ) ; kcw = 1
           success = ec_addtimespacerelation(qid, xz(1:ndx), yz(1:ndx), kcw, kx, filename, filetype, method, operand, z=zcs, pkbot=pkbot, pktop=pktop, varname=varname)

           if ( success ) then
              janudge = 1
           else
              janudge = 0
           end if

        else if (qidnam == 'qhbnd') then ! specifically for QH-boundaries

           success = addtimespacerelation_boundaries(qid, filename, filetype, method, operand)

        else if (qidnam(max(1,lenqidnam-2):lenqidnam) == 'bnd') then ! All-in-one handler for boundary qids

           success = addtimespacerelation_boundaries(qid, filename, filetype, method, operand)

        else if (qid == 'airpressure' .or. qid == 'atmosphericpressure') then

           if (.not. allocated(patm) ) then
              allocate ( patm(ndx) , stat=ierr)
              call aerr('patm(ndx)', ierr, ndx)
              patm = 0d0
           endif
           success = ec_addtimespacerelation(qid, xz, yz, kcs, kx, filename, filetype, method, operand, varname=varname)
           if (success) then
              japatm = 1
           endif

        else if (qid == 'airtemperature') then

           if (.not. allocated(tair) ) then
              allocate ( tair(ndx) , stat=ierr)
              call aerr('tair(ndx)', ierr, ndx)
              tair = 0d0
           endif
           success = ec_addtimespacerelation(qid, xz, yz, kcs, kx, filename, filetype, method, operand, varname=varname)
           if (success) then
              jatair = 1 ; itempforcingtyp = 5
           endif

        else if (qid == 'humidity') then

           if (.not. allocated(rhum) ) then
              allocate ( rhum(ndx) , stat=ierr)  ; rhum = 0d0
              call aerr('rhum(ndx)', ierr, ndx)
           endif
           success = ec_addtimespacerelation(qid, xz, yz, kcs, kx, filename, filetype, method, operand, varname=varname)
           if (success) then
              jarhum = 1  ; itempforcingtyp = 5
           endif

        else if (qid == 'cloudiness') then

           if (.not. allocated(clou) ) then
              allocate ( clou(ndx) , stat=ierr)  ; clou = 0d0
              call aerr('clou(ndx)', ierr, ndx)
           endif
           success = ec_addtimespacerelation(qid, xz, yz, kcs, kx, filename, filetype, method, operand, varname=varname)
           if (success) then
              jaclou = 1 ; itempforcingtyp = 5
           endif

         else if (qid == 'solarradiation') then

           if (.not. allocated(qrad) ) then
              allocate ( qrad(ndx) , stat=ierr)  ; qrad = 0d0
              call aerr('qrad(ndx)', ierr, ndx)
           endif
           success = ec_addtimespacerelation(qid, xz, yz, kcs, kx, filename, filetype, method, operand, varname=varname)
           if (success) then
              jasol = 1 ;  itempforcingtyp = 5
           endif

        else if (qid(1:8) == 'rainfall' ) then

           if (.not. allocated(rain) ) then
              allocate ( rain(ndx) , stat=ierr) ; rain = 0d0
              call aerr('rain(ndx)', ierr, ndx)
           endif

           ! TODO: AvD: consider adding mask to all quantities.
           success = ec_addtimespacerelation(qid, xz, yz, kcs, kx, filename, filetype, method, operand, varname=varname)

           if (success) then
               jarain = 1
               jaqin = 1
           endif

        else if (qid(1:16) == 'lateraldischarge' ) then

           call ini_alloc_laterals()

           select case (trim(qid(17:)))
           case ('1d')
              ilattype = ILATTP_1D
           case ('2d')
              ilattype = ILATTP_2D
           case ('1d2d')
              ilattype = ILATTP_ALL
           case default
              ilattype = ILATTP_ALL
           end select

           call prepare_lateral_mask(kclat, ilattype)

           numlatsg = numlatsg + 1
           call realloc(nnlat, max(2*ndxi, nlatnd+ndxi), keepExisting = .true., fill = 0)
           call selectelset_internal_nodes(xz, yz, kclat, ndxi, nnLat(nlatnd+1:), nlat, &
                                          LOCTP_POLYGON_FILE, filename)
           n1latsg(numlatsg) = nlatnd + 1
           n2latsg(numlatsg) = nlatnd + nlat

           nlatnd = nlatnd + nlat

           jaqin = 1 ; success = .true.  ! geen gezeik, iedereen reik

        else if (jaoldstr > 0 .and. qid == 'gateloweredgelevel' ) then

           call selectelset_internal_links(xz, yz, ndx, ln, lnx, keg(ngate+1:numl), numg, LOCTP_POLYLINE_FILE, filename)
           success = .true.
           WRITE(msgbuf,'(a,1x,a,i8,a)') trim(qid), trim(filename) , numg, ' nr of gate links' ; call msg_flush()


           ngatesg = ngatesg + 1
           call realloc(L1gatesg,ngatesg) ; L1gatesg(ngatesg) = ngate + 1
           call realloc(L2gatesg,ngatesg) ; L2gatesg(ngatesg) = ngate + numg

           ngate   = ngate   + numg

        else if (jaoldstr > 0 .and. qid == 'damlevel' ) then

           call selectelset_internal_links(xz, yz, ndx, ln, lnx, ked(ncdam+1:numl), numd, LOCTP_POLYLINE_FILE, filename)
           success = .true.
           WRITE(msgbuf,'(a,1x,a,i8,a)') trim(qid), trim(filename) , numd, ' nr of dam level cells' ; call msg_flush()


           ncdamsg = ncdamsg + 1
           call realloc(L1cdamsg,ncdamsg) ; L1cdamsg(ncdamsg) = ncdam + 1
           call realloc(L2cdamsg,ncdamsg) ; L2cdamsg(ncdamsg) = ncdam + numd

           ncdam   = ncdam   + numd

        else if (jaoldstr > 0 .and. qid == 'generalstructure' ) then

           call selectelset_internal_links(xz, yz, ndx, ln, lnx, kegen(ncgen+1:numl), numgen, LOCTP_POLYLINE_FILE, filename, sortLinks = 1)
           success = .true.
           WRITE(msgbuf,'(a,1x,a,i8,a)') trim(qid), trim(filename) , numgen, ' nr of general structure cells' ; call msg_flush()

           ncgensg = ncgensg + 1
           call realloc(L1cgensg,ncgensg) ; L1cgensg(ncgensg) = ncgen + 1
           call realloc(L2cgensg,ncgensg) ; L2cgensg(ncgensg) = ncgen + numgen

           ncgen   = ncgen + numgen

        else if (jaoldstr > 0 .and. (qid == 'pump1D' .or. qid == 'pump') ) then

           if (qid == 'pump1D') then
              call selectelset_internal_links(xz, yz, ndx, ln, lnx1D, kep(npump+1:numl), npum, LOCTP_POLYLINE_FILE, filename, linktype = IFLTP_1D, sortLinks = 1)
           else
              call selectelset_internal_links(xz, yz, ndx, ln, lnx, kep(npump+1:numl), npum, LOCTP_POLYLINE_FILE, filename, linktype = IFLTP_ALL, sortLinks = 1)
           endif
           success = .true.
           WRITE(msgbuf,'(a,1x,a,i8,a)') trim(qid), trim(filename) , npum, ' nr of pump links' ; call msg_flush()


           npumpsg = npumpsg + 1
           call realloc(L1pumpsg,npumpsg) ; L1pumpsg(npumpsg) = npump + 1
           call realloc(L2pumpsg,npumpsg) ; L2pumpsg(npumpsg) = npump + npum

           npump   = npump   + npum

        else if (jaoldstr > 0 .and. qid == 'checkvalve' ) then

           call selectelset_internal_links(xz, yz, ndx, ln, lnx, keklep(nklep+1:numl), numklep, LOCTP_POLYLINE_FILE, filename)
           success = .true.
           WRITE(msgbuf,'(a,1x,a,i8,a)') trim(qid), trim(filename) , numklep, ' nr of checkvalves ' ; call msg_flush()

           nklep = nklep + numklep
           call realloc(Lklep,nklep) ; Lklep = keklep(1:nklep)

        else if (jaoldstr > 0 .and. qid == 'valve1D' ) then

           call selectelset_internal_links(xz, yz, ndx, ln, lnx1D, kevalv(nvalv+1:numl), numvalv, LOCTP_POLYLINE_FILE, filename, linktype = IFLTP_1D )
           success = .true.
           WRITE(msgbuf,'(a,1x,a,i8,a)') trim(qid), trim(filename) , numvalv, ' nr of valves ' ; call msg_flush()

           nvalv = nvalv + numvalv
           call realloc(Lvalv,nvalv) ; Lvalv = kevalv(1:nvalv) ; call realloc(valv,nvalv)


        else if (qid == 'discharge_salinity_temperature_sorsin') then

           ! 1. Prepare source-sink location (will increment numsrc, and prepare geometric position), based on .pli file (transformcoef(4)=AREA).
           call addsorsin(filename, transformcoef(4), ierr )
           if (ierr /= DFM_NOERR) then
              success = .false.
           else
              success = .true.
           end if

           ! 2. Time series hookup is done below, once counting of all numsrc is done.


        else if (qid == 'shiptxy') then
           kx = 2
           nshiptxy = nshiptxy + 1
           ! Converter will put 'x' in array(2*nshiptxy-1) and 'y' in array(2*nshiptxy). en welke array is dat?
           success  = ec_addtimespacerelation(qid, xdum, ydum, kdum, kx, filename, filetype, method, operand, targetIndex = nshiptxy)

        else if (qid == 'movingstationtxy') then
           kx = 2

           rec = ' '
           call basename(filename, rec) ! rec now contains the station name.
           call addMovingObservation(dmiss, dmiss, rec)

           ! Converter will put 'x' in array(2*nummovobs-1) and 'y' in array(2*nummovobs).
           success  = ec_addtimespacerelation(qid, xdum, ydum, kdum, kx, filename, filetype, method, operand, targetIndex=nummovobs)

        else if (qid(1:12) == 'waqparameter' .or. qid(1:18) == 'waqmassbalancearea' .or. qid(1:17) == 'waqmonitoringarea') then
           ! Already taken care of in m_fm_wq_processes
           success  =  .true.

        else if (qid(1:11) == 'waqfunction') then
           success = ec_addtimespacerelation(qid, xdum, ydum, kdum, kx, filename, filetype, method, operand)

        else if (qid(1:18) == 'waqsegmentfunction') then
           success = ec_addtimespacerelation(qid, xz, yz, kcs, kx, filename, filetype, method, operand, varname=varname)

        else if (trim(qid) == "spiderweb") then
           call qnerror(' ', 'Quantity SPIDERWEB must be renamed to airpressure_windx_windy in the ext-file.', ' ')
           success = .false.
        else if (trim(qid) == "windx_windy_airpressure") then
           call qnerror(' ', 'Quantity WINDX_WINDY_AIRPRESSURE must be renamed to airpressure_windx_windy in the ext-file.', ' ')
           success = .false.
        else
           call mess(LEVEL_WARN, 'Reading *.ext forcings file '''//trim(md_extfile)//''', getting unknown QUANTITY '//trim(qid) )
           call qnerror('Reading *.ext forcings file '''//trim(md_extfile)//''', ', ' getting unknown QUANTITY ', trim(qid) )
           success = .false.

        endif

        if (.not. success) then
            rec = getmeteoerror()
            if (len_trim(rec) > 0) then
               call mess(LEVEL_WARN, rec)
            end if
            ! We do a direct goto 888 end, so qnerror for GUI is allowed here.
            call qnerror('flow_initexternalforcings: Error while initializing quantity: ', qid, 'Check preceding log lines for details.')
            iresult = DFM_EXTFORCERROR
            goto 888
        endif

    endif

 enddo



 !  If no source/sink exists, then do not write related statistics to His-file
 if (numsrc < 0) then
    jahissourcesink = 0
    call mess(LEVEL_INFO, 'Source/sink does not exist, no related info to write.')
 endif

 !if (ngate == 0) ngatesg = 0
 !if (ncdam == 0) ncdamsg = 0
 !if (npump == 0) npumpsg = 0

 ! initialise water level of 1d2d boundary points
 if (nbnd1d2d>0) then
    call init_1d2d_boundary_points()
 endif

 !if (jaoldstr > 0 .and. ngate > 0) then
 if (jaoldstr > 0) then

    if (allocated (kgate) ) deallocate(kgate)
    if (allocated (xgate) ) deallocate(xgate)
    if (allocated (ygate) ) deallocate(ygate)
    if (allocated (zgate) ) deallocate(zgate)

    allocate ( xgate(ngatesg), ygate(ngatesg), zgate(ngatesg), xy2gate(2,ngatesg), kgate(3,ngate), kdg(ngatesg) , stat=ierr     )
    call aerr('xgate(ngatesg), ygate(ngatesg), zgate(ngatesg), xy2gate(2,ngatesg), kgate(3,ngate), kdg(ngatesg)',ierr, ngate*10 )
    kgate = 0d0; zgate = 1d10; kdg = 1

    if ( allocated(gate_ids) ) deallocate( gate_ids )
    allocate( gate_ids(ngatesg) )

    do n = 1, ngatesg

       do k = L1gatesg(n), L2gatesg(n)
          Lf           = iabs(keg(k))
          kb           = ln(1,Lf)
          kbi          = ln(2,Lf)
          kgate(1,k)   = kb
          kgate(2,k)   = kbi
          kgate(3,k)   = Lf

          xgate(n)     = xz(kb)
          ygate(n)     = yz(kb)
          xy2gate(1,n) = xz(kbi)
          xy2gate(2,n) = yz(kbi)

          if (kmx <= 1) then
             iadv(L) = 0
             call setfixedweirscheme3onlink(Lf)
          endif

       enddo

    enddo

    ja = 1
    if (mext > 0) then
       rewind (mext)
    end if
    kx = 1
    ngatesg = 0
    do while (ja .eq. 1)                             ! for gates again postponed read *.ext file
       call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname)
       if (ja == 1 .and. qid == 'gateloweredgelevel') then
          call resolvePath(filename, md_extfile_dir, filename)
          ngatesg = ngatesg + 1
          ! Prepare time series relation, if the .pli file has an associated .tim file.
          L = index(filename,'.', back=.true.) - 1
          filename0 = filename(1:L)//'_0001.tim'
          gate_ids(ngatesg) = filename(1:L)
          inquire (file = trim(filename0), exist = exist)
          if (exist) then
             filetype0 = uniform            ! uniform=single time series vectormax = 1
             success  = ec_addtimespacerelation(qid, xdum, ydum, kdum, kx, filename0, filetype0, method=spaceandtime, operand='O', targetIndex=ngatesg)
          else
             write (msgbuf, '(a,a,a)') 'No .tim-series file found for quantity gateloweredgelevel and file ''', trim(filename), '''. Keeping fixed (open) gate level.'
             call warn_flush()
             success = .true.
          end if
       endif
    enddo

 endif

 if (jaoldstr > 0 .and. ncdamsg > 0) then
    if (allocated   (xcdam)   ) deallocate( xcdam)
    if (allocated   (ycdam)   ) deallocate( ycdam)
    if (allocated   (zcdam)   ) deallocate( zcdam)
    if (allocated   (kcdam)   ) deallocate( kcdam)
    allocate ( xcdam(ncdamsg), ycdam(ncdamsg), zcdam(ncdamsg), xy2cdam(2,ncdamsg), kcdam(3,ncdam), kdd(ncdamsg) , stat=ierr     )
    call aerr('xcdam(ncdamsg), ycdam(ncdamsg), zcdam(ncdamsg), xy2cdam(2,ncdamsg), kcdam(3,ncdam), kdd(ncdamsg)',ierr, ncdam*10 )
    kcdam = 0d0; zcdam = 1d10; kdd = 1

    if ( allocated( cdam_ids ) ) deallocate( cdam_ids )
    allocate( cdam_ids(ncdamsg) )

    do n = 1, ncdamsg

       do k = L1cdamsg(n), L2cdamsg(n)
          Lf           = iabs(ked(k))
          kb           = ln(1,Lf)
          kbi          = ln(2,Lf)
          kcdam(1,k)   = kb
          kcdam(2,k)   = kbi
          kcdam(3,k)   = Lf

          xcdam(n)     = xz(kb)
          ycdam(n)     = yz(kb)
          xy2cdam(1,n) = xz(kbi)
          xy2cdam(2,n) = yz(kbi)

          iadv(Lf)     = 21
          call setfixedweirscheme3onlink(Lf)

       enddo

    enddo

    ja = 1 ; rewind (mext); kx = 1
    ncdamsg = 0
    do while (ja .eq. 1)                             ! for cdams again postponed read *.ext file
       call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname)
       if (ja == 1 .and. qid == 'damlevel') then
          call resolvePath(filename, md_extfile_dir, filename)
          ncdamsg = ncdamsg + 1
          ! Prepare time series relation, if the .pli file has an associated .tim file.
          L = index(filename,'.', back=.true.) - 1
          filename0 = filename(1:L)//'_0001.tim'
          cdam_ids(ncdamsg) = filename(1:L)
          inquire (file = trim(filename0), exist = exist)
          if (exist) then
             filetype0 = uniform            ! uniform=single time series vectormax = 1
             success  = ec_addtimespacerelation(qid, xdum, ydum, kdum, kx, filename0, filetype0, method=spaceandtime, operand='O', targetIndex=ncdamsg)
          else
             write (msgbuf, '(a,a,a)') 'No .tim-series file found for quantity damlevel and file ''', trim(filename), '''. Keeping fixed (closed) dam level.'
             call warn_flush()
             success = .true.
          end if
!          success = ec_addtimespacerelation(qid, xcdam, ycdam, kdd, filename, filetype, method, operand, xy2cdam)
       endif
    enddo

 endif

 if (nvalv > 0) then
    ja = 1 ; rewind (mext); kx = 1 ; nvalv = 0

    do while (ja .eq. 1)                             ! for cdams again postponed read *.ext file
       call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname)
       if (ja == 1 .and. qid(1:7) == 'valve1D') then
          call resolvePath(filename, md_extfile_dir, filename)
          nvalv = nvalv + 1

          L = index(filename,'.', back=.true.) - 1
          success = adduniformtimerelation_objects(qid, filename, 'valve1D', filename(1:L), 'flow', '', nvalv, 1, valv)
       endif 
    enddo
 endif

 if (numlatsg > 0) then ! Allow laterals from old ext, even when new structures file is present.

    call realloc(balat, numlatsg, keepExisting = .false., fill = 0d0)
    call realloc(qplat, numlatsg, keepExisting = .false., fill = 0d0)
    call realloc(lat_ids, numlatsg, keepExisting = .false., fill = '')
    call realloc(n1latsg, numlatsg, keepExisting = .false., fill = 0)
    call realloc(n2latsg, numlatsg, keepExisting = .false., fill = 0)

    do n = 1,numlatsg
       balat(n) = 0d0
       do k1=n1latsg(n),n2latsg(n)
          k = nnlat(k1)
          if (jampi == 1) then
             if (idomain(k) /= my_rank) then
                nnlat(k1) = 0
             endif
          endif
          k = nnlat(k1)
          if (k > 0) then
             balat(n) = balat(n) + ba(k)
          endif
       end do
    end do

    if (jampi == 1) then
       call reduce_double_sum(numlatsg, balat, qplat )  ! qplat is sum of balat over domains
       balat = qplat
       qplat = 0d0
    endif
    ja = 1 ; rewind (mext); kx = 1 ; numlatsg = 0

    do while (ja .eq. 1)                             ! for cdams again postponed read *.ext file
       call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname)
       if (ja == 1 .and. qid(1:16) == 'lateraldischarge') then
          call resolvePath(filename, md_extfile_dir, filename)
          numlatsg = numlatsg + 1

          L = index(filename,'.', back=.true.) - 1
          success = adduniformtimerelation_objects('lateral_discharge', filename, 'lateral', filename(1:L), 'discharge', '', numlatsg, kx, qplat)
          if (success) then
             ! assign id derived from pol file
             lat_ids(numlatsg) = filename(1:L)
          endif

          !! Check outside EC whether associated .tim file exists. should this check be inside addtimeetc
          !L = index(filename,'.', back=.true.) - 1
          !filename0 = filename(1:L)//'_0001.tim'
          !inquire (file = trim(filename0), exist = exist)
          !if (exist) then
          !   filetype0 = uniform            ! uniform=single time series vectormax = 1
          !   success  = ec_addtimespacerelation(qid(1:16), xdum, ydum, kdum, kx, filename0, filetype0, method=spaceandtime, operand='O', targetIndex=numlatsg)
          !else
          !   write (msgbuf, '(a,a,a)') 'No .tim-series file found for quantity lateraldischarge and file ''', trim(filename), '''. Keeping zero discharge (closed).'
          !   call warn_flush()
          !   success = .true.
          !end if
       endif
    enddo
    if (allocated(kclat)) then
       deallocate(kclat)
    endif
 endif

 if (jaoldstr > 0 .and. ncgensg > 0) then
    if (allocated   (xcgen)   ) deallocate( xcgen, ycgen, zcgen)
    if (allocated   (kcgen)   ) deallocate( kcgen)         ; kx = 3
    allocate ( xcgen(ncgensg), ycgen(ncgensg), zcgen(ncgensg*kx), xy2cgen(2,ncgensg), kcgen(4,ncgen), kdgen(ncgensg) , stat=ierr     )
    call aerr('xcgen(ncgensg), ycgen(ncgensg), zcgen(ncgensg*kx), xy2cgen(2,ncgensg), kcgen(4,ncgen), kdgen(ncgensg)',ierr, ncgen*10 )
    kcgen = 0d0; zcgen = 1d10; kdgen = 1


    if (allocated(fusav)) deallocate(fusav)
    if (allocated(rusav)) deallocate(rusav)
    if (allocated(ausav)) deallocate(ausav)
    allocate( Fusav(3,ncgen), Rusav(3,ncgen), Ausav(3,ncgen) , stat = ierr ) ; Fusav = 0d0 ; Rusav = 0d0 ; ausav = 0d0

    if ( allocated(cgen_ids) ) deallocate( cgen_ids )
    allocate( cgen_ids(ncgensg) )

       ! Temp array width wu(L) values for all links under a single general structure
    allocate(widths(ncgen+1)) ! +1: L1cgensg <=ncgen+1

    do n = 1, ncgensg
       ! Here allocate the structure ids for generalstructuyre

       do k = L1cgensg(n), L2cgensg(n)
          Lf           = iabs(kegen(k))
!          widths(k-L1cgensg(n)+1) = wu(Lf)
          widths(k) = wu(Lf)
          kb           = ln(1,Lf)
          kbi          = ln(2,Lf)
          if (kegen(k) > 0) then
             kcgen(1,k)   = kb
             kcgen(2,k)   = kbi
          else
             kcgen(1,k)   = kbi ! Store point left of the structure in kcgen(1,*) (in this case opposite to flow link, so kcgen(1,k)==ln(2,Lf)
             kcgen(2,k)   = kb
          end if

          kcgen(3,k)   = Lf
          kcgen(4,k)   = n              ! pointer to general structure signal nr n

          xcgen(n)     = xz(kb)
          ycgen(n)     = yz(kb)
          xy2cgen(1,n) = xz(kbi)
          xy2cgen(2,n) = yz(kbi)

          iadv(Lf)     = 22             ! iadv = general
          call setfixedweirscheme3onlink(Lf)

       enddo

    enddo

    allocate( hulp(26,ncgensg) ) ; hulp = dmiss

    ja = 1
    rewind (mext)
    kx = 3
    ncgensg = 0
    do while (ja .eq. 1)                             ! for cgens again postponed read *.ext file
       call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname)
       if (ja == 1 .and. qid == 'generalstructure') then
          call resolvePath(filename, md_extfile_dir, filename)
          ncgensg = ncgensg + 1
          ! Prepare time series relation, if the .pli file has an associated .tim file.
          L = index(filename,'.', back=.true.) - 1
          L1 = index( filename, '\', back = .true. )
          L2 = index( filename, '/', back = .true. )
          L1 = max( L1, L2 ) + 1
          filename0 = filename(1:L)//'_0001.tim'
          cgen_ids(ncgensg) = filename(L1:L)
          inquire (file = trim(filename0), exist = exist)
          if (exist) then
             filetype0 = uniform            ! uniform=single time series vectormax = kx = 3
             success  = ec_addtimespacerelation(qid, xdum, ydum, kdum, kx, filename0, filetype0, method=spaceandtime, operand='O', targetIndex=ncgensg)
          else
             write (msgbuf, '(a,a,a)') 'No .tim-series file found for quantity generalstructure and file ''', trim(filename), '''. Keeping fixed (closed) general structure.'
             call warn_flush()
             success = .true.
          end if
          !success = ec_addtimespacerelation(qid, xcgen, ycgen, kdgen, filename, filetype, method, operand, xy2cgen, targetIndex=(ncgensg-1)*3+1)
          hulp(:,ncgensg) = transformcoef(:)
       endif
    enddo

    if ( allocated(generalstruc) )   deallocate (generalstruc)
    allocate (generalstruc(ncgensg) )
    if ( allocated(cgen_type) )   deallocate (cgen_type)
    allocate (cgen_type(ncgensg) )
    cgen_type(1:ncgensg) = ICGENTP_GENSTRU ! We only have true fully parameterized general structures from old ext file

    do n = 1, ncgensg
       ! Set some zcgen values to their initial scalar values (for example, zcgen((n-1)*3+1) is quickly need for updating bobs.)
       zcgen((n-1)*3+1) = hulp( 6, n) ! levelcenter
       zcgen((n-1)*3+2) = hulp(11, n) ! gateheight  == 'gateloweredgelevel', really a level
       zcgen((n-1)*3+3) = hulp(26, n) ! door_opening_width

       call togeneral(n, hulp(:,n), L2cgensg(n)-L1cgensg(n)+1,widths(L1cgensg(n):L2cgensg(n))) ! orgcode
    enddo
    deallocate( hulp )
    deallocate(widths)

 endif

 if (jaoldstr > 0 .and. npump > 0) then
    if (allocated (xpump)    ) deallocate( xpump)
    if (allocated (ypump)    ) deallocate( ypump)
    if (allocated (qpump)    ) deallocate( qpump)
    if (allocated (kpump)    ) deallocate( kpump)
    if (allocated (pumponoff)) deallocate( pumponoff)
    allocate ( xpump(npumpsg), ypump(npumpsg), qpump(npumpsg), xy2pump(2,npumpsg), kpump(3,npump), kdp(npumpsg) , stat=ierr     )
    call aerr('xpump(npumpsg), ypump(npumpsg), qpump(npumpsg), xy2pump(2,npumpsg), kpump(3,npump), kdp(npumpsg)',ierr, npump*10 )
    kpump = 0d0; qpump = 0d0; kdp = 1

    if ( allocated( pump_ids ) ) deallocate( pump_ids )
    allocate( pump_ids(npumpsg) ) ! TODO: names are not stored here yet (they are in init_structure_control, but not for old ext file)
    allocate( pumponoff(5,npumpsg) ) ; pumponoff = dmiss


    do n = 1, npumpsg

       pumponoff(5,n) = 0
       do k = L1pumpsg(n), L2pumpsg(n)
          L             = kep(k)
          Lf            = iabs(L)
          if (L > 0) then
             kb         = ln(1,Lf)
             kbi        = ln(2,Lf)
          else
             kb         = ln(2,Lf)
             kbi        = ln(1,Lf)
          endif
          kpump(1,k)    = kb
          kpump(2,k)    = kbi
          kpump(3,k)    = L ! f

          xpump(n)      = xz(kb)
          ypump(n)      = yz(kb)
          xy2pump(1,n)  = xz(kbi)
          xy2pump(2,n)  = yz(kbi)
       enddo

    enddo

    ja = 1 ; rewind (mext); kx = 1
    npumpsg = 0
    do while (ja .eq. 1)                             ! for pumps again postponed read *.ext file
       call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname)
       if (ja == 1 .and. ( qid == 'pump1D' .or. qid == 'pump') ) then
          call resolvePath(filename, md_extfile_dir, filename)
          qid = 'pump'
          npumpsg = npumpsg + 1
          success = ec_addtimespacerelation(qid, xpump, ypump, kdp, kx, filename, filetype, method, operand, xy2pump, targetIndex=npumpsg)
          if ( transformcoef(4) /= dmiss ) pumponoff(1,npumpsg) = transformcoef(4)
          if ( transformcoef(5) /= dmiss ) pumponoff(2,npumpsg) = transformcoef(5)
          if ( transformcoef(6) /= dmiss ) pumponoff(3,npumpsg) = transformcoef(6)
          if ( transformcoef(7) /= dmiss ) pumponoff(4,npumpsg) = transformcoef(7)
       endif
    enddo

 endif

 if (numsrc > 0) then


    ja = 1 ; rewind (mext)
    kx = numconst+1
    ! TODO: UNST-537/UNST-190: we now support timeseries, the constant values should come from new format ext file, not from transformcoef
    numsrc = 0
    do while (ja .eq. 1)                                 ! for sorsin again read *.ext file
       call readprovider(mext,qid,filename,filetype,method,operand,transformcoef,ja,varname)
       if (ja == 1 .and. qid == 'discharge_salinity_temperature_sorsin') then
          call resolvePath(filename, md_extfile_dir, filename)

          numsrc = numsrc + 1
          ! 2. Prepare time series relation, if the .pli file has an associated .tim file.
          L = index(filename,'.', back=.true.) - 1
          filename0 = filename(1:L)//'.tim'
          inquire (file = trim(filename0), exist = exist)
          if (exist) then
             filetype0 = uniform            ! uniform=single time series vectormax = ..
             ! Converter will put 'qsrc, sasrc and tmsrc' values in array qstss on positions: (3*numsrc-2), (3*numsrc-1), and (3*numsrc), respectively.
             success  = ec_addtimespacerelation(qid, xdum, ydum, kdum, kx, filename0, filetype0, method=spaceandtime, operand='O', targetIndex=numsrc)
          else
             success = .true. ! TODO: now, this is no error, because sorsin values will be handled below as transformcoef. Long term solution: only support timeseries??
          endif
       endif
    enddo
 endif


endif ! read mext file

 if (loglevel_StdOut == LEVEL_DEBUG) then
    call ecInstancePrintState(ecInstancePtr,callback_msg,LEVEL_DEBUG)
 endif

 if (.not. success) then
    iresult = DFM_EXTFORCERROR
    goto 888
 end if

! Cleanup:
888 continue
 if (jafrculin == 0 .and. allocated(frculin) ) then
    deallocate(frculin)
 endif

 if (allocated(kez)) then  ! mext > 0 .or. len_trim(md_extfile_new) > 0) then
    deallocate ( kez, keu, kes, ketm, kesd, ket, keuxy, ken, ke1d2d, keg, ked, kep, kedb, keklep, kevalv, kegs, kegen, itpez, itpenz, itpeu, itpenu, kew, ketr)
end if

 if (mext > 0) then
    call doclose(mext) ! close ext file
 end if

 if (allocated (xdum))     deallocate( xdum, ydum, kdum)
 if (allocated (kdz))      deallocate (kdz)
 if (allocated (kdu))      deallocate (kdu)
 if (allocated (kds))      deallocate (kds)
 if (allocated (kdTM))     deallocate (kdTM)
 if (allocated (kdw))      deallocate (kdw)
 if (allocated (kdsd))     deallocate (kdsd)
! if (allocated (kdtr))     deallocate (kdtr)
 if (allocated (kdt))      deallocate (kdt)
 if (allocated (kduxy))    deallocate (kduxy)
 if (allocated (kdn))      deallocate (kdn)
 if (allocated (kdg))      deallocate (kdg)
 if (allocated (kdd))      deallocate (kdd)
 if (allocated (kdgen))    deallocate (kdgen)
 if (allocated (kdp))      deallocate (kdp)
 if (allocated (kdss))     deallocate (kdss)

 if (allocated (xy2gate) ) deallocate (xy2gate)
 if (allocated (xy2cdam) ) deallocate (xy2cdam)
 if (allocated (xy2cgen) ) deallocate (xy2cgen)

 if (allocated (xy2pump) ) deallocate (xy2pump)

 if (allocated (xdum)    ) deallocate( xdum, ydum, kdum, xy2dum)

 if (jasol == 2) then
     if (allocated (qrad) ) deallocate (qrad)
 endif

 if (mxgr > 0 .and. .not.stm_included) then

    do j = 1,mxgr
       grainlay(j,:) = uniformerodablethickness(j)
    enddo

    if (jagrainlayerthicknessspecified == 1) then

       do k = 1,size(grainlay,2)
          do j = 1,mxgr
             if (grainlayerthickness(k,j) .ne. dmiss) then
                grainlay(j,k) = grainlayerthickness(k,j)
             endif
          enddo
       enddo

       deallocate (grainlayerthickness)
    else

    endif

 endif

 if (jawind == 0) then
     if (jawave > 0 .and. jawave < 3) then
         jawave = 0     ! no wind, no waves
         call mess(LEVEL_INFO, 'No wind, so waves is switched off ')
     endif
     if (jatem > 1) then
         jatem = 1      ! no wind, no heat model temperature
         call mess(LEVEL_INFO, 'No wind ?? => no heat model !')
     endif
 endif

 if (javiusp == 1) then
     do L = 1,lnx
        if (viusp(L) == dmiss) then
            viusp(L) = vicouv
        endif
     enddo
 endif

 if (jadiusp == 1) then
     do L = 1,lnx
        if (diusp(L) == dmiss) then
            diusp(L) = dicouv
        endif
     enddo
 endif

 if (jaSecchisp > 0) then
     do n = 1,ndx
        if (Secchisp(n) == dmiss) then
            Secchisp(n) = Secchidepth
        endif
     enddo
 endif

 if (inivel == 1) then
    do L=1,lnx
       if (uxini(L) == dmiss .and. uyini(L) == dmiss) then
          cycle
       end if

       u1(L) = uxini(L)*csu(L) + uyini(L)*snu(L)

! Lt not set
!       if (kmx > 0) then  ! Basic 3D initialization: entire water column same horizontal velocities u1.
!          call getLbotLtop(L,Lb,Lt)
!          u1(Lb:Lt) = u1(L)
!       end if

    end do

 else if (inivelx == 1) then ! only x component imposed
    do L=1,lnx
       if (uxini(L) == dmiss) then
          cycle
       end if

       u1(L) = uxini(L)*csu(L)
    end do

 else if (inively == 1) then ! only y component imposed
    do L=1,lnx
       if (uyini(L) == dmiss) then
          cycle
       end if

       u1(L) = uyini(L)*snu(L)
    end do

  end if

 if (allocated(uxini)) deallocate(uxini)
 if (allocated(uyini)) deallocate(uyini)

 if (javeg > 0) then
    call realloc(  rnveg, Ndkx, keepExisting=.false., fill=0d0, stat=ierr)
    call aerr   (' rnveg (Ndkx)', ierr, Ndkx)
    call realloc( diaveg, Ndkx, keepExisting=.false., fill=0d0, stat=ierr)
    call aerr   ('diaveg (Ndkx)', ierr, Ndkx)

    if (jaCdvegsp > 0) then
       call realloc( Cdvegsp, Ndkx, keepExisting=.false., fill=0d0, stat=ierr)
       call aerr   ('Cdvegsp (Ndkx)', ierr, Ndkx)
    endif

    javeg = 1
    if (.not.allocated(stemheight) .and. japillar == 2) then
       call realloc(  stemheight, Ndkx, keepExisting=.false., fill=0d0, stat=ierr)
       call aerr   (' stemheight (Ndkx)', ierr, Ndkx)
    endif

    if ( allocated(stemdiam) .and. allocated(stemdens) ) then
       do k = 1,ndx
          if (stemdens(k) > 0d0) then
             rnveg(k) = stemdens(k)
             diaveg(k) = stemdiam(k)
          endif
          if (stemheight(k) == dmiss) stemheight(k) = 0d0
       enddo
       deallocate (stemdiam, stemdens)
    endif

    if (kmx == 0) then
       if (jabaptist >= 3) then
          call realloc(  alfaveg, Lnx, keepExisting=.false., fill=0d0, stat=ierr)
          call aerr   (' alfaveg (Lnx)', ierr, Lnx)
          call realloc(  cfuveg,  Lnx, keepExisting=.false., fill=0d0, stat=ierr)
          call aerr   (' cfuveg  (Lnx)', ierr, Lnx)
       endif
       if (jabaptist >= 2) then
          call realloc(  alfav, Lnx, keepExisting=.false., fill=0d0, stat=ierr)
          call aerr   (' alfav (Lnx)', ierr, Lnx)
       endif
    endif

    if ( rhoveg .ne. dmiss ) then
        call realloc(  phiv ,Ndx, keepExisting=.false., fill=0d0, stat=ierr)
        call realloc(  phivt,Ndx, keepExisting=.false., fill=0d0, stat=ierr)
    endif

 endif

 if ((jatrt>0) .and. trachy_resistance) then
     call realloc(  alfav, Lnx, keepExisting=.false., fill=0d0, stat=ierr)
     call aerr   (' alfav (Lnx)', ierr, Lnx)
 endif

 if (jagrounLay == 1) then
    IF (ALLOCATED (wigr) ) deallocate (wigr, argr, pergr)
    allocate  ( argr(lnx1D) , stat= ierr)  ; argr  = 0d0
    call aerr ('argr(lnx1D)', ierr, Lnx1D)
    allocate  ( wigr(lnx1D) , stat= ierr)  ; wigr  = 0d0
    call aerr ('wigr(lnx1D)', ierr, Lnx1D)
    allocate  ( pergr(lnx1D) , stat= ierr) ; pergr = 0d0
    call aerr ('pergr(lnx1D)', ierr, Lnx1D)
    do L = 1,lnx1D
       if (grounlay(L) == dmiss) then
          if (grounlayuni > 0) then
             grounlay(L) = grounlayuni
          else
             grounlay(L) = 0d0
          endif
       endif
    enddo
    jagrounlay = 0
    do L = 1,lnx1D
       itp = prof1D(3,L)
       if (grounlay(L) > 0d0 .and. iabs(itp) <= 3) then
          call getprof_1D(L, grounlay(L), argr(L), wigr(L), 1, 1, pergr(L))
       endif
    enddo
    jagrounlay = 1
 else
    deallocate(grounlay)
 endif

 if ( jampi.eq.1 ) then
!   see if one or more discharge boundaries are partioned
    call set_japartqbnd()
    if ( japartqbnd.ne.0 ) call mess(LEVEL_WARN,'One or more discharge boundaries are partitioned.')
 else
    japartqbnd = 0
 end if

!   For parallel simulation initialize array ibnd_own and scalar ndxbnd_own, discarding ghost boundary points
 if (jampi > 0) then
    ndxbnd_own = 0      ! Nr. of boundary points without ghost boundary points
    call realloc(ibnd_own,    ndx-ndxi, stat = ierr, keepExisting = .false.)
    ibnd_own = 0

    do n = 1, ndx - ndxi
       kk = ln(2, lnxi+n) ! kk is the interior cell that connects by link lnxi+n to the current boundary points
       if (idomain(kk) == my_rank) then
          ndxbnd_own = ndxbnd_own + 1
          ibnd_own(ndxbnd_own) = n
       endif
    enddo
 endif

 if ( allocated(frcuroofs) ) then
    do L = 1,lnxi
       if (frcuroofs(L) .ne. dmiss) then
          frcu(L) = frcuroofs(L)
       endif
    enddo
    deallocate( frcuroofs)
 endif

 if ( allocated(infiltcaproofs) ) then
     do n = 1,ndxi
        if (infiltcaproofs(n) .ne. dmiss) then
           infiltcap(n) = infiltcaproofs(n)
        endif
     enddo
     deallocate( infiltcaproofs )
 endif

 if (jaevap == 0 .and. jarain == 0) then
    a1ini = sum( ba(1:ndxi) )
 else
    if (allocated (bare) ) deallocate(bare)
    allocate ( bare(ndxi)  , stat=ierr ) ! base area for rainfall / evaporation
    call aerr('bare(ndxi)' , ierr, ndx ) ;
    bare(1:ndxi) = ba(1:ndxi)

    if (network%loaded) then
       bare(ndx2D+1:ndxi) = 0d0
       do L = 1,lnx1D                                             ! for all links, set link width
          k1    = ln(1,L)
          k2    = ln(2,L)
          if (kcu(L) == 1) then
                ! Calculate maximal total area by using a water depth of 1000 m.
                hyst_dummy = .false.
                call GetCSParsTotal(network%adm%line2cross(L), network%crs%cross, 1d3, area, width, CS_TYPE_NORMAL,hyst_dummy)

                hdx = 0.5d0*dx(L)
                if (k1 > ndx2d) bare(k1) = bare(k1) + hdx*width
                if (k2 > ndx2d) bare(k2) = bare(k2) + hdx*width
             endif
       enddo
    endif

    nstor = network%stors%count
    if (nstor > 0) then
       stors => network%stors%stor
       do i = 1, nstor
          k1 = stors(i)%gridPoint
          ! Add storage area to BA by using a water depth of 1000 m
          bare(k1)   = bare(k1)   + getSurface(stors(i), bl(k1) + 1d3) ! TODO: needs change! Don't catch rain on storage area, only on manhole area.
       enddo
    endif


    do n = ndx2D+1, ndxi
       if (kcs(n) == 1) then
          call IN2Dflowcell(Xz(n),Yz(n),ja)
          if (ja >= 1) then
             bare(n) = 0d0
          endif
       endif
    enddo
    a1ini = sum(bare(1:ndxi))
 endif

 if (allocated(kcsini)) then
    deallocate(kcsini)
 end if

 ! Copy NUMCONST to NUMCONST_MDU, before the user (optionally) adds tracers interactively
 NUMCONST_MDU = NUMCONST

 end function flow_initexternalforcings


 subroutine setinitialverticalprofile(yy,ny,filename) ! polyfil
 use m_flowgeom
 use m_flow
 use m_polygon
 implicit none
 integer                   :: ny
 double precision          :: xx(kmxx)
 double precision          :: yy(ny)
 character(*),  intent(in) :: filename              ! file name for polygonfile

 integer :: minp0, n, k, kb, kt, ktx

 call oldfil(minp0, filename)
 call savepol()
 call reapol(minp0, 0)

 do n=1,ndxi
    call getkbotktop(n,kb,kt)
    do k = kb, kt
       xx(k-kb+1) = 0.5d0*( zws(k) + zws(k-1) )
    enddo
    ktx = kt-kb + 1
    call lineinterp(xx, yy(kb:), ktx, xpl, ypl, npl)
 enddo

 call restorepol()

 end subroutine setinitialverticalprofile
 
subroutine setinitialverticalprofilesigma(yy,ny,filename) ! polyfil
 use m_flowgeom
 use m_flow
 use m_polygon
 implicit none
 integer                   :: ny
 double precision          :: xx(kmxx),xxx(kmxx)
 double precision          :: yy(ny)
 character(*),  intent(in) :: filename              ! file name for polygonfile

 integer                   :: minp0, n, k, kb, kt, ktx 

 call oldfil(minp0, filename)
 call savepol()
 call reapol(minp0, 0)

 do n=1,ndxi
    call getkbotktop(n,kb,kt)
    do k = kb, kt
       xx(k-kb+1) = zws(k)-zws(k-1)  
    enddo
    xx(1) = xx(1)/(s1(n)-bl(n))  ! upper layer face values
    do k = kb+1,kt
       xx(k-kb+1) = xx(k-kb+1)/(s1(n)-bl(n)) + xx(k-kb)  
    enddo
    xxx(1) = 0.5d0*xx(1)   ! cell centre coordinate values
    do k = kb+1,kt
       xxx(k-kb+1) = 0.5d0*(xx(k-kb+1)+xx(k-kb))
    enddo
    
    ktx = kt-kb + 1
    call lineinterp(xxx, yy(kb:), ktx, xpl, ypl, npl)
 enddo

 call restorepol()

 end subroutine setinitialverticalprofilesigma

 subroutine lineinterp(xx, yy, ktx, x,y,n)
 implicit none
 integer          :: ktx, n, k, ip
 double precision :: xx(ktx), yy(ktx), x(n), y(n)
 double precision :: a, b


 ip = 1
 do k = 1, ktx
    do while ( xx(k) > x(ip+1) .and. ip < n-1 )
       ip = ip + 1
    enddo
    if ( xx(k) <= x(ip) ) then
       yy(k)  =  y(ip)
    else if ( xx(k) > x(ip) .and. xx(k) <= x(ip+1) ) then
       a     = ( xx(k) - x(ip) ) / max( 1d-4 , x(ip+1) - x(ip) ) ; b = 1d0 - a
       yy(k) = b*y(ip) + a*y(ip+1)
    else
       yy(k) = y(ip+1)
    endif
 enddo

 end subroutine lineinterp

 subroutine lineinterp3(xx, yy, zz, vv, ktx, x,y,z,v,n)
 implicit none
 integer          :: ktx, n, k, ip
 double precision :: xx(0:ktx), yy(0:ktx), zz(0:ktx), vv(0:ktx)
 double precision :: x(0:n)   , y(0:n)   , z(0:n)   , v(0:n)
 double precision :: a, b


 ip = 0
 do k = 0, ktx
    do while ( xx(k) > x(ip+1) .and. ip < n - 1 )
       ip = ip + 1
    enddo
    if ( xx(k) <= x(ip) ) then
       yy(k)  =   y(ip)
       zz(k)  =   z(ip)
       vv(k)  =   v(ip)
    else if ( xx(k) > x(ip) .and. xx(k) <= x(ip+1) ) then
       a     = ( xx(k) - x(ip) ) / max( 1d-4 , x(ip+1) - x(ip) ) ; b = 1d0 - a
       yy(k) = b*y(ip) + a*y(ip+1)
       zz(k) = b*z(ip) + a*z(ip+1)
       vv(k) = b*v(ip) + a*v(ip+1)
    else
       yy(k) = y(ip+1)
       zz(k) = z(ip+1)
       vv(k) = v(ip+1)
    endif
 enddo

 end subroutine lineinterp3



subroutine update_verticalprofiles()
!c************************************************************************
!c
!c         D e l f t      H y d r a u l i c s   -   Section    M-C-M
!c
!c             Module: based on Subroutine tratur in DPM
!c           Function: Transport solver tke and epsilon plus vertical momentum exchange u0
!c        Method used: Teta method for integration in time.
!c                     Tke and eps computed at layer interfaces.
!c                     SANCTUM
!c               Date: 13:26 dinsdag 4 augustus 1998
!c         Programmer: R.E. Uittenbogaard
!c************************************************************************

 use m_flow
 use m_flowgeom
 use m_partitioninfo
 use m_flowtimes
 use m_ship
 use m_sferic
 use m_missing

 implicit none

 double precision :: tetm1, dz0, dzc1, dzc2, zb1, zb2, tkedisL, tkeproL
 double precision :: vicu, vicd, difu, difd, fac, dzdz1, dzdz2, s2, sourtu, sinktu, bet, ybot, rhom, drhodz

 double precision :: uave, ustar, zz, sqcf, frcn, cz,z00, uave2, ac1, ac2, dzLw, sqcf3, ustar3, tkebot, tkesur, epsbot, epssur, volu

 double precision :: hdzb, hdzs, dtiL, hdz, adv, omega1, omega2, omegu, drhodz1, drhodz2, rhomea, sousin

 double precision :: dzu(kmxx), dzw(kmxx), womegu(kmxx)

 double precision :: gradk, gradt, grad, gradd, gradu, volki, arLL, qqq

 double precision :: wk,wke,vk,um,tauinv,tauinf,xlveg,rnv, diav,ap1,alf,c2esqcmukep,teps,tkin

 double precision :: cfuhi3D, vicwmax, tkewin, zint, z1, vicwww, alfaT, tke, eps, tttctot, c3t, c3e

 integer          :: k, ku, kd, kb, kt, n, kbn, kbn1, kn, knu, kk, kbk, ktk, kku, LL, L, Lb, Lt, kxL, Lu, Lb0, kb0
 integer          :: k1, k2, k1u, k2u, n1, n2, ifrctyp, ierr, jadrhodz = 1, kup, ierror, Ltv, ktv

 if (iturbulencemodel <= 0 .or. kmx == 0) return

 if (iadvec == 0) then
     javau = 0
 endif

 if (iturbulencemodel == 1) then                         ! 1=constant

!    vicwwu = vicoww

   !$OMP PARALLEL DO                                     &
   !$OMP PRIVATE(LL,Lb,Lt,kxL,dzu,L,k,hdzb,z00,ac1,ac2,n1,n2,zb1,zb2,k1,k2,omega1,omega2,volu,womegu,cfuhi3D)


    do LL = 1,lnx

       if ( hu(LL) > 0d0 )  then

          Lb  = Lbot(LL)                                   ! bed layer index
          Lt  = Ltop(LL)                                   ! surface layer index = surface interface index
          kxL = Lt-Lb+1                                    ! nr of layers

          dzu(1) = hu(Lb)
          do L   = Lb + 1, Lt                              ! layer thickness at layer center
             k   = L  - Lb + 1
             dzu(k) = hu(L) - hu(L-1)
          enddo

          call getustbcfuhi( LL,Lb,ustb(LL),cfuhi(LL),hdzb, z00, cfuhi3D)   !Constant
          advi(Lb) = advi(Lb)+cfuhi3D

          if (javau > 0) then
             ac1 = acL(LL)  ; ac2 = 1d0-ac1
             n1  = ln(1,LL) !; zb1 = zws(kbot(n1)-1)
             n2  = ln(2,LL) !; zb2 = zws(kbot(n2)-1)
             do L  = Lb , Lt-1                                  ! vertical omega velocity at layer interface u point
                k1 = ln(1,L) ; k2 = ln(2,L)
                k  = L  - Lb + 1

                if (n1 > ndxi) then                             ! open boundaries
                   if (u1(LL) < 0d0) then
                      womegu(k) = qw(k2)  / a1(n2)
                   else
                      womegu(k) = 0d0
                   endif
                else
                   womegu(k) = ( ac1*qw(k1) + ac2*qw(k2) ) /  ( ac1*a1(ln(1,LL)) + ac2*a1(ln(2,LL)) )
                endif

             enddo
             womegu(Lt-Lb+1) = 0d0                              ! top layer : 0
          endif

          call vertical_profile_u0( dzu, womegu, Lb, Lt, kxL, LL)

       endif

    enddo

    !$OMP END PARALLEL DO

 else  if (iturbulencemodel == 2) then                   ! 2=algebraic , just testing 1D flow

   !$xOMP PARALLEL DO                                     &
   !$xOMP PRIVATE(LL,Lb,Lt,kxL,dzu,frcn,L,k,Cz,z00,sqcf,zz,n1,n2,zb1,zb2,volu)
    do LL = 1,lnx

       if ( hu(LL) > 0d0 )  then

          Lb  = Lbot(LL)                                   ! bed layer index
          Lt  = Ltop(LL)                                   ! surface layer index = surface interface index
          kxL = Lt-Lb+1                                    ! nr of layers

          dzu(1)  = hu(Lb)
          do L    = Lb + 1, Lt                             ! layer thickness at layer center
             k    = L  - Lb + 1
             dzu(k) = hu(L) - hu(L-1)
          enddo

          call getustbcfuhi( LL,Lb,ustb(LL),cfuhi(LL),hdzb, z00, cfuhi3D)   ! algebraic
          advi(Lb) = advi(Lb)+cfuhi3D

          if (javau > 0) then
             ac1  = acL(LL)  ; ac2 = 1d0-ac1
             n1   = ln(1,LL) ; !zb1 = zws(kbot(n1)-1)
             n2   = ln(2,LL) ; !zb2 = zws(kbot(n2)-1)
             do L = Lb , Lt-1                                  ! vertical omega velocity at layer interface u point
               k1 = ln(1,L) ; k2 = ln(2,L)
               k  = L  - Lb + 1

               if (n1 > ndxi) then                             ! open boundaries
                  if (u1(LL) < 0d0) then
                     womegu(k) = qw(k2)  / a1(n2)
                  else
                     womegu(k) = 0d0
                  endif
               else
                   womegu(k) = ( ac1*qw(k1) + ac2*qw(k2) ) /  ( ac1*a1(ln(1,LL)) + ac2*a1(ln(2,LL)) )
               endif

             enddo
             womegu(Lt-Lb+1) = 0d0                              ! top layer : 0
          endif


          vicwwu(Lb-1) = 0d0

          do L  = Lb, Lt
             zz       = hu(L)*( 1d0 - hu(L)/ hu(LL) )             ! parabolic
 !           zz       = hu(L)*sqrt( ( 1d0 - hu(L)/ hu(LL) ) )     ! Bakhmetev
             vicwwu(L) = zz * ustb(LL) * vonkar
          enddo

          call vertical_profile_u0( dzu, womegu, Lb, Lt, kxL, LL)

       endif

    enddo

    !$xOMP END PARALLEL DO

 else if (iturbulencemodel >= 3) then                    ! 3=k-epsilon, 4=k-tau

  c2esqcmukep = c2e*sqcmukep

  if (javakeps > 0 ) then                                ! transport switched on: prepare horizontal advection k and eps

      call linkstocenterstwodoubles2(turkinepsws, turkin1, tureps1)

      if (numsrc > 0 .and. addksources > 0d0) then
         call doaddksources()
      endif

      if (nshiptxy > 0) then
        ! call addkships()
      endif

      if ( jampi.eq.1 ) then
         call update_ghosts(ITYPE_Sall3D, 2, Ndkx, turkinepsws, ierror)
      end if

      tqcu = 0d0 ; eqcu = 0d0 ; sqcu = 0d0

      javatest = 0
      if (javatest == 3) then
         if (.not. allocated (tttu) ) then
            allocate ( tttu(lnkx), ttqc(ndkx), tttc(ndkx) ) ; tttu = 0d0
            call getLbotLtop(lnx/2,Lb,Lt)
            do L = Lb,Lt
               tttu = 1d0
            enddo
         endif

         call linkstocenterstwodoubles(tttc, tttu)
         tttctot = 0d0
         do n = 1,ndxi
            call getkbotktop(n,kb,kt)
            do k = kb,kt
               tttctot = tttctot + tttc(k)*vol1(k)
            enddo
         enddo
         ttqc = 0d0

      endif

      do LL = 1,lnx
         call getLbotLtop(LL,Lb,Lt)
         do L   = Lb,Lt-1
            k1  = ln(1,L) ; k2 = ln(2,L)
            qqq =  0.5d0*(q1(L)+q1(L+1))

            ! k    = L - Lb + 1
            ! dzu(k  ) = hu(L) - hu(L-1)
            ! dzu(k+1) = hu(L+1) - hu(L)
            ! if (dzu(k) < 1d-10 .or. dzu(k+1) < 1d-10) then
            !    call qnerror('dzu(k) < 1d-10',' ',' ')
            ! endif
            ! qqq = dzu(k) * q1(L) + dzu(k+1) * q1(L+1)
            ! qqq = qqq / ( dzu(k) + dzu(k+1) )

            if (qqq > 0) then                         ! set upwind center values on links
               tqcu(k2) =  tqcu(k2) + qqq*turkinepsws(1,k1)
               eqcu(k2) =  eqcu(k2) + qqq*turkinepsws(2,k1)
               if (javatest == 3) ttqc(k2) =  ttqc(k2) + qqq*tttc(k1)
               sqcu(k2) =  sqcu(k2) + qqq
            else if (qqq < 0) then
               tqcu(k1) =  tqcu(k1) - qqq*turkinepsws(1,k2)
               eqcu(k1) =  eqcu(k1) - qqq*turkinepsws(2,k2)
               if (javatest == 3) ttqc(k1) =  ttqc(k1) - qqq*tttc(k2)
               sqcu(k1) =  sqcu(k1) - qqq
            endif
         enddo
      enddo
  endif

  tetm1     = 1d0-tetavkeps
  dtiL      = 1d0 / dtprev                                ! turbulence transport in current velocity field => do not use new timestep but previous step

  !$xOMP PARALLEL DO                                                                  &
  !$xOMP PRIVATE(LL,Lb,Lt,Lb0,kxL,L,k,dzu,dzw,hdzb,z00,tkebot,tkesur)                 &
  !$xOMP PRIVATE(ak,bk,ck,dk,ek,vicu,vicd,dzdz1,dzdz2,difu,difd,Lu,ku)                &
  !$xOMP PRIVATE(k1,k2,k1u,k2u,drhodz,drhodz1,drhodz2,dzc1,dzc2,bruva,buoflu,dijdij)  &
  !$xOMP PRIVATE(sourtu,sinktu,tkedisL,ac1,ac2,n1,n2,womegu,omega1,omega2,adv,omegu ) &
  !$xOMP PRIVATE(gradd,gradu,gradt,gradk,grad,wk,vk,um)

  do LL = 1,lnx                                           ! all this at velocity points

   Lt   = Ltop(LL)                                        ! surface layer index = surface interface index
   Lb   = Lbot(LL)                                        ! bed layer index
   if (Lt < Lb) cycle
   Lb0  = Lb - 1                                          ! bed interface index

   if (hu(LL) > 0) then
     kxL     = Lt-Lb+1                                    ! nr of layers

     do L    = Lb, Lt                                     ! layer thickness at layer center (org: Lb + 1)
        k    = L  - Lb + 1
        !k1   = ln(1,L)  ; k2  = ln(2,L)
        !dzu(k) = acl(LL)*(zws(k1)-zws(k1-1)) + (1d0-acl(LL))*(zws(k2)-zws(k2-1))
        dzu(k) = max(eps4, hu(L) - hu(L-1) )

        ! if (dzu(k) < 1d-10) then
        !   call qnerror('dzu(k) < 1d-10',' ',' ')
        ! endif

     enddo

     do L    = Lb , Lt-1                                  ! layer thickness at layer interface
        k    = L  - Lb + 1
        dzw(k) = 0.5d0*( dzu(k) + dzu(k+1) )
     enddo

     call getustbcfuhi( LL,Lb,ustb(LL),cfuhi(LL),hdzb,z00,cfuhi3D)      ! K-EPS, K-TAU

     if ( hu(LL) < trsh_u1Lb ) then
        advi(Lb:Lt) = advi(Lb:Lt) + cfuhi3D / dble(Lt-Lb+1)
     else
        advi(Lb) = advi(Lb)  + cfuhi3D
     endif
     tkebot   = sqcmukepi * ustb(LL)**2
     tkesur   = sqcmukepi * ustw(LL)**2

     if (ieps == 3) then                                   ! as Delft3D
         vicwwu(Lb0) = vonkar*ustb(LL)*z00                 ! as Delft3D
     endif

     turkin0(Lb0:Lt) = turkin1(Lb0:Lt)
     tureps0(Lb0:Lt) = tureps1(Lb0:Lt)

     ak(0:kxL) = 0.d0                                                 ! Matrix initialisation TKE
     bk(0:kxL) = dtiL
     ck(0:kxL) = 0.d0
     dk(0:kxL) = dtiL*turkin0(Lb0:Lt)

     vicu      = viskin+0.5d0*(vicwwu(Lb0)+vicwwu(Lb))*sigtkei        !

     do L  = Lb, Lt - 1                                               ! Loop over layer interfaces
        Lu    = L + 1

        vicd  = vicu
        vicu  = viskin + 0.5d0*(vicwwu(L)+vicwwu(Lu))*sigtkei

        k     = L - Lb + 1; ku = k + 1

        dzdz1 = dzw(k) * dzu(k)
        difd  = vicd   / dzdz1

        dzdz2 = dzw(k) * dzu(ku)
        difu  = vicu   / dzdz2

        ak(k) = ak(k)  -  difd*tetavkeps
        bk(k) = bk(k)  + (difd + difu)*tetavkeps
        ck(k) = ck(k)  -  difu*tetavkeps
        if (tetavkeps .ne. 1d0) then
           dk(k) = dk(k) - difu*(turkin0(L  ) - turkin0(Lu))*tetm1   &
                         + difd*(turkin0(L-1) - turkin0(L ))*tetm1
        endif


        !c Source and sink terms                                                                           k turkin
        if (idensform  > 0 ) then
            k1         = ln(1,L)  ; k2  = ln(2,L)
            k1u        = ln(1,Lu) ; k2u = ln(2,Lu)

            drhodz = 0d0 ; drhodz1 = 0d0 ; drhodz2 = 0d0

            dzc1       = 0.5d0*(zws(k1u) - zws(k1-1) )  ! vertical distance between cell centers on left side
            if (dzc1 >  0) then
               drhodz1 = ( rho(k1u) - rho(k1) ) / dzc1
            endif

            dzc2       = 0.5d0*(zws(k2u) - zws(k2-1) )  ! vertical distance between cell centers on right side
            if (dzc2 > 0) then
               drhodz2 = ( rho(k2u) - rho(k2) ) / dzc2
            endif

            if (jadrhodz == 1) then

               if (drhodz1 == 0) then
                  drhodz  = drhodz2
               else if (drhodz2 == 0) then
                  drhodz  = drhodz1
               else
                  !drhodz  = 0.5d0*( drhodz1 + drhodz2 )
                  drhodz  = acl(LL)* drhodz1 + (1.0d0 - acl(LL)) * drhodz2
               endif

            else if (jadrhodz == 2) then

               drhodz  = min( drhodz1, drhodz2 )

            endif
 !
            bruva (k)  = coefn2*drhodz                  ! N.B., bruva = N**2 / sigrho
            buoflu(k)  = max(vicwwu(L), vicwminb)*bruva(k)

            !c Production, dissipation, and buoyancy term in TKE equation;
            !c dissipation and positive buoyancy are split by Newton linearization:
            if (iturbulencemodel == 3) then
               if (bruva(k) > 0d0) then
                   dk(k) = dk(k) +     buoflu(k)
                   bk(k) = bk(k) + 2d0*buoflu(k) / turkin0(L)
                   ! EdG: make buoyance term in matrix safer
                   !  bk(k) = bk(k) + 2d0*buoflu(k) / max(turkin0(L), 1d-20)
               elseif (bruva(k)  < 0d0) then
                   dk(k) = dk(k) -     buoflu(k)
               endif
            else if (iturbulencemodel == 4) then
               if (bruva(k) > 0d0) then
                  bk(k) = bk(k) + buoflu(k) / turkin0(L)
               else if (bruva(k) < 0d0) then
                  dk(k) = dk(k) - buoflu(k)
               endif
            endif
        endif

        !c TKEPRO is the energy transfer flux from Internal Wave energy to
        !c Turbulent Kinetic energy and thus a source for the k-equation.
        !c TKEDIS is the energy transfer flux from Turbulent Kinetic energy to
        !c Internal Wave energy and thus a sink for the k-equation.

        ! Production, dissipation, and buoyancy term in TKE equation;
        ! dissipation and positive buoyancy are split by Newton linearization;
        ! buoyancy only for unstable stratification;
        ! notice: application of TKE at new time level:
        ! Addition of production and of dissipation to matrix ;
        ! observe implicit treatment by Newton linearization.

        dijdij(k) = ( ( u1(Lu) - u1(L) ) ** 2 + ( v(Lu) - v(L) ) ** 2 ) / dzw(k)**2

        if (jarichardsononoutput > 0) then                ! save richardson nr to output
            rich(L) = sigrho*bruva(k)/max(1d-8,dijdij(k)) ! sigrho because bruva premultiplied by 1/sigrho
        endif

        sourtu    = max(vicwwu(L),vicwminb)*dijdij(k) ! + tkepro(L)

        if (iturbulencemodel == 3) then
           sinktu = tureps0(L) / turkin0(L)               ! + tkedis(L) / turkin0(L)
           bk(k)  = bk(k)  + sinktu*2d0
           dk(k)  = dk(k)  + sinktu*turkin0(L) + sourtu
        else if (iturbulencemodel == 4) then
           sinktu =  1d0 / tureps0(L)                     ! + tkedis(L) / turkin0(L)
           bk(k)  = bk(k)  + sinktu
           dk(k)  = dk(k)  + sourtu
        endif

        ! dk(k)  = dk(k)  + sourtu - sinktu*turkin0(L)

     enddo

     ! Boundary conditions:
     ! TKE at free surface
     ak(kxL)  = 0.d0
     bk(kxL)  = 1.d0
     ck(kxL)  = 0.d0
     dk(kxL)  = tkesur
     ! TKE at the bed:
     ak(0)    = 0.d0
     bk(0)    = 1.d0
     ck(0)    = 0.d0
     dk(0)    = tkebot

     if (javau > 0 .or. javakeps > 0) then
         ac1 = acL(LL)  ; ac2 = 1d0-ac1
         n1  = ln(1,LL) ; !zb1 = zws(kbot(n1)-1)
         n2  = ln(2,LL) ; !zb2 = zws(kbot(n2)-1)
         do L = Lb , Lt-1                                  ! vertical omega velocity at layer interface u point
            k1 = ln(1,L) ; k2 = ln(2,L)
            k  = L  - Lb + 1

            if (n1 > ndxi) then                             ! open boundaries
               if (u1(LL) < 0d0) then
                  womegu(k) = qw(k2)  / a1(n2)
               else
                  womegu(k) = 0d0
               endif
            else
               womegu(k) = ( ac1*qw(k1) + ac2*qw(k2) ) /  ( ac1*a1(ln(1,LL)) + ac2*a1(ln(2,LL)) )
            endif

         enddo
         womegu(Lt-Lb+1) = 0d0                              ! top layer : 0

         if (javakeps >= 3) then                            ! Advection of turkin, vertical implicit, horizontal explicit
            arLL = ac1*a1(n1) + ac2*a1(n2)
            do L = Lb, Lt-1
               k = L  - Lb + 1
               omegu = 0.5d0*womegu(k)
               if (k > 1) omegu = omegu + 0.5d0*womegu(k-1) ! Omega at U-point in between layer interfaces
               if (omegu > 0d0) then                        ! omegu(k) lies below interface(k)
                  adv   = omegu / dzw(k)                    ! omegu(k) > 0 contributes to k
                  bk(k) = bk(k) + adv
                  ak(k) = ak(k) - adv
               else
                  if (k > 1) then
                     adv     = -omegu   / dzw(k-1)
                     bk(k-1) = bk(k-1) + adv
                     ck(k-1) = ck(k-1) - adv
                  endif
               endif
               if ( q1(L) + q1(L+1) > 0) then
                  kup = ln(1,L) ; arLL = a1(n1)
               else
                  kup = ln(2,L) ; arLL = a1(n2)
               endif
               volki = 1d0 / (dzw(k)*arLL )
               if (javakeps == 3) then
                  dk(k) = dk(k) + tqcu(kup)*volki
                  bk(k) = bk(k) + sqcu(kup)*volki
                else if (javakeps == 4) then
                   k1    = ln(1,L) ; k2 = ln(2,L)
                   dk(k) = dk(k) + ( ac1*tqcu(k1) + ac2*tqcu(k2) ) * volki
                   bk(k) = bk(k) + ( ac1*sqcu(k1) + ac2*sqcu(k2) ) * volki
                endif
            enddo

         endif

     endif

     if (javeg > 0) then             ! in turbulence model
        dke(1:Lt - Lb + 1) = 0d0 ; k1 = ln(1,LL) ; k2 = ln(2,LL)
        rnv = 0.5d0*( rnveg(ln(1,LL)) + rnveg(ln(2,LL)) )
        if (rnv > 0d0) then       ! if plants are here
           do L = Lb, Lt
              um  = sqrt( u1(L)*u1(L) + v(L)*v(L) )                ! umod (m2/s2)
              if (um > 0d0) then                                   ! and if there is flow,
                 k = L - Lb + 1 ; k1 = ln(1,L) ; k2 = ln(2,L)
                 rnv = 0.5d0*( rnveg(k1) + rnveg(k2) )
                 if (rnv > 0) then  ! if in this layer
                    if (diaveg(k1) > 0 .and. diaveg(k2) > 0) then
                       diav = 0.5d0*( diaveg(k1) + diaveg(k2) )
                    else
                       diav = max( diaveg(k1), diaveg(k2) )
                    endif
                    if (jaCdvegsp == 1) then
                       if (Cdvegsp(k1) > 0 .and. Cdvegsp(k2) > 0) then
                          Cdveg = 0.5d0*( Cdvegsp(k1) + Cdvegsp(k2) )
                       else
                          Cdveg = max (Cdvegsp(k1), Cdvegsp(k2) )
                       endif
                    endif
                    vk      = 0.5d0*Cdveg*rnv*diav*um                        ! (1/s)
                    advi(L) = advi(L) + vk                                   ! add to diagonal of u1
                    wk      = vk*um*um                                       ! work done by this layer m2/s3
                    ap1     = 1.0 - diav*diav*rnv*pi*0.25                    ! Free area
                    xlveg   = Clveg*sqrt( ap1 / rnv )                        ! typical length between plants
                    tauinv  = c2esqcmukep*(wk/xlveg**2)**r3
                    teps    = 0.5d0*( tureps0(L) + tureps0(L) )
                    tkin    = 0.5d0*( turkin0(L) + turkin0(L) ) 
                    if (iturbulencemodel == 3) then
                       tauinf = c2e*teps/tkin                  !   
                    else if (iturbulencemodel == 4) then
                       tauinf = c2e/teps  
                    endif
                    if (tauinf > tauinv) then ! turb damping not governed by plants => free flow damping only  
                       tauinv = 0d0           ! tauinv = max(tauinv, tauinf)
                    endif
                    if (iturbulencemodel == 3) then
                       wke = wk*tauinv
                    else if (iturbulencemodel == 4 ) then
                       wke = wk*( 1d0 - tureps1(L)*tauinv) * tureps1(L) / turkin1(L)
                    endif
                    if (L < Lt) then
                       alf      = 0.5d0*dzu(k)/dzw(k)
                       dk(k)    = dk(k)   + alf*wk                           ! half is added to top interface to k
                       dke(k)   = dke(k)  + alf*wke                          !                                to eps
                    endif
                    if (L > Lb) then
                       alf      =  0.5d0*dzu(k)/dzw(k-1)
                       dk(k-1)  = dk(k-1)  + alf*wk                          ! other half added to bed interface to k
                       dke(k-1) = dke(k-1) + alf*wke                         !                                   to eps
                    endif
                 endif 
              endif
           enddo
        endif
     endif

     call tridag(ak,bk,ck,dk,ek,turkin1(Lb0:Lt),kxL+1)                    ! solve k
     turkin1(Lb0:Lt) = max(epstke, turkin1(Lb0:Lt)   )
     do L = Lt+1 , Lb + kmxL(LL) - 1                           ! copy to surface for z-layers
        turkin1(L) = turkin1(Lt)
     enddo


    !_____________________________________________________________________________________!


     ak(0:kxL) = 0.d0                                      ! Matrix initialization eps, tau
     bk(0:kxL) = dtiL
     ck(0:kxL) = 0.d0
     dk(0:kxL) = dtiL*tureps0(Lb0:Lt)
                                                           ! Vertical diffusion; Neumann condition on surface;
                                                           ! Dirichlet condition on bed ; teta method:

     vicu  = viskin+0.5d0*(vicwwu(Lb0)+vicwwu(Lb))*sigepsi

     do L  = Lb, Lt - 1
        Lu    = L + 1

        vicd  = vicu
        vicu  = viskin + 0.5d0*(vicwwu(L)+vicwwu(Lu))*sigepsi

        k     = L - Lb + 1; ku = k + 1

        dzdz1 = dzw(k) * dzu(k)
        difd  = vicd   / dzdz1

        dzdz2 = dzw(k) * dzu(ku)
        difu  = vicu   / dzdz2

        ak(k) = ak(k)  -  difd*tetavkeps
        bk(k) = bk(k)  + (difd + difu)*tetavkeps
        ck(k) = ck(k)  -  difu*tetavkeps
        if (tetavkeps .ne. 1d0) then
           dk(k) = dk(k) - difu*(tureps0(L  ) - tureps0(Lu))*tetm1   &
                         + difd*(tureps0(L-1) - tureps0(L ))*tetm1
        endif

        if (iturbulencemodel == 3) then  !k-eps

            !c Source and sink terms                                                                epsilon
           if (bruva(k) <  0.d0) then    ! instable, increase rhs
              dk(k) = dk(k)-cmukep*c1e*bruva(k)*turkin1(L)
           endif

           ! Similar to the k-equation, in the eps-equation the net IWE to TKE
           ! transfer rate (TKEPRO-TKEDIS) is added to the eps-production term, but
           ! split for implicit treatment for avoiding negative epsilon.

           sourtu  =  c1e*cmukep*turkin0(L)*dijdij(k)
           tkedisL =  0d0 ! tkedis(L)
           sinktu  =  c2e*(tureps0(L) + tkedisL) / turkin1(L)    ! yoeri has here : /turkin0(L)

           !c Addition of production and of dissipation to matrix ;                               epsilon
           !c observe implicit treatment by Newton linearization.

           bk(k) = bk(k) + sinktu*2d0
           dk(k) = dk(k) + sinktu*tureps0(L) + sourtu

           !  bk(k) = bk(k) + sinktu
           !  dk(k) = dk(k) + sourtu

           ! dk(k) = dk(k) - sinktu*tureps0(L) + sourtu

        else if (iturbulencemodel == 4) then !                                               k-tau

           ! buoyancy term, we have in RHS :~ -Bruva*c3t
           ! c1e = 1.44
           ! bruva<0, instable, c3e=c1e c3t=1-c3e=-0.44 => -Bruva*c3t < 0 increase diag
           ! bruva>0    stable, c3e=0   c3t=1-c3e= 1.00 => -Bruva*c3t < 0 increase diag

           if (bruva(k) <  0d0) then         ! instable
              c3t   = c3tuns                 ! == -0.044   !c3e = c1e ; c3t = (1d0-c3e)*cmukep
              bk(k) = bk(k) + c3t*bruva(k)*tureps0(L)
           else if (bruva(k) >  0d0) then    ! stable
              c3t   = c3tsta                 ! == 0.09     !c3e = 0d0 ; c3t = (1d0-c3e)*cmukep
              bk(k) = bk(k) + c3t*bruva(k)*tureps0(L)
           endif

           bk(k)  = bk(k) - c1t*dijdij(k)*tureps0(L)
           dk(k)  = dk(k) - c2t

           gradd  = 0.5d0*(turkin0(L-1)+turkin0(L))*( tureps0(L) -tureps0(L-1) ) / dzu(k)    ! The D_tt-term:
           gradu  = 0.5d0*(turkin0(Lu) +turkin0(L))*( tureps0(Lu)-tureps0(L)   ) / dzu(ku)
           gradt  = gradd + gradu

           gradd  = 0.5d0*(tureps0(L-1)+tureps0(L))*( turkin0(L) -turkin0(L-1) ) / dzu(k)    ! The D_kt-term:
           gradu  = 0.5d0*(tureps0(Lu) +tureps0(L))*( turkin0(Lu)-turkin0(L)   ) / dzu(ku)
           gradk  = gradd + gradu
           grad   = gradk - gradt                                                            ! D_kt - D_tt

           grad   = -grad*sigepsi*cmukep           ! This is positive advection, dc/dt + wdc/dz
           grad   =  grad/dzw(k)                   ! dzw is receiving volume
           if (grad > 0d0) then
              bk(k) = bk(k) + grad
              ak(k) = ak(k) - grad
           else if (grad < 0d0) then
              bk(k) = bk(k) - grad
              ck(k) = ck(k) + grad
           endif

        endif

    enddo

    if (iturbulencemodel == 3) then       ! Boundary conditions EPSILON:

       ak(kxL) = -1.d0                    ! Flux at the free surface:
       bk(kxL) =  1.d0
       ck(kxL) =  0.d0
       dk(kxL) =  4d0*abs(ustw(LL))**3/ (vonkar*dzu(Lt-Lb+1))

       ak(0)  =  0.d0                     ! at the bed:
       bk(0)  =  1.d0
       ck(0)  = -1.d0
       if (ustb(LL) > 0 .and. kxL > 1) then             ! deps/dz = (epsb+1-epsb)/dz = (u*)**3/ ((dz/2+9z0)**2)
          dk(0) =  dzu(1)*abs(ustb(LL))**3/(vonkar*hdzb*hdzb)
       else
          dk(0) =  0d0
       endif

    else if (iturbulencemodel == 4) then  ! Boundary conditions tau:

       ak(kxL) =  0.d0                    ! at the free surface:
       bk(kxL) =  1.d0
       ck(kxL) =  0.d0
       dk(kxL) =  0.d0
       ! dk(kxL) =  vonkar*9d0*z00/(max(ustw(LL),eps6)*0.3d0)  ! 0.3=sqrt(cmu0), cmu0=cmukep

       ak(0)   =  0.d0                    ! at the bed:
       bk(0)   =  1.d0
       ck(0)   =  0.d0
       if (ustb(LL) > 0) then
          dk(0) =  vonkar*c9of1*z00/(max(ustb(LL),eps6)*0.3d0)  ! 0.3=sqrt(cmu0), cmu0=cmukep
       else
          dk(0) =  0d0
       endif

    endif

    if (javakeps >= 3) then                                  ! Advection of tureps, vertical implicit, horizontal explicit
        do L = Lb, Lt-1
           k = L  - Lb + 1
           omegu = 0.5d0*womegu(k)
           if (k > 1) omegu = omegu + 0.5d0*womegu(k-1)      ! Omega at U-point in between layer interfaces
           if (omegu > 0d0) then
              adv   = omegu / dzw(k)
              bk(k) = bk(k) + adv
              ak(k) = ak(k) - adv
           else
              if (k > 1) then
                 adv     = -omegu  / dzw(k-1)
                 bk(k-1) = bk(k-1) + adv
                 ck(k-1) = ck(k-1) - adv
              endif
           endif

           if ( q1(L) + q1(L+1) > 0) then
              kup = ln(1,L) ; arLL = a1(n1)
           else
              kup = ln(2,L) ; arLL = a1(n2)
           endif
           volki = 1d0 / (dzw(k)*arLL )
           if (javakeps == 3) then
              dk(k) = dk(k) + eqcu(kup)*volki
              bk(k) = bk(k) + sqcu(kup)*volki
           else if (javakeps == 4) then
              k1    = ln(1,L) ; k2 = ln(2,L)
              dk(k) = dk(k) + ( ac1*eqcu(k1) + ac2*eqcu(k2) ) * volki
              bk(k) = bk(k) + ( ac1*sqcu(k1) + ac2*sqcu(k2) ) * volki
           endif
         enddo
    endif

    if (javeg > 0) then  ! in turbulence model
        do L = Lb, Lt-1
           k = L - Lb + 1
           dk(k) = dk(k) + dke(k)
        enddo
    endif

    call tridag(ak,bk,ck,dk,ek,tureps1(Lb0:Lt),kxL+1)         ! solve eps
    tureps1(Lb0:Lt) = max(epseps, tureps1(Lb0:Lt) )
    do L = Lt+1 , Lb + kmxL(LL) - 1                           ! copy to surface for z-layers
       tureps1(L) = tureps1(Lt)
    enddo

    if (javatest == 3) then      ! test advection
      ak(0:kxL) = 0.d0                                                 ! Matrix initialisation
      bk(0:kxL) = dtiL
      ck(0:kxL) = 0.d0
      dk(0:kxL) = dtiL*tttu(Lb0:Lt)

      if (javau > 0 .or. javakeps > 0) then

         if (javakeps >= 3) then                            ! Advection of tttu, vertical implicit, horizontal explicit
            arLL = ac1*a1(n1) + ac2*a1(n2)
            do L = Lb, Lt-1
               k = L  - Lb + 1
               omegu = 0.5d0*womegu(k)
               if (k > 1) omegu = omegu + 0.5d0*womegu(k-1) ! Omega at U-point in between layer interfaces
               if (omegu > 0d0) then                        ! omegu(k) lies below interface(k)
                  adv   = omegu / dzw(k)                    ! omegu(k) > 0 contributes to k
                  bk(k) = bk(k) + adv
                  ak(k) = ak(k) - adv
               else
                  if (k > 1) then
                     adv     = -omegu   / dzw(k-1)
                     bk(k-1) = bk(k-1) + adv
                     ck(k-1) = ck(k-1) - adv
                  endif
               endif
               if ( q1(L) + q1(L+1) > 0) then
                  kup = ln(1,L) ; arLL = a1(n1)
               else
                  kup = ln(2,L) ; arLL = a1(n2)
               endif
               volki = 1d0 / (dzw(k)*arLL )
               if (javakeps == 3) then
                  dk(k) = dk(k) + ttqc(kup)*volki
                  bk(k) = bk(k) + sqcu(kup)*volki
               else if (javakeps == 4) then
                  k1    = ln(1,L) ; k2 = ln(2,L)
                  dk(k) = dk(k) + ( ac1*ttqc(k1) + ac2*ttqc(k2) ) * volki
                  bk(k) = bk(k) + ( ac1*sqcu(k1) + ac2*sqcu(k2) ) * volki
               endif
            enddo

         endif

     endif

     call tridag(ak,bk,ck,dk,ek,tttu(Lb0:Lt),kxL+1)     ! solve tttu

    endif  ! end test

    ! If it is a restart simulation, spin up function is not allowed
    !if (jarestart == 0) then
     if (  ( Tspinupturblogprof > 0d0 .and. Time1 < Tstart_user + Tspinupturblogprof )  .or.  &
          ( jaLogprofkepsbndin == 1   .and. LL    > lnxi .and. u1(LL) >= 0d0         )  .or.  &
          ( jaLogprofkepsbndin == 2   .and. LL    > lnxi                             )        ) then

       alfaT = dmiss
       if (Tspinupturblogprof > 0d0) then
          alfaT = (Time1-Tstart_user) / Tspinupturblogprof
       endif
       if (LL > lnxi) then
           alfaT = 0d0
       endif

       if (alfaT .ne. dmiss) then
          do L    = Lb,Lt-1      ! TKE and epsilon at layer interfaces:
             zint   = hu(L) / hu(LL)
             z1     = 1d0 - zint
             k1     = ln(1,L) ; k2   = ln(1,L)
             tke    = tkebot*z1 + tkesur*zint
             zz     = hu(L)*( 1d0 - hu(L)/ hu(LL) )             ! parabolic visc
             vicwww = zz * max(0.001d0, ustb(LL)) * vonkar
             eps    = cmukep*tke*tke / vicwww
             turkin1(L)  = tke*(1d0-alfaT) + alfaT*turkin1(L)
             tureps1(L)  = eps*(1d0-alfaT) + alfaT*tureps1(L)
          enddo
          epsbot =  tureps1(Lb) + dzu(1)*abs(ustb(LL))**3/(vonkar*hdzb*hdzb)
          epssur =  tureps1(Lt-1) - 4d0*abs(ustw(LL))**3/ (vonkar*dzu(Lt-Lb+1))
          epsbot = max(epsbot,epseps)
          epssur = max(epssur,epseps)
          tke               = max(epstke,tkesur)
          turkin1(Lt)       = tke*(1d0-alfaT) + alfaT*turkin1(Lt)
          eps               = epssur / ( hu(Lt) - hu(Lt-1) )
          tureps1(Lt)       = eps*(1d0-alfaT) + alfaT*tureps1(Lt)
          tke               = max(epstke,tkebot)
          turkin1(Lb-1)     = tke*(1d0-alfaT) + alfaT*turkin1(Lb-1)
          eps               = epsbot / ( hu(Lb) - hu(Lb-1) )
          tureps1(Lb-1)     = eps*(1d0-alfaT) + alfaT*tureps1(Lb-1)

          if (jamodelspecific == 1) then
             call update_turkin_modelspecific(LL) ! will update turkin1 and tureps1 for all layers of flow link LL.
          endif
       endif
     endif
    !endif
    vicwmax = 0.1d0*hu(LL)                                    ! 0.009UH, Elder, uavmax=
    if (iturbulencemodel == 3) then                           ! k-eps
       vicwwu (Lb0:Lt) = min(vicwmax, cmukep*turkin1(Lb0:Lt)*turkin1(Lb0:Lt) / tureps1(Lb0:Lt) )
    else if (iturbulencemodel == 4) then                      ! k-tau
       vicwwu (Lb0:Lt) = min(vicwmax, cmukep*turkin1(Lb0:Lt)*tureps1(Lb0:Lt) )
    endif

    vicwwu(Lt)  = min( vicwwu(Lt)  , vicwwu(Lt-1)*Eddyviscositysurfacmax )
    vicwwu(Lb0) = min( vicwwu(Lb0) , vicwwu(Lb)  *Eddyviscositybedfacmax )

    call vertical_profile_u0( dzu, womegu, Lb, Lt, kxL, LL)

   else   ! dry

    tureps1(Lb0:Lb + kmxL(LL) - 1 ) = epseps
    turkin1(Lb0:Lb + kmxL(LL) - 1 ) = epstke

   endif  ! if (hu(L) > 0) then
  enddo   ! links loop

  !$xOMP END PARALLEL DO

  turkin0 = turkin1
  tureps0 = tureps1

 endif

 !if ( jampi.eq.1 ) then
 !   call update_ghosts(ITYPE_U3DW, 1, Ndkx, turkin1, ierror)
 !   call update_ghosts(ITYPE_U3DW, 1, Ndkx, tureps1, ierror)
 !end if

 call linkstocenterstwodoubles(vicwws, vicwwu)

 end subroutine update_verticalprofiles

 subroutine doaddksources() ! add k sources
 use m_flow
 use m_flowtimes
 implicit none

 integer          :: n, k, kk, kk2
 double precision :: qsrck, dvoli, dtol = 1d-4

 do n  = 1,numsrc
    if (ksrc(2,n) == 0 .and. ksrc(5,n) == 0) cycle  ! due to initialisation

    if (arsrc(n) == 0) cycle
    kk    = ksrc(1,n)                   ! 2D pressure cell nr FROM
    kk2   = ksrc(4,n)                   ! 2D pressure cell nr TO
    qsrck = qsrc(n)

    if (kk > 0) then                    ! FROM Point
       k = ksrc(2,n) ; dvoli = 1d0/max(vol1(k),dtol)
       if (qsrck > 0) then              ! FROM k to k2
          turkinepsws(1,k) = turkinepsws(1,k) - dts*qsrck*dvoli*turkinepsws(1,k)
       else if  (qsrck  < 0) then       ! FROM k2 to k
          turkinepsws(1,k) = turkinepsws(1,k) - dts*qsrck*dvoli*0.5D0*(qsrck/arsrc(n))**2
       endif
    endif

    if (kk2 > 0) then                   ! TO Point
       k = ksrc(5,n) ; dvoli = 1d0/max(vol1(k),dtol)
       if (qsrck > 0) then
          turkinepsws(1,k) = turkinepsws(1,k) + dts*qsrck*dvoli*0.5D0*(qsrck/arsrc(n))**2
       else if  (qsrck  < 0) then
          turkinepsws(1,k) = turkinepsws(1,k) + dts*qsrck*dvoli*turkinepsws(1,k)
       endif
    endif

 enddo
 end subroutine doaddksources

 subroutine getustbcfuhi( LL,Lb,ustbLL,cfuhiLL,hdzb, z00,cfuhi3D)                ! see Uittenbogaard's subroutine USTAR
 use m_flow
 use m_flowgeom  , only : ln, dxi, csu, snu, acL
 use m_flowtimes , only : dti
 use m_waves     , only : ustokes, vstokes, taubxu, wblt
 use m_sediment  , only : stm_included
 use m_turbulence, only : tkepro
 use m_flowtimes, only: dts

 implicit none
 integer,          intent (in)  :: LL, Lb
 double precision, intent (out) :: ustbLL, cfuhiLL, hdzb, z00
 double precision, intent(out)  :: cfuhi3D                   ! 3D bedfriction coeffient, advi(Lb) = adbi(Lb) + cfuhi3D

 integer          :: ifrctyp, L
 double precision :: frcn, sqcf, cz, umod, u1Lb, gsx, ustw2, ustc2, fw, Cdrag, abscos, dfuc, costu
 double precision :: taubpuLL                                ! taubpu = umod*ag/C2 or ypar*(taucur+tauwav)
 double precision :: taubxuLL                                ! taubxu = taubpu*umod*rhomean

 double precision :: csw, snw                                ! wave direction cosines
 double precision :: Dfu, Dfu0, Dfu1, tkpr, tkp0, tkp1, aa   ! wave dissipation by bed friction, / (rhomean*c*deltau)
 double precision :: deltau                                  ! wave dissipation layer thickness

 integer          :: nit, nitm = 100
 double precision :: r, rv = 123.8d0, e = 8.84d0 , eps = 1d-2, s, sd, er, ers, dzb, uux, uuy, htop, dzw, dzu, alin

 cfuhi3D = 0d0 ; nit = 0

 frcn = frcu(LL)
 if (frcn == 0d0 ) return
 ifrctyp = ifrcutp(LL)

 if ( hu(LL) < trsh_u1Lb) then
     gsx = ag*( s1(ln(2,LL)) - s1(ln(1,LL)) ) * dxi(LL)
 endif

 if (ifrctyp < 10) then
    if (frcn > 0d0 ) then
        call getczz0(hu(LL), frcn, ifrctyp, cz, z00)

        hdzb  = 0.5d0*hu(Lb)     + c9of1*z00                ! half bottom layer plus 9z0

        if (z00 > 0d0) then

           if (jaustarint == 0) then
              ! sqcf = vonkar/log(c9of1 + hdzb/z00)            ! till 012015
              sqcf = vonkar/log(hdzb/z00)
           else if (jaustarint == 1) then                      ! Yoeri 2014 long time default for jaustarint == 1
              dzb  = hu(Lb) + c9of1*z00
              sqcf = vonkar / ( log(dzb/z00)-1d0 )
           else if (jaustarint == 2) then                      ! remobilised through jaustarint == 2, good convergence
              dzb  = hu(Lb)/ee + c9of1*z00
              sqcf = vonkar / ( log(dzb/z00) )
           else if (jaustarint == 3) then                     ! Delft3D
              hdzb  = 0.5d0*hu(Lb)     + z00
              sqcf = vonkar / ( log(1d0+0.5d0*hu(Lb)/z00) )    ! D3D:
           else if(jaustarint == 4) then
               !hdzb  = 0.5d0*hu(Lb)     + c9of1*z00/0.65d0
               dzb  = hu(Lb)/ee + c9of1*z00 *0.66d0
              sqcf = vonkar / ( log(dzb/z00) )
           else if (jaustarint == 5) then
              dzb  = hu(Lb)
              sqcf = vonkar / ( ( 1d0 + c9of1 * z00 / dzb ) * log(dzb/z00+c9of1) - c9of1 * z00/dzb * log(c9of1) - 1d0 )
           endif

        else
           sqcf = 0d0
        endif

    else
        hdzb = 0.5d0*hu(Lb)
        sqcf = 0d0
    endif

    u1Lb = u1(Lb)

    10  continue

    if (jawaveStokes >= 1) then                                      ! ustokes correction at bed
       umod = sqrt( (u1Lb-ustokes(Lb))*(u1Lb-ustokes(Lb)) + (v(Lb)-vstokes(Lb))*(v(Lb)-vstokes(Lb)) )
    else
        umod = sqrt( u1Lb*u1Lb + v(Lb)*v(Lb) )
    endif

    if (umod == 0d0) then         ! from dry to wet
       umod = max(1d-4, dts*ag*abs( s1(ln(1,LL)) - s1(ln(2,LL)) )*dxi(LL) )
    else
       umod = max(umod, 1d-4)     ! 1d-5 for some wave cases     ! until 3D handled like 2D iterative loop , solves Roses problem: ust=1.1e-104 to the power 3 is underflow
    endif

    ustbLL = sqcf*umod                                           ! ustar based upon bottom layer velocity

    if (jawave > 0) then

       call getustwav(LL, z00, fw, ustw2, csw, snw, Dfu, Dfuc, deltau, costu) ! get ustar wave squared, fw and wavedirection cosines  based upon Swart
       if (ustw2 > 1d-8) then
          ustc2 = ustbLL*ustbLL
          if (modind < 9) then                                   ! wave-current interaction Soulsby (1997)
             Cdrag  = ag/(cz*cz)
             uux    = acL(LL)*ucx(ln(1,Lb)) + (1d0-acL(LL))*ucx(ln(2,Lb))
             uuy    = acL(LL)*ucy(ln(1,Lb)) + (1d0-acL(LL))*ucy(ln(2,Lb))
             abscos = abs( csw*uux     + snw*uuy ) / max(1d-4, sqrt(uux*uux + uuy*uuy) )         ! abs(prodin(uw,uc))
             call getsoulsbywci(modind, z00, ustc2, ustw2, fw, cdrag, umod, abscos, taubpuLL, taubxuLL)
          else if (modind == 9) then                          ! wave-current interaction van Rijn (2004)
             ! call getvanrijnwci    (LL, z00, ustc2, ustw2, ustcw2, z0urou(LL))
          endif
          ustbLL = sqrt(umod*taubpuLL)
          sqcf   = max(sqcf,ustbLL / umod )                      ! waveps not needed, see umod = max(umod, 1d-4) line above
          if (stm_included .or. jawaveSwartDelwaq > 1)  then                                  ! For usage in coupled models
             taubxu(LL) = taubxuLL
             z0ucur(LL) = z00                                    ! And, in case anybody needs these arrays :
             z0urou(LL) = dzb*exp(-vonkar/sqcf - 1d0)            ! inverse of jaustarint == 1 above
             wblt(LL) = deltau
             ! N.b., in Delft3D zourou is established upon velocities just outside the wave boundary layer, at L = Lbw1:
          endif

          if (jawavestreaming >= 1 .and. deltau > 0d0)  then     ! Streaming below deltau with linear distribution
             tkpr  = 2d0*Dfu                                     ! (m2/s3)
             tkp0  = tkpr
             tkepro(0) = tkpr*0.5d0*hu(Lb)/deltau                ! fraction in bed layer
             Dfuc  = Dfuc*costu                                  ! (m/s2)
             Dfu0  = Dfuc
             do L  = Lb, Ltop(LL)
                if (hu(L) <= deltau) then
                   htop   = min( hu(L), deltau )                 ! max height within waveboundarylayer
                   alin   = 1d0 -  htop / deltau                 ! linear from 1 at bed to 0 at deltau
                   Dfu1   = Dfuc*alin
                   dzu    = htop-hu(L-1)
                   adve(L) = adve(L) - 0.5d0*(Dfu0 + Dfu1)*dzu / deltau
                   if (jawavestreaming >= 2 .and. L < Ltop(LL) ) then
                       tkp1 = tkpr*alin
                       dzw  = min( deltau, 0.5d0*(hu(L+1) + hu(L) ) )  - 0.5d0*( hu(L) + hu(L-1) )
                       tkepro(L-Lb+1) = tkp1*dzw / deltau
                   endif
                endif
                Dfu0    = dfu1
                if (hu(L) > deltau) then
                   exit
                endif
             enddo
          endif
       endif
    endif

    cfuhiLL   = sqcf*sqcf/hu(Lb)                              ! cfuhiLL   = g / (H.C.C) = (g.K.K) / (A.A)
    cfuhi3D   = cfuhiLL*umod                                  ! cfuhi3D = frc. contr. to diagonal
    !advi(Lb) = advi(Lb) +  cfuhiLL*umod

    if (jawave==0) then
       z0ucur(LL) = z00
       z0urou(LL) = z00
    endif

    if (jawave>0 .and. jawaveStokes >= 1) then                               ! Ustokes correction at bed
       adve(Lb)  = adve(Lb) - cfuhi3D*ustokes(Lb)
    endif

 else if (ifrctyp == 10) then                                 ! Hydraulically smooth, glass etc
     nit = 0
     u1Lb = u1(Lb)
      if (jawaveStokes >= 1) then
         umod  = sqrt( (u1Lb-ustokes(LL))*(u1Lb-ustokes(LL)) + (v(Lb)-vstokes(LL))*(v(Lb)-vstokes(LL)) )
     else
         umod  = sqrt( u1Lb*u1Lb + v(Lb)*v(Lb) )
     endif

     r   = umod*hu(Lb)/viskin                                  ! Local re-number:
     r   = max(r,0.001d0)
     er  = e*r
     if (r.lt.rv) then                                         ! Viscous sublayer:
        s   = sqrt(r)
     else

        s   = 12d0                                             ! In log-layer; initial trial for s:
100     continue
        nit = nit+1
        sd  = s
        ers = max(er/sd, 1.0001d0)
        s   = log(ers)/vonkar

        if (nit.ge.nitm) then
           call error ('***ERROR in USTAR: no convergence.', ' ', ' ' )
        endif
        if (s.gt.r) then
           call error ('***ERROR in USTAR: S too large.', ' ', ' ' )
        endif


        if (abs(sd-s).gt.(eps*s)) then
            go to 100                                          ! Convergence criterium:
        endif
     endif

     if (s > 0d0) then
        sqcf = 1d0/s
     else
        sqcf = 0d0
     endif
     ustbLL = sqcf*umod                                        ! ustar based upon bottom layer velocity
     cfuhiLL  = sqcf*sqcf/hu(Lb)
     hdzb   = 0.5d0*hu(Lb)

     if (cfuhiLL > 100d0) then
        nit = nit + 1
     endif

!     advi(Lb) = advi(Lb) +  cfuhiLL*umod                        ! g / (H.C.C) = (g.K.K) / (A.A) travels in cfuhi
     cfuhi3D = cfuhiLL*umod

 else if (ifrctyp == 11) then                                    ! Noslip

!    advi(Lb) = advi(Lb) +  2d0*(vicwwu(Lb)+vicouv)/hu(Lb)**2
     cfuhi3D = 2d0*(vicwwu(Lb)+vicoww)/hu(Lb)**2

 endif

 if ( hu(LL) < trsh_u1Lb .and. abs(gsx) > 1d-3 .and. nit <= 3) then
    ! u1Lb = ( u1(Lb)*dti - adve(Lb) - gsx ) / (cfuhi3D + dti)
    u1Lb = ( u1(Lb)*dti            - gsx ) / (cfuhi3D + dti)
    nit  = nit + 1
    goto 10
 endif

 if (jafrculin > 0) then
    cfuhi3D = cfuhi3D + frculin(LL)/hu(Lb)
 endif

 end subroutine getustbcfuhi

 subroutine hydraulicallysmooth(umod,h,sqcf)
 use m_physcoef
 use m_flow
 implicit none
 integer :: L
 double precision :: umod,h,sqcf
 double precision :: r, rv = 123.8d0, e = 8.84d0 , eps = 1d-2, s, sd, er, ers


 r    = umod*h/viskin                                      ! Local re-number:
 r    = max(r,0.001d0)
 er   = e*r
 if (r.lt.rv) then                                         ! Viscous sublayer:
     s   = sqrt(r)
 else

     s   = 12d0                                            ! In log-layer; initial trial for s:
100  continue
     sd  = s
     ers = max(er/sd, 1.0001d0)
     s   = log(ers)/vonkar

     if (abs(sd-s).gt.(eps*s)) then
         go to 100                                         ! Convergence criterium:
     endif
 endif

 if (s > 0d0) then
    sqcf = 1d0/s
 else
    sqcf = 0d0
 endif

 end subroutine hydraulicallysmooth


subroutine getsoulsbywci(modind, z00, ustc2, ustw2, fw, cdrag, umod, abscos, taubpuLL, taubxuLL)
 use m_physcoef, only : rhomean
 implicit none
 integer         , intent(in)  :: modind
 double precision, intent(in)  :: z00, ustc2, ustw2, fw, cdrag, umod, abscos           ! Cdrag = ag/C2, abscos = wav relative to link dir
 double precision, intent(out) :: taubpuLL, taubxuLL
 double precision              :: ypar, ymxpar
 double precision              :: tauwav, taucur

 tauwav = ustw2*rhomean
 taucur = ustc2*rhomean

 call getymxpar(modind, tauwav, taucur, fw, cdrag, abscos, ypar, ymxpar)

 taubpuLL = ypar   * (taucur + tauwav) / ( umod*rhomean + 1d-4 ) ! umod*ag/C2, (m/s)
 taubxuLL = ymxpar * (taucur + tauwav)                           ! Max shear stress needed in Erosed, (N/m2)

end subroutine getsoulsbywci

subroutine getymxpar(modind,tauwav, taucur, fw, cdrag, abscos, ypar, ymxpar)
 implicit none
 integer         , intent(in)  :: modind
 double precision, intent(in)  :: tauwav, taucur, fw, cdrag, abscos
 double precision, intent(out) :: ypar, ymxpar
 double precision              :: xpar       ! Variable x in in expression for parametrized models
 real, dimension(8)            :: coeffi     ! Coefficient i in expression for parametrized models
 real, dimension(8)            :: coeffj     ! Coefficient j in expression for parametrized models
 real, dimension(8, 4)         :: aa         ! Coefficient a(i) in expression for parameter a
 real, dimension(8, 4)         :: bb         ! Coefficient b(i) in expression for parameter b
 real, dimension(8, 4)         :: mm         ! Coefficient m(i) in expression for parameter n
 real, dimension(8, 4)         :: nn         ! Coefficient n(i) in expression for parameter n
 real, dimension(8, 4)         :: pp         ! Coefficient p(i) in expression for parameter p
 real, dimension(8, 4)         :: qq         ! Coefficient q(i) in expression for parameter q
 double precision              :: lfc, cj, coeffb, coeffp, coeffq, ci,coeffa, coeffm, coeffn

 data bb/      0.29,  0.65,  0.27,  0.73,  0.22,  0.32,  0.47, -0.06, &
               0.55,  0.29,  0.51,  0.40,  0.73,  0.55,  0.29,  0.26, &
              -0.10, -0.30, -0.10, -0.23, -0.05,  0.00, -0.09,  0.08, &
              -0.14, -0.21, -0.24, -0.24, -0.35,  0.00, -0.12, -0.03/

 data pp/     -0.77, -0.60, -0.75, -0.68, -0.86, -0.63, -0.70, -1.00, &
               0.10,  0.10,  0.13,  0.13,  0.26,  0.05,  0.13,  0.31, &
               0.27,  0.27,  0.12,  0.24,  0.34,  0.00,  0.28,  0.25, &
               0.14, -0.06,  0.02, -0.07, -0.07,  0.00, -0.04, -0.26/

 data qq/      0.91,  1.19,  0.89,  1.04, -0.89,  1.14,  1.65,  0.38, &
               0.25, -0.68,  0.40, -0.56,  2.33,  0.18, -1.19,  1.19, &
               0.50,  0.22,  0.50,  0.34,  2.60,  0.00, -0.42,  0.25, &
               0.45, -0.21, -0.28, -0.27, -2.50,  0.00,  0.49, -0.66/

 data coeffj/  3.00,  0.50,  2.70,  0.50,  2.70,  3.00,  0.60,  1.50/

 !-----for Tau_max
 data aa/     -0.06, -0.01, -0.07,  0.11,  0.05,  0.00, -0.01, -0.45, &
               1.70,  1.84,  1.87,  1.95,  1.62,  2.00,  1.58,  2.24, &
              -0.29, -0.58, -0.34, -0.49, -0.38,  0.00, -0.52,  0.16, &
               0.29, -0.22, -0.12, -0.28,  0.25,  0.00,  0.09, -0.09/

 data mm/      0.67,  0.63,  0.72,  0.65,  1.05,  0.00,  0.65,  0.71, &
              -0.29, -0.09, -0.33, -0.22, -0.75,  0.50, -0.17,  0.27, &
               0.09,  0.23,  0.08,  0.15, -0.08,  0.00,  0.18, -0.15, &
               0.42, -0.02,  0.34,  0.06,  0.59,  0.00,  0.05,  0.03/

 data nn/      0.75,  0.82,  0.78,  0.71,  0.66,  0.00,  0.47,  1.19, &
              -0.27, -0.30, -0.23, -0.19, -0.25,  0.50, -0.03, -0.66, &
               0.11,  0.19,  0.12,  0.17,  0.19,  0.00,  0.59, -0.13, &
              -0.02, -0.21, -0.12, -0.15, -0.03,  0.00, -0.50,  0.12/

 data coeffi/  0.80,  0.67,  0.82,  0.67,  0.82,  1.00,  0.64,  0.77/

 if (tauwav<1.0D-8) then
    xpar   = 1d0
    ypar   = 1d0
    ymxpar = 1d0
 else
    xpar = taucur/(taucur + tauwav)
    if (xpar<1.0D-8 .or. modind==9) then
       ypar   = 0d0
       ymxpar = 1d0
    else
       lfc    = log10(fw/cdrag)
       cj     = abscos**coeffj(modind)
       coeffb = (bb(modind, 1) + bb(modind, 2)*cj) + (bb(modind, 3) + bb(modind, 4)*cj)*lfc
       coeffp = (pp(modind, 1) + pp(modind, 2)*cj) + (pp(modind, 3) + pp(modind, 4)*cj)*lfc
       coeffq = (qq(modind, 1) + qq(modind, 2)*cj) + (qq(modind, 3) + qq(modind, 4)*cj)*lfc
       ypar   = xpar*(1d0 + coeffb*(xpar**coeffp)*((1d0 - xpar)**coeffq))
       ci     = abscos**coeffi(modind)
       coeffa = (aa(modind, 1) + aa(modind, 2)*ci) + (aa(modind, 3) + aa(modind, 4)*ci)*lfc
       coeffm = (mm(modind, 1) + mm(modind, 2)*ci) + (mm(modind, 3) + mm(modind, 4)*ci)*lfc
       coeffn = (nn(modind, 1) + nn(modind, 2)*ci) + (nn(modind, 3) + nn(modind, 4)*ci)*lfc
       ymxpar = 1d0 + coeffa*(xpar**coeffm)*((1d0 - xpar)**coeffn)
    endif
 endif
 end subroutine getymxpar

 !subroutine getvanrijnwci(LL, z00, ustc2, ustw2, ustcw2, z0urou)
 !   use m_flow
 !   use m_bedform
 !
 !   implicit none
 !
 !   hrmsu    = 0.5_fp * (hrms  (nm) + hrms  (nmu))
 !   tpu      = 0.5_fp * (tp    (nm) + tp    (nmu))
 !   rlabdau  = 0.5_fp * (rlabda(nm) + rlabda(nmu))
 !   rr       = -0.4_fp * sqrt(2.0_fp) / hu(nm) + 1.0_fp
 !   umax     = rr * 2.0_fp * uorbhs
 !   t1       = tpu  * sqrt(ag/hu(nm))
 !   u11      = umax / sqrt(ag*hu(nm))
 !   a11      = -0.0049_fp*t1**2 - 0.069_fp*t1 + 0.2911_fp
 !   raih     = max(0.5_fp , -5.25_fp-6.1_fp*tanh(a11*u11-1.76_fp))
 !   rmax     = max(0.62_fp , min(0.75_fp , -2.5_fp*hu(nm)/max(rlabdau,1.0e-20_fp) + 0.85_fp))
 !   uon      = umax * (0.5_fp + (rmax-0.5_fp)*tanh((raih-0.5_fp)/(rmax-0.5_fp)))
 !   uoff     = umax - uon
 !   uon      = max(1.0e-5_fp , uon)
 !   uoff     = max(1.0e-5_fp , uoff)
 !   uwbih    = (0.5_fp*uon**3.0_fp + 0.5_fp*uoff**3.0_fp)**(1.0_fp/3.0_fp)
 !   rksru    = 0.5_fp*(rksr (nm) + rksr (nmu))
 !   rksmru   = 0.5_fp*(rksmr(nm) + rksmr(nmu))
 !   !
 !   ! Van Rijn 2004 formulation
 !   !
 !   phi        = acos((uuu*costu+vvv*sintu) / (umod+waveps))
 !   gamma      = 0.8_fp + phi - 0.3_fp*phi**2
 !   ksc        = sqrt(rksru**2 + rksmru**2)
 !   uratio     = min(uwbih/(u2dh+waveps) , 5.0_fp)
 !   ka(nm)     = ksc * exp(gamma*uratio)
 !   ka(nm)     = min(ka(nm) , 10.0_fp*ksc , 0.2_fp*hu(nm))
 !   ca         = 18.0_fp * log10(12.0_fp*hu(nm)/ka(nm))
 !   taubpu(nm) = ag * (u2dh * u2dh / umod0) / ca**2
 !end subroutine getvanrijnwci

! =================================================================================================
! =================================================================================================
 subroutine vertical_profile_u0(dzu, womegu, Lb, Lt, kxL, LL)
 use m_flow
 use m_flowgeom
 use m_flowtimes
 use m_missing
 use m_waves
 use m_sferic
 use m_filter, only: ustar, itype
 implicit none
 double precision   :: a(kmxx),b(kmxx),c(kmxx),d(kmxx),e(kmxx), dzu(kxL), womegu(kxL-1), dzv(kmxx)
 integer            :: Lb,Lt,kxL,LL

 integer            :: L, k, k1, k2
 double precision   :: dzLw, vstress, adv , adv1, tt, ustv, st2, agp, dzurho

 double precision   :: rhof, gdxi, gdxids, bui, du, cu, ac1, ac2, hup, twot = 0.666666666666d0, slopec

 double precision   :: aa(kmxx),cc(kmxx) ! for five-diaginal matrix
                                         ! aa(i)*u(i-2)+a(i)*u(i-1)+b(i)*u(i)+c(i)*u(i+1)+cc(i)*u(i+2)=d(i)

integer            :: jav3

 a(1:kxL) = 0d0 ; b(1:kxL) = dti ; c(1:kxL) = 0d0

 if ( jafilter.ne.0 ) then
   d(1:kxL) = ustar(Lb:Lt)*dti
 else
    d(1:kxL) = u0(Lb:Lt)*dti   ! put u1 in ddk
 end if

 aa(1:kxL) = 0d0 ; cc(1:kxL) = 0d0

 adv = 0d0; adv1 = 0d0

 ac1 = acL(LL) ; ac2 = 1d0 - ac1

 do L    = Lb, 0 ! Lt
    k    = L - Lb + 1
    k1   = ln(1,L) ; k2 = ln(2,L)
    dzv(k) = ac1*(zws(k1) - zws(k1-1)) + ac2*(zws(k2) - zws(k2-1))      ! volume weighted dzu , ok for pillar
 enddo

 jav3 = 0
 if (javau3onbnd == 1) then
    if (LL > lnxi)     jav3 = 1
 else if (javau3onbnd == 2) then
    if (iadv(LL) == 6) jav3 = 1
 else if (javau == 3) then
                       jav3 = 1
 endif

 do L    = Lb, Lt - 1
    k        = L - Lb + 1
    dzLw     = 0.5d0 *  ( dzu(k+1) + dzu(k) )

    vstress  = (vicwwu(L) + vicoww        ) / dzLw                      ! long time default like DPM,  finite volume weights, dim = (m/s)

    ! vstress  = (vicwwu(L) + vicoww + viskin ) / dzLw                    ! 08-12-14 : add kinematic viscosity

    ! vstress  = ( max(vicwwu(L), vicoww) + viskin ) / dzLw                 ! 23-12-14 : D3D like

    if (jav3 == 1) then         ! vertical advection upwind implicit
       if (womegu(k) > 0d0) then
          if (jarhoxu > 0) then
             adv1 =  womegu(k)*rhou(L)/rhou(L+1)  ; adv  = 0d0
          else
             adv1 =  womegu(k) ; adv  = 0d0                             ! here, omegu(k) lies above u point of same index
          endif
       else if (womegu(k) < 0d0) then
          if (jarhoxu > 0) then
             adv  = -womegu(k)*rhou(L+1)/rhou(L)  ; adv1 = 0d0
          else
             adv  = -womegu(k) ; adv1 = 0d0
          endif
       endif

       ! adv = 0d0 ; adv1 = 0d0   ! noslip test

       !tt     = vstress/dzu(k+1) + adv1/dzv(k+1)
       tt      = (vstress + adv1)/dzu(k+1)
       b(k+1)  = b(k+1)  + tt
       a(k+1)  = a(k+1)  - tt

       !tt     = vstress/dzu(k  ) + adv/dzv(k  )
       tt      = (vstress + adv)/dzu(k  )
       b(k  )  = b(k  )  + tt
       c(k  )  = c(k  )  - tt

       !a(k+1) = a(k+1) - adv1/dzu(k+1)
       !b(k+1) = b(k+1) + adv/dzu(k+1)
       !
       !b(k) = b(k) + adv1/dzu(k)
       !c(k) = c(k) - adv/dzu(k)

       !d(k)   = d(k)   - adv1/dzu(k)   * u0(L) + adv/dzu(k)   * u0(L+1)
       !d(k+1) = d(k+1) + adv1/dzu(k+1) * u0(L) - adv/dzu(k+1) * u0(L+1)

    else if (javau == 4) then             ! vertical advection central implicit

       adv  =  0.5d0*womegu(k)            ! here, omegu(k) lies above u point of same index

       b(k+1)  = b(k+1)  + (vstress - adv) / dzu(k+1)
       a(k+1)  = a(k+1)  - (vstress + adv) / dzu(k+1)

       b(k  )  = b(k  )  + (vstress + adv) / dzu(k)
       c(k  )  = c(k  )  - (vstress - adv) / dzu(k)

    else if ( javau == 0 .or. javau >= 6) then  ! 3D checkerboard

       if (jarhoxu < 3) then
       b(k+1)  = b(k+1)  + vstress / dzu(k+1)
       a(k+1)  = a(k+1)  - vstress / dzu(k+1)

       b(k  )  = b(k  )  + vstress / dzu(k)
       c(k  )  = c(k  )  - vstress / dzu(k)
       else if (jarhoxu == 3) then
          vstress = vstress*( rhou(L)*dzu(k) + rhou(L+1)*dzu(k+1) ) / (2d0*dzLw)
          dzurho  = dzu(k+1)*rhou(L+1)
          b(k+1)  = b(k+1)  + vstress / dzurho
          a(k+1)  = a(k+1)  - vstress / dzurho

          dzurho  = dzu(k)*rhou(L)
          b(k  )  = b(k  )  + vstress / dzurho
          c(k  )  = c(k  )  - vstress / dzurho
       else if (jarhoxu >= 4) then

          b(k+1)  = b(k+1)  + vstress           /   dzu(k+1)
          a(k+1)  = a(k+1)  - vstress*rhou(L)   / ( dzu(k+1)*rhou(L+1) )

          b(k  )  = b(k  )  + vstress           /   dzu(k)
          c(k  )  = c(k  )  - vstress*rhou(L+1) / ( dzu(k)*rhou(L) )
       endif

    else if( javau == 5 ) then
       if (womegu(k) > 0) then
          if (jarhoxu > 0) then
             adv1 =  womegu(k)*rhou(L)/rhou(L+1)  ; adv  = 0d0
          else
             adv1 =  womegu(k) ; adv  = 0d0
          endif
          if( L == Lb ) then
             tt      = adv1 / dzu(k+1)
             b(k+1)  = b(k+1)  + tt
             a(k+1)  = a(k+1)  - tt
          else
             tt = adv1 / dzu(k)
             a(k) = a(k) - tt * 0.125d0
             b(k) = b(k) + tt * 0.750d0 - tt
             c(k) = c(k) + tt * 0.375d0
             tt = adv1 / dzu(k+1)
             aa(k+1) = aa(k+1) + tt * 0.125d0
             a(k+1) = a(k+1) - tt * 0.750d0
             b(k+1) = b(k+1) - tt * 0.375d0 + tt
          endif
       else
          if (jarhoxu > 0) then
             adv = -womegu(k)*rhou(L+1)/rhou(L)  ; adv1 = 0d0
          else
             adv = -womegu(k) ; adv1 = 0d0
          endif
          if( L == Lt-1 ) then
             tt      = adv / dzu(k)
             b(k  )  = b(k  )  + tt
             c(k  )  = c(k  )  - tt
          else
             tt = - adv / dzu(k)
             b(k) = b(k) + tt * 0.375d0 - tt
             c(k) = c(k) + tt * 0.750d0
             cc(k) = cc(k) - tt * 0.125d0
             tt = - adv / dzu(k+1)
             a(k+1) = a(k+1) - tt * 0.375d0
             b(k+1) = b(k+1) - tt * 0.750d0 + tt
             c(k+1) = c(k+1) + tt * 0.125
          endif
       endif

       tt = vstress / dzu(k+1)
       b(k+1) = b(k+1) + tt
       a(k+1) = a(k+1) - tt
       tt = vstress / dzu(k)
       b(k) = b(k) + tt
       c(k) = c(k) - tt
    else
       adv = 0d0; adv1 = 0d0
    endif

    if (jawaveStokes == 3) then                            ! ustokes correction in vertical viscosity
       ustv   = vstress*(ustokes(L) - ustokes(L-1))
       d(k+1) = d(k+1) + ustv / dzu(k+1)
       d(k  ) = d(k  ) - ustv / dzu(k  )
    endif

 enddo

 agp = ag
 if (jahelmert > 0 .and. jsferic > 0) then      ! possibly operationalise later for now avoid the checks
     st2  = sin(dg2rd*yu(L))**2
     agp  = 9.7803253359*(1d0+0.00193185265241*st2)/sqrt(1d0-0.00669437999013*st2)
 endif
 gdxi = agp*dxi(LL)

 if (    jarhoxu >= 2) then
    gdxi = gdxi*rhomean/rhou(L)
 endif

 k1      = ln(1,LL) ; k2 = ln(2,LL)
 gdxids  = gdxi*( s0(k2) - s0(k1) )

 slopec = 0d0
 if (drop3D > 0d0) then
     if (.not. ( iadv(LL) == 21 .or. iadv(LL) >= 23 .and. iadv(LL) <=25)  ) then  ! don't do this for weirs
        hup = s0(k2) - ( min(bob(1,LL), bob(2,LL) ) + drop3D*twot*hu(LL) )
        if (hup < 0) then
            slopec = hup
        else
            hup = s0(k1) - ( min( bob(1,LL), bob(2,LL) ) + drop3D*twot*hu(LL) )
            if (hup < 0) then
                slopec = -hup
            endif
        endif
     endif
 endif

 cu      = gdxi*teta(LL)
 du      = gdxids*(1d0-teta(LL)) - gdxi*slopec

 if ( jafilter.ne.0 .and. itype.eq.3 ) then
    do L = Lb, Lt
       k = L - Lb + 1
       b(k) = b(k) + advi(L)
       d(k) = d(k) - du
    enddo
 else
    do L = Lb, Lt
       k = L - Lb + 1
       b(k) = b(k) + advi(L)
       d(k) = d(k) - adve(L) - du
    enddo
 end if

 if( javau == 5 ) then
    call pentadiag( aa, a, b, c, cc, d, Ru(Lb:), kxL )
 else
    call tridag(a,b,c,d,e,Ru(Lb:),kxL)
 endif

 d(1:kxL) = cu

 if( javau == 5 ) then
    call pentadiag( aa, a, b, c, cc, d, Fu(Lb:), kxL )
 else
    call tridag(a,b,c,d,e,Fu(Lb:),kxL)
 endif

 end subroutine vertical_profile_u0

! =================================================================================================
! =================================================================================================
 subroutine tridag(a,b,c,d,e,u,n)
 implicit none
 integer          :: n, j
 double precision :: a(n),b(n),c(n),d(n),e(n),u(n), bet, accur = 1d-15

 bet =b(1)
 u(1)=d(1)/bet
 do j=2,n
    e(j)=c(j-1)/bet
    bet=b(j)-a(j)*e(j)
    if (abs(bet) < accur) then
        bet = sign(accur,bet)
    endif
    u(j)=(d(j)-a(j)*u(j-1))/bet
 enddo

 do j=n-1,1,-1
    u(j)=u(j)-e(j+1)*u(j+1)
 enddo
 end subroutine tridag

! =================================================================================================
! =================================================================================================
   subroutine pentadiag( aavec, avec, bvec, cvec, ccvec, dvec, x, n )
      implicit none
      integer          :: i, n
      double precision :: aa(n), a(n), b(n), c(n), cc(n), d(n), x(n)
      double precision :: aavec(n), avec(n), bvec(n), cvec(n), ccvec(n), dvec(n)
      double precision :: cof0

      aa = aavec
      a  = avec
      b  = bvec
      c  = cvec
      cc = ccvec
      d  = dvec

      do i = 2,n-1
         cof0 = a(i) / b(i-1)
         b(i) = b(i) - cof0 *  c(i-1)
         c(i) = c(i) - cof0 * cc(i-1)
         d(i) = d(i) - cof0 *  d(i-1)
         cof0 = aa(i+1) / b(i-1)
         a(i+1) = a(i+1) - cof0 *  c(i-1)
         b(i+1) = b(i+1) - cof0 * cc(i-1)
         d(i+1) = d(i+1) - cof0 *  d(i-1)
      enddo

      cof0 = a(n) / b(n-1)
      b(n) = b(n) - cof0 *  c(n-1)
      c(n) = c(n) - cof0 * cc(n-1)
      d(n) = d(n) - cof0 *  d(n-1)

      x(n)   = d(n) / b(n)
      x(n-1) = ( d(n-1) - c(n-1) * x(n) ) / b(n-1)
      do i = n-2,1,-1
         x(i) = ( d(i) - c(i) * x(i+1) - cc(i) * x(i+2) ) / b(i)
      enddo

   end subroutine pentadiag

! =================================================================================================
! =================================================================================================
subroutine getprof_1D(L, hprL, area, width, japerim, calcConv, perim)
use m_profiles
use m_flow
use m_flowgeom
use m_missing
use unstruc_channel_flow
use m_crosssections
use m_cross_helper

implicit none
integer          :: L, japerim, calcConv
double precision :: hprL                 !< hoogte in profiel
double precision :: area                 !< wet cross sectional area
double precision :: width                !< width at water surface
double precision :: perim                !< wet perimeter

double precision :: profw                !< width  of profile
double precision :: profh                !< height of profile
double precision :: hydrad               !< hydraulic radius

double precision :: area2, width2, perim2, cf2, alfa ! second prof i.c. interpolation
double precision :: area_sbk, width_sbk ! second prof i.c. interpolation
double precision :: perimgr, perimgr2, alfg, czg, hpr

double precision :: frcn, cz, cf, conv, af_sub(3), perim_sub(3), cz_sub(3)
double precision :: q_sub(3)             ! discharge per segment
integer          :: LL, ka, kb, itp, ifrctyp
integer          :: k1, k2
double precision :: u1L, q1L, s1L, dpt, factor
type(t_CrossSection), pointer :: cross1, cross2

LL = L
if (L > lnxi) then                      ! for 1D boundary links, refer to attached link
   LL = LBND1D(L)
endif

hpr = hprL

if (abs(kcu(ll))==1 .and. network%loaded) then !flow1d used only for 1d channels and not for 1d2d roofs and gullies
   cz = 0d0

   if (japerim == 0) then ! calculate total area and volume
      call GetCSParsTotal(network%adm%line2cross(LL), network%crs%cross, hpr, area, width, CSCalculationOption, network%adm%hysteresis_for_summerdike(:,LL))
   else ! japerim = 1: calculate flow area, conveyance and perimeter.
      cz = 0d0
      call GetCSParsFlow(network%adm%line2cross(LL), network%crs%cross, hpr, area, perim, width, af_sub = af_sub, perim_sub = perim_sub)

      if (calcConv ==1) then
         u1L = u1(LL)
         q1L = q1(LL)
         k1 = ln(1,LL)
         k2 = ln(2,LL)
         s1L = acl(L)*s1(k1) + (1d0-acl(L))*s1(k2)
         dpt = hu(L)
         cz = 0d0
         call getconveyance(network, dpt, u1L, q1L, s1L, LL, perim_sub, af_sub, conv, cz_sub, cz, area, perim)

         ! For sediment transport the discharge in the main channel is required:
         ! Qmain/ QT = Kmain/KT -> u_main = Kmain/KT * (AT/Amain)
         if (conv > 0d0) then
            u_to_umain(L)  = area*cz_sub(1) * sqrt(af_sub(1)/perim_sub(1)) /  conv
            cfuhi(L)       = ag/(conv/area)**2
            frcu(L)        = cz
            frcu_mor(L)    = cz_sub(1)
            call getCrossDischarge(perim_sub, af_sub, cz_sub, q1L, q_sub)
            q1_main(L) = q_sub(1)
         else
            u_to_umain(L) = 1d0
            cfuhi(L) = 0d0
         endif
      endif

      if (hpr==0d0) then
         wu(L) = 0.01d0
      else
         wu(L) = max(0.01d0,area/hpr)
      endif
      
   endif
   ! finished for 1d network from flow1d
   return
endif


! No flow1d cross input, OR a 1d2d link. Proceeed with conventional prof1D approach.
if (prof1D(1,LL) > 0 ) then            ! direct profile based upon link value
    ka    = 0; kb = 0                  ! do not use profiles
    profw = prof1D(1,LL)
    profh = prof1D(2,LL)
    itp   = prof1D(3,LL)
    if (japerim == 1) then
       frcn    = frcu(LL)
       ifrctyp = ifrcutp(LL)
    endif
else
    ka    = -prof1D(1,LL); kb = -prof1D(2,LL)
    profw = profiles1D(ka)%width
    profh = profiles1D(ka)%height
    itp   = profiles1D(ka)%ityp
    alfa  = prof1d(3,LL)

    if (japerim == 1) then
       if (profiles1D(ka)%frccf .ne. dmiss .and. profiles1D(kb)%frccf .ne. dmiss .and.  &
           profiles1D(ka)%frctp == profiles1D(kb)%frctp) then
           frcn    =  (1d0-alfa)*profiles1D(ka)%frccf  + alfa*profiles1D(kb)%frccf
           ifrctyp = profiles1D(ka)%frctp
       else
           frcn    = frcu(LL)
           ifrctyp = ifrcutp(LL)
       endif
    endif

endif

if (jagrounlay > 0) then
   hpr = hpr + grounlay(LL)
endif

! base nrs == open, negative = closed
if (abs(itp) == 1) then   ! pipe
    call pipe(hpr, profw, area, width, japerim, perim)
else if (abs(itp) == 2) then   ! rectan, peri=wu + 2*hpr
    call rectan  (hpr, profw, profh, area, width, japerim, perim)
else if (abs(itp) == 3) then  ! rectan, peri=wu
    call rectan2D(hpr, profw, profh, area, width, japerim, perim)
else if (abs(itp) == 100 .or. abs(itp) == 101) then  !                          itp >= 100, yzprof
   call yzprofile(hpr,ka,itp, area, width, japerim, frcn, ifrctyp, perim, cf )
endif

if (ka .ne. 0 .and. kb .ne. ka) then     ! interpolate in profiles
    profw = profiles1D(kb)%width
    profh = profiles1D(kb)%height
    itp   = profiles1D(kb)%ityp

    if (abs(itp) == 1) then                   ! pipe
       call pipe(hpr, profw, area2, width2, japerim, perim2)
    else if (abs(itp) == 2) then              ! rectan, peri=wu + 2*hpr
       call rectan  (hpr, profw, profh, area2, width2, japerim, perim2)
    else if (abs(itp) == 3) then              ! rectan, peri=wu
       call rectan2D(hpr, profw, profh, area2, width2, japerim, perim2)
    else if (abs(itp) == 100 .or. abs(itp) == 101) then ! >= 10, conveyance approach
      call yzprofile(hpr, kb,itp,area2, width2, japerim, frcn, ifrctyp, perim2, cf2 )
    endif
    area  = (1d0-alfa)*area  + alfa*area2
    width = (1d0-alfa)*width + alfa*width2

    if (japerim == 1) then
       if  (abs(itp) == 101) then                 ! 1D conveyance
          cf     = (1d0-alfa)*cf     + alfa*cf2
       else
          perim  = (1d0-alfa)*perim  + alfa*perim2
       endif
    endif
endif


if (jagrounlay > 0) then
   if (grounlay(LL) > 0) then
       area = area - argr(LL)
       if (japerim == 1) then
          perim = perim - pergr(LL) + wigr(LL)
       endif
   endif
endif

if (japerim == 1) then

   if (abs(itp) == 101) then                      ! 1D conveyance

      cfuhi(L) = cf

   else

      if (frcn > 0) then
         hydrad  = area / perim                   ! hydraulic radius
         call getcz(hydrad, frcn, ifrctyp, cz,L)
         cfuhi(L) = ag/(hydrad*cz*cz)             ! see note on 2D conveyance in sysdoc5
      else
         cfuhi(L) = 0d0
      endif

      if (jagrounlay > 0) then
         if (grounlay(LL) > 0) then
            call getcz(hydrad, frcuni1Dgrounlay, ifrctyp, czg, L)
            alfg     = wigr(LL)/perim
            cfuhi(L) = (ag/hydrad)*(alfg/czg**2 + (1d0-alfg)/cz**2)
         endif
      endif

   endif

endif

end subroutine getprof_1D

subroutine getprof_1D_min(L, hpr, area, width) ! pressurepipe
use m_profiles
use m_flow
use m_flowgeom
use unstruc_channel_flow
use m_crosssections
use m_cross_helper


implicit none
integer          :: L
double precision :: hpr                  ! hoogte in profiel
double precision :: area                 ! wet cross sectional area
double precision :: width                ! width at water surface

double precision :: profw                ! width  of profile
double precision :: profh                ! height of profile
double precision :: area2, width2        ! second prof i.c. interpolation
double precision :: alfa, hh
integer          :: LL, ka, kb, itp

area = 0d0 ; width = 0d0

LL = L
if (L > lnxi) then                       ! for 1D boundary links, refer to attached link
   LL = LBND1D(L)
endif


if (abs(kcu(ll))==1 .and. network%loaded) then !flow1d used only for 1d channels and not for 1d2d roofs and gullies
   call GetCSParsTotal(network%adm%line2cross(LL), network%crs%cross, hpr, area, width, CS_TYPE_MIN)
   return
endif

if (prof1D(1,LL) > 0 ) then              ! direct profile based upon link value
    ka    = 0; kb = 0                    ! do not use profiles
    profw = prof1D(1,LL)
    profh = prof1D(2,LL)
    itp   = prof1D(3,LL)
else
    ka    = -prof1D(1,LL); kb = -prof1D(2,LL)
    profw = profiles1D(ka)%width
    profh = profiles1D(ka)%height
    itp   = profiles1D(ka)%ityp
endif

! negative = closed
if (itp  == -1) then                      ! pipe
    call pipemin(hpr, profw, area, width)
else if (itp < 0) then                    ! closed rest
   hh = hpr - profh
   if (hh > 0d0) then
       width = profw
       area  = hh*width
   endif
endif

if (ka .ne. 0 .and. kb .ne. ka) then     ! interpolate in profiles
    area2 = 0d0 ; width2 = 0d0
    profw = profiles1D(kb)%width
    profh = profiles1D(kb)%height
    itp   = profiles1D(kb)%ityp
    alfa  = prof1d(3,LL)
    if (itp  == -1) then                       ! pipe
       call pipemin(hpr, profw, area2, width2)
    else                                       ! rest
       hh = hpr - profh
       if (hh > 0d0) then
           width2 = profw
           area2  = hh*width2
       endif
    endif
    area  = (1d0-alfa)*area  + alfa*area2
    width = (1d0-alfa)*width + alfa*width2
endif
end subroutine getprof_1D_min

subroutine yzprofile(hpr, ka, itp, area, width, japerim, frcn, ifrctyp, perim, cfhi )
use m_profiles
use m_physcoef, only : ag
use m_flow    , only : slotw1D
implicit none
integer          :: ka, japerim, itp
double precision :: hpr             ! hoogte in profiel
double precision :: area            ! wet cross sectional area
double precision :: width           ! width at water surface
double precision :: perim           ! wet perimeter
double precision :: cfhi            ! cfuhi(L)

double precision :: wid             ! wid of segment
double precision :: ar              ! ar of segment
double precision :: conv, convall   ! (sum of) conv
double precision :: hpr2            ! height in segment under consideration
double precision :: frcn            ! user defined friction coefficient
double precision :: bl1, bl2, b21   ! bottom levels segment, b21, diff of bl1,bl2, always > 0
double precision :: wu2, ai, aconv, per, hyr, Cz
integer          :: ifrctyp         ! user defined frcition type
integer          :: k, numseg, jac

numseg = size ( profiles1D(ka)%y ) - 1

area = 0d0 ; width = 0d0 ; convall = 0d0; perim = 0d0

jac =0
if (japerim == 1) then
   if (itp == 100) then
      jac  = 1 ! lumped
   else
      jac  = 2 ! 1D conveyance
   endif
endif

do k = 1,numseg

   if (profiles1D(ka)%z(k) < profiles1D(ka)%z(k+1) ) then
      BL1 = profiles1D(ka)%z(k) ; BL2 = profiles1D(ka)%z(k+1)
   else
      BL2 = profiles1D(ka)%z(k) ; BL1 = profiles1D(ka)%z(k+1)
   endif
   hpr2   = hpr - bl1 ! TODO: LUMBRICUS: HK: is hpr niet een hu en bl een echte/nep BL?

   if (hpr2 > 0d0) then
      b21      = BL2 - BL1
      wu2      = abs( profiles1D(ka)%y(k) - profiles1D(ka)%y(k+1) )
      ai       = b21/wu2
      call getseg1D(hpr2,wu2,b21,ai,frcn,ifrctyp, wid,ar,conv,per,jac)
      width  = width + wid
      area   = area  + ar
      if (jac == 2) then
         convall = convall + conv
      else if (jac == 1) then
         perim   = perim + per
      endif
   endif

enddo

if (jac == 2) then
   if (convall > 0 ) then
      aconv = ( area/convall )**2
      cfhi  = ag*aconv
   else
      cfhi  = 0d0
   endif
endif

end subroutine yzprofile

subroutine rectan(hpr, br, hr, area, width, japerim, perim)
use m_flow, only : slotw1D
implicit none
integer          :: japerim
double precision :: hpr                  ! hoogte   in profiel
double precision :: br                   ! breedte van profiel
double precision :: hr                   ! hoogte  van profiel
double precision :: area                 ! wet cross sectional area
double precision :: width                ! width at water surface
double precision :: perim, hp            ! wet perimeter
if (japerim == 1) then
   hp = min(hpr, hr)
else
   hp = hpr
endif
area  = hp*br
width = br
perim = 2d0*hp + br
if (slotw1D > 0 .and. japerim == 0) then
   width = width + slotw1D
   area  = area  + slotw1D*hpr
endif
end subroutine rectan

subroutine rectan2D(hpr, br, hr, area, width, japerim, perim)
use m_flow, only : slotw1D
implicit none
integer          :: japerim
double precision :: hpr                  ! hoogte   in profiel
double precision :: br                   ! breedte van profiel
double precision :: hr                   ! hoogte  van profiel
double precision :: area                 ! wet cross sectional area
double precision :: width                ! width at water surface
double precision :: perim, hp            ! wet perimeter
if (japerim == 1) then
   hp = min(hpr, hr)
else
   hp = hpr
endif
area  = hp*br
width = br
perim = br
if (slotw1D > 0 .and. japerim == 0) then
   width = width + slotw1D
   area  = area  + slotw1D*hpr
endif
end subroutine rectan2D

subroutine pipe(hpr, dia, area, width, japerim, perim) ! half open part
use m_sferic
use m_flow, only : slotw1D
!
! this subroutine computes wetted circle surface as function
! of diameter d and waterdepth dpt, as an option (if jd=1) it can compute
! the derivative da(dpt)/ddpt and (if jw=1) it can also compute the wetted
! perimeter
!
!  dpt   I, water depth
!  dia   I, diameter
!  wet   O, wetted surface
!  dwdd  O, det/ddpt
!  wtp   O, wetted perimeter
!  jd    I, compute dwdd if jd=1
!  jw    I, compute wtp if jw=1
!  sl    I, slotbreedte
implicit none
integer, intent(in)            :: japerim
double precision, intent(in)   :: dia, hpr
double precision, intent(out)  :: area, width, perim

! Local variables

double precision               :: are, dacos, dsqrt, fi, r, sq

r    = 0.5*dia
are  = r - hpr
if (hpr< r) then
   fi = dacos(are/r)
   sq = dsqrt(hpr*(dia - hpr))
   area  = fi*r*r - sq*are
   width = 2*sq
   if (japerim == 1) perim = 2*fi*r
else
   area  = 0.5d0*pi*r*r+(hpr-r)*dia
   width = dia
   if (japerim == 1) then
       if (hpr < dia) then
          fi = dacos(are/r)
          sq = dsqrt(hpr*(dia - hpr))
          area  = fi*r*r - sq*are
          perim = 2*fi*r
       else
          area  = pi*r*r
          perim = twopi*r
       endif
   endif
endif
if (slotw1D > 0 .and. japerim == 0) then
   width = width + slotw1D
   area  = area  + slotw1D*hpr
endif
end subroutine pipe



subroutine pipemin(hpr, dia, area, width) ! top minus part
use m_sferic
use m_flow, only : slotw1D
implicit none
double precision, intent(in)   :: dia, hpr
double precision, intent(out)  :: area, width

double precision               :: are, dacos, dsqrt, fi, r, sq

r = 0.5*dia
if (hpr< r) then
   area  = 0d0
   width = 0d0
else if (hpr < dia) then
   are   = hpr - r
   fi    = dasin(are/r)
   sq    = dsqrt(hpr*(dia - hpr))
   area  = are*dia - fi*r*r - sq*are
   width = dia - 2*sq
else
   area  = (hpr-r)*dia - 0.5d0*pi*r*r
   width = dia
endif
end subroutine pipemin

 subroutine chknan(a, b, n)
 use m_flow

 implicit none
 integer           :: n
 double precision  :: a(n)
 character(len=*)  :: b

 integer           :: i
 logical           :: isnan
 character(len=40) :: tex
 do i = 1,n
    if (isnan(a(i)) ) then
       write(tex,'(I10)') i
       write(*,*)  'isnan: ', b , tex
       call error ('isnan: ', b , tex)
    endif
 !   write(mdump,*) b, i, a(i)
 enddo
 end subroutine chknan

 subroutine checknans()
 use m_flowgeom
 use m_flow
 use m_reduce
 implicit none

 call newfil(mdump     , 'dump')

 call chknan(s0        , 's0       ', ndx)
 call chknan(s1        , 's1       ', ndx)
 call chknan(bbr       , 'bbr      ', ndx)
 call chknan(ccr       , 'ccr      ', ndx)
 call chknan(ddr       , 'ddr      ', ndx)
 call chknan(bb        , 'bb       ', ndx)
 call chknan(dd        , 'dd       ', ndx)
 call chknan(vol0      , 'vol0     ', ndx)
 call chknan(vol1      , 'vol1     ', ndx)
 call chknan(vol1_f    , 'vol1_f   ', ndx)
 call chknan(au        , 'au       ', ndx)
 call chknan(ba        , 'ba       ', ndx)
 call chknan(a1        , 'a1       ', ndx)
 call chknan(hu        , 'hu       ', ndx)
 call chknan(u0        , 'u0       ', ndx)
 call chknan(u1        , 'u1       ', ndx)

 call doclose(mdump)



 end subroutine checknans


subroutine einstein_garcia(da,rs,dj1,dj2)
use m_einstein_garcia
implicit none
double precision :: da,rs, dj1, dj2

double precision :: aa, cck, rsk, dj12, dj22
integer          :: i1, i2,k

if      (da < 0.001d0) then
   i1 = 1; i2  = 1
else if (da < 0.005d0) then
   i1 = 1; i2  = 2
else if (da < 0.01d0) then
   i1 = 2; i2  = 3
else if (da < 0.05d0) then
   i1 = 3; i2  = 4
else if (da < 0.1d0) then
   i1 = 4; i2  = 5
else
   i1 = 5; i2  = 5
endif
if (i1 == i2) then
    aa = 0d0
else
    aa = ( da - d(i1) ) / ( d(i2) - d(i1) )
endif

dj1   = 0d0
dj2   = 0d0
dj12  = 0d0
dj22  = 0d0

do k  = 0,6
  rsk = rs**k
  !cck = (1d0-aa)*c1(i1,k) + aa*c1(i2,k)
  !dj1 = dj1 + cck*rsk
  !cck = (1d0-aa)*c2(i1,k) + aa*c2(i2,k)
  !dj2 = dj2 + cck*rsk

  dj1  = dj1  + c1(i1,k)*rsk
  dj12 = dj12 + c1(i2,k)*rsk
  dj2  = dj2  + c2(i1,k)*rsk
  dj22 = dj22 + c2(i2,k)*rsk

enddo

dj1 = (1d0-aa)*dj1 + aa*dj12
dj2 = (1d0-aa)*dj2 + aa*dj22

if (dj1 .ne. 0d0) then
    dj1 = 1d0/dj1
endif


if (dj2 .ne. 0d0) then
    dj2 = -1d0/dj2
endif


end subroutine einstein_garcia

subroutine check_einstein_garcia(aref,h,z0,rs,ein)
implicit none
double precision :: aref,h,z0,rs,ein, ucrouse, z, dz
integer :: num, k

ein = 0d0
z   = aref
num = 10000
dz  = (h - z) / dble(num)
z   = z - 0.5d0*dz
do k = 1,num
   z = z + dz
   ucrouse = log(z/z0) * ( (aref/(h-aref))*( (h-z)/z) )** rs
   ein = ein + ucrouse*dz
enddo
end subroutine check_einstein_garcia



subroutine check_einstein_garcia2(aref,h,z0,rs,ein)
use m_sediment, only : numintverticaleinstein

implicit none
double precision :: aref,h,z0,rs,ein, ucrouse1, ucrouse2, dz, g,d1,di,d, z1, z2

double precision :: a,b,y1,y2,zl,zm,zlm,zlm2,alfa

integer :: n, k

ein = 0d0
n   = numintverticaleinstein
g   = 1.1
d1  = (h-aref)*(1-g)/(1-g**n)
di  = d1

!d   = 0d0 ! just checking
!do k = 1,n
!   d  = d + di
!   di = g*di
!enddo

!di       = d1
z2       = aref
y1       = z2/z0
zL       = log(y1)

!y2       = h/z0
!zm       = log(y2)
!alfa     = 1d0/6d0
!a        = (zL-zM) / (y1**alfa - y2**alfa)
!b        =  zL - a*y1**alfa

ucrouse2 = zl *  ( (h-z2)/z2 ) ** rs

do k = 1,n
   z1 = z2
   z2 = z1 + di
   ucrouse1 = ucrouse2
   ucrouse2 = 0
   if (k < n) then
      zlm      = log(z2/z0)

  !   zlm      = a*(z2/z0)**alfa + b

      ucrouse2 = zlm *  ( (h-z2)/z2 ) ** rs
   endif
   ein = ein + 0.5d0*(ucrouse1+ucrouse2)*di
   di  = g*di
enddo
ein = ein * (aref/(h-aref) )** rs
end subroutine check_einstein_garcia2


double precision function ucrouse(z,z0,h,a,rs)
use m_einstein_garcia
implicit none
double precision :: z, z0, h, a, rs

ucrouse = log(z/z0) * ( (a/(h-a))*( (h-z)/z) )** rs

end function

subroutine setfixedweirs()      ! override bobs along pliz's, jadykes == 0: only heights, 1 = also dyke attributes
 use m_netw
 use m_flowgeom
 use m_flow
 use m_missing
 use m_alloc
 use unstruc_model
 use timespace
 use unstruc_messages
 use m_fixedweirs
 use kdtree2Factory
 use m_sferic
 use m_polygon
 use m_partitioninfo
 use string_module, only: strsplit
 use geometry_module, only: dbdistance, CROSSinbox, dcosphi, duitpl, normalout
 use unstruc_caching

 implicit none

 integer                       :: np, k, kk, n1, n2, n12, n, nn, L, LL, ja,  jacros, minp, kint, ierr, nt, nh, nhh, i, Lf
 integer                       :: jaweir, Lastfoundk, kf, kL, jarestorepol, Lnt, k1, nna, nnb, nl1, nl2, k3, k4
 integer         , allocatable :: iwu(:), ihu(:)
 double precision              :: SL, SM, XCR, YCR, CRP, Xa, Ya, Xb, Yb, zc, zh, zhu, zhd, af, dz1, dz2, xn, yn, adjacentbob, cosphi, sig, bobL
 double precision, allocatable :: csh(:), snh(:), zcrest(:), dzsillu(:), dzsilld(:), crestlen(:), taludu(:), taludd(:), vegetat(:),ztoeu(:),ztoed(:)
 integer         , allocatable :: iweirtyp(:)
 integer         , allocatable :: ifirstweir(:)

 double precision, dimension(:), allocatable :: dSL
 integer,          dimension(:), allocatable :: iLink
 integer,          dimension(:), allocatable :: iLcr ! link crossed yes no
 integer,          dimension(:), allocatable :: iPol

 integer                                     :: iL, numLL, numcrossedLinks, ii
 integer                                     :: mout, jatabellenboekorvillemonte
 integer                                     :: ierror

 integer                                     :: jakdtree=1
 character(len=5)                            :: sd
 character(len=1), external                  :: get_dirsep
 character(len=200), dimension(:), allocatable       :: fnames
 integer                                     :: jadoorladen, ifil
 double precision                            :: t0, t1, t_extra(2,10)
 character(len=128)                          :: mesg


 if ( len_trim(md_fixedweirfile) == 0 ) then
    ifixedweirscheme = 0
    return
 endif

 jatabellenboekorvillemonte = 0
 if (ifixedweirscheme == 8) jatabellenboekorvillemonte = 1
 if (ifixedweirscheme == 9) jatabellenboekorvillemonte = 2


 call readyy('Setfixedweirs', 0d0)

 !if (allocated(csh) ) then
 !   deallocate(ihu, csh, snh, zcrest, dzsillu, dzsilld, crestlen, taludu, taludd, vegetat) ! (10 arrays)
 !endif

 allocate (ihu(lnx))      ; ihu = 0
 allocate (csh(lnx))      ; csh = 0d0
 allocate (snh(lnx))      ; snh = 0d0
 allocate (zcrest(lnx))  ; zcrest = -1000d0   ! starting from a low value
 allocate (dzsillu(lnx))  ; dzsillu = 0d0
 allocate (dzsilld(lnx))  ; dzsilld = 0d0
 allocate (ztoeu(lnx))   ; ztoeu = 1000d0  ! starting from a high value
 allocate (ztoed(lnx))   ; ztoed = 1000d0  ! starting from a high value
 allocate (crestlen(lnx)) ; crestlen = 3d0
 allocate (taludu(lnx))   ; taludu = 4d0
 allocate (taludd(lnx))   ; taludd = 4d0
 allocate (vegetat(lnx))  ; vegetat = 0d0
 allocate (iweirtyp(lnx)) ; iweirtyp = 0
 allocate (ifirstweir(lnx)) ; ifirstweir = 1                       ! added to check whether fixed weir data is set for the first time at a net link (1=true, 0=false)

 call klok(t0)
 t_extra(1,1) = t0

 ! Load fixed weirs polygons from file.
 ! --------------------------------------------------------------------
 if (len_trim(md_fixedweirfile) > 0) then
    call strsplit(md_fixedweirfile,1,fnames,1)
    jadoorladen = 0
    do ifil=1,size(fnames)
       call oldfil(minp, fnames(ifil))
       N1  = index (fnames(ifil), get_dirsep(), .true.)
       !  fix for Linux-prepared input on Windows
       if ( N1.eq.0 ) then
            N1 = index(fnames(ifil), char(47), .true.)
       end if

       sd  = ''
       if (jampi == 1) then
           sd = '_'//trim(sdmn)
       end if

       N2  = INDEX (fnames(ifil), '.' , .true.)
       if (N2 == 0) then
           N2 = len_trim(fnames(ifil))
       else
           N2 = N2 - 1
       end if
       if (jawriteDFMinterpretedvalues > 0) then
          call newfil(mout, trim(getoutputdir())//'DFM_interpreted_fxwvalues_'//fnames(ifil)(n1+1:n2)//trim(sd)//'.xyz')
          write (mout, '(a)') '* xu yu crest(bob) width(wu) xk3 yk3 xk4 yk4'
       end if
       call reapol(minp, jadoorladen)
       jadoorladen = 1
    enddo
    call klok(t_extra(2,1))
    call klok(t_extra(1,2))
    call pol_to_flowlinks(xpl, ypl, zpl, npl, nfxw, fxw)
    call klok(t_extra(2,2))
    deallocate(fnames)
 end if

 kint = max(lnxi/1000,1)

 call klok(t_extra(1,3))
 allocate (iLink(Lnx))
 allocate (iLcr(Lnx))     ; Ilcr = 0
 allocate (ipol(Lnx))
 allocate (dSL(Lnx))
 if ( cacheRetrieved() ) then
    ierror = 0
    call copyCachedFixedWeirs( npl, xpl, ypl, numcrossedLinks, iLink, iPol, dSL, success )
 else
    success = .false.
 endif
 if ( .not. success ) then
 call find_crossed_links_kdtree2(treeglob,NPL,XPL,YPL,2,Lnx,1,numcrossedLinks, iLink, iPol, dSL, ierror)
    call cacheFixedWeirs( npl, xpl, ypl, numcrossedLinks, iLink, iPol, dSL )
 endif
 call klok(t_extra(2,3))

 call klok(t_extra(1,4))
 if ( ierror == 0) then
    do iL = 1,numcrossedlinks
       L  = iLink(il)
       iLcr(L) = 1
    enddo
 else
    n = 0 ; Lastfoundk = 0
    do L = 1,lnxi

       if (mod(L,kint) == 0) then
           AF = dble(L)/dble(lnxi)
           call readyy('Setfixedweirs', af )
       endif

       n1 = ln(1,L) ; n2 = ln(2,L)
       xa = xz(n1)  ; ya = yz(n1)
       xb = xz(n2)  ; yb = yz(n2)

       iloop:do i = 1,2

           if (i == 1) then
              if (Lastfoundk == 0) cycle
              kf = max(1,     Lastfoundk - 100)
              kL = min(npl-1, Lastfoundk + 100)
           else
              kf = 1
              kL = npl-1
           endif

           Lastfoundk = 0
           do k = kf,kL

               if (xpl(k) .ne. dmiss .and. xpl(k+1) .ne. dmiss) then
                   CALL CROSSinbox (XPL(k), YPL(k), XPL(k+1), YPL(k+1), Xa, Ya, Xb, Yb, jacros, SL, SM, XCR, YCR, CRP, jsferic, dmiss)

                   if ( jacros.eq.1 ) then
                      Lastfoundk = k
                      n = n + 1
                      ilink(n) = L
                      ipol(n)  = k
                      dsl(n)   = SL
                      iLcr(L)  = 1
                      exit iloop
                   end if
               endif
           enddo

       enddo iloop

    enddo
    numcrossedlinks = n
 endif
 call klok(t_extra(2,4))

 call klok(t1)
 write(mesg,"('fixed weirs with kdtree2, elapsed time: ', G15.5, 's.')") t1-t0
 call mess(LEVEL_INFO, trim(mesg))
 write(mesg,"('fixed weirs: read files,  elapsed time: ', G15.5, 's.')") t_extra(2,1)-t_extra(1,1)
 call mess(LEVEL_INFO, trim(mesg))
 write(mesg,"('fixed weirs: pol_to_flowlinks, elapsed time: ', G15.5, 's.')") t_extra(2,2)-t_extra(1,2)
 call mess(LEVEL_INFO, trim(mesg))
 write(mesg,"('fixed weirs: find_crossed_links, elapsed time: ', G15.5, 's.')") t_extra(2,3)-t_extra(1,3)
 call mess(LEVEL_INFO, trim(mesg))
 write(mesg,"('fixed weirs: attributes,  elapsed time: ', G15.5, 's.')") t_extra(2,4)-t_extra(1,4)
 call mess(LEVEL_INFO, trim(mesg))

 nh = 0
 do iL = 1,numcrossedlinks

    L  = ilink(iL)
    k  = ipol(iL)
    SL = dsl(iL)
    n1 = ln(1,L) ; n2 = ln(2,L)

    if (kcu(L) .eq. 1 .or. kcu(L) == 5) then
       cycle ! UNST-2226: test code for forbidding fixed weirs on 1D
    end if

    zc = sl*zpL(k+1) + (1d0-sl)*zpL(k)

    if (abs(kcu(L)) == 2) then
       bobL = min(bob(1,L), bob(2,L))
    else
       bobL = max(bob(1,L), bob(2,L))
    endif

    if ( (zc > bobL .and. zc > zcrest(L)) .or. ( (ifixedweirscheme == 8 .or. ifixedweirscheme == 9) .and. ifirstweir(L) == 1) ) then   ! For Villemonte and Tabellenboek fixed weirs under bed level are also possible

       ! Set whether this is the first time that for this link weir values are set:
       ! As a result, only the first fixed weir under the bed level is used
       ifirstweir(L) = 0

       bob(1,L) = max(bob(1,L), zc) ; bob(2,L) = max(bob(2,L), zc)


       if (kcu(L) .ne. 2 .and. kcu(L) .ne. 1) then
          cycle  ! weirs only on regular links
       endif

       jaweir   = 0
       if (ifixedweirscheme > 0) then
          if (jakol45 == 0) then ! no dzl or dzr specified
             jaweir = 1
          else
             dz1   = sl*dzL(k+1) + (1d0-sl)*dzL(k)
             dz2   = sl*dzR(k+1) + (1d0-sl)*dzR(k)

             if (min (dz1,dz2) >= sillheightmin) then  ! weir if sufficiently high and regular link
                jaweir = 1
             elseif (ifixedweirscheme == 8 .or. ifixedweirscheme == 9) then
                ! For Villemonte and Tabellenboek weirs with low sills are also applied, in order to be consistent with Simona
                jaweir = 1
             endif

             if (jaconveyance2D > 0) then   ! now set adjacent bobs of netlinks | sufficiently perpendicular to fixedweir to local ground level
                do i = 1,2
                   n1 = lncn(i,L)
                   do kk  = 1, nmk(n1)                                  !          |         |
                      Lnt = nod(n1)%lin(kk)                             ! ---------o---------o-------fixedweir
                      Lf = lne2ln(Lnt)                                  !          |         |
                      if (Lf == 0) cycle
                      if (iLcr(abs(Lf)) == 1) cycle
                      nna = kn(1,Lnt)
                      nnb = kn(2,Lnt)
                      xa  = xk(nna) ; ya = yk(nna)
                      xb  = xk(nnb) ; yb = yk(nnb)

                      COSPHI = DCOSPHI(Xpl(k), Ypl(k), xpl(k+1), ypl(k+1), xa, ya, xb, yb, jsferic, jasfer3D, dxymis)
                      if (abs(cosphi) < 0.5d0) then
                          if (nna .ne. n1) then
                              nhh = nna
                              nna = nnb
                              nnb = nhh
                          endif  ! na is now basepoint
                          xa = xk(nna) ; ya = yk(nna)
                          xb = xk(nnb) ; yb = yk(nnb)
                          call duitpl(Xpl(k), Ypl(k), xpl(k+1), ypl(k+1), xa, ya, xb, yb, sig, jsferic)
                          adjacentbob = dmiss
                          if (sig > 0 ) then
                              if (dz2 > 3d0 .and. dz1 < 3d0) then  ! kade at other side deeper than 3 m
                                 adjacentbob = zc - dz1            ! then set kade ground level
                              endif
                          else
                              if (dz1 > 3d0 .and. dz2 < 3d0) then
                                 adjacentbob = zc - dz2
                              endif
                          endif

                          if (Lf > 0 .and. adjacentbob .ne. dmiss) then
                             if (lncn(1,Lf) == n1) then
                                 bob(1,Lf) = adjacentbob
                             else
                                 bob(2,Lf) = adjacentbob
                             endif
                             nl1 = ln(1,Lf) ; nl2 = ln(2,Lf)
                             bl(nl1) = min(bl(nl1), adjacentbob )
                             bl(nl2) = min(bl(nl2), adjacentbob )
                          endif

                      endif

                   enddo

                enddo !1,2
             endif
          endif
       endif

       if (jaweir > 0) then                                      ! set weir treatment

          ihu(L) = k
          call normalout( XPL(k), YPL(k), XPL(k+1), YPL(k+1) , xn, yn, jsferic, jasfer3D, dmiss, dxymis)

          k3 = lncn(1,L) ; k4 = lncn(2,L)
          wu(L) = dbdistance ( xk(k3), yk(k3), xk(k4), yk(k4), jsferic, jasfer3D, dmiss)  ! set 2D link width

          wu(L) = wu(L) * abs( xn*csu(L) + yn*snu(L) )           ! projected length of fixed weir

          if (jakol45 == 2) then                                 ! use local type definition
             !
             ! recompute ground heights if zc is larger than previous crest levels
             !
             if (zc .gt. zcrest(L)) then
                dzsillu(L)  = zc - ztoeu(L)
                dzsilld(L)  = zc - ztoed(L)
             endif
             !
             zcrest(L)  = zc
             zhu = (1d0-sl)*dzl(k) + sl*dzl(k+1)                 ! ground height left
             zhd = (1d0-sl)*dzr(k) + sl*dzr(k+1)                 ! ground height right
             crestlen(L) = (1d0-sl)*dcrest(k) + sl*dcrest(k+1)   ! crest length
             taludu(L)   = (1d0-sl)*dtl(k)    + sl*dtl(k+1)      ! talud at ln(1,L)
             taludd(L)   = (1d0-sl)*dtr(k)    + sl*dtr(k+1)      ! talud at ln(2,L)
             vegetat(L)  = (1d0-sl)*dveg(k)   + sl*dveg(k+1)     ! vegetation on fixed weir
             iweirtyp(L) = iweirt(k)                             ! type of weir
             if (iweirt(k) .eq. 1 ) then
                 iadv(L) = 24 ; jatabellenboekorvillemonte = 1   !  Tabellenboek
             else if (iweirt(k) .eq. 2 ) then
                 iadv(L) = 25 ; jatabellenboekorvillemonte = 1   !  Villemonte
             else
                 iadv(L) = 21                                    !  Subgrid, ifixedweirscheme = 6 or 7
             endif
             !
             ! If link is reversed, exchange ground height levels and taluds
             !
             if (xn*csu(L) + yn*snu(L) < 0d0) then  ! check left/right
                 zh = taludd(L)  ; taludd(L)  = taludu(L)  ; taludu(L)  = zh
                 zh = zhd; zhd = zhu;  zhu = zh
             endif
             !
             ! lowest toe is applied
             !
             if (zc-zhu .lt. ztoeu(L)) then
                ztoeu(L)   = zc - zhu
                dzsillu(L)  = zcrest(L) - ztoeu(L)
             endif
             if (zc-zhd .lt. ztoed(L)) then
                ztoed(L)   = zc - zhd
                dzsilld(L)  = zcrest(L) - ztoed(L)
             endif
             !! write (msgbuf,'(a,2i5,7f10.3)') 'Projected fixed weir', L, iweirtyp(L), zc, bobL, dzsillu(L), dzsilld(L),crestlen(L),taludu(L),taludd(L); call msg_flush()
          else                                                       ! use global type definition
             if (ifixedweirscheme == 7) then
                iadv(L)    = 23    !  Rajaratnam
             else if (ifixedweirscheme == 8) then
                iadv(L)    = 24    !  Tabellenboek
                dzsillu(L) = zc - bl(n1) ; dzsilld(L) = zc - bl(n2)  ! if not specified then estimate
             else if (ifixedweirscheme == 9) then
                iadv(L)    = 25    !  Villemonte
                dzsillu(L) = max(0d0, zc - bl(n1) ) ; dzsilld(L) = max(0d0, zc - bl(n2) ) ! if not specified then estimate
             else
                iadv(L)    = 21    !  Ifixedweirscheme 6
             endif
          endif

          if ( iadv(L) == 21) then
             call setfixedweirscheme3onlink(L)
             if (ifixedweirscheme == 7) then
                 iadv(L) = 23
             endif
          endif

          ! 21 = Ifixedweirscheme 6
          ! 22 = General structure
          ! 23 = Rajaratnam
          ! 24 = Tabellenboek
          ! 25 = Villemonte

          if (jawriteDFMinterpretedvalues > 0) then
             write (mout, '(8(f24.4))') xu(L), yu(L), bob(1,L), fixedweircontraction*wu(L), xk(k3), yk(k3), xk(k4), yk(k4)
          end if
       else
          nh = nh + 1                                            ! just raised bobs
       endif
    else
       if ( ifirstweir(L) == 0  .and. (ifixedweirscheme == 8 .or. ifixedweirscheme == 9) ) then   !  only for fixed weirs under the bed level for Tabellenboek or Villemonte and not for the first time that a fixed weir is set on this link
          ! check for larger ground height height values if at this link already a fixed weir exist

          call normalout( XPL(k), YPL(k), XPL(k+1), YPL(k+1) , xn, yn, jsferic, jasfer3D, dmiss, dxymis)  ! test EdG
          zhu =  (1d0-sl)*dzl(k) + sl*dzl(k+1)
          zhd =  (1d0-sl)*dzR(k) + sl*dzR(k+1)
          if (xn*csu(L) + yn*snu(L) < 0d0) then  ! check left/right
             zh = zhd; zhd = zhu;  zhu = zh
          endif
          !
          ! check whether crestlevel is higher
          !
          if (zc > zcrest(L)) then
             zcrest(L) = zc
             !! write (msgbuf,'(a,i5,f10.3)') 'Higher crest level: ', L,  zcrest(L); call msg_flush()
         endif
         !
         ! Check whether toe is lower. If so, also adjust toe level and the ground height
         ! If ground height is smaller than 1 cm, then this neglected
         !
         if (zc-zhu .lt. ztoeu(L) .and. zhu .gt. 0.01) then
            ztoeu(L)   = zc - zhu
            dzsillu(L)  = zcrest(L) - ztoeu(L)
            !! write (msgbuf,'(a,i5,f10.3)') 'Larger sill up:     ', L,  dzsillu(L); call msg_flush()
         endif
         if (zc-zhd .lt. ztoed(L) .and. zhd .gt. 0.01) then
            ztoed(L)   = zc - zhd
            dzsilld(L)  = zcrest(L) - ztoed(L)
            !! write (msgbuf,'(a,i5,f10.3)') 'Larger sill down:   ', L, dzsilld(L); call msg_flush()
         endif
       endif
    endif
    !! write (msgbuf,'(a,2i5,7f10.3)') 'Projected fixed weir', L, iweirtyp(L), zcrest(L), ztoeu(L), dzsillu(L),ztoed(L),dzsilld(L),taludu(L),taludd(L); call msg_flush()

 enddo
 if (jawriteDFMinterpretedvalues > 0) then
    call doclose(mout)
 end if
 nfxw = 0
 do L = 1,lnxi
    if ( ihu(L) > 0) then
       nfxw = nfxw + 1 ! TODO: HK: incorrect/inconsistent use of nfxw: upon reading the pliz file it is nr of polylines, now it becomes the total number of flow links crossed by a fixed weir.
    endif
 enddo

 if (nfxw > 0) then
    if (allocated (lnfxw) )   deallocate(nfxwL,lnfxw)
    if (allocated (weirdte) ) deallocate(weirdte)
    if (allocated (shlxw) )   deallocate(shlxw,shrxw,crestlevxw,crestlxw,taludlxw,taludrxw,vegxw,iweirtxw)
    allocate ( nfxwL(Lnx) ,stat=ierr)
    call aerr('nfxwL(Lnx)',ierr,lnx)

    call realloc(weirdte, nfxw, keepExisting=.false., fill=0d0, stat=ierr)
    call aerr  ('weirdte', ierr, nfxw)
    allocate ( lnfxw(nfxw) ,stat=ierr)
    call aerr('lnfxw(nfxw)',ierr,nfxw)
    allocate ( shlxw(nfxw) ,stat=ierr)   ! Tabellenboek / Villemonte parameters)
    call aerr('shlxw(nfxw)',ierr,nfxw)
    allocate ( shrxw(nfxw) ,stat=ierr)
    call aerr('shrxw(nfxw)',ierr,nfxw)
    allocate ( crestlevxw(nfxw) ,stat=ierr)
    call aerr('crestlevxw(nfxw)',ierr,nfxw)
    allocate ( crestlxw(nfxw) ,stat=ierr)
    call aerr('crestlxw(nfxw)',ierr,nfxw)
    allocate ( taludlxw(nfxw) ,stat=ierr)
    call aerr('taludlxw(nfxw)',ierr,nfxw)
    allocate ( taludrxw(nfxw) ,stat=ierr)
    call aerr('taludrxw(nfxw)',ierr,nfxw)
    allocate ( vegxw(nfxw) ,stat=ierr)
    call aerr('vegxw(nfxw)',ierr,nfxw)
    allocate ( iweirtxw(nfxw) ,stat=ierr)
    call aerr('iweirtxw(nfxw)',ierr,nfxw)
 endif

 nfxw = 0
 do L = 1,lnxi
    if ( ihu(L) > 0) then
       nfxw = nfxw + 1
       lnfxw(nfxw)    = L
       nfxwL(L)       = nfxw
       crestlevxw(nfxw) = zcrest(L)
       shlxw(nfxw)    = dzsillu(L)
       if (ifixedweirscheme == 8 .or. ifixedweirscheme == 9) then
          shlxw(nfxw) = max (0.1d0, shlxw(nfxw) )  !  in case of the Tabellenboek and Villemonte the ground height left should be at least 0.1 m, as in Simona and Delft3D-FLOW
       endif
       shrxw(nfxw)    = dzsilld(L)
       if (ifixedweirscheme == 8 .or. ifixedweirscheme == 9) then
          shrxw(nfxw) = max (0.1d0, shrxw(nfxw) )  !  in case of the Tabellenboek and Villemonte the ground height right should be at least 0.1 m, as in Simona and Delft3D-FLOW
       endif
       crestlxw(nfxw) = crestlen(L)
       taludlxw(nfxw) = taludu(L)
       taludrxw(nfxw) = taludd(L)
       vegxw(nfxw)    = vegetat(L)
       iweirtxw(nfxw) = iweirtyp(L)
    endif
 enddo

 deallocate(ihu, csh, snh, zcrest, dzsillu, dzsilld, crestlen, taludu, taludd, vegetat, iweirtyp, ztoeu, ztoed)
 if (jatabellenboekorvillemonte == 0 .and. jashp_fxw == 0 .and. allocated(shlxw) ) then
    deallocate(shlxw, shrxw, crestlevxw, crestlxw, taludlxw, taludrxw, vegxw, iweirtxw)
 endif

 do i = 1, nfxw
    L = lnfxw(i)
    if (L > 0) then
       wu(L)    = wu(L) * fixedweircontraction ! TODO: EdG/HK: this will be wrong if MULTIPLE fixed weirs are snapped onto the same flow link (repeated multiplication by fixedweircontraction)
    endif
 enddo

 call doclose(minp)

 if (nfxw > 0) then
    call mess(LEVEL_INFO,'Number of flow Links with fixed weirs :: ', nfxw)
 endif
 if (nh > 0) then
    call mess(LEVEL_INFO,'Number of flow Links with highlines :: ', nh)
 endif

 call readyy(' ', -1d0 )


1234 continue

! deallocate
 if ( jakdtree.eq.1 ) then
    if ( allocated(iLink) ) deallocate(iLink)
    if ( allocated(iPol)  ) deallocate(iPol)
    if ( allocated(dSL)   ) deallocate(dSL)
 end if

 end subroutine setfixedweirs


 subroutine setbobsongullies()      ! override bobs along pliz's, jadykes == 0: only heights, 1 = also dyke attributes
 use m_netw
 use m_flowgeom
 use m_flow
 use m_missing
 use unstruc_model
 use unstruc_messages
 use kdtree2Factory
 use m_sferic
 use m_polygon
 use geometry_module, only: crossinbox, dbdistance

 implicit none

 integer                       :: i, k, L, n1, n2, nt, minp, lastfoundk, kL, kint, kf, jacros
 integer                       :: iL, numLL, numcrossedLinks, ierror, jakdtree=1, ja2pt
 double precision              :: SL, SM, XCR, YCR, CRP, Xa, Ya, Xb, Yb, zc, af, width
 double precision, allocatable :: dSL(:)
 integer,          allocatable :: iLink(:), iLcr(:), iPol(:)
 character(len=5)              :: sd
 character(len=1), external    :: get_dirsep
 double precision              :: t0, t1
 character(len=128)            :: mesg

 if ( len_trim(md_gulliesfile) == 0 ) then
    return
 endif

 call readyy('Setbobsongullies', 0d0)

 call oldfil (minp, md_gulliesfile)
 call reapol (minp, 0)

 if ( jakdtree.eq.1 ) then
    call klok(t0)
    allocate(iLink(Lnx),ipol(Lnx),dSL(Lnx))
    call find_crossed_links_kdtree2(treeglob,NPL,XPL,YPL,2,numL,0,numcrossedLinks, iLink, iPol, dSL, ierror)
    numLL = numcrossedLinks
    if ( ierror.ne.0 ) then                               !   check if kdtree was succesfull, disable if not so
       deallocate(iLink,ipoL,dSL)
       jakdtree = 0
    end if
    call klok(t1)
    write(mesg,"('set bobs (on gullies) with kdtree2, elapsed time: ', G15.5, 's.')") t1-t0
    call mess(LEVEL_INFO, trim(mesg))
 else
    numLL = Lnxi
 end if

 kint = max(numLL/100,1) ; nt = 0
 do iL = 1,numLL

    jacros = 0
    if ( jakdtree.eq.0 ) then
       L = iL
    else
       L = ilink(iL)
       ! L = lne2ln( iLink(iL) )
       IF (L <= 0) cycle
       k = iPol(iL)
    end if

    if (mod(iL,kint) == 0) then
        AF = dble(iL)/dble(numLL)
        call readyy('Setbobsongullies', af )
    endif

    n1 = ln(1,L) ; n2 = ln(2,L)
    if ( jakdtree.eq.0 ) then

       xa = xz(n1)  ; ya = yz(n1)
       xb = xz(n2)  ; yb = yz(n2)

       iloop:do i = 1,2

           if (i == 1) then
              if (Lastfoundk == 0) cycle
              kf = max(1,     Lastfoundk - 100)
              kL = min(npl-1, Lastfoundk + 100)
           else
              kf = 1
              kL = npl-1
           endif

           Lastfoundk = 0
           do k = kf,kL

               if (xpl(k) .ne. dmiss .and. xpl(k+1) .ne. dmiss) then
                   CALL CROSSinbox (XPL(k), YPL(k), XPL(k+1), YPL(k+1), Xa, Ya, Xb, Yb, jacros, SL, SM, XCR, YCR, CRP, jsferic, dmiss)

                   if ( jacros.eq.1 ) then
                      Lastfoundk = k
                      exit iloop
                   end if
               endif
           enddo

        enddo iloop
     else                                                  !       use kdtree to find nearest dike
        k      = iPol(iL)
        jacros = 1
        sL     = dSL(iL)
     end if

     if (jacros == 1) then                                 !        dig the gullies
         zc       = sl*zpL(k+1) + (1d0-sl)*zpL(k)
         bob(1,L) = min(zc, bob(1,L), bob(2,L) ) ; bob(2,L) = bob(1,L)
         bob0(:,L) = bob(:,L)

         bl(n1)   = min(bl(n1),zc)
         bl(n2)   = min(bl(n2),zc)
         nt       = nt + 1

         ja2pt = 0
         if (npl == 2) then
            ja2pt = 1
         else if (k == 1 .and. xpl(3) == dmiss) then
            ja2pt = 1
         else if (xpl(k-1) == dmiss .and. xpl(k+2) == dmiss) then
            ja2pt = 1
         endif

         if (ja2pt == 1) then
            width = dbdistance(xpl(k),ypl(k), xpl(k+1), ypl(k+1), jsferic, jasfer3D, dmiss)
            wu(L) = min(wu(L), width)
         endif

     endif

 enddo

 if (nt > 0) then
    call mess(LEVEL_INFO,'Number of flow Links with lowered gullies :: ', nt)
 endif

 call readyy(' ', -1d0 )

1234 continue

! deallocate
 if ( jakdtree.eq.1 ) then
    if ( allocated(iLink) ) deallocate(iLink)
    if ( allocated(iPol)  ) deallocate(iPol)
    if ( allocated(dSL)   ) deallocate(dSL)
 end if

end subroutine setbobsongullies

subroutine setbobsonroofs( )      ! override bobs along pliz's
 use m_netw
 use m_flowgeom
 use m_flow
 use m_missing
 use unstruc_model
 use unstruc_messages
 use kdtree2Factory
 use m_sferic
 use m_polygon
 use geometry_module
 use m_roofs

 implicit none

 integer                       :: i, k, L, n1, n2, k1, k2, nt, nt2, minp, lastfoundk, kL, kint, kf, jacros
 integer                       :: iL, numLL, numcrossedLinks, ierror, jakdtree=1, inp, n, ip, ip1, ip2, ierr
 double precision              :: SL, SM, XCR, YCR, CRP, Xa, Ya, Xb, Yb, zc, af, roofgutterheight = 0.1d0
 double precision, allocatable :: dSL(:),   blav(:)
 integer,          allocatable :: iLink(:), iLcr(:), iPol(:), nblav(:)
 double precision              :: t0, t1
 character(len=128)            :: mesg

 character(len=5)              :: sd
 character(len=1), external    :: get_dirsep

 if ( len_trim(md_roofsfile) == 0 ) then
    return
 endif

 allocate ( frcuroofs(lnx)      , stat = ierr)
 call aerr('frcuroofs(lnx)'     , ierr,   lnx) ; frcuroofs      = dmiss
 if (infiltrationmodel >= 2) then
    allocate ( infiltcaproofs(ndx) , stat = ierr)
    call aerr('infiltcaproofs(ndx)', ierr,   lnx) ; infiltcaproofs = dmiss
 endif

 call readyy('Setbobsonroofs', 0d0)

 call oldfil (minp, md_roofsfile)
 call reapol (minp, 0)

 inp  = -1
 kc   = 0
 do n = 1,ndxi
    call inwhichpolygon(xzw(n), yzw(n), inp)
    if (inp > 0) then
       kc(n) = inp
    endif
 enddo

 zpmin = 1d10
 do n = 1, npoly
    zpmin(n) = minval(zpl(iistart(n):iiend(n) ) )
 enddo

 if ( jakdtree.eq.1 ) then
    call klok(t0)
    allocate(iLink(Lnx),ipol(Lnx),dSL(Lnx))
    call find_crossed_links_kdtree2(treeglob,NPL,XPL,YPL,2,Lnxi,0,numcrossedLinks, iLink, iPol, dSL, ierror)
    numLL = numcrossedLinks
    if ( ierror.ne.0 ) then                               !   check if kdtree was succesfull, disable if not so
       deallocate(iLink,ipoL,dSL)
       jakdtree = 0
    end if
    call klok(t1)
    write(mesg,"('set bobs (on roofs) with kdtree2, elapsed time: ', G15.5, 's.')") t1-t0
    call mess(LEVEL_INFO, trim(mesg))
 else
    numLL = Lnxi
 end if

 do i = 1,npoly
    do k = iistart(i), iiend(i)
       ipsection(k) = i
    enddo
 enddo

 kint = max(numLL/100,1) ; nt = 0

 if (roofheightuni > 0d0) then
    allocate( blav(npoly), nblav(npoly) ); blav = 0d0 ; nblav = 0d0
    do iL = 1,numLL

       jacros = 0
       if ( jakdtree.eq.0 ) then
          L = iL
       else
          L = iLink(iL)
          IF (L <= 0) cycle
          k = iPol(iL)
       end if

       if (kcu(L) .ne. 2) then
           cycle
       endif

       if (mod(iL,kint) == 0) then
           AF = dble(iL)/dble(numLL)
           call readyy('Setbobsonroofs', af )
       endif

       n1 = ln(1,L) ; n2 = ln(2,L)
       if ( jakdtree.eq.0 ) then

          xa = xz(n1)  ; ya = yz(n1)
          xb = xz(n2)  ; yb = yz(n2)

          iloop:do i = 1,2

              if (i == 1) then
                 if (Lastfoundk == 0) cycle
                 kf = max(1,     Lastfoundk - 100)
                 kL = min(npl-1, Lastfoundk + 100)
              else
                 kf = 1
                 kL = npl-1
              endif

              Lastfoundk = 0
              do k = kf,kL

                  if (xpl(k) .ne. dmiss .and. xpl(k+1) .ne. dmiss) then
                      CALL CROSSinbox (XPL(k), YPL(k), XPL(k+1), YPL(k+1), Xa, Ya, Xb, Yb, jacros, SL, SM, XCR, YCR, CRP, jsferic, dmiss)

                      if ( jacros.eq.1 ) then
                         Lastfoundk = k
                         exit iloop
                      end if
                  endif
              enddo

           enddo iloop
        else                                                  ! use kdtree to find nearest dike
           k      = iPol(iL)
           jacros = 1
           sL     = dSL(iL)
        end if

        if (jacros == 1) then                                 !  set roofgutterheight
            n1  = ln(1,L) ; n2 = ln(2,L)
            i   = ipsection(k)
            blav(i)  = blav(i)  + min( bl(n1), bl(n2) )
            nblav(i) = nblav(i) + 1
            nt = nt + 1
         endif

    enddo

    do k = 1,npoly
       if (nblav(k) > 0) then
          blav(k) = blav(k) / nblav(k)
       endif
    enddo

    do L  = 1,lnxi      ! make flat roof
       if (kcu(L) == 2) then
          n1 = ln(1,L) ; n2  = ln(2,L)
          ip1 = kc(n1) ; ip2 = kc(n2)
          if (ip1 > 0 .and. ip2 == ip1) then     ! both in same poly
             zc       = blav(ip1) + roofheightuni
             bob(1,L) = zc ; bob(2,L) = bob(1,L)
             bob0(:,L) = bob(:,L)
             bl(n1)   = zc
             bl(n2)   = zc
             frcuroofs(L)       = frcuniroof
             if (infiltrationmodel >= 2) then
                infiltcaproofs(n1) = 0d0
                infiltcaproofs(n2) = 0d0
             endif
          endif
       endif
    enddo

 endif

 nt2 = 0
 do iL = 1,numLL

    jacros = 0
    if ( jakdtree.eq.0 ) then
       L = iL
    else
       L = iLink(iL)
       IF (L <= 0) cycle
       k = iPol(iL)
    end if

    if (kcu(L) .ne. 2) then
        cycle
    endif

    if (mod(iL,kint) == 0) then
        AF = dble(iL)/dble(numLL)
        call readyy('Setbobsonroofs', af )
    endif

    n1 = ln(1,L) ; n2 = ln(2,L)
    if ( jakdtree.eq.0 ) then

       xa = xz(n1)  ; ya = yz(n1)
       xb = xz(n2)  ; yb = yz(n2)

       iloop2:do i = 1,2

           if (i == 1) then
              if (Lastfoundk == 0) cycle
              kf = max(1,     Lastfoundk - 100)
              kL = min(npl-1, Lastfoundk + 100)
           else
              kf = 1
              kL = npl-1
           endif

           Lastfoundk = 0
           do k = kf,kL

               if (xpl(k) .ne. dmiss .and. xpl(k+1) .ne. dmiss) then
                   CALL CROSSinbox (XPL(k), YPL(k), XPL(k+1), YPL(k+1), Xa, Ya, Xb, Yb, jacros, SL, SM, XCR, YCR, CRP, jsferic, dmiss)

                   if ( jacros.eq.1 ) then
                      Lastfoundk = k
                      exit iloop2
                   end if
               endif
           enddo

        enddo iloop2
     else                                                  ! use kdtree to find nearest dike
        k      = iPol(iL)
        jacros = 1
        sL     = dSL(iL)
     end if

     if (jacros == 1) then                                 !  set roofgutterheight
         n1 = ln(1,L) ; n2 = ln(2,L)
         ip = ipsection(k)
         if (roofheightuni > 0) then
            zc = blav(ip) + roofheightuni + roofedgeheight
         else
            zc = sl*zpL(k+1) + (1d0-sl)*zpL(k)
         endif
         bob(1,L) = zc ; bob(2,L) = bob(1,L)
         bob0(:,L) = bob(:,L)
         bl(n1)   = min(bl(n1),zc)
         bl(n2)   = min(bl(n2),zc)
         iadv(L)  = 8
         nt2 = nt2 + 1
     endif

 enddo


 do L  = 1,lnxi    ! roofgutter connection
    if (kcu(L) == 7) then
       n1  = ln(1,L)   ; n2  = ln(2,L)
       k1  = lncn(1,L) ; k2  = lncn(2,L)
       ip1 = kc(n1)  ; ip2 = kc(n2)
       if (ip1 > 0) then
          bob(1,L) = bl(n1) ; ! zk(k1) = bl(n1)
       endif
       if (ip2 > 0) then
          bob(2,L) = bl(n2) ; ! zk(k2) = bl(n2)
       endif
       bob0(:,L) = bob(:,L)
       if (ip1 > 0 .or. ip2 > 0) then
          dx(L)        = max(dx(L), dxminroofgutterpipe)
          frcuroofs(L) = frcuniroofgutterpipe
       endif
    endif
 enddo

 if (nt > 0) then
    call mess(LEVEL_INFO,'Number of roof polygons                   :: ', npoly)
    call mess(LEVEL_INFO,'Number of flow Links with roof attributes :: ', nt2  )
 endif

 call readyy(' ', -1d0 )

1234 continue

! deallocate
 if ( jakdtree.eq.1 ) then
    if ( allocated(iLink) ) deallocate(iLink)
    if ( allocated(iPol)  ) deallocate(iPol)
    if ( allocated(dSL)   ) deallocate(dSL)
 end if

 call deallocpoladm()
 if (allocated (blav) ) deallocate(blav, nblav)

 end subroutine setbobsonroofs

 subroutine make1D2Dconnections()
 use network_data, only: imake1d2dtype, searchRadius1D2DLateral, I1D2DTP_1TO1, I1D2DTP_1TON_EMB, I1D2DTP_1TON_LAT
 use geometry_module
 use gridoperations
 use m_samples
 use m_polygon
 use m_sferic, only: jsferic, jasfer3D
 integer :: minp, ierr
 character FILNAM*86
 minp = 0
 Filnam = '*.pliz, *.xyz'
 select case (imake1d2dtype)
 case (I1D2DTP_1TO1) ! 0: HK
    CALL FILEMENU(minp,FILNAM)
    if (minp == -1) then
       ierr = make1D2Dinternalnetlinks(xpl(1:npl), ypl(1:npl), zpl(1:npl))
    else if (index(filnam, '.pliz' ) > 0)  then
       call reapol (minp, 0)
       call make1D2Droofgutterpipes()
    else if (index(filnam, '.xyz'  ) > 0)  then
       call reasam(minp, 0)
       call make1D2Dstreetinletpipes()
    endif
    call doclose(minp)
 case (I1D2DTP_1TON_EMB)
    ierr = ggeo_make1D2Dembeddedlinks(jsferic, jasfer3D)
 case (I1D2DTP_1TON_LAT)
    ierr = ggeo_make1D2DRiverLinks(jsferic, jasfer3D, searchRadius1D2DLateral)
 case default
    call QNERROR('Invalid 1D2D algorithm selected. Please check your network parameters.', '', '')
 end select

 end subroutine make1D2Dconnections

subroutine switchiadvnearlink(L)
use m_flowgeom
use m_flow
implicit none
integer :: L, k1, k2, kk,LL, iadv1, iadv2

k1 = ln(1,L) ; k2 = ln(2,L)

if (iadvec==0) then
   iadv1 = 0
   iadv2 = 0
elseif (u0(L) > 0) then
   iadv1 = 8  ! piaczek incoming upwind
   iadv2 = 0  ! noadv downstream
else if (u0(L) < 0) then
   iadv1 = 0
   iadv2 = 8
else ! == (now safe for grid direction)
   iadv1 = 8
   iadv2 = 8
end if

do kk  = 1,nd(k1)%lnx
   LL = iabs( nd(k1)%ln(kk) )
   if ( iadv(LL) .ne. 22 .and. (kcu(LL) == 1 .or. kcu(LL) == 2)) then ! Only for regular 1D or 2D.
        iadv(LL) = iadv1
   endif
enddo
do kk  = 1,nd(k2)%lnx
   LL = iabs( nd(k2)%ln(kk) )
   if ( iadv(LL) .ne. 22 .and. (kcu(LL) == 1 .or. kcu(LL) == 2)) then ! Only for regular 1D or 2D.
        iadv(LL) = iadv2
   endif
enddo

end subroutine switchiadvnearlink

subroutine setfixedweirscheme3onlink(L)
use m_flowgeom
use m_flow
implicit none
integer :: L, nn, n12,kk,LL

teta(L) = 1d0

if (iadv(L) .ne. 24 .and. iadv(L) .ne. 25) then                      ! no change in advection for Tabellenboek and Villemonte
   do nn  = 1,2
      n12 = ln(nn,L)
      do kk  = 1,nd(n12)%lnx                                         ! and flag non-21 links to perot incoming only
          LL = iabs( nd(n12)%ln(kk) )
          if ( iadv(LL) < 21 .or. iadv(LL) > 25) then
               iadv(LL) = 4
          endif
          teta(LL) = 1d0
      enddo
   enddo
endif

end subroutine setfixedweirscheme3onlink

subroutine heatu(timhr)
use m_flow
use m_flowgeom
use m_sferic
implicit none

double precision :: timhr

double precision :: qsnom
integer          :: n, kb, kt


heatsrc0 = 0d0                                              ! array of heat sources zero

if (jamapheatflux > 0 .or. jahisheatflux > 0) then          ! map output zero
   if ( jatem.eq.3 ) then
      Qtotmap=0d0
   else if ( jatem.eq.5 ) then
      Qtotmap=0d0
      Qsunmap=0d0
      Qevamap=0d0
      Qconmap=0d0
      Qlongmap=0d0
      Qfrevamap=0d0
      Qfrconmap=0d0
   end if
endif

call qsun_nominal(anglon, anglat, timhr, qsnom) ! for models not in spherical coordinates do this just once

!epshstem     = 0.001d0
!chktempdep   = 0.0d0
!Soiltempthick = 0.2d0

!$OMP PARALLEL DO   &
!$OMP PRIVATE(n,kb,kt)
do n = 1,ndxi
   if (nd(n)%lnx == 0) cycle   ! The need for this statement makes Santa Claus unhappy
   if (hs(n) < epshstem) cycle
   call heatun(n,timhr,qsnom)
   if (hs(n) < chktempdep) then
      call getkbotktop(n,kb,kt)
      heatsrc0 (kb:kt) = heatsrc0 (kb:kt)*hs(n)/chktempdep
   endif
enddo
!$OMP END PARALLEL DO

end subroutine heatu

subroutine heatun(n, timhr, qsno)
use m_flow
use m_flowgeom
use m_sferic
use m_itdate
use unstruc_model
use m_flowtimes
use m_heatfluxes
 use m_transport, only: constituents, itemp

implicit none

double precision, intent (in) :: timhr, qsno
integer         , intent (in) :: n

integer          :: i, k, kb, kt, k2, L, LL, j, j2, ncols, lunadh = 0 , jafree = 0 ! D3D
double precision :: rlon, rlat, sc, qsn, qsu, qsnom, presn, tairn, twatn, twatK, rhumn, cloun, windn
double precision :: ce, ch, qwmx, qahu, tl, Qcon, Qeva, Qlong, sg, pvtamx, pvtwmx, pvtahu, delvap
double precision :: dexp, zlo, zup, explo, expup, ratio, rcpiba, qheat, atot

double precision :: w(20), Qtot, Qfree, b, gred, wfree, Qfrcon, Qfreva, rhoa0, rhoa10

double precision :: prair=0.7d0, pr2=.49d0, xnuair=16d-6, cfree=0.14d0

double precision :: rdry=287.05d-2 , rvap=461.495d-2 , evafac = 1d0

double precision :: hlc, arn, wxL, wyL, uL, vL, uxL, uyL, bak2, twatb

double precision :: qsunsoil, qwatsoil, watsoiltransfer, rdtsdz, soiltemprev, pvtamxB, pvtwmxB


presn   = 1d-2*paver                 ! Air pressure (mbar)
rhumn   = 1d-2*backgroundhumidity    ! ( )
cloun   = 1d-2*backgroundcloudiness  ! ( )
ce      = Dalton                     ! Dalton  number = 1.50e-3 (Gill, 1982)           evaporative flux
ch      = Stanton                    ! Stanton number = 1.45e-3 (Friehe&Schmitt, 1976) convective heat flux
qsu     = 0d0
qsnom   = qsno
call getlink1(n,L)
if (jarelativewind == 1) then
    wxL = wx(L) - ucx(ktop(n))
    wyL = wy(L) - ucy(ktop(n))
else
    wxL = wx(L)
    wyL = wy(L)
endif
windn  = sqrt( wxL*wxL + wyL*wyL )

call getkbotktop(n,kb,kt)

twatn = constituents(itemp, kt)
if (surftempsmofac > 0d0) then
   arn    = ba(n)
   do LL  = 1,nd(n)%lnx
      L   = iabs( nd(n)%ln(LL) )
      k2  = ln(1,L) + ln(2,L) - n
      if (hs(k2) > epshstem) then
         bak2  = surftempsmofac*ba(k2)
         twatn = twatn + constituents(itemp, ktop(k2))*bak2
         arn   = arn   + bak2
      endif
   enddo
   if (arn  > 0d0) then
      twatn = twatn / arn
   endif
endif

tairn = tair(n)

if (jatem == 3) then                 ! excess

   hlc    = 4.48d0 + 0.049d0 * twatn + fwind * ( 3.5d0 + 2.05d0*windn ) * ( 1.12d0 + 0.018d0*twatn + 0.00158d0*twatn**2 )

   qheat  = -hlc*(twatn-tairn)
   rcpiba = rcpi*ba(n)
   heatsrc0(kt) = heatsrc0(kt) + qheat*rcpiba  ! fill heat source array

   if (jamapheatflux > 0 .or. jahisheatflux > 0) then          ! todo, only at mapintervals
      Qtotmap(n) = qheat
   endif

else if (jatem == 5) then

   rhumn  = min(1d0, max(0d0, 1d-2*rhum(n) ) )
   cloun  = min(1d0, max(0d0, 1d-2*clou(n) ) )

   if (japatm > 0) then
       presn = 1d-2*patm(n)
   endif
                             ! Solar radiation restricted by presence of clouds and reflection of water surface (albedo)
   if (jasol == 1) then      ! Measured solar radiation qradin specified in .tem file
      qsu = qrad(n) * (1d0-albedo)
   else                      ! Calculate solar radiation from cloud coverage specified in file
      if (jsferic == 1) then
          call qsun_nominal(xz(n), yz(n), timhr, qsnom)
      endif
      if (qsnom > 0d0) then
         qsu   = qsnom * (1d0 - 0.40d0*cloun - 0.38d0*cloun*cloun) * (1d0-albedo)
      else
         qsu   = 0d0
      endif
   endif

   rcpiba = rcpi*ba(n)
   qsn    = qsu*rcpiba

   if (qsn > 0d0 ) then

      if (kmx > 0) then     ! distribute incoming radiation over water column
         ! zab  = (min(0.5d0*hs(n) ,Secchidepth)) / 1.7d0

         if (Secchidepth2 > 0d0) then
            j2 = 2
         else
            j2 = 1
         endif

         do j=j2,1,-1

            if (j==1 .and. jaSecchisp > 0) then
               zab(1) = Secchisp(n) / 1.7d0
            endif

            zlo   = 0d0
            explo = 1d0

            do k  = kt,kb,-1
               zup     = zlo ; expup   = explo
               zlo     = zws(kt) - zws(k-1)
               ratio   = zlo/zab(j)
               if (ratio   > 4d0) then !  .or. k.eq.kb) then
                  explo    = 0.0
               else
                  explo    = exp(-ratio)
               endif
               dexp        = expup-explo
               if (dexp > 0d0) then
                  heatsrc0(k) = heatsrc0(k) + sfr(j)*qsn*dexp
               else
                  exit
               endif
            enddo
         enddo

      else
         heatsrc0(n) = heatsrc0(n) + qsn
      endif

   endif

   if (kmx > 0 .and. Soiltempthick > 0) then
       if (qsn > 0d0) then
          qsunsoil = qsu*explo
       else
          qsunsoil = 0d0
       endif
       watsoiltransfer = 1d0/(0.5d0*Soiltempthick)           ! thermalcond sand = 0.15 -> 4 for dry -> saturated, [W/mK]
       twatb           = constituents(itemp, kb)
       qwatsoil        = watsoiltransfer*( twatb - tbed(n) )
       heatsrc0(kb)    = heatsrc0(kb) - rcpiba*qwatsoil
       rdtsdz          = rcpi*dts/Soiltempthick
       tbed(n)         = ( tbed(n) + rdtsdz*( qsunsoil + watsoiltransfer* twatb )  ) / ( 1d0 + watsoiltransfer*rdtsdz )
   endif


   ! PVTWMX = PVapour at TWater and MaX relative humidity
   ! PVTAMX = PVapour at TAir   and MaX relative humidity
   pvtamx = 10d0**((0.7859d0+0.03477d0*tairn)/(1d0+0.00412d0*tairn)) ! saturation pressure of water vapour in air remote (ewl)
   pvtwmx = 10d0**((0.7859d0+0.03477d0*twatn)/(1d0+0.00412d0*twatn)) ! and near water surface (ew); eq.(A.12):

   !pvtamxB = 6.1121d0*exp( (18.678d0 - (tairn/234.5d0))*(tairn/(257.14d0+tairn) ) )  ! Buck
   !pvtwmxB = 6.1121d0*exp( (18.678d0 - (twatn/234.5d0))*(twatn/(257.14d0+twatn) ) )  ! Buck

   pvtahu = rhumn*pvtamx                                             ! vapour pressure in air remote (eal)

   qwmx   = (0.62d0*pvtwmx)/(presn - 0.38d0*pvtwmx)                  ! specific humidity of air remote and
   qahu   = (0.62d0*pvtahu)/(presn - 0.38d0*pvtahu)                  ! saturated air near water surface; eq.(A.9)+(A.10):

   tl     = 2.5d6 - 2.3d3*twatn                                      ! latent heat tl; eq.(A.19.b): (J/kg)

   if (Stanton < 0) then                                             ! if specified negative, use windspeed dependent Cd coeff
       ch = abs(Stanton)*cdwcof(L)
   endif
   if (Dalton < 0) then                                              ! if specified negative, use windspeed dependent Cd coeff
       ce = abs(Dalton )*cdwcof(L)
   endif

   delvap = qwmx-qahu               ! D3D, both positive and negative evaporation, cannot be correct
   if (jadelvappos == 1) then
      delvap = max(0d0, delvap)     ! DPM, DFM This must be positive, otherwise heat is pumped into water
   endif                            ! causing air to cool down below prescribed temperature, immedia. and

   Qeva   = -ce*rhoair*windn*delvap*tl                            ! heat loss of water by evaporation eq.(A.19.a); Dalton number is ce:

   Qcon   = -ch*rcpa*windn*(twatn-tairn)                          ! heat loss of water by convection eq.(A.23); Stanton number is ch:

   twatK  =  twatn + tkelvn
   Qlong  = -em*stf*(twatK**4d0)*(0.39d0-0.05d0*sqrt(pvtahu))     ! heat loss by effective infrared back radiation hl, restricted by
   Qlong  =  Qlong*(1d0 - 0.6d0*cloun**2 )                        !  presence of clouds and water vapour in air; eq.(A.22):

   Qfree  = 0d0 ; Qfrcon = 0d0 ; Qfreva = 0d0                     ! Contribution by free convection:
   rhoa0  = ((presn-pvtwmx)/rdry + pvtwmx/rvap) / (Twatn + Tkelvn)
   rhoa10 = ((presn-pvtahu)/rdry + pvtahu/rvap) / (Tairn + Tkelvn)
   if (jaroro > 0) then
      if (jaroro == 2) then
         roair(n) = rhoa0
      else if (jaroro == 3) then
         roair(n) = rhoa10
      else if (jaroro == 4) then
         roair(n) = 0.5d0*(rhoa10+rhoa0)
      endif
   endif
   gred   = 2d0*ag*(rhoa10-rhoa0)/(rhoa0+rhoa10)
   if (gred > 0d0) then                                           ! Ri= (gred/DZ)/ (du/dz)2, Ri>0.25 stable
       wfree  =  gred*xnuair/pr2
       wfree  =  cfree*wfree**0.33333333d0
       Qfrcon = min(0d0, -rcpa*wfree*(twatn-tairn)*evafac )                   ! Free convective sensible heat loss:
       Qfreva = min(0d0, -wfree*(qwmx-qahu)*tl*evafac*(rhoa0+rhoa10)*0.5d0 )  ! Free convective latent/evaporation heat loss:
       Qfree  =  Qfrcon + Qfreva
   endif

   qheat = Qeva + Qcon + Qlong + Qfree                            ! net heat flux [W/m^2] into water, solar radiation excluded:
   if (jaevap > 0) then
      evap(n) = (Qeva+Qfreva)/(tL*rhomean)                        ! (J/sm2)/(J/kg)/kg/m3) = (m/s)
   endif

   heatsrc0(kt) = heatsrc0(kt) + qheat*rcpiba                     ! fill heat source array

   if (jamapheatflux > 0 .or. jahisheatflux > 0) then ! todo, only at mapintervals
      Qsunmap(n)   = Qsu
      Qevamap(n)   = Qeva
      Qconmap(n)   = Qcon
      Qlongmap(n)  = Qlong
      Qfrevamap(n) = Qfreva
      Qfrconmap(n) = Qfrcon
      Qtotmap(n)   = Qsu + qheat
   endif

  !if (ti_xls > 0) then

  Atot  = 0d0                        ! these 2 lines outside loop
  w     = 0d0                        ! array of spatially averaged output

  b     = ba(n)                   ! Spatially averaged time series output :
  atot  = atot + b                ! Total area
  w( 1) = timhr/24d0              ! Time in days
  w( 2) = w( 2) + b*tairn         ! tair
  w( 3) = w( 3) + b*constituents(itemp, kt)      ! Twatn, SST
  if (soiltempthick > 0d0) then
     w( 4) = w( 4) + b*tbed(n)       ! tbed
  endif
  w( 5) = w( 5) + b*(qsu + qheat) ! qtot
  w( 6) = w( 6) + b*Qsu           ! Qsun
  w( 7) = w( 7) + b*Qlong         ! QLw
  w( 8) = w( 8) + b*Qcon          ! Qcon
  w( 9) = w( 9) + b*Qeva          ! Qeva
  w(10) = w(10) + b*Qfrcon        ! Qfreecon
  w(11) = w(11) + b*Qfreva        ! Qfree
  w(12) = w(12) + b*windn         ! wind
  w(13) = w(13) + b*rhumn         ! rhum
  w(14) = w(14) + b*cloun         ! clou
  w(15) = w(15) + b*presn         ! pres

  ncols = 15
  if (Atot  > 0d0) then
      w(2:ncols) = w(2:ncols) / Atot
  endif
  Qsunav = w(6) ; Qlongav = w(7) ; Qconav = w(8) ; Qevaav = w(9) ; Qfrconav = w(10) ; Qfrevaav = w(11)

     !if (lunadh == 00) then
     !    call newfil(lunadh, trim(md_ident)//'Spatially_Averaged_Heatfluxes.tek')
     !    write(lunadh,'(a)') '* column  1: minut :'
     !    write(lunadh,'(a)') '* column  2: T_air :'
     !    write(lunadh,'(a)') '* column  3: SST   :'
     !    write(lunadh,'(a)') '* column  4: T_bed :'
     !    write(lunadh,'(a)') '* column  5: Q_tot :'
     !    write(lunadh,'(a)') '* column  6: Qsun  : input solar radiation   '
     !    write(lunadh,'(a)') '* column  7: Qlw   : back radiation'
     !    write(lunadh,'(a)') '* column  8: Qcon  : convection'
     !    write(lunadh,'(a)') '* column  9: Qeva  : evaporation'
     !    write(lunadh,'(a)') '* column 10: Qfrconav : free convection'
     !    write(lunadh,'(a)') '* column 11: Qfrevaav : free evaporation'
     !    write(lunadh,'(a)') '* column 12: Wind  :'
     !    write(lunadh,'(a)') '* column 13: Rhum  :'
     !    write(lunadh,'(a)') '* column 14: Clou  :'
     !    write(lunadh,'(a)') '* column 15: Pres  :'
     !    write(lunadh,'(a)') 'BL01'
     !    write(lunadh,'(a)') '105125   15 '
     !endif
     !write(lunadh,'(20(1x,g12.6))') ( w(i), i = 1,ncols )
  !endif

endif

end subroutine heatun

subroutine qsun_nominal(rlon, rlat, timhr, qs)
   use m_sferic
   use m_flowtimes, only : timjan, tzone
   implicit none

   double precision :: rlat, rlon, timhr, qs

   double precision :: decln, w0, w1, d, e, tm , snh


   ! Calculate sine of the angle of the sun above the horizon: SNH
   ! d is the declination angle
   ! June 21st is the 171st day after TM=0

   tm     = timjan + timhr
   !if (jsferic > 0) then
      tm     = tm + 24.0d0*rlon/360.0d0 - tzone
   !endif
   w0     = twopi / (365.24d0*24d0)
   w1     = twopi / (24d0)
   decln  = 23.5d0*dg2rd
   d      = decln * cos(w0*tm - 2.950d0)
   e      = rlat*dg2rd
   snh    = -cos(e) * cos(d) * cos(w1*tm) + sin(e) * sin(d)
   snh    = max(0d0,min(1d0,snh))
   qs     = 1368d0 * snh *  0.76d0
end subroutine qsun_nominal


!> update the z-layer administration in parallel computations
!>    check bl and kmxn
!>    update kmxn, kmxL
subroutine update_vertadmin()
   use m_partitioninfo
   use m_flowgeom
   use m_flow
   use unstruc_messages
   implicit none

   character(len=128)                            :: mesg

   double precision, dimension(:,:), allocatable :: dum

   integer                                       :: k, L
   integer                                       :: n3, n4
   integer                                       :: ierror

   ierror = 0

   if ( jampi.eq.0 ) return   ! intended for parallel computations only

   if ( kmx.le.0 ) return    ! 3D only

!  allocate dummy array
   allocate(dum(2,Ndx))

!  bl, kmxn: filly dummy array
   do k=1,Ndx
      dum(1,k) = dble(kmxn(k))
      dum(2,k) = bl(k)
   end do
!  udpate dummy array
   call update_ghosts(ITYPE_SALL, 2, Ndx, dum, ierror)
   call update_ghostboundvals(ITYPE_SALL, 2, Ndx, dum, 0, ierror)
   if ( ierror.ne.0 ) then
      call mess(LEVEL_INFO, 'update_vertadmin: error')
      ierror = 1
      goto 1234
   end if

!  check bl and kmxn values
   do k=1,Ndx
      if ( int(dum(1,k)).ne.kmxn(k) ) then
         write(mesg,"('update_vertadmin: kmxn error, k=', I7 )") k
         call mess(LEVEL_INFO, mesg)
         ierror = 1
         goto 1234
      end if

      if ( dum(2,k).ne.bl(k) ) then
         write(mesg,"('update_vertadmin: bl error, k=', I7 )") k
         call mess(LEVEL_INFO, mesg)
         ierror = 1
         goto 1234
      end if
   end do

   if ( allocated(dum) ) deallocate(dum)
   allocate(dum(1,Lnx))

!  kmxL: filly dummy array
   do L=1,Lnx
      dum(1,L) = dble(kmxL(L))
   end do
!  update dummy array
   call update_ghosts(ITYPE_U, 1, Lnx, dum, ierror)

   if ( ierror.ne.0 ) then
      call mess(LEVEL_INFO, 'update_vertadmin: error')
      ierror = 1
      goto 1234
   end if

!  update values
   do L=1,Lnx
      if ( int(abs(dum(1,L))).ne.kmxL(L) ) then
!         write(mesg,"('update_vertadmin: kmxL error, L=', I7, 2I7 )") L, kmxL(L), int(dum(1,L))
!         call mess(LEVEL_INFO, trim(mesg))
!         ierror = 1

         kmxL(L) = int(abs(dum(1,L)))
      end if
   end do

!   if ( allocated(dum) ) deallocate(dum)
!   allocate(dum(2,Lnx))
!
!!  kmxc: fill dummy array
!   do L=1,Lnx
!      n3 = lncn(1,L)
!      n4 = lncn(2,L)
!      dum(1,L) = dble(kmxc(n3))
!      dum(2,L) = dble(kmxc(n4))
!   end do
!!  update dummy array
!   call update_ghosts(ITYPE_U, 2, Lnx, dum, ierror)
!
!   if ( ierror.ne.0 ) then
!      call mess(LEVEL_INFO, 'update_vertadmin: error')
!      ierror = 1
!      goto 1234
!   end if
!
!!  udpate values
!   do L=1,Lnx
!      n3 = lncn(1,L)
!      n4 = lncn(2,L)
!      if ( (int(dum(1,L)).ne.kmxc(n3) .or. int(dum(2,L)).ne.kmxc(n4)) ) then
!!         write(mesg,"('update_vertadmin: kmxc error, L=', I7 )") L
!!         call mess(LEVEL_INFO, trim(mesg))
!!         ierror = 1
!         kmxc(n3) = int(dum(1,L))
!         kmxc(n4) = int(dum(2,L))
!      end if
!   end do

   if ( ierror.eq.1 ) then
     call mess(LEVEL_ERROR, 'update_vertadmin: vertical layer administration out of sync', ' ', ' ')
!     stop
   end if

1234 continue
   if ( allocated(dum) ) deallocate(dum)

   return
end subroutine update_vertadmin

!> disable ghostcells that have no internal cells in the other subdomains by setting the wu of their flowlinks to zero
!>   and rely on sethu to disable the flowlinks
!>   an invalid ghostcell is a flownode, say k, that:
!>     -is not a boundary node (k.le.Ndxi), and
!>     -is not in the own subdomain (idomain(k).ne.my_rank), and
!>     -is not a member of ghostlist_sall
subroutine disable_invalid_ghostcells_with_wu()
   use m_partitioninfo
   use m_flowgeom, only: Ndx, Ndxi, nd, wu
   implicit none

   integer, dimension(:), allocatable          :: imask
   integer                                     :: i, k, L
   integer                                     :: ierror

   ierror = 0  ! so far, so good
   if ( jampi.eq.0 ) return   ! nothing to do

   ierror = 1

!  allocate
   allocate(imask(Ndx)) ! safety, could also be Ndxi

!  mark the flownodes in the ghostlist
   imask = 0
   do i=1,nghostlist_sall(ndomains-1)
      k = ighostlist_sall(i)
      imask(k) = 1
   end do

!  check non-boundary flownodes and disable cells that are neither in own subdomain nor in ghostlist by setting wu's of their flowlinks to zero
   do k=1,Ndxi
      if ( imask(k).eq.0 .and. idomain(k).ne.my_rank ) then
         do i=1,nd(k)%lnx
            L = iabs(nd(k)%ln(i))
            wu(L) = 0d0
         end do
      end if
   end do

   ierror = 0
1234 continue

   if ( allocated(imask) ) deallocate(imask)

   return
   end subroutine disable_invalid_ghostcells_with_wu


! Anti-creep
subroutine anticreep( L )

   use m_flow
   use m_flowgeom
   use m_transport
   use m_flowparameters

   implicit none
   double precision, allocatable, dimension(:)     :: polal   ! Z-coordinate horizontal layers in nm
   double precision, allocatable, dimension(:)     :: pocol
   double precision, allocatable, dimension(:)     :: polar   ! Z-coordinate horizontal layers in nmu
   double precision, allocatable, dimension(:)     :: pocor
   double precision, allocatable, dimension(:)     :: poflu   ! Z-coordinate gradient flux
   double precision, allocatable, dimension(:)     :: point
   double precision, allocatable, dimension(:)     :: drho, dsal, dtem
   double precision, allocatable, dimension(:)     :: kicol, kicor

   integer                                         :: k1, k2, kbl, kbr, ktl, ktr, kll, krr, kl, kr, kl1, kl2, kr1, kr2
   integer                                         :: kpoint, kf, k, j, Lb, Lt, LL, kfmax, kfmax1, kflux
   integer, intent(in)                             :: L
   double precision                                :: grad, grad1, grad2, cl, cr, flux, flux1
   double precision                                :: zbot, ztop, zmid, zbed, farea, area
   double precision                                :: rhods, rhodt, temp, sal, dummy, dpbdx

   allocate (polal(0:kmx),pocol(0:kmx),polar(0:kmx),pocor(0:kmx))
   allocate (poflu(0:2*kmx+1),kicol(0:2*kmx+1),kicor(0:2*kmx+1))
   allocate (point(0:2*kmx+1), drho(0:2*kmx+1), dsal(0:2*kmx+1), dtem(0:2*kmx+1))

   if( jasal == 0 .and. jatem == 0 ) return

   k1 = ln(1,L) ; k2 = ln(2,L)
   call getkbotktop( k1, kbl, ktl )
   call getkbotktop( k2, kbr, ktr )
   call getLbotLtop( L, Lb, Lt )
   zbed = ( bob(1,L) + bob(2,L) ) * 0.5d0        ! interpolates the bed level on flow link
   !
   !***position horizontal interfaces left and right
   !
   polal = 0d0
   pocol = 0d0
   polar = 0d0
   pocor = 0d0
   polal(0) = zws(kbl-1)
   polar(0) = zws(kbr-1)
   do k = 1,kmx
      kl = kbl + k - 1
      kr = kbr + k - 1
      polal(k) =   zws(kl)
      polar(k) =   zws(kr)
      pocol(k) = ( zws(kl) + zws(kl-1) ) * 0.5d0
      pocor(k) = ( zws(kr) + zws(kr-1) ) * 0.5d0
   enddo
   !
   !***merge polal and polar
   !
   kll = 0
   krr = 0
   do k = 0,2*kmx+1
      j = 0
      if ( polal(kll) < polar(krr) ) then
         point(k) = polal(kll)
         kll = kll + 1
         if ( kll > kmx ) then
            kpoint = k + 1
            point(kpoint) = polar(krr)
            j = 1
            exit
         endif
      else
         point(k) = polar(krr)
         krr = krr + 1
         if ( krr > kmx ) then
            kpoint = k + 1
            point(kpoint) = polal(kll)
            j = 1
            exit
         endif
      endif
   enddo
   if( j == 0 ) kpoint = 2 * kmx + 1
   !
   !***position flux points
   !
   poflu = 0d0
   kflux = kpoint
   do k = 1,kflux
      poflu(k) = 0.5d0 * ( point(k) + point(k-1) )
   enddo
   !
   !***k-index concentration points left and right for flux point
   !
   kll = 1
   krr = 1
   do kf = 1,kflux
      kicol(kf) = 0
      kicor(kf) = 0
      do k = kll,kmx
         if ( poflu(kf) >= polal(k-1) .and. poflu(kf) <= polal(k) ) then
            kicol(kf) = k
            kll = k
            exit
         endif
      enddo
      do k = krr,kmx
         if ( poflu(kf) >= polar(k-1) .and. poflu(kf) <= polar(k) ) then
            kicor(kf) = k
            krr = k
            exit
         endif
      enddo
   enddo
   !
   !***computation diffusive flux using limiter
   !
   drho = 0d0
   dsal = 0d0
   dtem = 0d0
   do kf = kflux,1,-1
      kll = kicol(kf)
      krr = kicor(kf)
      if ( kll * krr == 0 ) cycle
      kl = kbl + kll - 1                         ! changes the number of layer to number of cell
      kr = kbr + krr - 1
      if ( point(kf) <= zbed ) exit
      drho(kf) = 0d0
      dsal(kf) = 0d0
      dtem(kf) = 0d0
      !
      !***flux
      !
      if ( pocor(krr) > pocol(kll) ) then
         kl1 = ktl + 1
         do k = kl+1,ktl
            if ( pocol(k-kbl+1) > pocor(krr) ) then
               kl1 = k
               exit
            endif
         enddo
         kl2 = kl1 - 1
      else
         kl1 = kbl - 1
         do k = kl-1,kbl,-1
            if ( pocol(k-kbl+1) < pocor(krr) ) then
               kl1 = k
               exit
            endif
         enddo
         kl2 = kl1 + 1
      endif

      if ( pocol(kll) > pocor(krr) ) then
      kr1 = ktr + 1
         do k = kr+1,ktr
            if ( pocor(k-kbr+1) > pocol(kll) ) then
               kr1 = k
               exit
            endif
         enddo
         kr2 = kr1 - 1
      else
         kr1 = kbr - 1
         do k = kr-1,kbr,-1
            if ( pocor(k-kbr+1) < pocol(kll) ) then
               kr1 = k
               exit
            endif
         enddo
         kr2 = kr1 + 1
      endif

      if ( jasal > 0 ) then
         cl = sa1(kl2)
         if ( kl1 >= kbl .and. kl1 <= ktl ) cl = ( ( pocol(kl2-kbl+1) - pocor(krr      ) ) * sa1(kl1)   &
                                                 + ( pocor(krr      ) - pocol(kl1-kbl+1) ) * sa1(kl2) ) &
                                                 / ( pocol(kl2-kbl+1) - pocol(kl1-kbl+1) )
         cr = sa1(kr2)
         if ( kr1 >= kbr .and. kr1 <= ktr ) cr = ( ( pocor(kr2-kbr+1) - pocol(kll      ) ) * sa1(kr1)   &
                                                 + ( pocol(kll      ) - pocor(kr1-kbr+1) ) * sa1(kr2) ) &
                                                 / ( pocor(kr2-kbr+1) - pocor(kr1-kbr+1) )
         grad1 = ( sa1(kr) - cl ) ! / dx(L)
         grad2 = ( cr - sa1(kl) ) ! / dx(L)
         grad = 0d0 ; if ( grad1 * grad2 > 0d0 ) grad = 2.0d0 * grad1 * grad2 / (grad1 + grad2)
         sal = acl(L) * sa1(kl) + ( 1d0 - acl(L) ) * sa1(kr)
         temp = backgroundwatertemperature
         if ( jatem > 0 ) temp = acl(L) * constituents(itemp, kl) + ( 1d0 - acl(L) ) * constituents(itemp, kr)
         call dens_eck( temp, sal, dummy, rhods, dummy )
         drho(kf) = drho(kf) + rhods * grad
         dsal(kf) = grad
      endif

      if ( jatem > 0 ) then
         cl = constituents(itemp, kl2)
         if ( kl1 >= kbl .and. kl1 <= ktl ) cl = ( ( pocol(kl2-kbl+1) - pocor(krr      ) ) * constituents(itemp,kl1)   &
                                                 + ( pocor(krr      ) - pocol(kl1-kbl+1) ) * constituents(itemp,kl2) ) &
                                                 / ( pocol(kl2-kbl+1) - pocol(kl1-kbl+1) )
         cr = tem1(kr2)
         if ( kr1 >= kbr .and. kr1 <= ktr ) cr = ( ( pocor(kr2-kbr+1) - pocol(kll      ) ) * constituents(itemp,kr1)   &
                                                 + ( pocol(kll      ) - pocor(kr1-kbr+1) ) * constituents(itemp,kr2) ) &
                                                 / ( pocor(kr2-kbr+1) - pocor(kr1-kbr+1) )
         grad1 = ( constituents(itemp,kr) - cl ) ! / dx(L)
         grad2 = ( cr - constituents(itemp,kl) ) ! / dx(L)
         grad = 0d0 ; if ( grad1 * grad2 > 0d0 ) grad = 2.0d0 * grad1 * grad2 / (grad1 + grad2)
         temp = acl(L) * constituents(itemp,kl) + ( 1d0 - acl(L) ) * constituents(itemp,kr)
         sal = backgroundsalinity
         if ( jasal > 0 ) sal  = acl(L) * sa1(kl) + ( 1d0 - acl(L) ) * sa1(kr)
         call dens_eck( temp, sal, dummy, dummy, rhodt )
         drho(kf) = drho(kf) + rhodt * grad
         dtem(kf) = grad
      endif
   enddo

   dpbdx = 0d0
   flux1  = 0d0
   kfmax  = kflux
   kfmax1 = kflux
   do k = kmx,1,-1
      ztop = acl(L) * zws(kbl+k-1) + ( 1d0 - acl(L) ) * zws(kbr+k-1)
      zbot = acl(L) * zws(kbl+k-2) + ( 1d0 - acl(L) ) * zws(kbr+k-2)
      if (ztop - zbot < 1d-4) cycle
      zmid = ( zbot + ztop ) * 0.5d0
      LL = Lb + k - 1
      do kf = kfmax,1,-1
         kll = kicol(kf)
         krr = kicor(kf)
         if ( point(kf) <= zbed ) exit
         if ( kll * krr == 0 ) cycle
         if ( zmid < point(kf-1) ) then
            flux = ag * ( point(kf) - point(kf-1) ) * drho(kf) / rhomean
            flux1 = flux1 + flux
            dpbdx = flux1
         elseif( zmid < point(kf) .and. zmid >= point(kf-1) ) then
            flux = ag * ( point(kf) - zmid           ) * drho(kf) / rhomean
            dpbdx = flux1 + flux
            kfmax = kf
            exit
         endif
      enddo
      if (jabaroctimeint .le. 1) then ! explicit
         adve(LL) = adve(LL) + dpbdx / dx(L)  !   to compensate for not dividing by dx above
      else
         adve(LL) = adve(LL) + (1.5d0*dpbdx - 0.5d0*dpbdx0(LL) )    / dx(L)  !   to compensate for not dividing by dx above
      endif
      if (abs(jabaroctimeint) >= 2) then
          dpbdx0(LL) = dpbdx
      endif

      do kf = kfmax1,1,-1
         farea = - max( point(kf  )-ztop, 0d0 ) &   ! to find the flux area between the flux pieces and the sigma layer
                 + max( point(kf  )-zbot, 0d0 ) &
                 - max( point(kf-1)-zbot, 0d0 )
         if ( farea < 0 ) then
            kfmax1 = kf
            exit
         endif
         dsalL(LL) = dsalL(LL) + dsal(kf) * farea
         dtemL(LL) = dtemL(LL) + dtem(kf) * farea
      enddo
      dsalL(LL) = dsalL(LL) / ( ztop - zbot )
      dtemL(LL) = dtemL(LL) / ( ztop - zbot )
   enddo

   if (abs(jabaroctimeint) >= 2) then
      jabaroctimeint = abs(jabaroctimeint)
   endif

   deallocate(polal,pocol,polar,pocor)
   deallocate(poflu,kicol,kicor)
   deallocate(point, drho, dsal, dtem)

 end subroutine anticreep


 subroutine dens_eck( temp, sal, rholoc ,rhods ,rhodt )

   implicit none
   double precision, intent(in)  :: temp, sal
    double precision, intent(out) :: rholoc, rhods, rhodt
   double precision              :: cp0, clam, clam0, cp1, clam1, alph0, cp1ds, cp1dt, cladt, rhom, den
    !
   !! Data statements
    !
    alph0 = 0.698d0
    rhom  = 0.0d0
    !
    !! executable statements -------------------------------------------------------
    !
   den = temp * temp
   cp0   = 5890.0d0 + 38.00d0 * temp - 0.3750d0 * den
   clam  = 1779.5d0 + 11.25d0 * temp - 0.0745d0 * den
   clam0 =    3.8d0 +  0.01d0 * temp
   cp1   = cp0  + 3.0d0 * sal
   clam1 = clam - clam0 * sal
   rholoc   = 1000.0d0 * cp1 / ( alph0 * cp1 + clam1 ) ! - rhom

   den   = ( alph0 * cp1 + clam1)**2
   cp1ds = 3.0d0
   rhods = 1000.0d0 * ( cp1ds * clam1 + cp1 * clam0 ) / den

   cp1dt = 38.00d0 - 0.750d0 * temp
   cladt = 11.25d0 - 0.149d0 * temp - 0.01d0 * sal
   rhodt = 1000.0d0 * ( cp1dt * clam1 - cp1 * cladt ) / den

 end subroutine dens_eck

 !> speed test: compute z = Ax+y
 !> note: no communcation included in parallel runs, only test speed
 subroutine axpy(Mglob,Nglob)
    use m_partitioninfo
    use unstruc_messages
    use m_timer

    implicit none

    integer,                          intent(in)  :: Mglob  !> global size of x
    integer,                          intent(in)  :: Nglob  !> global size of y

    double precision, dimension(:),   allocatable :: x, y, z
    double precision, dimension(:,:), allocatable :: A

    integer                                       :: irun
    integer                                       :: ierror
    integer                                       :: M, N, i, j

    ierror = 1

!   compute array sizes based on number of subdomains
    M = Mglob
    N = Nglob

!   allocate
    allocate(x(M))
    allocate(y(N))
    allocate(z(N))
    allocate(A(N,M))

!   fill matrix A and vector x
     do j=1,M
        do i=1,N
          call random_number(A(i,j))
        end do
        call random_number(x(j))
      end do

    ! fill vecor y
    do i=1,N
        call random_number(y(i))
    end do

    call starttimer(IAXPY)

    ! z = Ax + y
    do i=1,N
       z(i) = y(i)
       do j=1,M
          z(i) = z(i) + A(i,j)*x(j)
       end do
    end do

    call stoptimer(IAXPY)

    ierror = 0

1234 continue

!   deallocate
    if ( allocated(x) ) deallocate(x)
    if ( allocated(y) ) deallocate(y)
    if ( allocated(A) ) deallocate(A)

 end subroutine axpy



!  update geometry data that may have been incorrectly computed in the ghost area
   subroutine update_geom(iphase)
      use m_partitioninfo
      use m_flowgeom
      use unstruc_channel_flow
      use m_crosssections
      use m_cross_helper

      implicit none

      integer, intent(in) :: iphase ! phase, 0 (all), 1 (first) or 2 (second)
      integer :: ierror

      if ( iphase.eq.0 .or. iphase.eq.1 ) then
         call update_ghosts        (ITYPE_SALL, 1, Ndx, xz, ierror)
         call update_ghostboundvals(ITYPE_SALL, 1, Ndx, xz, 1, ierror)  ! safety: check
         call update_ghosts        (ITYPE_SALL, 1, Ndx, yz, ierror)
         call update_ghostboundvals(ITYPE_SALL, 1, Ndx, yz, 0, ierror)
      end if

      if (iphase.eq.0 .or. iphase.eq.2 ) then
         call update_ghosts        (ITYPE_SALL, 1, Ndx, bl, ierror)
         call update_ghostboundvals(ITYPE_SALL, 1, Ndx, bl, 0, ierror)
      end if

      return
   end subroutine update_geom


!> computer cell-centered gradient from cell-centered data
!>   note: since we use wcx1 etc., it is assumed that normal components at the closed boundary are zero
   subroutine comp_gradC(val, gradx, grady)
      use m_flowgeom, only: ln, Lnx, Ndx, Dxi, wcx1, wcy1, wcx2, wcy2
      implicit none

      double precision, dimension(Ndx), intent(in)  :: val  !< cell-centered data
      double precision, dimension(Ndx), intent(out) :: gradx !< x-component of cell-centered gradient vector
      double precision, dimension(Ndx), intent(out) :: grady !< y-component of cell-centered gradient vector

      double precision                              :: DvalDn

      integer                                       :: k1, k2, L

      gradx = 0d0
      grady = 0d0

      do L=1,Lnx
         k1 = ln(1,L)
         k2 = ln(2,L)
         DvalDn = (val(k2) - val(k1))*Dxi(L)   ! outward positive for k1

         gradx(k1) = gradx(k1) + wcx1(L) * DvalDn
         grady(k1) = grady(k1) + wcy1(L) * DvalDn
         gradx(k2) = gradx(k2) + wcx2(L) * DvalDn
         grady(k2) = grady(k2) + wcy2(L) * DvalDn
      end do

      return
   end subroutine comp_gradC

!> add internal tides friction forces to adve
   subroutine add_InternalTidesFrictionForces()
      use m_flowgeom
      use m_flow
      use m_flowtimes
      use unstruc_messages
      use m_partitioninfo
      implicit none

      character(len=256)         :: str

      double precision           :: GradHinUc, dum, Lambda, dfac
      double precision           :: dumx1, dumy1, dumx2, dumy2
      double precision           :: diss

      integer                    :: k, k1, k2, L
      integer                    :: ierror

      double precision, external :: nod2linx, nod2liny

!     compute water depth gradient, based on cell-centered date
      hs = s1-bl
      call comp_gradC(hs, workx, worky)

      !call realloc(plotlin, Ndx, keepExisting=.false.)
      !plotlin = worky

!     compute cell-centered forces
      ierror = 0
      DissInternalTides = 0d0
      do k=1,Ndx
         dum = sqrt(workx(k)**2 + worky(k)**2)
         GradHinUc = workx(k)*ucx(k) + worky(k)*ucy(k)
         workx(k) =  -FrcInternalTides2D(k) * GradHinUc * workx(k)
         worky(k) =  -FrcInternalTides2D(k) * GradHinUc * worky(k)

         if ( hs(k).gt.epshs ) then

            if( ITcap.gt.0d0 ) then
!              limit with ITcap
               diss = -rho(k)*( workx(k) * ucx(k) + worky(k) * ucy(k) )

               if ( diss.gt.ITcap ) then
                  dfac = ITcap/diss

                  workx(k) = dfac * workx(k)
                  worky(k) = dfac * worky(k)
               end if
            end if

!           check time step
!           estimate eigenvalue
            Lambda = FrcInternalTides2D(k) * dum**2 / hs(k)
            if ( Lambda*dts.gt.1d0 ) then
               dfac = 1d0 / (Lambda*dts)
               write(str, "('k = ', I8, ': gamma ||grad H||^2 / H = ', E15.5, ' > 1/Delta t =', E15.5, ', H=', E15.5, ', ||grad H||=', E15.5, ', gamma=', E15.5, ', reduce factor=', E15.5)") k, Lambda, 1d0/dts, hs(k), dum, FrcInternalTides2D(k), dfac
               call mess(LEVEL_WARN, trim(str))
!               ierror = 1

               workx(k) = dfac * workx(k)
               worky(k) = dfac * worky(k)
            end if

            DissInternalTidesPerArea(k) = -rho(k)*( workx(k) * ucx(k) + worky(k) * ucy(k) )

!           add to total internal tides dissipation rate
            if ( jampi.eq.1 ) then
               if ( idomain(k).ne.my_rank ) cycle
            end if

            if ( k.le.Ndxi ) then   ! do not add fictitious boundary nodes
               DissInternalTides = DissInternalTides + DissInternalTidesPerArea(k) * ba(k)
            end if
         end if
      end do
      if ( ierror.eq.1 ) then
         call mess(LEVEL_ERROR, 'add_InternalTidesFrictionForces: time step too large')
      end if

!     interpolate to faces, project in face-normal direction, divide by water depth and add to adve
      do L=1,Lnx
         if ( hu(L).gt.0d0 ) then
            k1 = ln(1,L)
            k2 = ln(2,L)

!            adve(L) = adve(L) - huvli(L) * (  &
!              (acL(L)*workx(k1) + (1d0-acL(L))*workx(k2)) * csu(L) +   &
!              (acL(L)*worky(k1) + (1d0-acL(L))*worky(k2)) * snu(L) )

            dumx1 = nod2linx(L,1,workx(k1),worky(k1))
            dumy1 = nod2liny(L,1,workx(k1),worky(k1))

            dumx2 = nod2linx(L,2,workx(k2),worky(k2))
            dumy2 = nod2liny(L,2,workx(k2),worky(k2))

            adve(L) = adve(L) - huvli(L) * (  &
              (acL(L)*dumx1 + (1d0-acL(L))*dumx2) * csu(L) +   &
              (acL(L)*dumy1 + (1d0-acL(L))*dumy2) * snu(L) )

         end if
      end do

      return
   end subroutine add_InternalTidesFrictionForces

!  increase netcell admin. to include boundary nodes (safety)
   subroutine add_boundarynetcells()

      use network_data
      use m_flowgeom
      use gridoperations

      implicit none

      integer nump_store
      integer k

  !   store nump
      nump_store = nump

  !   need to store nump1d2d netcells in "increasenetcells", not only nump
      nump = nump1d2d
      call increasenetcells(Ndx,1.0,.true.)
      do k=nump1d2d+1,Ndx
         netcell(k)%n = 0   ! safety
      end do

  !   restore nump
      nump = nump_store

      return
   end subroutine add_boundarynetcells

   !> compute Graviational Input from tidal forces and SAL
   subroutine comp_GravInput()
      use m_flowgeom
      use m_flow
      use unstruc_messages
      use m_partitioninfo
      implicit none

      double precision :: force, dfac

      integer          :: L, k, k1, k2
      logical          :: Ldoit1, Ldoit2

!     initialize
      GravInput = 0d0
      SALInput  = 0d0
      force     = 0d0

      SALinput2 = 0d0

!     reconstruct tidel force at cell centers and compute power at once
      do L=1,Lnx
         if ( tidef(L).ne.0d0 ) then
            k1 = ln(1,L)
            k2 = ln(2,L)

            if ( jaselfal.gt.0 ) then
   !           compute total unlimited tide force
               force = ( tidep(1,k2) - tidep(1,k1) )*dxi(L)

   !           compute limitation factor (see setextforcechkadvec)
               dfac = 1d0
               if ( abs(force).gt.0d0 ) then
                  dfac = tidef(L)/force
               end if

   !           compute limited SAL force
               force  = dfac * ( tidep(2,k2) - tidep(2,k1) )*dxi(L)
            end if

!           contribution from left cell
            Ldoit1 = .true.
            Ldoit2 = .true.
            if ( jampi.eq.1 ) then
               if ( idomain(k1).ne.my_rank ) Ldoit1 = .false.
               if ( idomain(k2).ne.my_rank ) Ldoit2 = .false.
            end if

            if ( Ldoit1 .and. k1.le.Ndxi ) then  ! boundary cells excluded
               dfac = rho(k1)*hs(k1)*ba(k1) * (ucx(k1)*wcx1(L) + ucy(k1)*wcy1(L))
               GravInput = GravInput + dfac * tidef(L)
               if ( jaselfal.gt.0 ) then
                  SALInput  = SALInput  + dfac * force
               end if
            end if

!           contribution from right cell
            if ( Ldoit2 .and. k2.le.Ndxi ) then
               dfac = rho(k2)*hs(k2)*ba(k2) * (ucx(k2)*wcx2(L) + ucy(k2)*wcy2(L))
               GravInput = GravInput + dfac * tidef(L)
               if ( jaselfal.gt.0 ) then
                  SALInput  = SALInput  + dfac * force
               end if
            end if
         end if
      end do


      if ( jaselfal.gt.0 ) then
         if ( jampi.eq.0 ) then
            do k=1,Ndxi
               SALinput2 = SALinput2 + tidep(2,k) * rho(k) * sq(k)
            end do
         else
            do k=1,Ndxi
               if ( idomain(k).ne.my_rank ) then
                  SALinput2 = SALinput2 + tidep(2,k) * rho(k) * sq(k)
               end if
            end do
         end if
      end if

      return
   end subroutine comp_GravInput


   subroutine disable_higherorder_at_sorsin()
      use m_flowgeom
      use m_flowexternalforcings, only: numsrc, ksrc
      use m_partitioninfo
      use m_alloc
      implicit none

      double precision, dimension(:,:), allocatable :: dum

      integer,          dimension(:),   allocatable :: imask

      integer                                       :: ierror
      integer                                       :: i, iL, kk, kk1, kk2, LL, n

      logical                                       :: Ldisabled

      integer,                          parameter   :: jaall = 1 !< disable all flowlinks attached to flownodes with sources/sinks (1) or only links with both connected flownodes (0)

      if ( jaall.eq.1 ) then
!        disable all flowlink attached to flownodes with sources/sinks
         do n=1,numsrc
            do i=1,4,3 ! 1 and 4
!              get 2D flow nodes
               kk = ksrc(i,n)
               if ( kk.le.0 ) cycle ! 0: not in whole domain, -1: not in own subdomain, but can be in ghostregion

!              loop over all attached flow links
               do iL = 1,nd(kk)%lnx
!                 get 2D flink link
                  LL = iabs(nd(kk)%ln(iL))

!                 disable high-order reconstruction
                  klnup(:,LL) = 0
               end do
            end do
         end do
      else
!        disable only flowlinks connecting two flownodes with sources/sinks

!        alloc mask array
         call realloc(imask, Ndx, keepExisting=.false., fill=0)

!        mask flownodes with sources
         do n=1,numsrc
            imask(ksrc(1,n)) = 1
            imask(ksrc(4,n)) = 1
         end do

!        disable flowlinks
         do LL=1,Lnx
            kk1 = ln(1,LL)
            kk2 = ln(2,LL)
            if ( imask(kk1).eq.1 .and. imask(kk2).eq.1 ) then
               klnup(:,LL) = 0
            end if
         end do

!        deallocate
         if ( allocated(imask) ) deallocate(imask)
      end if

      if ( jampi.eq.1 ) then
!        source/sink could have been in ghost region
         allocate(dum(6,Lnx));

         do LL=1,Lnx
            do i=1,6
               dum(i,LL) = klnup(i,LL)
            end do
         end do

         call update_ghosts(ITYPE_U, 6, Lnx, dum, ierror)

         do LL=1,Lnx
!           check if higher-order reconstruction of this link has been disabled
            Ldisabled = .true.
            do i=1,6
               if ( dum(i,LL).ne.0d0 ) then
                  Ldisabled = .false.
                  exit
               end if
            end do

            if ( Ldisabled ) then
!              disable higher-order reconstruction
               do i=1,6
                  if ( klnup(i,LL).ne.0 ) then
                     klnup(i,LL) = 0
                  end if
               end do
            end if
         end do

         deallocate(dum)
      end if

      return
   end subroutine disable_higherorder_at_sorsin

!> compute riemann boundary reference state
   subroutine riemann_setmean()
      use m_flow, only: s1, u1
      use m_flowgeom, only: bl
      use m_flowexternalforcings
      use m_flowtimes, only: dts
      use m_physcoef, only: ag
      implicit none

      double precision :: dfac, dfac1
      double precision :: h

      integer          :: n, kb, k2, L, itpbn

      double precision :: Tref

      if ( nbndz.gt.0 ) then
         do n=1,nbndz
            itpbn   = kbndz(4,n)
            Tref    = dble(kbndz(6,n))  ! integer, but can get away with it, nobody uses fractional seconds..
            dfac  = max(min(dts/Tref, 1d0), 0d0)
            dfac1 = 1d0 - dfac

            if ( itpbn.eq.5 ) then
               kb      = kbndz(1,n)
               k2      = kbndz(2,n)
               L       = kbndz(3,n)

               k2 = kbndz(2,n)

               h = s1(k2) - bl(k2)
               zbndz0(n) = dfac1*zbndz0(n) + dfac*(s1(k2) - sqrt(h/ag)*u1(L))
            end if
         end do
      end if

      return
   end subroutine riemann_setmean


   subroutine get_spiral3d
      use m_flow, only: ucx, ucy, spirint, czssf, zws, hs, dzslay, spiratx, spiraty
      use m_flowgeom, only: ndx

      implicit none
      integer :: k, kk, k1, kb, kt
      double precision :: uav, vav, utot, unx, uny, ut, un, zn, fn
      double precision :: sumff, sumfu

      do k = 1,ndx
         call getkbotktop( k, kb, kt )
         uav = 0d0
         vav = 0d0
         do kk = kb,kt
            k1 = kk - kb + 1
            uav = uav + ucx(kk) * dzslay(k1,1)
            vav = vav + ucy(kk) * dzslay(k1,1)
         enddo
         utot = sqrt( uav**2 + vav**2 )
         if( utot == 0d0 ) then
            spirint(k) = 0d0
            cycle
         endif
         spiratx(k) = uav / utot
         spiraty(k) = vav / utot
         sumff = 0d0
         sumfu = 0d0
         do kk = kb,kt
            zn = ( ( zws(kk) + zws(kk-1) ) * 0.5d0 - zws(kb-1) )/ hs(k)
            call findfn( czssf(k), zn, fn )
            ut  = ucx(kk) * spiratx(k) + ucy(kk) * spiraty(k)
            unx = ucx(kk) - ut * spiratx(k)
            uny = ucy(kk) - ut * spiraty(k)
            un  = -unx * spiraty(k) + uny * spiratx(k)   ! transverse component
            sumff = sumff + fn * fn
            sumfu = sumfu + fn * un
         enddo
         spirint(k) = 0d0
         if( sumff < 1d-6 ) cycle
         spirint(k) = sumfu / sumff
      enddo

   end subroutine get_spiral3d

subroutine findfn( cz, zn, fn )

   implicit none
   integer :: i, j
   double precision :: acof, bcof
   double precision, intent(in)  :: zn
   double precision, intent(in)  :: cz
   double precision, intent(out) :: fn
   integer, parameter :: itab=100, jtab=1
   double precision, dimension(0:itab) :: fnarray
   double precision :: znc, czc, dzn

   fnarray = (/ 0.0000000e+00 ,  0.0000000e+00 , -3.2435628e+00 , -4.8713274e+00 , -5.8552221e+00 , -6.4959081e+00 , &
               -6.9255574e+00 , -7.2137312e+00 , -7.4013821e+00 , -7.5145552e+00 , -7.5707797e+00 , &
               -7.5823759e+00 , -7.5583058e+00 , -7.5052724e+00 , -7.4284060e+00 , -7.3317101e+00 , &
               -7.2183609e+00 , -7.0909148e+00 , -6.9514544e+00 , -6.8016956e+00 , -6.6430654e+00 , &
               -6.4767611e+00 , -6.3037949e+00 , -6.1250285e+00 , -5.9412000e+00 , -5.7529454e+00 , &
               -5.5608153e+00 , -5.3652891e+00 , -5.1667855e+00 , -4.9656720e+00 , -4.7622720e+00 , &
               -4.5568716e+00 , -4.3497240e+00 , -4.1410546e+00 , -3.9310641e+00 , -3.7199319e+00 , &
               -3.5078185e+00 , -3.2948682e+00 , -3.0812105e+00 , -2.8669622e+00 , -2.6522285e+00 , &
               -2.4371048e+00 , -2.2216772e+00 , -2.0060236e+00 , -1.7902149e+00 , -1.5743155e+00 , &
               -1.3583837e+00 , -1.1424727e+00 , -9.2663110e-01 , -7.1090286e-01 , -4.9532825e-01 , &
               -2.7994396e-01 , -6.4783449e-02 ,  1.5012272e-01 ,  3.6474668e-01 ,  5.7906297e-01 , &
                7.9304836e-01 ,  1.0066816e+00 ,  1.2199435e+00 ,  1.4328162e+00 ,  1.6452838e+00 , &
                1.8573316e+00 ,  2.0689463e+00 ,  2.2801157e+00 ,  2.4908290e+00 ,  2.7010760e+00 , &
                2.9108478e+00 ,  3.1201362e+00 ,  3.3289339e+00 ,  3.5372344e+00 ,  3.7450317e+00 , &
                3.9523205e+00 ,  4.1590963e+00 ,  4.3653548e+00 ,  4.5710924e+00 ,  4.7763060e+00 , &
                4.9809928e+00 ,  5.1851506e+00 ,  5.3887774e+00 ,  5.5918716e+00 ,  5.7944319e+00 , &
                5.9964574e+00 ,  6.1979473e+00 ,  6.3989011e+00 ,  6.5993187e+00 ,  6.7992001e+00 , &
                6.9985455e+00 ,  7.1973553e+00 ,  7.3956301e+00 ,  7.5933705e+00 ,  7.7905776e+00 , &
                7.9872522e+00 ,  8.1833957e+00 ,  8.3790092e+00 ,  8.5740942e+00 ,  8.7686522e+00 , &
                8.9626847e+00 ,  9.1561934e+00 ,  9.3491800e+00 ,  9.5416465e+00 ,  9.7333452e+00 /)
   dzn = 1d0 / itab

   i    = zn / dzn
   znc  = i  * dzn
   !j    = cz * jtab
   !czc  = j  * jtab
   acof = ( fnarray(i+1) - fnarray(i) ) / dzn
   bcof = fnarray(i)
   fn = acof * ( zn - znc ) + bcof

end subroutine findfn

   !> limited higher-order correction of vector data
   subroutine dslimvec(ds1x, ds1y, ds2x, ds2y, csu, snu, limtyp, dsx, dsy)
      use m_flowparameters
      implicit none

      double precision, intent(in)  :: ds1x, ds1y   !< "voorslope" components
      double precision, intent(in)  :: ds2x, ds2y   !< "naslope" components
      double precision, intent(in)  :: csu, snu     !< orientation vector components
      integer,          intent(in)  :: limtyp       !< limiter type
      double precision, intent(out) :: dsx, dsy     !< correction components

      double precision              :: ds1n, ds1t   !< normal and tangential component, respectively
      double precision              :: ds2n, ds2t   !< normal and tangential component, respectively
      double precision              :: dsn, dst

      double precision, external    :: dslim

      if ( jalimnor.eq.1 ) then
         ds1n =  csu*ds1x + snu*ds1y
         ds1t = -snu*ds1x + csu*ds1y

         ds2n =  csu*ds2x + snu*ds2y
         ds2t = -snu*ds2x + csu*ds2y

         dsn = 0d0
         dst = 0d0

         if (abs(ds2n)  > eps10 .and. abs(ds1n) > eps10) then
             dsn = dslim(ds1n, ds2n, limtyp)
         endif

         if (abs(ds2y)  > eps10 .and. abs(ds1y) > eps10) then
             dst =  dslim(ds1t, ds2t, limtyp)
         endif

         dsx = csu*dsn - snu*dst
         dsy = snu*dsn + csu*dst

      else
         dsx = dslim(ds1x, ds2x, limtyp)
         dsy = dslim(ds1y, ds2y, limtyp)
      end if

      return
   end subroutine dslimvec

! =================================================================================================
! =================================================================================================
   subroutine setstruclink()

      use m_flow
      implicit none
      integer          :: i, n, L, Lf, La
      !
      ! === Gates (old)
      !
      do n = 1,ngatesg
         do L = L1gatesg(n), L2gatesg(n)
            Lf = kgate(3,L)
            La = abs( Lf )
            struclink(La) = 1
         enddo
      enddo
      !
      ! === Gates (new)
      !
      do n = 1,ngategen
         i = gate2cgen(n)
         do L = L1cgensg(i), L2cgensg(i)
            Lf = kcgen(3,L)
            La = abs( Lf )
            struclink(La) = 1
         enddo
      enddo
      !
      ! === General structures (old)
      !
      do n = 1,ncgensg
         i = n
         do L = L1cgensg(i),L2cgensg(i)
            Lf = kcgen(3,L)
            La = abs( Lf )
            struclink(La) = 1
         enddo
      enddo
      !
      ! === General structures (new)
      !
      do n = 1,ngenstru
         i = genstru2cgen(n)
         do L = L1cgensg(i),L2cgensg(i)
            Lf = kcgen(3,L)
            La = abs( Lf )
            struclink(La) = 1
         enddo
      enddo
      !
      ! === Weirs
      !
      do n = 1,nweirgen
         i = weir2cgen(n)
         do L = L1cgensg(i),L2cgensg(i)
            Lf = kcgen(3,L)
            La = abs( Lf )
            struclink(La) = 1
         enddo
      enddo

   end subroutine setstruclink

subroutine makethindamadmin()
   use m_flowgeom
   use network_data
   use m_alloc
   use m_sferic, only: jsferic, jasfer3D
   use geometry_module, only: getdxdy, duitpl, dlinedis
   use m_missing, only: dmiss

   implicit none

   integer                      :: n, kk, L, k1, k3, k4, ja, ierr
   double precision             :: cs, sn, a, b, sig, dis, xn, yn, rrr

   ! count thin dam points
   nthd = 0
   do n=1, nump
      do kk=1,netcell(n)%n
         L = netcell(n)%lin(kk)
         if (lne2ln(L)==0) then
            nthd = nthd+1
         end if
      end do
   end do

   ! set up thin dam structure
   if ( allocated(thindam) ) deallocate(thindam)
   allocate(thindam(6,nthd), stat=ierr)
   call aerr( 'thindam(6,nthd)', ierr, 6*nthd)

   nthd = 0
   do n=1, nump
      do kk=1,netcell(n)%n
         L = netcell(n)%lin(kk)

         if (kn(3,L) .eq. 0) then
            nthd = nthd+1
            k1 = n
            k3 = kn(1,L)     ! netnode 1
            k4 = kn(2,L)     ! netnode 2

            thindam(1,nthd) = k1
            thindam(2,nthd) = k3
            thindam(3,nthd) = k4

            call duitpl(xzw(k1), yzw(k1), xk(k3), yk(k3), xzw(k1), yzw(k1), xk(k4), yk(k4), sig, jsferic)
            call dlinedis(xzw(k1), yzw(k1), xk(k3), yk(k3), xk(k4), yk(k4),JA,DIS,XN,YN, jsferic, jasfer3D, dmiss)
            a = 0d0; b = 0d0
            call getdxdy( xk(k3), yk(k3), xk(k4), yk(k4), a, b, jsferic)
            rrr = sqrt(a*a + b*b)
            cs  = 0d0 ; sn = 0d0
            if (rrr .ne. 0d0) then
               cs = sig*a/rrr
               sn = sig*b/rrr
            endif
            thindam(4,nthd) = cs
            thindam(5,nthd) = sn
            thindam(6,nthd) = rrr
         end if
      end do
   end do
end subroutine makethindamadmin


   ! ********************************************************************
      SUBROUTINE ENTRYFLOW (Y0,J,U,DUDY,TKE,EPS,NUT,GAMT)
! ********************************************************************
!     STRATIFIED MIXING LAYER EXPERIMENTS BY DELFT HYDRAULICS
!                           1987
!
!     INLET CONDITIONS FOR HORIZONTAL VELOCITY, TURBULENT KINETIC
!     ENERGY AND ENERGY DISSIPATION.
!
!     R.E. UITTENBOGAARD.
!     NOV. 1987
!
      double precision :: Y0(*),U,DUDY,TKE,EPS,NUT,GAMT
      double precision :: AU(50,5),CMU,DY,KAP,ST,Y , uwall, uplate
      INTEGER          :: J, NPOINTS , nupnts, ip
!
      DATA AU( 1,1)/   .00/,AU( 1,2)/   .00/,AU( 1,3)/ .1605E+03/, &
           AU( 1,4)/ .0000E+00/,AU( 1,5)/-.2652E+02/
      DATA AU( 2,1)/  1.00/,AU( 2,2)/134.00/,AU( 2,3)/ .8097E+02/, &
           AU( 2,4)/-.7955E+02/,AU( 2,5)/ .2958E+02/
      DATA AU( 3,1)/  2.00/,AU( 3,2)/165.00/,AU( 3,3)/ .1062E+02/, &
            AU( 3,4)/ .9203E+01/,AU( 3,5)/-.4821E+01/
      DATA AU( 4,1)/  3.00/,AU( 4,2)/180.00/,AU( 4,3)/ .1456E+02/, &
           AU( 4,4)/-.5261E+01/,AU( 4,5)/ .1450E+01/
      DATA AU( 5,1)/  4.00/,AU( 5,2)/190.75/,AU( 5,3)/ .8390E+01/, &
           AU( 5,4)/-.9100E+00/,AU( 5,5)/ .5523E-01/
      DATA AU( 6,1)/  7.50/,AU( 6,2)/211.34/,AU( 6,3)/ .4050E+01/, &
           AU( 6,4)/-.3300E+00/,AU( 6,5)/ .1380E-01/
      DATA AU( 7,1)/ 17.00/,AU( 7,2)/231.85/,AU( 7,3)/ .1515E+01/, &
           AU( 7,4)/ .6319E-01/,AU( 7,5)/-.4415E-02/
      DATA AU( 8,1)/ 25.00/,AU( 8,2)/245.75/,AU( 8,3)/ .1678E+01/, &
           AU( 8,4)/-.4277E-01/,AU( 8,5)/ .1367E-02/
      DATA AU( 9,1)/ 35.00/,AU( 9,2)/259.62/,AU( 9,3)/ .1233E+01/, &
           AU( 9,4)/-.1743E-02/,AU( 9,5)/ .5904E-05/
      DATA AU(10,1)/ 50.00/,AU(10,2)/277.74/,AU(10,3)/ .1185E+01/, &
           AU(10,4)/-.1478E-02/,AU(10,5)/-.9626E-04/
      DATA AU(11,1)/ 75.00/,AU(11,2)/304.92/,AU(11,3)/ .9301E+00/, &
           AU(11,4)/-.8697E-02/,AU(11,5)/-.1250E-03/
      DATA AU(12,1)/100.00/,AU(12,2)/320.79/,AU(12,3)/ .2610E+00/, &
           AU(12,4)/-.1807E-01/,AU(12,5)/ .2623E-03/
      DATA AU(13,1)/125.00/,AU(13,2)/320.12/,AU(13,3)/-.1506E+00/, &
           AU(13,4)/ .1606E-02/,AU(13,5)/-.7927E-04/
      DATA AU(14,1)/150.00/,AU(14,2)/316.12/,AU(14,3)/-.2189E+00/, &
           AU(14,4)/-.4339E-02/,AU(14,5)/ .2096E-03/
      DATA AU(15,1)/175.00/,AU(15,2)/311.21/,AU(15,3)/-.4285E-01/, &
           AU(15,4)/ .1138E-01/,AU(15,5)/-.1237E-03/
      DATA AU(16,1)/200.00/,AU(16,2)/315.32/,AU(16,3)/ .2943E+00/, &
           AU(16,4)/ .2104E-02/,AU(16,5)/ .4974E-04/
      DATA AU(17,1)/225.00/,AU(17,2)/324.77/,AU(17,3)/ .4928E+00/, &
           AU(17,4)/ .5834E-02/,AU(17,5)/-.1028E-03/
      DATA AU(18,1)/250.00/,AU(18,2)/339.13/,AU(18,3)/ .5918E+00/, &
           AU(18,4)/-.1873E-02/,AU(18,5)/-.8348E-04/
      DATA AU(19,1)/275.00/,AU(19,2)/351.45/,AU(19,3)/ .3416E+00/, &
           AU(19,4)/-.8134E-02/,AU(19,5)/ .3620E-03/
      DATA AU(20,1)/280.00/,AU(20,2)/353.00/,AU(20,3)/ .2874E+00/, &
           AU(20,4)/-.2704E-02/,AU(20,5)/-.2956E-02/
      DATA AU(21,1)/285.00/,AU(21,2)/354.00/,AU(21,3)/ .3867E-01/, &
           AU(21,4)/-.4705E-01/,AU(21,5)/-.1374E-03/
      DATA AU(22,1)/290.00/,AU(22,2)/353.00/,AU(22,3)/-.4421E+00/, &
           AU(22,4)/-.4911E-01/,AU(22,5)/-.4494E-02/
      DATA AU(23,1)/295.00/,AU(23,2)/349.00/,AU(23,3)/-.1270E+01/, &
           AU(23,4)/-.1165E+00/,AU(23,5)/ .2114E-02/
      DATA AU(24,1)/300.00/,AU(24,2)/340.00/,AU(24,3)/-.2277E+01/, &
           AU(24,4)/-.8480E-01/,AU(24,5)/-.3964E-02/
      DATA AU(25,1)/305.00/,AU(25,2)/326.00/,AU(25,3)/-.3422E+01/, &
           AU(25,4)/-.1443E+00/,AU(25,5)/-.2260E-02/
      DATA AU(26,1)/310.00/,AU(26,2)/305.00/,AU(26,3)/-.5034E+01/, &
           AU(26,4)/-.1782E+00/,AU(26,5)/-.8325E-01/
      DATA AU(27,1)/312.50/,AU(27,2)/290.00/,AU(27,3)/-.7486E+01/, &
           AU(27,4)/-.8026E+00/,AU(27,5)/ .2388E+00/
      DATA AU(28,1)/315.00/,AU(28,2)/270.00/,AU(28,3)/-.7022E+01/, &
           AU(28,4)/ .9884E+00/,AU(28,5)/-.5519E+00/
      DATA AU(29,1)/317.50/,AU(29,2)/250.00/,AU(29,3)/-.1243E+02/, &
           AU(29,4)/-.3151E+01/,AU(29,5)/-.1265E+01/
      DATA AU(30,1)/319.00/,AU(30,2)/220.00/,AU(30,3)/-.3042E+02/, &
           AU(30,4)/-.8843E+01/,AU(30,5)/-.7395E+00/
      DATA AU(31,1)/320.00/,AU(31,2)/180.00/,AU(31,3)/-.5032E+02/, &
           AU(31,4)/-.1106E+02/,AU(31,5)/ .3073E+01/
      DATA AU(32,1)/321.50/,AU(32,2)/ 90.00/,AU(32,3)/-.6277E+02/, &
           AU(32,4)/ .2765E+01/,AU(32,5)/-.6145E+00/
      DATA AU(33,1)/323.00/,AU(33,2)/ 90.00/,AU(33,3)/-.6277E+02/, &
           AU(33,4)/ .2765E+01/,AU(33,5)/-.6145E+00/
      DATA AU(34,1)/323.00/,AU(34,2)/   .00/,AU(34,3)/ .4136E+02/, &
           AU(34,4)/ .0000E+00/,AU(34,5)/ .8638E+01/
      DATA AU(35,1)/324.00/,AU(35,2)/ 50.00/,AU(35,3)/ .6728E+02/, &
           AU(35,4)/ .2591E+02/,AU(35,5)/-.1319E+02/
      DATA AU(36,1)/325.00/,AU(36,2)/130.00/,AU(36,3)/ .7954E+02/, &
           AU(36,4)/-.1365E+02/,AU(36,5)/ .4116E+01/
      DATA AU(37,1)/326.00/,AU(37,2)/200.00/,AU(37,3)/ .6458E+02/, &
           AU(37,4)/-.1304E+01/,AU(37,5)/-.1166E+01/
      DATA AU(38,1)/327.50/,AU(38,2)/290.00/,AU(38,3)/ .5280E+02/, &
          AU(38,4)/-.6552E+01/,AU(38,5)/ .1895E+00/
      DATA AU(39,1)/330.00/,AU(39,2)/384.00/,AU(39,3)/ .2359E+02/, &
           AU(39,4)/-.5131E+01/,AU(39,5)/ .4026E+00/
      DATA AU(40,1)/335.00/,AU(40,2)/424.00/,AU(40,3)/ .2476E+01/, &
           AU(40,4)/ .9080E+00/,AU(40,5)/-.8861E-01/
      DATA AU(41,1)/340.00/,AU(41,2)/448.00/,AU(41,3)/ .4909E+01/, &
           AU(41,4)/-.4212E+00/,AU(41,5)/ .2636E-01/
      DATA AU(42,1)/345.00/,AU(42,2)/465.31/,AU(42,3)/ .2674E+01/, &
           AU(42,4)/-.2581E-01/,AU(42,5)/-.1885E-02/
      DATA AU(43,1)/360.00/,AU(43,2)/493.25/,AU(43,3)/ .6273E+00/, &
           AU(43,4)/-.1106E+00/,AU(43,5)/ .3572E-02/
      DATA AU(44,1)/375.00/,AU(44,2)/489.82/,AU(44,3)/-.2810E+00/, &
           AU(44,4)/ .5009E-01/,AU(44,5)/-.8666E-03/
      DATA AU(45,1)/400.00/,AU(45,2)/500.56/,AU(45,3)/ .5986E+00/, &
           AU(45,4)/-.1490E-01/,AU(45,5)/ .2445E-03/
      DATA AU(46,1)/425.00/,AU(46,2)/510.03/,AU(46,3)/ .3119E+00/, &
           AU(46,4)/ .3436E-02/,AU(46,5)/ .1521E-03/
      DATA AU(47,1)/450.00/,AU(47,2)/522.35/,AU(47,3)/ .7688E+00/, &
           AU(47,4)/ .1484E-01/,AU(47,5)/-.8228E-04/
      DATA AU(48,1)/475.00/,AU(48,2)/549.56/,AU(48,3)/ .1357E+01/, &
           AU(48,4)/ .8670E-02/,AU(48,5)/-.3145E-03/
      DATA AU(49,1)/500.00/,AU(49,2)/583.98/,AU(49,3)/ .1200E+01/, &
           AU(49,4)/-.1491E-01/,AU(49,5)/ .7649E-04/
      DATA AU(50,1)/565.00/,AU(50,2)/583.98/,AU(50,3)/ .1200E+01/, &
           AU(50,4)/-.1491E-01/,AU(50,5)/ .7649E-04/
!
!     SQUARE ROOT OF WALL SHEAR STRESS: UWALL IN MM/S
!       ,,    ,,     SHEAR STRESS ON SPLITTERPLATE: UPLATE IN MM/S
!
      DATA UWALL/11.44d0/,UPLATE/9.11d0/
      DATA KAP/0.41d0/,CMU/0.09d0/,ST/1.0d0/
!
      NUPNTS = 50
!
      Y = 1000.0d0 *Y0(J)
!
      IF (Y.GT.AU(NUPNTS,1)) THEN
        WRITE(*,*) '   STOP **** ERROR DETECTED IN ROUTINE ENTRY:'
        WRITE(*,*) '   AN ATTEMPT WAS MADE TO EXTRAPOLATE IN HEIGHT'
        WRITE(*,*) '   AT Y=',Y
        STOP
      ENDIF
      IP = 2
   10 IF (Y.GT.AU(IP,1)) THEN
         IP = IP+1
         GOTO 10
      ENDIF
      IP = IP-1
!
      DY = Y-AU(IP,1)
      U  = AU(IP,2)+DY*(AU(IP,3)+DY*(AU(IP,4)+DY*AU(IP,5)))
!
!     OPTION FOR DERIVATIVE DUDY = DU/DY:
!
      DUDY =  AU(IP,3)+DY*(2d0*AU(IP,4)+3d0*DY*AU(IP,5))
!
!     INLET CONDITION FOR TURBULENT KINETIC ENERGY (TKE):
!
      IF (Y.LT.110.) THEN
         TKE = 500d0-4d0*Y
      ELSEIF (Y.LT.217.) THEN
         TKE = 60d0
      ELSEIF (Y.LT.323.) THEN
         TKE = -383d0+2.037d0*Y
      ELSEIF (Y.LT.415.4) THEN
         TKE = 974.4d0-2.165d0*Y
      ELSE
         TKE = 76.
      ENDIF
!
!     INLET CONDITION FOR EPSILON (EPS):
!
      IF (Y.LT.1.) THEN
         EPS = 5.*UWALL*UWALL*UWALL/(KAP*1000.*Y0(2))
      ELSEIF (Y.LT.322.) THEN
         EPS = (UWALL*UWALL*UWALL/Y+UPLATE*UPLATE*UPLATE/(323.-Y))/KAP
      ELSEIF (Y.LT.324.) THEN
         DY  = 500.*(Y0(J+1)-Y0(J-1))
         EPS = 5.*UPLATE*UPLATE*UPLATE/(KAP*DY)
      ELSE
         EPS = UPLATE*UPLATE*UPLATE/(KAP*(Y-323.))
      ENDIF

!      CONVERSION FROM (MM) TO (M):

      U    = U  *1.d-3
      TKE  = TKE*1.d-6
      EPS  = EPS*1.d-6

      NUT  = CMU*TKE*TKE/EPS
      GAMT = NUT/ST
      RETURN
   END

 subroutine alloc_jacobi(ndx,lnx)
 use m_jacobi
 use m_alloc
 integer :: ndx, lnx, ierr

 if (ndx == ndxjac .and. lnx == lnxjac) return

 if (allocated(bbi) ) then
    deallocate(bbi,db,rr)
 endif

 allocate ( bbi  (ndx) , stat = ierr)
 call aerr('bbi  (ndx)', ierr,   ndx) ; bbi = 0
 allocate ( db   (ndx) , stat = ierr)
 call aerr('db   (ndx)', ierr,   ndx) ; db  = 0
 allocate ( rr   (ndx) , stat=ierr )
 call aerr('rr   (ndx)', ierr, ndx )  ; rr  = 0

end subroutine alloc_jacobi

  ! =================================================================================================
  ! =================================================================================================
  subroutine setpillars()
    use m_flowgeom            , only: ndx, lnx, ba, wu, nd
    use m_flowexternalforcings, only: pillar, Cpil
    use m_vegetation          , only: rnveg, diaveg, stemheight
    use gridoperations
    use m_flowparameters      , only: japillar
    use m_crspath
    implicit none
    integer                                     :: i, j, k, L, Lf, La, m, n
    double precision                            :: pi
    integer         , dimension(:), allocatable :: npil
    double precision, dimension(:), allocatable :: cdeq
    double precision, dimension(:), allocatable :: Aeff
    integer         , dimension(:), allocatable :: linktype
    integer                                     :: nPath
    type (tcrspath) , dimension(:), allocatable :: Path
    integer         , dimension(:), allocatable :: idum

    if (allocated(Cpil)) deallocate( Cpil )
    if (japillar == 1) then
      allocate( Cpil(ndx) )
    else if (japillar == 3) then
      allocate( Cpil(lnx) )
    endif

    if (allocated(idum)) deallocate(idum)
    allocate(idum(1))
    idum = 0

    pi = 4.0d0 * atan( 1d0 )

    if( japillar == 2 ) then
      if( allocated( cdeq ) ) deallocate( cdeq, npil )
      allocate( cdeq(ndx), npil(ndx) )
      cdeq = 0d0
      npil = 0
      do m = 1,size(pillar)
        do i = 1,pillar(m)%np
          if( pillar(m)%dia(i) == -999d0 .or. pillar(m)%cd(i) == -999d0 ) cycle
          call incells( pillar(m)%xcor(i), pillar(m)%ycor(i), j )
          if( j == 0 ) cycle
          rnveg(j) = rnveg(j) + pillar(m)%dia(i)**2 * pi * 0.25d0 / ba(j)
          cdeq(j)  = cdeq(j)  + pillar(m)%cd(i) * pillar(m)%dia(i)
          npil(j) = npil(j) + 1
        enddo
      enddo
      do j = 1,ndx
        if( npil(j) == 0 ) cycle
        diaveg(j)  = diaveg(j) + cdeq(j) / npil(j)
        stemheight(j) = 1d30
      enddo
      deallocate( cdeq )
      deallocate( npil )

    elseif( japillar == 1 ) then   ! Delft3D implimentation, but modified version on flow cells
      if (allocated(Aeff) ) deallocate( Aeff, cdeq )
      allocate( Aeff(ndx), cdeq(ndx) )
      do j = 1,ndx
        Aeff(j) = ba(j)
      enddo
      cdeq = 0d0
      do m = 1,size(pillar)
        do i = 1,pillar(m)%np
          if (pillar(m)%dia(i) == -999d0 .or. pillar(m)%cd(i) == -999d0) cycle
          call incells( pillar(m)%xcor(i), pillar(m)%ycor(i), j )
          if (j == 0) cycle
          cdeq(j) = cdeq(j) + pillar(m)%cd(i) * pillar(m)%dia(i)
          Aeff(j) = Aeff(j) - pillar(m)%dia(i)**2 * pi * 0.25d0
        enddo
      enddo
      Cpil = 0d0
      do j = 1,ndx
        if( cdeq(j) == 0 ) cycle
        if( Aeff(j) <= 0d0 ) then
          Cpil(j) = 1d30
          cycle
        endif
        Cpil(j) = cdeq(j) * 0.25d0 / Aeff(j) * sqrt( ba(j) * pi )
      enddo
      deallocate( Aeff )
      deallocate( cdeq )

    else if (japillar == 3) then       ! Based on D3D approach on flow links
      if (allocated(Aeff) ) deallocate( Aeff, cdeq, linktype )
      allocate( Aeff(lnx), cdeq(lnx), linktype(lnx) )
      linktype = 0
      Aeff = wu
      cdeq = 0d0
      do m = 1,size(pillar)
        call pol_to_flowlinks(pillar(m)%xcor, pillar(m)%ycor, pillar(m)%xcor*0d0, pillar(m)%np, nPath, Path)
        do n = 1,nPath
          call crspath_on_flowgeom(Path(n),0,0,1,idum, 0)
          do L = 1,Path(n)%lnx
            Lf = Path(n)%ln(L)
            La = iabs(Lf)
            linktype(La) = 1
          enddo
        enddo
        do i = 1,pillar(m)%np
          if (pillar(m)%dia(i) == -999d0 .or. pillar(m)%cd(i) == -999d0) cycle
          call incells( pillar(m)%xcor(i), pillar(m)%ycor(i), k )
          if( k == 0 ) cycle
          do L = 1,nd(k)%lnx
            Lf = nd(k)%ln(L)
            La = iabs(Lf)
            if (linktype(La) /= 1) cycle
            cdeq(La) = cdeq(La) + pillar(m)%cd(i) * pillar(m)%dia(i)
            Aeff(La) = Aeff(La) - pillar(m)%dia(i)
          enddo
        enddo
      enddo
      Cpil = 0d0
      do L = 1,lnx
        if( cdeq(L) == 0 ) cycle
        if( Aeff(L) <= 0d0 ) then
          Cpil(L) = 1d30
          cycle
        endif
        Cpil(L)  = cdeq(L) * 0.5d0 * wu(L) / Aeff(L)**2
      enddo
      deallocate( Aeff )
      deallocate( cdeq )
      deallocate( linktype )
    endif

  end subroutine setpillars

  ! =================================================================================================
  ! =================================================================================================
  subroutine pillar_upd()
    use m_flowexternalforcings, only: Cpil
    use m_flowgeom            , only: lnx, ln, dx
    use m_flow                , only: u1, v, advi
    use m_flowparameters      , only: japillar
    implicit none
    integer          :: L, k1, k2
    double precision :: CpilL, uv

    if (japillar == 1) then
      do L = 1,lnx
        k1 = ln(1,L)
        k2 = ln(2,L)
        CpilL = ( Cpil(k1) + Cpil(k2) ) * 0.5d0
        uv = sqrt( u1(L) * u1(L) + v(L) * v(L) )
        advi(L) = advi(L) + CpilL * uv / dx(L)
      enddo
    else if (japillar == 3) then
      do L = 1,lnx
        if (Cpil(L) == 0d0) cycle
        CpilL = Cpil(L)
        uv = sqrt( u1(L) * u1(L) + v(L) * v(L) )
        advi(L) = advi(L) + CpilL * uv / dx(L)
      enddo
    endif

  end subroutine pillar_upd

! =================================================================================================
! =================================================================================================
   subroutine get_netlinks_of_dryarea()
      use network_data   , only: numl, lne
      use m_flowexternalforcings, only: kdryarea, nDryLinks

      implicit none
      integer :: L, k1, k2

      if (allocated(kdryarea) ) deallocate( kdryarea )
      allocate( kdryarea(numl) ) ; kdryarea = 0

      nDryLinks = 0
      do L = 1,numl
         k1 = lne(1,L) ; k2 = lne(2,L)
         if (k1 > 0 .and. k2 > 0) cycle
         if (k1 <= 0 .and. k2 <= 0) cycle
         nDryLinks = nDryLinks + 1
         kdryarea(nDryLinks) = L
      enddo

   end subroutine get_netlinks_of_dryarea


!>  set nudge rates [1/s] from input in following order of preference:
!>     1. nudge time [s]
!>     2. nudge rate [NUDGE_RATE_UNIT_TO_SECI]
!>     3. uniform nudge time [s]
!>
!>  caution: will overwrite nudge_rate in 1/s
   subroutine set_nudgerate()
      use m_flowgeom, only: Ndx
      use m_flowparameters, only: Tnudgeuni
      use m_nudge
      use m_missing
      implicit none

      integer :: k

      do k=1,Ndx
         if ( nudge_time(k).eq.DMISS ) then
            if ( nudge_rate(k).ne.DMISS ) then
               nudge_rate(k) = NUDGE_RATE_UNIT_TO_SECI * nudge_rate(k)
            else if ( Tnudgeuni.gt.0d0 ) then
               nudge_rate(k) = 1d0 / Tnudgeuni
            else
               nudge_rate(k) = 0d0
            end if
         else if ( nudge_time(k).gt.0d0 ) then
            nudge_rate(k) = 1d0 / nudge_time(k)
         else
            nudge_rate(k) = 0d0
         end if
      end do

      return
   end subroutine set_nudgerate


   !> fill initial salinity and temperature with nudge variables
   subroutine set_saltem_nudge()
      use m_flowgeom
      use m_flow, only: sa1, kmxn
      use m_transport
      use m_nudge
      use m_missing
      implicit none

      integer :: k, kk, KB, KT

      do kk=1,Ndx
         call getkbotktop(kk,kb,kt)
         do k=kb,kt
            if ( ITEMP.gt.0 .and. nudge_tem(k).ne.DMISS ) then
               constituents(ITEMP,k) = nudge_tem(k)
            end if

            if ( ISALT.gt.0 .and. nudge_sal(k).ne.DMISS ) then
               constituents(ISALT,k) = nudge_sal(k)
               sa1(k) = constituents(ISALT,k)
            end if
         end do

         do k = kt+1, kb + kmxn(kk) - 1
            if ( ITEMP.gt.0) constituents(ITEMP,k) = constituents(ITEMP,kt)
            if ( ISALT.gt.0) constituents(ISALT,k) = constituents(ISALT,kt)
            if ( ISALT.gt.0) sa1(k)                = constituents(ISALT,kt)
         enddo

      end do

   end subroutine set_saltem_nudge
